diff -NurpX dontdiff linux-2.4.37/Documentation/Configure.help linux-2.4.37-pax/Documentation/Configure.help
--- linux-2.4.37/Documentation/Configure.help	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/Documentation/Configure.help	2008-12-02 10:29:29.000000000 +0100
@@ -29158,6 +29158,327 @@ CONFIG_SOUND_WM97XX
   
   If unsure, say N.
 
+Support soft mode
+CONFIG_PAX_SOFTMODE
+  Enabling this option will allow you to run PaX in soft mode, that
+  is, PaX features will not be enforced by default, only on executables
+  marked explicitly.  You must also enable PT_PAX_FLAGS support as it
+  is the only way to mark executables for soft mode use.
+
+  Soft mode can be activated by using the "pax_softmode=1" kernel command
+  line option on boot.  Furthermore you can control various PaX features
+  at runtime via the entries in /proc/sys/kernel/pax.
+
+Use legacy ELF header marking
+CONFIG_PAX_EI_PAX
+  Enabling this option will allow you to control PaX features on
+  a per executable basis via the 'chpax' utility available at
+  http://pax.grsecurity.net/.  The control flags will be read from
+  an otherwise reserved part of the ELF header.  This marking has
+  numerous drawbacks (no support for soft-mode, toolchain does not
+  know about the non-standard use of the ELF header) therefore it
+  has been deprecated in favour of PT_PAX_FLAGS support.
+
+  If you have applications not marked by the PT_PAX_FLAGS ELF
+  program header then you MUST enable this option otherwise they
+  will not get any protection.
+
+  Note that if you enable PT_PAX_FLAGS marking support as well,
+  the PT_PAX_FLAG marks will override the legacy EI_PAX marks.
+
+Use ELF program header marking
+CONFIG_PAX_PT_PAX_FLAGS
+  Enabling this option will allow you to control PaX features on
+  a per executable basis via the 'paxctl' utility available at
+  http://pax.grsecurity.net/.  The control flags will be read from
+  a PaX specific ELF program header (PT_PAX_FLAGS).  This marking
+  has the benefits of supporting both soft mode and being fully
+  integrated into the toolchain (the binutils patch is available
+  from http://pax.grsecurity.net).
+
+  If you have applications not marked by the PT_PAX_FLAGS ELF
+  program header then you MUST enable the EI_PAX marking support
+  otherwise they will not get any protection.
+
+  Note that if you enable the legacy EI_PAX marking support as well,
+  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+
+MAC system integration
+CONFIG_PAX_NO_ACL_FLAGS
+  Mandatory Access Control systems have the option of controlling
+  PaX flags on a per executable basis, choose the method supported
+  by your particular system.
+
+  - "none": if your MAC system does not interact with PaX,
+  - "direct": if your MAC system defines pax_set_initial_flags() itself,
+  - "hook": if your MAC system uses the pax_set_initial_flags_func callback.
+
+  NOTE: this option is for developers/integrators only.
+
+Enforce non-executable pages
+CONFIG_PAX_NOEXEC
+  By design some architectures do not allow for protecting memory
+  pages against execution or even if they do, Linux does not make
+  use of this feature.  In practice this means that if a page is
+  readable (such as the stack or heap) it is also executable.
+
+  There is a well known exploit technique that makes use of this
+  fact and a common programming mistake where an attacker can
+  introduce code of his choice somewhere in the attacked program's
+  memory (typically the stack or the heap) and then execute it.
+
+  If the attacked program was running with different (typically
+  higher) privileges than that of the attacker, then he can elevate
+  his own privilege level (e.g. get a root shell, write to files for
+  which he does not have write access to, etc).
+
+  Enabling this option will let you choose from various features
+  that prevent the injection and execution of 'foreign' code in
+  a program.
+
+  This will also break programs that rely on the old behaviour and
+  expect that dynamically allocated memory via the malloc() family
+  of functions is executable (which it is not).  Notable examples
+  are the XFree86 4.x server, the java runtime and wine.
+
+Paging based non-executable pages
+CONFIG_PAX_PAGEEXEC
+  This implementation is based on the paging feature of the CPU.
+  On i386 it has a variable performance impact on applications
+  depending on their memory usage pattern.  You should carefully
+  test your applications before using this feature in production.
+  On alpha, ia64, parisc, sparc, sparc64 and x86_64 there is no
+  performance impact.  On ppc there is a slight performance impact.
+
+Segmentation based non-executable pages
+CONFIG_PAX_SEGMEXEC
+  This implementation is based on the segmentation feature of the
+  CPU and has little performance impact, however applications will
+  be limited to a 1.5 GB address space instead of the normal 3 GB.
+
+Emulate trampolines
+CONFIG_PAX_EMUTRAMP
+  There are some programs and libraries that for one reason or
+  another attempt to execute special small code snippets from
+  non-executable memory pages.  Most notable examples are the
+  signal handler return code generated by the kernel itself and
+  the GCC trampolines.
+
+  If you enabled CONFIG_PAX_PAGEEXEC or CONFIG_PAX_SEGMEXEC then
+  such programs will no longer work under your kernel.
+
+  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+  utilities to enable trampoline emulation for the affected programs
+  yet still have the protection provided by the non-executable pages.
+
+  On parisc and ppc you MUST enable this option and EMUSIGRT as
+  well, otherwise your system will not even boot.
+
+  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+  utilities to disable CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC
+  for the affected files.
+
+  NOTE: enabling this feature *may* open up a loophole in the
+  protection provided by non-executable pages that an attacker
+  could abuse.  Therefore the best solution is to not have any
+  files on your system that would require this option.  This can
+  be achieved by not using libc5 (which relies on the kernel
+  signal handler return code) and not using or rewriting programs
+  that make use of the nested function implementation of GCC.
+  Skilled users can just fix GCC itself so that it implements
+  nested function calls in a way that does not interfere with PaX.
+
+Automatically emulate sigreturn trampolines
+CONFIG_PAX_EMUSIGRT
+  Enabling this option will have the kernel automatically detect
+  and emulate signal return trampolines executing on the stack
+  that would otherwise lead to task termination.
+
+  This solution is intended as a temporary one for users with
+  legacy versions of libc (libc5, glibc 2.0, uClibc before 0.9.17,
+  Modula-3 runtime, etc) or executables linked to such, basically
+  everything that does not specify its own SA_RESTORER function in
+  normal executable memory like glibc 2.1+ does.
+
+  On parisc and ppc you MUST enable this option, otherwise your
+  system will not even boot.
+
+  NOTE: this feature cannot be disabled on a per executable basis
+  and since it *does* open up a loophole in the protection provided
+  by non-executable pages, the best solution is to not have any
+  files on your system that would require this option.
+
+Restrict mprotect()
+CONFIG_PAX_MPROTECT
+  Enabling this option will prevent programs from
+   - changing the executable status of memory pages that were
+     not originally created as executable,
+   - making read-only executable pages writable again,
+   - creating executable pages from anonymous memory.
+
+  You should say Y here to complete the protection provided by
+  the enforcement of non-executable pages.
+
+  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+  this feature on a per file basis.
+
+Disallow ELF text relocations
+CONFIG_PAX_NOELFRELOCS
+  Non-executable pages and mprotect() restrictions are effective
+  in preventing the introduction of new executable code into an
+  attacked task's address space.  There remain only two venues
+  for this kind of attack: if the attacker can execute already
+  existing code in the attacked task then he can either have it
+  create and mmap() a file containing his code or have it mmap()
+  an already existing ELF library that does not have position
+  independent code in it and use mprotect() on it to make it
+  writable and copy his code there.  While protecting against
+  the former approach is beyond PaX, the latter can be prevented
+  by having only PIC ELF libraries on one's system (which do not
+  need to relocate their code).  If you are sure this is your case,
+  then enable this option otherwise be careful as you may not even
+  be able to boot or log on your system (for example, some PAM
+  modules are erroneously compiled as non-PIC by default).
+
+  NOTE: if you are using dynamic ELF executables (as suggested
+  when using ASLR) then you must have made sure that you linked
+  your files using the PIC version of crt1 (the et_dyn.tar.gz package
+  referenced there has already been updated to support this).
+
+Allow ELF ET_EXEC text relocations
+CONFIG_PAX_ETEXECRELOCS
+  On some architectures there are incorrectly created applications
+  that require text relocations and would not work without enabling
+  this option.  If you are an alpha, ia64 or parisc user, you should
+  enable this option and disable it once you have made sure that
+  none of your applications need it.
+
+Automatically emulate ELF PLT
+CONFIG_PAX_EMUPLT
+  Enabling this option will have the kernel automatically detect
+  and emulate the Procedure Linkage Table entries in ELF files.
+  On some architectures such entries are in writable memory, and
+  become non-executable leading to task termination.  Therefore
+  it is mandatory that you enable this option on alpha, parisc, ppc,
+  sparc and sparc64, otherwise your system would not even boot.
+
+  NOTE: this feature *does* open up a loophole in the protection
+  provided by the non-executable pages, therefore the proper
+  solution is to modify the toolchain to produce a PLT that does
+  not need to be writable.
+
+Enforce non-executable kernel pages
+CONFIG_PAX_KERNEXEC
+  This is the kernel land equivalent of PAGEEXEC and MPROTECT,
+  that is, enabling this option will make it harder to inject
+  and execute 'foreign' code in kernel memory itself.
+
+Address Space Layout Randomization
+CONFIG_PAX_ASLR
+  Many if not most exploit techniques rely on the knowledge of
+  certain addresses in the attacked program.  The following options
+  will allow the kernel to apply a certain amount of randomization
+  to specific parts of the program thereby forcing an attacker to
+  guess them in most cases.  Any failed guess will most likely crash
+  the attacked program which allows the kernel to detect such attempts
+  and react on them.  PaX itself provides no reaction mechanisms,
+  instead it is strongly encouraged that you make use of Nergal's
+  segvguard (ftp://ftp.pl.openwall.com/misc/segvguard/) or grsecurity's
+  (http://www.grsecurity.net/) built-in crash detection features or
+  develop one yourself.
+
+  By saying Y here you can choose to randomize the following areas:
+   - top of the task's kernel stack
+   - top of the task's userland stack
+   - base address for mmap() requests that do not specify one
+     (this includes all libraries)
+   - base address of the main executable
+
+  It is strongly recommended to say Y here as address space layout
+  randomization has negligible impact on performance yet it provides
+  a very effective protection.
+
+  NOTE: you can use the 'chpax' or 'paxctl' utilities to control most
+  of these features on a per file basis.
+
+Randomize kernel stack base
+CONFIG_PAX_RANDKSTACK
+  By saying Y here the kernel will randomize every task's kernel
+  stack on every system call.  This will not only force an attacker
+  to guess it but also prevent him from making use of possible
+  leaked information about it.
+
+  Since the kernel stack is a rather scarce resource, randomization
+  may cause unexpected stack overflows, therefore you should very
+  carefully test your system.  Note that once enabled in the kernel
+  configuration, this feature cannot be disabled on a per file basis.
+
+Randomize user stack base
+CONFIG_PAX_RANDUSTACK
+  By saying Y here the kernel will randomize every task's userland
+  stack.  The randomization is done in two steps where the second
+  one may apply a big amount of shift to the top of the stack and
+  cause problems for programs that want to use lots of memory (more
+  than 2.5 GB if SEGMEXEC is not active, or 1.25 GB when it is).
+  For this reason the second step can be controlled by 'chpax' or
+  'paxctl' on a per file basis.
+
+Randomize mmap() base
+CONFIG_PAX_RANDMMAP
+  By saying Y here the kernel will use a randomized base address for
+  mmap() requests that do not specify one themselves.  As a result
+  all dynamically loaded libraries will appear at random addresses
+  and therefore be harder to exploit by a technique where an attacker
+  attempts to execute library code for his purposes (e.g. spawn a
+  shell from an exploited program that is running at an elevated
+  privilege level).
+
+  Furthermore, if a program is relinked as a dynamic ELF file, its
+  base address will be randomized as well, completing the full
+  randomization of the address space layout.  Attacking such programs
+  becomes a guess game.  You can find an example of doing this at
+  http://pax.grsecurity.net/et_dyn.tar.gz and practical samples
+  at http://www.grsecurity.net/grsec-gcc-specs.tar.gz .
+
+  NOTE: you can use the 'chpax' or 'paxctl' utilities to control this
+  feature on a per file basis.
+
+Sanitize all freed memory
+CONFIG_PAX_MEMORY_SANITIZE
+  By saying Y here the kernel will erase memory pages as soon as they
+  are freed.  This in turn reduces the lifetime of data stored in the
+  pages, making it less likely that sensitive information such as
+  passwords, cryptographic secrets, etc stay in memory for too long.
+
+  This is especially useful for programs whose runtime is short, long
+  lived processes and the kernel itself benefit from this as long as
+  they operate on whole memory pages and ensure timely freeing of pages
+  that may hold sensitive information.
+
+  The tradeoff is performance impact, on a single CPU system kernel
+  compilation sees a 3% slowdown, other systems and workloads may vary
+  and you are advised to test this feature on your expected workload
+  before deploying it.
+
+  Note that this feature does not protect data stored in live pages,
+  e.g., process memory swapped to disk may stay there for a long time.
+
+Prevent invalid userland pointer dereference
+CONFIG_PAX_MEMORY_UDEREF
+  By saying Y here the kernel will be prevented from dereferencing
+  userland pointers in contexts where the kernel expects only kernel
+  pointers.  This is both a useful runtime debugging feature and a
+  security measure that prevents exploiting a class of kernel bugs.
+
+  The tradeoff is that some virtualization solutions may experience
+  a huge slowdown and therefore you should not enable this feature
+  for kernels meant to run in such environments.  Whether a given VM
+  solution is affected or not is best determined by simply trying it
+  out, the performance impact will be obvious right on boot as this
+  mechanism engages from very early on.  A good rule of thumb is that
+  VMs running on CPUs without hardware virtualization support (i.e.,
+  the majority of IA-32 CPUs) will likely experience the slowdown.
+
 #
 # A couple of things I keep forgetting:
 #   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet,
diff -NurpX dontdiff linux-2.4.37/Makefile linux-2.4.37-pax/Makefile
--- linux-2.4.37/Makefile	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/Makefile	2008-12-02 10:29:30.000000000 +0100
@@ -382,6 +382,11 @@ init/do_mounts.o: init/do_mounts.c inclu
 fs lib mm ipc kernel drivers net: dummy
 	$(MAKE) CFLAGS="$(CFLAGS) $(CFLAGS_KERNEL)" $(subst $@, _dir_$@, $@)
 
+cscope:
+	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print > cscope.files
+	find kernel drivers mm fs net ipc lib crypto init arch/${ARCH} include/asm-$(ARCH) include/asm-generic -name '*.[chS]' >> cscope.files
+	cscope -k -b -q < cscope.files
+
 TAGS: dummy
 	{ find include/asm-${ARCH} -name '*.h' -print ; \
 	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print ; \
diff -NurpX dontdiff linux-2.4.37/arch/alpha/config.in linux-2.4.37-pax/arch/alpha/config.in
--- linux-2.4.37/arch/alpha/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/alpha/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -466,5 +466,65 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+#            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+            bool '    Allow ELF ET_EXEC text relocations' CONFIG_PAX_ETEXECRELOCS
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/alpha/kernel/osf_sys.c linux-2.4.37-pax/arch/alpha/kernel/osf_sys.c
--- linux-2.4.37/arch/alpha/kernel/osf_sys.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/alpha/kernel/osf_sys.c	2008-12-02 10:29:30.000000000 +0100
@@ -1357,6 +1357,10 @@ arch_get_unmapped_area(struct file *filp
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != -ENOMEM)
@@ -1364,8 +1368,15 @@ arch_get_unmapped_area(struct file *filp
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+
+	addr = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		addr += current->mm->delta_mmap;
+#endif
+
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 	if (addr != -ENOMEM)
 		return addr;
 
diff -NurpX dontdiff linux-2.4.37/arch/alpha/mm/fault.c linux-2.4.37-pax/arch/alpha/mm/fault.c
--- linux-2.4.37/arch/alpha/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/alpha/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -53,6 +53,123 @@ __load_new_mm_context(struct mm_struct *
 	__reload_thread(&current->thread);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long*)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -133,8 +250,29 @@ do_page_fault(unsigned long address, uns
 good_area:
 	info.si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)rdusp());
+			do_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -NurpX dontdiff linux-2.4.37/arch/i386/Makefile linux-2.4.37-pax/arch/i386/Makefile
--- linux-2.4.37/arch/i386/Makefile	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/Makefile	2008-12-02 10:29:30.000000000 +0100
@@ -123,6 +123,9 @@ arch/i386/mm: dummy
 
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
 
+arch/i386/vmlinux.lds: arch/i386/vmlinux.lds.S FORCE
+	$(CPP) -C -P -I$(HPATH) -D__KERNEL__ -imacros $(HPATH)/linux/config.h -imacros $(HPATH)/asm-i386/segment.h -imacros $(HPATH)/asm-i386/page.h -Ui386 arch/i386/vmlinux.lds.S >arch/i386/vmlinux.lds
+
 vmlinux: arch/i386/vmlinux.lds
 
 FORCE: ;
@@ -159,6 +162,7 @@ archclean:
 	@$(MAKEBOOT) clean
 
 archmrproper:
+	rm -f arch/i386/vmlinux.lds
 
 archdep:
 	@$(MAKEBOOT) dep
diff -NurpX dontdiff linux-2.4.37/arch/i386/boot/bootsect.S linux-2.4.37-pax/arch/i386/boot/bootsect.S
--- linux-2.4.37/arch/i386/boot/bootsect.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/boot/bootsect.S	2008-12-02 10:29:30.000000000 +0100
@@ -237,7 +237,7 @@ rp_read:
 #ifdef __BIG_KERNEL__
 					# look in setup.S for bootsect_kludge
 	bootsect_kludge = 0x220		# 0x200 + 0x20 which is the size of the
-	lcall	bootsect_kludge		# bootsector + bootsect_kludge offset
+	lcall	*bootsect_kludge	# bootsector + bootsect_kludge offset
 #else
 	movw	%es, %ax
 	subw	$SYSSEG, %ax
diff -NurpX dontdiff linux-2.4.37/arch/i386/boot/compressed/head.S linux-2.4.37-pax/arch/i386/boot/compressed/head.S
--- linux-2.4.37/arch/i386/boot/compressed/head.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/boot/compressed/head.S	2008-12-02 10:29:30.000000000 +0100
@@ -38,11 +38,13 @@ startup_32:
 	movl %eax,%gs
 
 	lss SYMBOL_NAME(stack_start),%esp
+	movl 0x000000,%ecx
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000	# loop forever if it isn't
 	cmpl %eax,0x100000
 	je 1b
+	movl %ecx,0x000000
 
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
diff -NurpX dontdiff linux-2.4.37/arch/i386/boot/setup.S linux-2.4.37-pax/arch/i386/boot/setup.S
--- linux-2.4.37/arch/i386/boot/setup.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/boot/setup.S	2008-12-02 10:29:30.000000000 +0100
@@ -637,7 +637,7 @@ edd_done:
 	cmpw	$0, %cs:realmode_swtch
 	jz	rmodeswtch_normal
 
-	lcall	%cs:realmode_swtch
+	lcall	*%cs:realmode_swtch
 
 	jmp	rmodeswtch_end
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/config.in linux-2.4.37-pax/arch/i386/config.in
--- linux-2.4.37/arch/i386/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -103,6 +103,7 @@ if [ "$CONFIG_M586MMX" = "y" ]; then
 fi
 if [ "$CONFIG_M686" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    bool 'PGE extensions (not for Cyrix/Transmeta)' CONFIG_X86_PGE
@@ -112,6 +113,7 @@ if [ "$CONFIG_M686" = "y" ]; then
 fi
 if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_PGE y
@@ -120,6 +122,7 @@ if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
 fi
 if [ "$CONFIG_MPENTIUM4" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 7
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_PGE y
@@ -139,6 +142,7 @@ if [ "$CONFIG_MK8" = "y" ]; then
 fi
 if [ "$CONFIG_MK7" = "y" ]; then
    define_int  CONFIG_X86_L1_CACHE_SHIFT 6
+   define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_USE_3DNOW y
@@ -503,5 +507,84 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      if [ "$CONFIG_M586" = "y" -o \
+           "$CONFIG_M586TSC" = "y" -o \
+           "$CONFIG_M586MMX" = "y" -o \
+           "$CONFIG_M686" = "y" -o \
+           "$CONFIG_MPENTIUMIII" = "y" -o \
+           "$CONFIG_MPENTIUM4" = "y" -o \
+           "$CONFIG_MK7" = "y" -o \
+           "$CONFIG_MK8" = "y" -o \
+           "$CONFIG_MWINCHIPC6" = "y" -o \
+           "$CONFIG_MWINCHIP2" = "y" -o \
+           "$CONFIG_MWINCHIP3D" = "y" -o \
+           "$CONFIG_MVIAC3_2" = "y" ]; then
+         bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      fi
+      bool 'Segmentation based non-executable pages' CONFIG_PAX_SEGMEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" -o "$CONFIG_PAX_SEGMEXEC" = "y" ]; then
+         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+         fi
+      fi
+      if [ "$CONFIG_MODULES" != "y" -a "$CONFIG_X86_WP_WORKS_OK" = "y" ]; then
+         bool 'Enforce non-executable kernel pages' CONFIG_PAX_KERNEXEC
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      if [ "$CONFIG_X86_TSC" = "y" ]; then
+         bool '  Randomize kernel stack base' CONFIG_PAX_RANDKSTACK
+      fi
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+bool 'Prevent invalid userland pointer dereference' CONFIG_PAX_MEMORY_UDEREF
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/acpi.c linux-2.4.37-pax/arch/i386/kernel/acpi.c
--- linux-2.4.37/arch/i386/kernel/acpi.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/acpi.c	2008-12-02 10:29:30.000000000 +0100
@@ -370,7 +370,7 @@ acpi_scan_rsdp (
 	 * RSDP signature.
 	 */
 	for (offset = 0; offset < length; offset += 16) {
-		if (strncmp((char *) (start + offset), "RSD PTR ", sig_len))
+		if (strncmp((char *) (phys_to_virt(start) + offset), "RSD PTR ", sig_len))
 			continue;
 		return (start + offset);
 	}
@@ -708,7 +708,7 @@ static void acpi_create_identity_pmd (vo
 	saved_pmd = *pmd;
 
 	/* set the new one */
-	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(ptep)));
+	set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(ptep)));
 
 	/* flush the TLB */
 	local_flush_tlb();
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/apm.c linux-2.4.37-pax/arch/i386/kernel/apm.c
--- linux-2.4.37/arch/i386/kernel/apm.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/apm.c	2008-12-02 10:29:30.000000000 +0100
@@ -223,7 +223,7 @@
 #include <linux/sysrq.h>
 
 extern unsigned long get_cmos_time(void);
-extern void machine_real_restart(unsigned char *, int);
+extern void machine_real_restart(const unsigned char *, unsigned int);
 
 #if defined(CONFIG_APM_DISPLAY_BLANK) && defined(CONFIG_VT)
 extern int (*console_blank_hook)(int);
@@ -614,7 +614,7 @@ static u8 apm_bios_call(u32 func, u32 eb
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall %%cs:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
+		"lcall *%%ss:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
 		"setc %%al\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
@@ -666,7 +666,7 @@ static u8 apm_bios_call_simple(u32 func,
 		__asm__ __volatile__(APM_DO_ZERO_SEGS
 			"pushl %%edi\n\t"
 			"pushl %%ebp\n\t"
-			"lcall %%cs:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
+			"lcall *%%ss:" SYMBOL_NAME_STR(apm_bios_entry) "\n\t"
 			"setc %%bl\n\t"
 			"popl %%ebp\n\t"
 			"popl %%edi\n\t"
@@ -924,7 +924,7 @@ recalc:
  
 static void apm_power_off(void)
 {
-	unsigned char	po_bios_call[] = {
+	const unsigned char	po_bios_call[] = {
 		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
 		0x8e, 0xd0,		/* movw  ax,ss       */
 		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
@@ -1985,6 +1985,12 @@ static int __init apm_init(void)
 		 __va((unsigned long)0x40 << 4));
 	_set_limit((char *)&gdt[APM_40 >> 3], 4095 - (0x40 << 4));
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	set_base(gdt2[APM_40 >> 3],
+		__va((unsigned long)0x40 << 4));
+	_set_limit((char *)&gdt2[APM_40 >> 3], 4095 - (0x40 << 4));
+#endif
+
 	apm_bios_entry.offset = apm_info.bios.offset;
 	apm_bios_entry.segment = APM_CS;
 	set_base(gdt[APM_CS >> 3],
@@ -1993,6 +1999,16 @@ static int __init apm_init(void)
 		 __va((unsigned long)apm_info.bios.cseg_16 << 4));
 	set_base(gdt[APM_DS >> 3],
 		 __va((unsigned long)apm_info.bios.dseg << 4));
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	set_base(gdt2[APM_CS >> 3],
+		 __va((unsigned long)apm_info.bios.cseg << 4));
+	set_base(gdt2[APM_CS_16 >> 3],
+		 __va((unsigned long)apm_info.bios.cseg_16 << 4));
+	set_base(gdt2[APM_DS >> 3],
+		 __va((unsigned long)apm_info.bios.dseg << 4));
+#endif
+
 #ifndef APM_RELAX_SEGMENTS
 	if (apm_info.bios.version == 0x100) {
 #endif
@@ -2002,6 +2018,13 @@ static int __init apm_init(void)
 		_set_limit((char *)&gdt[APM_CS_16 >> 3], 64 * 1024 - 1);
 		/* For the DEC Hinote Ultra CT475 (and others?) */
 		_set_limit((char *)&gdt[APM_DS >> 3], 64 * 1024 - 1);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_set_limit((char *)&gdt2[APM_CS >> 3], 64 * 1024 - 1);
+		_set_limit((char *)&gdt2[APM_CS_16 >> 3], 64 * 1024 - 1);
+		_set_limit((char *)&gdt2[APM_DS >> 3], 64 * 1024 - 1);
+#endif
+
 #ifndef APM_RELAX_SEGMENTS
 	} else {
 		_set_limit((char *)&gdt[APM_CS >> 3],
@@ -2010,6 +2033,16 @@ static int __init apm_init(void)
 			(apm_info.bios.cseg_16_len - 1) & 0xffff);
 		_set_limit((char *)&gdt[APM_DS >> 3],
 			(apm_info.bios.dseg_len - 1) & 0xffff);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_set_limit((char *)&gdt2[APM_CS >> 3],
+			(apm_info.bios.cseg_len - 1) & 0xffff);
+		_set_limit((char *)&gdt2[APM_CS_16 >> 3],
+			(apm_info.bios.cseg_16_len - 1) & 0xffff);
+		_set_limit((char *)&gdt2[APM_DS >> 3],
+			(apm_info.bios.dseg_len - 1) & 0xffff);
+#endif
+
 	}
 #endif
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/entry.S linux-2.4.37-pax/arch/i386/kernel/entry.S
--- linux-2.4.37/arch/i386/kernel/entry.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/entry.S	2008-12-02 10:29:30.000000000 +0100
@@ -84,7 +84,7 @@ processor	= 52
 ENOSYS = 38
 
 
-#define SAVE_ALL \
+#define __SAVE_ALL \
 	cld; \
 	pushl %es; \
 	pushl %ds; \
@@ -99,6 +99,18 @@ ENOSYS = 38
 	movl %edx,%ds; \
 	movl %edx,%es;
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL \
+	movl %cr0,%edx; \
+	movl %edx,%ebp; \
+	orl $0x10000,%edx; \
+	xorl %edx,%ebp; \
+	movl %edx,%cr0;
+#else
+#define SAVE_ALL __SAVE_ALL
+#endif
+
 #define RESTORE_ALL	\
 	popl %ebx;	\
 	popl %ecx;	\
@@ -209,6 +221,17 @@ ENTRY(system_call)
 	jae badsys
 	call *SYMBOL_NAME(sys_call_table)(,%eax,4)
 	movl %eax,EAX(%esp)		# save the return value
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	cli				# need_resched and signals atomic test
+	cmpl $0,need_resched(%ebx)
+	jne reschedule
+	cmpl $0,sigpending(%ebx)
+	jne signal_return
+	call SYMBOL_NAME(pax_randomize_kstack)
+	jmp restore_all
+#endif
+
 ENTRY(ret_from_sys_call)
 	cli				# need_resched and signals atomic test
 	cmpl $0,need_resched(%ebx)
@@ -260,6 +283,13 @@ ret_from_exception:
 	movb CS(%esp),%al
 	testl $(VM_MASK | 3),%eax	# return to VM86 mode or non-supervisor?
 	jne ret_from_sys_call
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0, %edx
+	xorl %ebp, %edx
+	movl %edx, %cr0
+#endif
+
 	jmp restore_all
 
 	ALIGN
@@ -283,6 +313,15 @@ error_code:
 	pushl %ecx
 	pushl %ebx
 	cld
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0,%edx
+	movl %edx,%ebp
+	orl $0x10000,%edx
+	xorl %edx,%ebp
+	movl %edx,%cr0
+#endif
+
 	movl %es,%ecx
 	movl ORIG_EAX(%esp), %esi	# get the error code
 	movl ES(%esp), %edi		# get the function address
@@ -337,6 +376,13 @@ ENTRY(nmi)
 	pushl %edx
 	call SYMBOL_NAME(do_nmi)
 	addl $8,%esp
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0, %edx
+	xorl %ebp, %edx
+	movl %edx, %cr0
+#endif
+
 	RESTORE_ALL
 
 ENTRY(int3)
@@ -389,8 +435,77 @@ ENTRY(alignment_check)
 	jmp error_code
 
 ENTRY(page_fault)
+#ifdef CONFIG_PAX_PAGEEXEC
+	ALIGN
+	pushl $ SYMBOL_NAME(pax_do_page_fault)
+#else
 	pushl $ SYMBOL_NAME(do_page_fault)
+#endif
+
+#ifndef CONFIG_PAX_EMUTRAMP
 	jmp error_code
+#else
+	pushl %ds
+	pushl %eax
+	xorl %eax,%eax
+	pushl %ebp
+	pushl %edi
+	pushl %esi
+	pushl %edx
+	decl %eax			# eax = -1
+	pushl %ecx
+	pushl %ebx
+	cld
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl %cr0,%edx
+	movl %edx,%ebp
+	orl $0x10000,%edx
+	xorl %edx,%ebp
+	movl %edx,%cr0
+#endif
+
+	movl %es,%ecx
+	movl ORIG_EAX(%esp), %esi	# get the error code
+	movl ES(%esp), %edi		# get the function address
+	movl %eax, ORIG_EAX(%esp)
+	movl %ecx, ES(%esp)
+	movl %esp,%edx
+	pushl %esi			# push the error code
+	pushl %edx			# push the pt_regs pointer
+	movl $(__KERNEL_DS),%edx
+	movl %edx,%ds
+	movl %edx,%es
+	GET_CURRENT(%ebx)
+	call *%edi
+	addl $8,%esp
+	decl %eax
+	jnz ret_from_exception
+
+	popl %ebx
+	popl %ecx
+	popl %edx
+	popl %esi
+	popl %edi
+	popl %ebp
+	popl %eax
+1:	popl %ds;
+2:	popl %es;
+	addl $4,%esp;
+	jmp system_call
+
+.section .fixup,"ax";
+3:	movl $0,(%esp);
+	jmp 1b;
+4:	movl $0,(%esp);
+	jmp 2b;
+.previous;
+.section __ex_table,"a";
+	.align 4;
+	.long 1b,3b;
+	.long 2b,4b;
+.previous
+#endif
 
 ENTRY(machine_check)
 	pushl $0
@@ -402,7 +517,7 @@ ENTRY(spurious_interrupt_bug)
 	pushl $ SYMBOL_NAME(do_spurious_interrupt_bug)
 	jmp error_code
 
-.data
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* 0  -  old "setup()" system call*/
 	.long SYMBOL_NAME(sys_exit)
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/head.S linux-2.4.37-pax/arch/i386/kernel/head.S
--- linux-2.4.37/arch/i386/kernel/head.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/head.S	2008-12-02 10:29:30.000000000 +0100
@@ -36,11 +36,23 @@
 #define X86_CAPABILITY	CPU_PARAMS+12
 #define X86_VENDOR_ID	CPU_PARAMS+36	/* tied to NCAPINTS in cpufeature.h */
 
+#ifdef CONFIG_PAX_KERNEXEC
+/* PaX: fill first page in .text with int3 to catch NULL derefs in kernel mode */
+.fill 4096,1,0xcc
+#endif
+
+/*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
+
 /*
  * swapper_pg_dir is the main page directory, address 0x00101000
  *
  * On entry, %esi points to the real-mode code as a 32-bit pointer.
  */
+.global startup_32
 startup_32:
 /*
  * Set segments to known values
@@ -51,9 +63,88 @@ startup_32:
 	movl %eax,%es
 	movl %eax,%fs
 	movl %eax,%gs
+	movl %eax,%ss
+
 #ifdef CONFIG_SMP
 	orw %bx,%bx
-	jz 1f
+	jnz 1f
+#endif
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	/* check for VMware */
+	movl $0x564d5868,%eax
+	xorl %ebx,%ebx
+	movl $0xa,%ecx
+	movl $0x5658,%edx
+	in (%dx),%eax
+	cmpl $0x564d5868,%ebx
+	jz 2f
+
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c09700),%eax
+	movl %eax,(SYMBOL_NAME(gdt_table) - __PAGE_OFFSET + __KERNEL_DS + 4)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	movl %eax,(SYMBOL_NAME(gdt_table2) - __PAGE_OFFSET + __KERNEL_DS + 4)
+#endif
+
+2:
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $__KERNEL_TEXT_OFFSET,%eax
+	movw %ax,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 2 - __PAGE_OFFSET)
+	rorl $16,%eax
+	movb %al,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 4 - __PAGE_OFFSET)
+	movb %ah,(SYMBOL_NAME(gdt_table) + __KERNEL_CS + 7 - __PAGE_OFFSET)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	movb %al,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 4 - __PAGE_OFFSET)
+	movb %ah,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 7 - __PAGE_OFFSET)
+	rorl $16,%eax
+	movw %ax,(SYMBOL_NAME(gdt_table2) + __KERNEL_CS + 2 - __PAGE_OFFSET)
+#endif
+
+#endif
+
+/*
+ * Clear BSS first so that there are no surprises...
+ * No need to cld as DF is already clear from cld above...
+ */
+	xorl %eax,%eax
+	movl $ SYMBOL_NAME(__bss_start) - __PAGE_OFFSET,%edi
+	movl $ SYMBOL_NAME(__bss_end) - __PAGE_OFFSET,%ecx
+	subl %edi,%ecx
+	rep
+	stosb
+/*
+ * Copy bootup parameters out of the way. First 2kB of
+ * _empty_zero_page is for boot parameters, second 2kB
+ * is for the command line.
+ *
+ * Note: %esi still has the pointer to the real-mode data.
+ */
+	movl $ SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET,%edi
+	movl $512,%ecx
+	cld
+	rep
+	movsl
+	xorl %eax,%eax
+	movl $512,%ecx
+	rep
+	stosl
+	movl SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET + NEW_CL_POINTER,%esi
+	andl %esi,%esi
+	jnz 2f			# New command line protocol
+	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
+	jne 1f
+	movzwl OLD_CL_OFFSET,%esi
+	addl $(OLD_CL_BASE_ADDR),%esi
+2:
+	movl $ SYMBOL_NAME(empty_zero_page) - __PAGE_OFFSET + 2048,%edi
+	movl $512,%ecx
+	rep
+	movsl
+1:
 
 /*
  *	New page tables may be in 4Mbyte page mode and may
@@ -71,22 +162,28 @@ startup_32:
  */
 #define cr4_bits mmu_cr4_features-__PAGE_OFFSET
 	cmpl $0,cr4_bits
-	je 3f
+	je 1f
 	movl %cr4,%eax		# Turn on paging options (PSE,PAE,..)
 	orl cr4_bits,%eax
 	movl %eax,%cr4
-	jmp 3f
 1:
+
+#ifdef CONFIG_SMP
+	orw  %bx,%bx
+	jnz 3f
 #endif
+
 /*
  * Initialize page tables
  */
 	movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */
-	movl $007,%eax		/* "007" doesn't mean with right to kill, but
-				   PRESENT+RW+USER */
+	movl $0x63,%eax		/* "0x63" is PRESENT+RW+ACCESSED+DIRTY */
 2:	stosl
+#ifdef CONFIG_X86_PAE
+	addl $4,%edi
+#endif
 	add $0x1000,%eax
-	cmp $empty_zero_page-__PAGE_OFFSET,%edi
+	cmp $0x01000063,%eax
 	jne 2b
 
 /*
@@ -100,37 +197,16 @@ startup_32:
 	movl %eax,%cr0		/* ..and set paging (PG) bit */
 	jmp 1f			/* flush the prefetch-queue */
 1:
-	movl $1f,%eax
-	jmp *%eax		/* make sure eip is relocated */
-1:
+	lgdt gdt_descr
+	ljmp $__KERNEL_CS,$1f
+1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
+	movl %eax,%ds		# after changing gdt.
+	movl %eax,%es
+	movl %eax,%fs
+	movl %eax,%gs
 	/* Set up the stack pointer */
 	lss stack_start,%esp
 
-#ifdef CONFIG_SMP
-	orw  %bx,%bx
-	jz  1f				/* Initial CPU cleans BSS */
-	pushl $0
-	popfl
-	jmp checkCPUtype
-1:
-#endif /* CONFIG_SMP */
-
-/*
- * Clear BSS first so that there are no surprises...
- * No need to cld as DF is already clear from cld above...
- */
-	xorl %eax,%eax
-	movl $ SYMBOL_NAME(__bss_start),%edi
-	movl $ SYMBOL_NAME(_end),%ecx
-	subl %edi,%ecx
-	rep
-	stosb
-
-/*
- * start system 32-bit setup. We need to re-do some of the things done
- * in 16-bit mode for the "real" operations.
- */
-	call setup_idt
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
  * confuse the debugger if this code is traced.
@@ -138,35 +214,18 @@ startup_32:
  */
 	pushl $0
 	popfl
+
+#ifdef CONFIG_SMP
+	orw  %bx,%bx
+	jnz checkCPUtype
+#endif /* CONFIG_SMP */
+
 /*
- * Copy bootup parameters out of the way. First 2kB of
- * _empty_zero_page is for boot parameters, second 2kB
- * is for the command line.
- *
- * Note: %esi still has the pointer to the real-mode data.
+ * start system 32-bit setup. We need to re-do some of the things done
+ * in 16-bit mode for the "real" operations.
  */
-	movl $ SYMBOL_NAME(empty_zero_page),%edi
-	movl $512,%ecx
-	cld
-	rep
-	movsl
-	xorl %eax,%eax
-	movl $512,%ecx
-	rep
-	stosl
-	movl SYMBOL_NAME(empty_zero_page)+NEW_CL_POINTER,%esi
-	andl %esi,%esi
-	jnz 2f			# New command line protocol
-	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
-	jne 1f
-	movzwl OLD_CL_OFFSET,%esi
-	addl $(OLD_CL_BASE_ADDR),%esi
-2:
-	movl $ SYMBOL_NAME(empty_zero_page)+2048,%edi
-	movl $512,%ecx
-	rep
-	movsl
-1:
+	call setup_idt
+
 checkCPUtype:
 
 	movl $-1,X86_CPUID		#  -1 for no CPUID initially
@@ -241,20 +300,7 @@ is386:	pushl %ecx		# restore original EF
 2:	movl %eax,%cr0
 	call check_x87
 	incb ready
-	lgdt gdt_descr
 	lidt idt_descr
-	ljmp $(__KERNEL_CS),$1f
-1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
-	movl %eax,%ds		# after changing gdt.
-	movl %eax,%es
-	movl %eax,%fs
-	movl %eax,%gs
-#ifdef CONFIG_SMP
-	movl $(__KERNEL_DS), %eax
-	movl %eax,%ss		# Reload the stack pointer (segment only)
-#else
-	lss stack_start,%esp	# Load processor stack
-#endif
 	xorl %eax,%eax
 	lldt %ax
 	cld			# gcc2 wants the direction flag cleared at all times
@@ -272,8 +318,6 @@ L6:
 	jmp L6			# main should never return here, but
 				# just in case, we know what happens.
 
-ready:	.byte 0
-
 /*
  * We depend on ET to be correct. This checks for 287/387.
  */
@@ -319,13 +363,6 @@ rp_sidt:
 	jne rp_sidt
 	ret
 
-ENTRY(stack_start)
-	.long SYMBOL_NAME(init_task_union)+8192
-	.long __KERNEL_DS
-
-/* This is the default interrupt "handler" :-) */
-int_msg:
-	.asciz "Unknown interrupt, stack: %p %p %p %p\n"
 	ALIGN
 ignore_int:
 	cld
@@ -341,6 +378,18 @@ ignore_int:
 1:	hlt
 	jmp 1b
 
+.data
+ready:	.byte 0
+
+ENTRY(stack_start)
+	.long SYMBOL_NAME(init_task_union)+8192-8
+	.long __KERNEL_DS
+
+.section .rodata,"a"
+/* This is the default interrupt "handler" :-) */
+int_msg:
+	.asciz "Unknown interrupt, stack: %p %p %p %p\n"
+
 /*
  * The interrupt descriptor table has room for 256 idt's,
  * the global descriptor table is dependent on the number
@@ -360,60 +409,134 @@ idt_descr:
 SYMBOL_NAME(idt):
 	.long SYMBOL_NAME(idt_table)
 
+.globl SYMBOL_NAME(boot_gdt_table)
+boot_gdt_table:
+	.fill __KERNEL_CS,1,0
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+
 	.word 0
 gdt_descr:
 	.word GDT_ENTRIES*8-1
 SYMBOL_NAME(gdt):
 	.long SYMBOL_NAME(gdt_table)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+.globl SYMBOL_NAME(gdt2)
+	.word 0
+gdt_descr2:
+	.word GDT_ENTRIES*8-1
+SYMBOL_NAME(gdt2):
+	.long SYMBOL_NAME(gdt_table2)
+#endif
+
 /*
- * This is initialized to create an identity-mapping at 0-8M (for bootup
- * purposes) and another mapping of the 0-8M area at virtual address
+ * This is initialized to create an identity-mapping at 0-16M (for bootup
+ * purposes) and another mapping of the 0-16M area at virtual address
  * PAGE_OFFSET.
  */
-.org 0x1000
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
-	.long 0x00102007
-	.long 0x00103007
-	.fill BOOT_USER_PGD_PTRS-2,4,0
-	/* default: 766 entries */
-	.long 0x00102007
-	.long 0x00103007
-	/* default: 254 entries */
-	.fill BOOT_KERNEL_PGD_PTRS-2,4,0
+#ifdef CONFIG_X86_PAE
+	.long swapper_pm_dir-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*8-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*16-__PAGE_OFFSET+1
+	.long 0
+	.long swapper_pm_dir+512*24-__PAGE_OFFSET+1
+	.long 0
+#else
+	.long pg0-__PAGE_OFFSET+63
+	.long pg0+1024*4-__PAGE_OFFSET+63
+	.long pg0+1024*8-__PAGE_OFFSET+63
+	.long pg0+1024*12-__PAGE_OFFSET+63
+	.fill BOOT_USER_PGD_PTRS-4,4,0
+	/* default: 764 entries */
+	.long pg0-__PAGE_OFFSET+67
+	.long pg0+1024*4-__PAGE_OFFSET+63
+	.long pg0+1024*8-__PAGE_OFFSET+63
+	.long pg0+1024*12-__PAGE_OFFSET+63
+	/* default: 252 entries */
+	.fill BOOT_KERNEL_PGD_PTRS-4,4,0
+#endif
+
+#ifdef CONFIG_X86_PAE
+.section .swapper_pm_dir,"a",@progbits
+ENTRY(swapper_pm_dir)
+	.long pg0-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*8-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*16-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*24-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*32-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*40-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*48-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*56-__PAGE_OFFSET+63
+	.long 0
+	.fill BOOT_USER_PMD_PTRS-8,8,0
+	/* default: 1024+512-4 entries */
+	.long pg0-__PAGE_OFFSET+67
+	.long 0
+	.long pg0+512*8-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*16-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*24-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*32-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*40-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*48-__PAGE_OFFSET+63
+	.long 0
+	.long pg0+512*56-__PAGE_OFFSET+63
+	.long 0
+	/* default: 512-4 entries */
+	.fill BOOT_KERNEL_PMD_PTRS-8,8,0
+#endif
 
 /*
- * The page tables are initialized to only 8MB here - the final page
+ * The page tables are initialized to only 16MB here - the final page
  * tables are set up later depending on memory size.
  */
-.org 0x2000
+.section .pg0,"a",@progbits
 ENTRY(pg0)
+	.fill 1024*4,4,0
 
-.org 0x3000
-ENTRY(pg1)
+#ifdef CONFIG_X86_PAE
+	.fill 1024*4,4,0
+#endif
 
 /*
  * empty_zero_page must immediately follow the page tables ! (The
  * initialization loop counts until empty_zero_page)
  */
-
-.org 0x4000
+.section .empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
-
-.org 0x5000
+	.fill 1024,4,0
 
 /*
- * Real beginning of normal "text" segment
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
  */
-ENTRY(stext)
-ENTRY(_stext)
+.section .idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
 
 /*
  * This starts the data section. Note that the above is all
  * in the text section because it has alignment requirements
  * that we cannot fulfill any other way.
  */
-.data
+.section .rodata,"a",@progbits
 
 ALIGN
 /*
@@ -425,18 +548,39 @@ ALIGN
 ENTRY(gdt_table)
 	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x0000000000000000	/* not used */
-	.quad 0x00cf9a000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
-	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
-	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
-	.quad 0x0000000000000000	/* not used */
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x23 user   4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x2b user   4GB data at 0x00000000 */
+	.quad 0x0000000000000000	/* PCIBIOS_CS */
+	.quad 0x0000000000000000	/* PCIBIOS_DS */
+	/*
+	 * The APM segments have byte granularity and their bases
+	 * and limits are set at run time.
+	 */
+	.quad 0x0040930000000000	/* 0x40 APM set up for bad BIOS's */
+	.quad 0x00409b0000000000	/* 0x48 APM CS    code */
+	.quad 0x00009b0000000000	/* 0x50 APM CS 16 code (16 bit) */
+	.quad 0x0040930000000000	/* 0x58 APM DS    data */
+	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+ENTRY(gdt_table2)
+	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x0000000000000000	/* not used */
+	.quad 0x00cf9b000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+	.quad 0x60c5fb000000ffff	/* 0x23 user 1.5GB code at 0x60000000 */
+	.quad 0x00cff3000000ffff	/* 0x2b user   4GB data at 0x00000000 */
+	.quad 0x0000000000000000	/* PCIBIOS_CS */
+	.quad 0x0000000000000000	/* PCIBIOS_DS */
 	/*
 	 * The APM segments have byte granularity and their bases
 	 * and limits are set at run time.
 	 */
-	.quad 0x0040920000000000	/* 0x40 APM set up for bad BIOS's */
-	.quad 0x00409a0000000000	/* 0x48 APM CS    code */
-	.quad 0x00009a0000000000	/* 0x50 APM CS 16 code (16 bit) */
-	.quad 0x0040920000000000	/* 0x58 APM DS    data */
+	.quad 0x0040930000000000	/* 0x40 APM set up for bad BIOS's */
+	.quad 0x00409b0000000000	/* 0x48 APM CS    code */
+	.quad 0x00009b0000000000	/* 0x50 APM CS 16 code (16 bit) */
+	.quad 0x0040930000000000	/* 0x58 APM DS    data */
 	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
+#endif
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/i386_ksyms.c linux-2.4.37-pax/arch/i386/kernel/i386_ksyms.c
--- linux-2.4.37/arch/i386/kernel/i386_ksyms.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/i386_ksyms.c	2008-12-02 10:29:30.000000000 +0100
@@ -34,7 +34,7 @@ extern void dump_thread(struct pt_regs *
 extern spinlock_t rtc_lock;
 
 #if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
-extern void machine_real_restart(unsigned char *, int);
+extern void machine_real_restart(const unsigned char *, unsigned int);
 EXPORT_SYMBOL(machine_real_restart);
 extern void default_idle(void);
 EXPORT_SYMBOL(default_idle);
@@ -74,6 +74,11 @@ EXPORT_SYMBOL(pm_power_off);
 EXPORT_SYMBOL(get_cmos_time);
 EXPORT_SYMBOL(apm_info);
 EXPORT_SYMBOL(gdt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+EXPORT_SYMBOL(gdt2);
+#endif
+
 EXPORT_SYMBOL(empty_zero_page);
 
 #ifdef CONFIG_DEBUG_IOVIRT
@@ -86,6 +91,8 @@ EXPORT_SYMBOL_NOVERS(__down_failed_trylo
 EXPORT_SYMBOL_NOVERS(__up_wakeup);
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_generic);
+EXPORT_SYMBOL(csum_partial_copy_generic_to_user);
+EXPORT_SYMBOL(csum_partial_copy_generic_from_user);
 /* Delay loops */
 EXPORT_SYMBOL(__ndelay);
 EXPORT_SYMBOL(__udelay);
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/i8259.c linux-2.4.37-pax/arch/i386/kernel/i8259.c
--- linux-2.4.37/arch/i386/kernel/i8259.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/i8259.c	2008-12-02 10:29:30.000000000 +0100
@@ -107,7 +107,8 @@ BUILD_SMP_INTERRUPT(spurious_interrupt,S
 	IRQ(x,8), IRQ(x,9), IRQ(x,a), IRQ(x,b), \
 	IRQ(x,c), IRQ(x,d), IRQ(x,e), IRQ(x,f)
 
-void (*interrupt[NR_IRQS])(void) = {
+typedef void (*interrupt_t)(void);
+const interrupt_t interrupt[NR_IRQS] = {
 	IRQLIST_16(0x0),
 
 #ifdef CONFIG_X86_IO_APIC
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/init_task.c linux-2.4.37-pax/arch/i386/kernel/init_task.c
--- linux-2.4.37/arch/i386/kernel/init_task.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/init_task.c	2008-12-02 10:29:30.000000000 +0100
@@ -29,5 +29,9 @@ union task_union init_task_union 
  * section. Since TSS's are completely CPU-local, we want them
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */ 
-struct tss_struct init_tss[NR_CPUS] __cacheline_aligned = { [0 ... NR_CPUS-1] = INIT_TSS };
 
+#ifdef CONFIG_PAX_KERNEXEC
+struct tss_struct init_tss[NR_CPUS] __attribute__((__aligned__(SMP_CACHE_BYTES), __section__(".rodata"))) = { [0 ... NR_CPUS-1] = INIT_TSS };
+#else
+struct tss_struct init_tss[NR_CPUS] __cacheline_aligned = { [0 ... NR_CPUS-1] = INIT_TSS };
+#endif
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/io_apic.c linux-2.4.37-pax/arch/i386/kernel/io_apic.c
--- linux-2.4.37/arch/i386/kernel/io_apic.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/io_apic.c	2008-12-02 10:29:30.000000000 +0100
@@ -620,7 +620,8 @@ next:
 	return current_vector;
 }
 
-extern void (*interrupt[NR_IRQS])(void);
+typedef void (*interrupt_t)(void);
+extern const interrupt_t interrupt[NR_IRQS];
 static struct hw_interrupt_type ioapic_level_irq_type;
 static struct hw_interrupt_type ioapic_edge_irq_type;
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/ioport.c linux-2.4.37-pax/arch/i386/kernel/ioport.c
--- linux-2.4.37/arch/i386/kernel/ioport.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/ioport.c	2008-12-02 10:29:30.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
+#include <asm/desc.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
@@ -57,6 +58,10 @@ asmlinkage int sys_ioperm(unsigned long 
 	struct thread_struct * t = &current->thread;
 	struct tss_struct * tss = init_tss + smp_processor_id();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
@@ -78,6 +83,11 @@ asmlinkage int sys_ioperm(unsigned long 
 	 * do it in the per-thread copy and in the TSS ...
 	 */
 	set_bitmap(t->io_bitmap, from, num, !turn_on);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	if (tss->bitmap == IO_BITMAP_OFFSET) { /* already active? */
 		set_bitmap(tss->io_bitmap, from, num, !turn_on);
 	} else {
@@ -85,6 +95,10 @@ asmlinkage int sys_ioperm(unsigned long 
 		tss->bitmap = IO_BITMAP_OFFSET; /* Activate it in the TSS */
 	}
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	return 0;
 }
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/ldt.c linux-2.4.37-pax/arch/i386/kernel/ldt.c
--- linux-2.4.37/arch/i386/kernel/ldt.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/ldt.c	2008-12-02 10:29:30.000000000 +0100
@@ -151,7 +151,7 @@ static int read_default_ldt(void * ptr, 
 {
 	int err;
 	unsigned long size;
-	void *address;
+	const void *address;
 
 	err = 0;
 	address = &default_ldt[0];
@@ -214,6 +214,13 @@ static int write_ldt(void * ptr, unsigne
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & 2)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	entry_1 = ((ldt_info.base_addr & 0x0000ffff) << 16) |
 		  (ldt_info.limit & 0x0ffff);
 	entry_2 = (ldt_info.base_addr & 0xff000000) |
@@ -224,7 +231,7 @@ static int write_ldt(void * ptr, unsigne
 		  ((ldt_info.seg_not_present ^ 1) << 15) |
 		  (ldt_info.seg_32bit << 22) |
 		  (ldt_info.limit_in_pages << 23) |
-		  0x7000;
+		  0x7100;
 	if (!oldmode)
 		entry_2 |= (ldt_info.useable << 20);
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/mpparse.c linux-2.4.37-pax/arch/i386/kernel/mpparse.c
--- linux-2.4.37/arch/i386/kernel/mpparse.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/mpparse.c	2008-12-02 10:29:30.000000000 +0100
@@ -833,7 +833,7 @@ void __init get_smp_config (void)
 		 * Read the physical hardware table.  Anything here will
 		 * override the defaults.
 		 */
-		if (!smp_read_mpc((void *)mpf->mpf_physptr)) {
+		if (!smp_read_mpc(phys_to_virt(mpf->mpf_physptr))) {
 			smp_found_config = 0;
 			printk(KERN_ERR "BIOS bug, MP table errors detected!...\n");
 			printk(KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/pci-pc.c linux-2.4.37-pax/arch/i386/kernel/pci-pc.c
--- linux-2.4.37/arch/i386/kernel/pci-pc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/pci-pc.c	2008-12-02 10:29:30.000000000 +0100
@@ -17,6 +17,7 @@
 #include <asm/io.h>
 #include <asm/smp.h>
 #include <asm/smpboot.h>
+#include <asm/desc.h>
 
 #include "pci-i386.h"
 
@@ -575,11 +576,10 @@ union bios32 {
  * we'll make pcibios_present() take a memory start parameter and store
  * the array there.
  */
-
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} bios32_indirect = { 0, __KERNEL_CS };
+} bios32_indirect = { 0, __PCIBIOS_CS };
 
 /*
  * Returns the entry point for the given service, NULL on error
@@ -593,34 +593,122 @@ static unsigned long bios32_service(unsi
 	unsigned long entry;		/* %edx */
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	__save_flags(flags); __cli();
-	__asm__("lcall (%%edi); cld"
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	gdt_table[6].a = 0x0000FFFFUL;
+	gdt_table[6].b = 0x00CF9B00UL;
+	gdt_table[7].a = 0x0000FFFFUL;
+	gdt_table[7].b = 0x00CF9300UL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[6].a = 0x0000FFFFUL;
+	gdt_table2[6].b = 0x00CF9B00UL;
+	gdt_table2[7].a = 0x0000FFFFUL;
+	gdt_table2[7].b = 0x00CF9300UL;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	__asm__("movw %w7, %%ds; lcall *(%%edi); push %%ss; pop %%ds; cld"
 		: "=a" (return_code),
 		  "=b" (address),
 		  "=c" (length),
 		  "=d" (entry)
 		: "0" (service),
 		  "1" (0),
-		  "D" (&bios32_indirect));
+		  "D" (&bios32_indirect),
+		  "r" (__PCIBIOS_DS)
+		: "memory");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	gdt_table[6].a = 0;
+	gdt_table[6].b = 0;
+	gdt_table[7].a = 0;
+	gdt_table[7].b = 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[6].a = 0;
+	gdt_table2[6].b = 0;
+	gdt_table2[7].a = 0;
+	gdt_table2[7].b = 0;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	__restore_flags(flags);
 
 	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
-				service, return_code);
+	case 0: {
+		unsigned long a, b1, b2;
+		unsigned char flags;
+
+		printk(KERN_INFO "bios32_service: base:%08lx length:%08lx entry:%08lx\n", address, length, entry);
+		if (address >= 0xFFFF0 || length >= 0xFFFF0 - address || length <= entry) {
+			printk(KERN_WARNING "bios32_service: not valid\n");
 			return 0;
+		}
+		address = address + PAGE_OFFSET;
+		length += 16UL; /* some BIOSs underreport this... */
+		flags = 4;
+		if (length >= 64*1024*1024) {
+			length >>= PAGE_SHIFT;
+			flags |= 8;
+		}
+		a = (length & 0xFFFFUL) | ((address & 0xFFFFUL) << 16);
+		b1 = (address & 0xFF000000UL) | ((address & 0x00FF0000UL) >> 16) | (length & 0xF0000UL) | (flags << 20) | 0x9B00UL;
+		b2 = (address & 0xFF000000UL) | ((address & 0x00FF0000UL) >> 16) | (length & 0xF0000UL) | (flags << 20) | 0x9300UL;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_open_kernel(cr0);
+#endif
+
+		gdt_table[6].a = a;
+		gdt_table[6].b = b1;
+		gdt_table[7].a = a;
+		gdt_table[7].b = b2;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		gdt_table2[6].a = a;
+		gdt_table2[6].b = b1;
+		gdt_table2[7].a = a;
+		gdt_table2[7].b = b2;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+
+		return entry;
+	}
+	case 0x80:	/* Not present */
+		printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
+		return 0;
+	default: /* Shouldn't happen */
+		printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
+			service, return_code);
+		return 0;
 	}
 }
 
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} pci_indirect = { 0, __KERNEL_CS };
+} pci_indirect = { 0, __PCIBIOS_CS };
 
 static int pci_bios_present;
 
@@ -631,11 +719,13 @@ static int __devinit check_pcibios(void)
 	unsigned long flags, pcibios_entry;
 
 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry + PAGE_OFFSET;
+		pci_indirect.address = pcibios_entry;
 
 		__save_flags(flags); __cli();
-		__asm__(
-			"lcall (%%edi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%edi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -644,7 +734,8 @@ static int __devinit check_pcibios(void)
 			  "=b" (ebx),
 			  "=c" (ecx)
 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
+			  "D" (&pci_indirect),
+			  "r" (__PCIBIOS_DS)
 			: "memory");
 		__restore_flags(flags);
 
@@ -680,7 +771,10 @@ static int __devinit pci_bios_find_devic
 	unsigned short bx;
 	unsigned short ret;
 
-	__asm__("lcall (%%edi); cld\n\t"
+	__asm__("movw %w7, %%ds\n\t"
+		"lcall *%%ss:(%%edi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n\t"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -690,7 +784,8 @@ static int __devinit pci_bios_find_devic
 		  "c" (device_id),
 		  "d" (vendor),
 		  "S" ((int) index),
-		  "D" (&pci_indirect));
+		  "D" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	*bus = (bx >> 8) & 0xff;
 	*device_fn = bx & 0xff;
 	return (int) (ret & 0xff00) >> 8;
@@ -709,7 +804,10 @@ static int pci_bios_read (int seg, int b
 
 	switch (len) {
 	case 1:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -718,10 +816,14 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_BYTE),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -730,10 +832,14 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_WORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -742,7 +848,8 @@ static int pci_bios_read (int seg, int b
 			: "1" (PCIBIOS_READ_CONFIG_DWORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -764,7 +871,10 @@ static int pci_bios_write (int seg, int 
 
 	switch (len) {
 	case 1:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -773,10 +883,14 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -785,10 +899,14 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall (%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -797,7 +915,8 @@ static int pci_bios_write (int seg, int 
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -1009,10 +1128,13 @@ struct irq_routing_table * __devinit pci
 
 	DBG("PCI: Fetching IRQ routing table... ");
 	__asm__("push %%es\n\t"
+		"movw %w8, %%ds\n\t"
 		"push %%ds\n\t"
 		"pop  %%es\n\t"
-		"lcall (%%esi); cld\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
 		"pop %%es\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -1023,7 +1145,8 @@ struct irq_routing_table * __devinit pci
 		  "1" (0),
 		  "D" ((long) &opt),
 		  "S" (&pci_indirect),
-		  "m" (opt)
+		  "m" (opt),
+		  "r" (__PCIBIOS_DS)
 		: "memory");
 	DBG("OK  ret=%d, size=%d, map=%x\n", ret, opt.size, map);
 	if (ret & 0xff00)
@@ -1047,7 +1170,10 @@ int pcibios_set_irq_routing(struct pci_d
 {
 	int ret;
 
-	__asm__("lcall (%%esi); cld\n\t"
+	__asm__("movw %w5, %%ds\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -1055,7 +1181,8 @@ int pcibios_set_irq_routing(struct pci_d
 		: "0" (PCIBIOS_SET_PCI_HW_INT),
 		  "b" ((dev->bus->number << 8) | dev->devfn),
 		  "c" ((irq << 8) | (pin + 10)),
-		  "S" (&pci_indirect));
+		  "S" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	return !(ret & 0xff00);
 }
 
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/process.c linux-2.4.37-pax/arch/i386/kernel/process.c
--- linux-2.4.37/arch/i386/kernel/process.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/process.c	2008-12-02 10:29:30.000000000 +0100
@@ -153,7 +153,7 @@ static int __init idle_setup (char *str)
 
 __setup("idle=", idle_setup);
 
-static int reboot_mode;
+static unsigned short reboot_mode;
 int reboot_thru_bios;
 
 #ifdef CONFIG_SMP
@@ -209,18 +209,18 @@ __setup("reboot=", reboot_setup);
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
 
-static unsigned long long
+static const unsigned long long
 real_mode_gdt_entries [3] =
 {
 	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009a000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000092000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	0x00009b000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
+	0x000093000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
-static struct
+static const struct
 {
 	unsigned short       size __attribute__ ((packed));
-	unsigned long long * base __attribute__ ((packed));
+	const unsigned long long * base __attribute__ ((packed));
 }
 real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, real_mode_gdt_entries },
 real_mode_idt = { 0x3ff, 0 },
@@ -245,7 +245,7 @@ no_idt = { 0, 0 };
    More could be done here to set up the registers as if a CPU reset had
    occurred; hopefully real BIOSs don't assume much. */
 
-static unsigned char real_mode_switch [] =
+static const unsigned char real_mode_switch [] =
 {
 	0x66, 0x0f, 0x20, 0xc0,			/*    movl  %cr0,%eax        */
 	0x66, 0x83, 0xe0, 0x11,			/*    andl  $0x00000011,%eax */
@@ -259,7 +259,7 @@ static unsigned char real_mode_switch []
 	0x24, 0x10,				/* f: andb  $0x10,al         */
 	0x66, 0x0f, 0x22, 0xc0			/*    movl  %eax,%cr0        */
 };
-static unsigned char jump_to_bios [] =
+static const unsigned char jump_to_bios [] =
 {
 	0xea, 0x00, 0x00, 0xff, 0xff		/*    ljmp  $0xffff,$0x0000  */
 };
@@ -278,10 +278,14 @@ static inline void kb_wait(void)
  * specified by the code and length parameters.
  * We assume that length will aways be less that 100!
  */
-void machine_real_restart(unsigned char *code, int length)
+void machine_real_restart(const unsigned char *code, unsigned int length)
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	cli();
 
 	/* Write zero to CMOS register number 0x0f, which the BIOS POST
@@ -302,9 +306,17 @@ void machine_real_restart(unsigned char 
 	   from the kernel segment.  This assumes the kernel segment starts at
 	   virtual address PAGE_OFFSET. */
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	memcpy (swapper_pg_dir, swapper_pg_dir + USER_PGD_PTRS,
 		sizeof (swapper_pg_dir [0]) * KERNEL_PGD_PTRS);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/* Make sure the first page is mapped to the start of physical memory.
 	   It is normally not mapped, to trap kernel NULL pointer dereferences. */
 
@@ -321,7 +333,7 @@ void machine_real_restart(unsigned char 
 	   REBOOT.COM programs, and the previous reset routine did this
 	   too. */
 
-	*((unsigned short *)0x472) = reboot_mode;
+	__put_user(reboot_mode, (unsigned short *)0x472);
 
 	/* For the switch to real mode, copy some code to low memory.  It has
 	   to be in the first 64k because it is running in 16-bit mode, and it
@@ -329,9 +341,9 @@ void machine_real_restart(unsigned char 
 	   off paging.  Copy it near the end of the first page, out of the way
 	   of BIOS variables. */
 
-	memcpy ((void *) (0x1000 - sizeof (real_mode_switch) - 100),
+	__copy_to_user ((void *) (0x1000 - sizeof (real_mode_switch) - 100),
 		real_mode_switch, sizeof (real_mode_switch));
-	memcpy ((void *) (0x1000 - 100), code, length);
+	__copy_to_user ((void *) (0x1000 - 100), code, length);
 
 	/* Set up the IDT for real mode. */
 
@@ -414,7 +426,7 @@ void machine_restart(char * __unused)
 
 	if(!reboot_thru_bios) {
 		/* rebooting needs to touch the page at absolute addr 0 */
-		*((unsigned short *)__va(0x472)) = reboot_mode;
+		__put_user(reboot_mode, (unsigned short *)0x472);
 		for (;;) {
 			int i;
 			for (i=0; i<100; i++) {
@@ -552,7 +564,7 @@ int copy_thread(int nr, unsigned long cl
 {
 	struct pt_regs * childregs;
 
-	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p)) - 1;
+	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p - sizeof(unsigned long))) - 1;
 	struct_cpy(childregs, regs);
 	childregs->eax = 0;
 	childregs->esp = esp;
@@ -613,6 +625,19 @@ void dump_thread(struct pt_regs * regs, 
 	dump->u_fpvalid = dump_fpu (regs, &dump->i387);
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+void pax_switch_segments(struct task_struct * tsk)
+{
+	if (!tsk->mm)
+		return;
+
+	if (tsk->mm->pax_flags & MF_PAX_SEGMEXEC)
+		__asm__ __volatile__("lgdt %0": "=m" (gdt_descr2));
+	else
+		__asm__ __volatile__("lgdt %0": "=m" (gdt_descr));
+}
+#endif
+
 /*
  * This special macro can be used to load a debugging register
  */
@@ -650,12 +675,15 @@ void fastcall __switch_to(struct task_st
 				 *next = &next_p->thread;
 	struct tss_struct *tss = init_tss + smp_processor_id();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	unlazy_fpu(prev_p);
 
-	/*
-	 * Reload esp0, LDT and the page table pointer:
-	 */
-	tss->esp0 = next->esp0;
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_switch_segments(next_p);
+#endif
 
 	/*
 	 * Save away %fs and %gs. No need to save %es and %ds, as
@@ -683,6 +711,15 @@ void fastcall __switch_to(struct task_st
 		loaddebug(next, 7);
 	}
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	/*
+	 * Reload esp0, LDT and the page table pointer:
+	 */
+	tss->esp0 = next->esp0;
+
 	if (prev->ioperm || next->ioperm) {
 		if (next->ioperm) {
 			/*
@@ -705,6 +742,11 @@ void fastcall __switch_to(struct task_st
 			 */
 			tss->bitmap = INVALID_IO_BITMAP_OFFSET;
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 asmlinkage int sys_fork(struct pt_regs regs)
@@ -792,3 +834,44 @@ unsigned long get_wchan(struct task_stru
 }
 #undef last_sched
 #undef first_sched
+
+#ifdef CONFIG_PAX_RANDKSTACK
+asmlinkage void pax_randomize_kstack(void)
+{
+	struct tss_struct *tss;
+	unsigned long time;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (!pax_aslr)
+		return;
+#endif
+
+	tss = init_tss + smp_processor_id();
+	rdtscl(time);
+
+	/* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x1EUL;
+	time <<= 2;
+#else
+	time &= 0xFUL;
+	time <<= 3;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	tss->esp0 ^= time;
+	current->thread.esp0 = tss->esp0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+}
+#endif
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/setup.c linux-2.4.37-pax/arch/i386/kernel/setup.c
--- linux-2.4.37/arch/i386/kernel/setup.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/setup.c	2008-12-02 10:29:30.000000000 +0100
@@ -129,7 +129,11 @@
 char ignore_irq13;		/* set if exception 16 works */
 struct cpuinfo_x86 boot_cpu_data = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
 
+#ifdef CONFIG_X86_PAE
+unsigned long mmu_cr4_features = X86_CR4_PAE;
+#else
 unsigned long mmu_cr4_features;
+#endif
 EXPORT_SYMBOL(mmu_cr4_features);
 
 /*
@@ -170,7 +174,7 @@ unsigned char aux_device_present;
 extern void mcheck_init(struct cpuinfo_x86 *c);
 extern void dmi_scan_machine(void);
 extern int root_mountflags;
-extern char _text, _etext, _edata, _end;
+extern char _text, _etext, _data, _edata, _end;
 
 static int have_cpuid_p(void) __init;
 
@@ -1209,14 +1213,14 @@ void __init setup_arch(char **cmdline_p)
 
 	if (!MOUNT_ROOT_RDONLY)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) &_text;
-	init_mm.end_code = (unsigned long) &_etext;
+	init_mm.start_code = (unsigned long) &_text + __KERNEL_TEXT_OFFSET;
+	init_mm.end_code = (unsigned long) &_etext + __KERNEL_TEXT_OFFSET;
 	init_mm.end_data = (unsigned long) &_edata;
 	init_mm.brk = (unsigned long) &_end;
 
-	code_resource.start = virt_to_bus(&_text);
-	code_resource.end = virt_to_bus(&_etext)-1;
-	data_resource.start = virt_to_bus(&_etext);
+	code_resource.start = virt_to_bus(&_text + __KERNEL_TEXT_OFFSET);
+	code_resource.end = virt_to_bus(&_etext + __KERNEL_TEXT_OFFSET)-1;
+	data_resource.start = virt_to_bus(&_data);
 	data_resource.end = virt_to_bus(&_edata)-1;
 
 	parse_cmdline_early(cmdline_p);
@@ -3184,6 +3188,10 @@ void __init cpu_init (void)
 	int nr = smp_processor_id();
 	struct tss_struct * t = &init_tss[nr];
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (test_and_set_bit(nr, &cpu_initialized)) {
 		printk(KERN_WARNING "CPU#%d already initialized!\n", nr);
 		for (;;) __sti();
@@ -3218,10 +3226,19 @@ void __init cpu_init (void)
 		BUG();
 	enter_lazy_tlb(&init_mm, current, nr);
 
-	t->esp0 = current->thread.esp0;
 	set_tss_desc(nr,t);
-	gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	t->esp0 = current->thread.esp0;
 	load_TR(nr);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	load_LDT(&init_mm.context);
 
 	/*
@@ -3288,7 +3305,53 @@ int __init ppro_with_ram_bug(void)
 	printk(KERN_INFO "Your Pentium Pro seems ok.\n");
 	return 0;
 }
-	
+
+static int current_ypos = 25, current_xpos;
+#define VGABASE (0xb8000)
+#define VGAXY(x, y) (VGABASE + 2 * (x + y * SCREEN_INFO.orig_video_cols))
+
+static void early_vga_write(const char *str, int n)
+{
+	char c;
+	int  i, k, j;
+
+	while ((c = *str++) != '\0' && n-- > 0) {
+		if (current_ypos >= SCREEN_INFO.orig_video_lines) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < SCREEN_INFO.orig_video_lines; k++, j++) {
+				for (i = 0; i < SCREEN_INFO.orig_video_cols; i++) {
+					isa_writew(isa_readw(VGAXY(i, k)), VGAXY(i, j));
+				}
+			}
+			for (i = 0; i < SCREEN_INFO.orig_video_cols; i++)
+				isa_writew(0x720, VGAXY(i, j));
+			current_ypos = SCREEN_INFO.orig_video_lines-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			isa_writew((0x700 | (unsigned short) c), VGAXY(current_xpos, current_ypos));
+			if (++current_xpos >= SCREEN_INFO.orig_video_cols) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+asmlinkage void __init early_printk(const char *fmt, ...)
+{
+	char buf[512];
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vsnprintf(buf, 512, fmt, ap);
+	early_vga_write(buf, n);
+	va_end(ap);
+}
+
 /*
  * Local Variables:
  * mode:c
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/sys_i386.c linux-2.4.37-pax/arch/i386/kernel/sys_i386.c
--- linux-2.4.37/arch/i386/kernel/sys_i386.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/sys_i386.c	2008-12-02 10:29:30.000000000 +0100
@@ -48,6 +48,11 @@ static inline long do_mmap2(
 	int error = -EBADF;
 	struct file * file = NULL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR)
+		return -EINVAL;
+#endif
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/trampoline.S linux-2.4.37-pax/arch/i386/kernel/trampoline.S
--- linux-2.4.37/arch/i386/kernel/trampoline.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/trampoline.S	2008-12-02 10:29:30.000000000 +0100
@@ -54,7 +54,7 @@ r_base = .
 	lmsw	%ax		# into protected mode
 	jmp	flush_instr
 flush_instr:
-	ljmpl	$__KERNEL_CS, $0x00100000
+	ljmpl	$__KERNEL_CS, $SYMBOL_NAME(startup_32) + __KERNEL_TEXT_OFFSET - __PAGE_OFFSET
 			# jump to startup_32 in arch/i386/kernel/head.S
 
 idt_48:
@@ -62,8 +62,8 @@ idt_48:
 	.word	0, 0			# idt base = 0L
 
 gdt_48:
-	.word	0x0800			# gdt limit = 2048, 256 GDT entries
-	.long	gdt_table-__PAGE_OFFSET	# gdt base = gdt (first SMP CPU)
+	.word	__KERNEL_DS+7			# gdt limit = just the minimum
+	.long	boot_gdt_table-__PAGE_OFFSET	# gdt base = boot_gdt (first SMP CPU)
 
 .globl SYMBOL_NAME(trampoline_end)
 SYMBOL_NAME_LABEL(trampoline_end)
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/traps.c linux-2.4.37-pax/arch/i386/kernel/traps.c
--- linux-2.4.37/arch/i386/kernel/traps.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/traps.c	2008-12-02 10:29:30.000000000 +0100
@@ -54,15 +54,10 @@ asmlinkage int system_call(void);
 asmlinkage void lcall7(void);
 asmlinkage void lcall27(void);
 
-struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
+const struct desc_struct default_ldt[] = { { 0, 0 }, { 0, 0 }, { 0, 0 },
 		{ 0, 0 }, { 0, 0 } };
 
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.. We have a special link segment
- * for this.
- */
-struct desc_struct idt_table[256] __attribute__((__section__(".data.idt"))) = { {0, 0}, };
+extern struct desc_struct idt_table[256];
 
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
@@ -87,6 +82,7 @@ asmlinkage void machine_check(void);
 
 int kstack_depth_to_print = 24;
 
+extern char _text, _sinittext, _einittext;
 
 /*
  * If the address is either in the .text section of the
@@ -104,6 +100,10 @@ static inline int kernel_text_address(un
 	int retval = 0;
 	struct module *mod;
 
+	if (addr >= (unsigned long) &_sinittext &&
+	    addr <= (unsigned long) &_einittext)
+		return 1;
+
 	if (addr >= (unsigned long) &_stext &&
 	    addr <= (unsigned long) &_etext)
 		return 1;
@@ -125,8 +125,15 @@ static inline int kernel_text_address(un
 
 static inline int kernel_text_address(unsigned long addr)
 {
-	return (addr >= (unsigned long) &_stext &&
-		addr <= (unsigned long) &_etext);
+	if (addr >= (unsigned long) &_sinittext &&
+	    addr <= (unsigned long) &_einittext)
+		return 1;
+
+	if (addr >= (unsigned long) &_stext &&
+	    addr <= (unsigned long) &_etext)
+		return 1;
+
+	return 0;
 }
 
 #endif
@@ -228,13 +235,13 @@ void show_registers(struct pt_regs *regs
 		show_stack((unsigned long*)esp);
 
 		printk("\nCode: ");
-		if(regs->eip < PAGE_OFFSET)
+		if(regs->eip + __KERNEL_TEXT_OFFSET < PAGE_OFFSET)
 			goto bad;
 
 		for(i=0;i<20;i++)
 		{
 			unsigned char c;
-			if(__get_user(c, &((unsigned char*)regs->eip)[i])) {
+			if(__get_user(c, &((unsigned char*)regs->eip)[i+__KERNEL_TEXT_OFFSET])) {
 bad:
 				printk(" Bad EIP value.");
 				break;
@@ -256,7 +263,7 @@ static void handle_BUG(struct pt_regs *r
 	if (regs->xcs & 3)
 		goto no_bug;		/* Not in kernel */
 
-	eip = regs->eip;
+	eip = regs->eip + __KERNEL_TEXT_OFFSET;
 
 	if (eip < PAGE_OFFSET)
 		goto no_bug;
@@ -264,10 +271,11 @@ static void handle_BUG(struct pt_regs *r
 		goto no_bug;
 	if (ud2 != 0x0b0f)
 		goto no_bug;
-	if (__get_user(line, (unsigned short *)(eip + 2)))
+	if (__get_user(line, (unsigned short *)(eip + 7)))
 		goto bug;
-	if (__get_user(file, (char **)(eip + 4)) ||
-		(unsigned long)file < PAGE_OFFSET || __get_user(c, file))
+	if (__get_user(file, (char **)(eip + 3)) || file < &_text + __KERNEL_TEXT_OFFSET)
+		goto bug;
+	if (__get_user(c, file))
 		file = "<bad filename>";
 
 	printk("kernel BUG at %s:%d!\n", file, line);
@@ -422,6 +430,13 @@ gp_in_kernel:
 			regs->eip = fixup;
 			return;
 		}
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if ((regs->xcs & 0xFFFF) == __KERNEL_CS)
+			die("PAX: suspicious general protection fault", regs, error_code);
+		else
+#endif
+
 		die("general protection fault", regs, error_code);
 	}
 }
@@ -527,13 +542,12 @@ asmlinkage void do_debug(struct pt_regs 
 {
 	unsigned int condition;
 	struct task_struct *tsk = current;
-	unsigned long eip = regs->eip;
 	siginfo_t info;
 
 	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
 
 	/* If the user set TF, it's simplest to clear it right away. */
-	if ((eip >=PAGE_OFFSET) && (regs->eflags & TF_MASK))
+	if (!(regs->xcs & 3) && (regs->eflags & TF_MASK) && !(regs->eflags & VM_MASK))
 		goto clear_TF;
 
 	/* Mask out spurious debug traps due to lazy DR7 setting */
@@ -778,6 +792,8 @@ asmlinkage void math_emulate(long arg)
 #ifndef CONFIG_X86_F00F_WORKS_OK
 void __init trap_init_f00f_bug(void)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	/*
 	 * "idt" is magic - it overlaps the idt_descr
 	 * variable so that updating idt will automatically
@@ -787,12 +803,17 @@ void __init trap_init_f00f_bug(void)
 	idt = (struct desc_struct *)__fix_to_virt(FIX_F00F);
 
 	__asm__ __volatile__("lidt %0": "=m" (idt_descr));
+#endif
+
 }
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
 #define _set_gate(gate_addr,type,dpl,addr) \
 do { \
   int __d0, __d1; \
+  unsigned long cr0; \
+  pax_open_kernel(cr0); \
   __asm__ __volatile__ ("movw %%dx,%%ax\n\t" \
 	"movw %4,%%dx\n\t" \
 	"movl %%eax,%0\n\t" \
@@ -801,8 +822,22 @@ do { \
 	 "=m" (*(1+(long *) (gate_addr))), "=&a" (__d0), "=&d" (__d1) \
 	:"i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
 	 "3" ((char *) (addr)),"2" (__KERNEL_CS << 16)); \
+  pax_close_kernel(cr0); \
 } while (0)
-
+#else
+#define _set_gate(gate_addr,type,dpl,addr) \
+do { \
+  int __d0, __d1; \
+  __asm__ __volatile__ ("movw %%dx,%%ax\n\t" \
+	"movw %4,%%dx\n\t" \
+	"movl %%eax,%0\n\t" \
+	"movl %%edx,%1" \
+	:"=m" (*((long *) (gate_addr))), \
+	 "=m" (*(1+(long *) (gate_addr))), "=&a" (__d0), "=&d" (__d1) \
+	:"i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
+	 "3" ((char *) (addr)),"2" (__KERNEL_CS << 16)); \
+} while (0)
+#endif
 
 /*
  * This needs to use 'idt_table' rather than 'idt', and
@@ -810,26 +845,42 @@ do { \
  * Pentium F0 0F bugfix can have resulted in the mapped
  * IDT being write-protected.
  */
-void set_intr_gate(unsigned int n, void *addr)
+void set_intr_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,14,0,addr);
 }
 
-static void __init set_trap_gate(unsigned int n, void *addr)
+static void __init set_trap_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,15,0,addr);
 }
 
-static void __init set_system_gate(unsigned int n, void *addr)
+static void __init set_system_gate(unsigned int n, const void *addr)
 {
 	_set_gate(idt_table+n,15,3,addr);
 }
 
-static void __init set_call_gate(void *a, void *addr)
+static void __init set_call_gate(const void *a, const void *addr)
 {
 	_set_gate(a,12,3,addr);
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define _set_seg_desc(gate_addr,type,dpl,base,limit) \
+do {\
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*((gate_addr)+1) = ((base) & 0xff000000) | \
+		(((base) & 0x00ff0000)>>16) | \
+		((limit) & 0xf0000) | \
+		((dpl)<<13) | \
+		(0x00408000) | \
+		((type)<<8); \
+	*(gate_addr) = (((base) & 0x0000ffff)<<16) | \
+		((limit) & 0x0ffff); \
+	pax_close_kernel(cr0); \
+} while (0)
+#else
 #define _set_seg_desc(gate_addr,type,dpl,base,limit) {\
 	*((gate_addr)+1) = ((base) & 0xff000000) | \
 		(((base) & 0x00ff0000)>>16) | \
@@ -839,7 +890,25 @@ static void __init set_call_gate(void *a
 		((type)<<8); \
 	*(gate_addr) = (((base) & 0x0000ffff)<<16) | \
 		((limit) & 0x0ffff); }
+#endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define _set_tssldt_desc(n,addr,limit,type) \
+do { \
+  unsigned long cr0; \
+  pax_open_kernel(cr0); \
+  __asm__ __volatile__ ("movw %w3,0(%2)\n\t" \
+	"movw %%ax,2(%2)\n\t" \
+	"rorl $16,%%eax\n\t" \
+	"movb %%al,4(%2)\n\t" \
+	"movb %4,5(%2)\n\t" \
+	"movb $0,6(%2)\n\t" \
+	"movb %%ah,7(%2)\n\t" \
+	"rorl $16,%%eax" \
+	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type)); \
+  pax_close_kernel(cr0); \
+} while (0)
+#else
 #define _set_tssldt_desc(n,addr,limit,type) \
 __asm__ __volatile__ ("movw %w3,0(%2)\n\t" \
 	"movw %%ax,2(%2)\n\t" \
@@ -850,15 +919,26 @@ __asm__ __volatile__ ("movw %w3,0(%2)\n\
 	"movb %%ah,7(%2)\n\t" \
 	"rorl $16,%%eax" \
 	: "=m"(*(n)) : "a" (addr), "r"(n), "ir"(limit), "i"(type))
+#endif
 
-void set_tss_desc(unsigned int n, void *addr)
+void set_tss_desc(unsigned int n, const void *addr)
 {
 	_set_tssldt_desc(gdt_table+__TSS(n), (int)addr, 235, 0x89);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	_set_tssldt_desc(gdt_table2+__TSS(n), (int)addr, 235, 0x89);
+#endif
+
 }
 
-void set_ldt_desc(unsigned int n, void *addr, unsigned int size)
+void set_ldt_desc(unsigned int n, const void *addr, unsigned int size)
 {
 	_set_tssldt_desc(gdt_table+__LDT(n), (int)addr, ((size << 3)-1), 0x82);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	_set_tssldt_desc(gdt_table2+__LDT(n), (int)addr, ((size << 3)-1), 0x82);
+#endif
+
 }
 
 #ifdef CONFIG_X86_VISWS_APIC
diff -NurpX dontdiff linux-2.4.37/arch/i386/kernel/vm86.c linux-2.4.37-pax/arch/i386/kernel/vm86.c
--- linux-2.4.37/arch/i386/kernel/vm86.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/kernel/vm86.c	2008-12-02 10:29:30.000000000 +0100
@@ -44,6 +44,7 @@
 #include <asm/pgalloc.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/desc.h>
 
 /*
  * Known problems:
@@ -97,6 +98,10 @@ struct pt_regs * fastcall save_v86_state
 	struct pt_regs *ret;
 	unsigned long tmp;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (!current->thread.vm86_info) {
 		printk("no vm86_info: BAD\n");
 		do_exit(SIGSEGV);
@@ -111,7 +116,17 @@ struct pt_regs * fastcall save_v86_state
 		do_exit(SIGSEGV);
 	}
 	tss = init_tss + smp_processor_id();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	tss->esp0 = current->thread.esp0 = current->thread.saved_esp0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	current->thread.saved_esp0 = 0;
 	ret = KVM86->regs32;
 	return ret;
@@ -237,6 +252,11 @@ out:
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk)
 {
 	struct tss_struct *tss;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr3;
+#endif
+
 /*
  * make sure the vm86() system call doesn't try to do anything silly
  */
@@ -278,8 +298,17 @@ static void do_sys_vm86(struct kernel_vm
 	info->regs32->eax = 0;
 	tsk->thread.saved_esp0 = tsk->thread.esp0;
 	tss = init_tss + smp_processor_id();
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr3);
+#endif
+
 	tss->esp0 = tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr3);
+#endif
+
 	tsk->thread.screen_bitmap = info->screen_bitmap;
 	if (info->flags & VM86_SCREEN_BITMAP)
 		mark_screen_rdonly(tsk);
diff -NurpX dontdiff linux-2.4.37/arch/i386/lib/checksum.S linux-2.4.37-pax/arch/i386/lib/checksum.S
--- linux-2.4.37/arch/i386/lib/checksum.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/lib/checksum.S	2008-12-02 10:29:30.000000000 +0100
@@ -27,7 +27,8 @@
 
 #include <linux/config.h>
 #include <asm/errno.h>
-				
+#include <asm/segment.h>
+
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
  */
@@ -281,12 +282,23 @@ unsigned int csum_partial_copy_generic (
 
 .align 4
 .globl csum_partial_copy_generic
-				
+.globl csum_partial_copy_generic_to_user
+.globl csum_partial_copy_generic_from_user
+
 #ifndef CONFIG_X86_USE_PPRO_CHECKSUM
 
 #define ARGBASE 16		
 #define FP		12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	subl  $4,%esp	
 	pushl %edi
@@ -305,7 +317,7 @@ csum_partial_copy_generic:
 	jmp 4f
 SRC(1:	movw (%esi), %bx	)
 	addl $2, %esi
-DST(	movw %bx, (%edi)	)
+DST(	movw %bx, %es:(%edi)	)
 	addl $2, %edi
 	addw %bx, %ax	
 	adcl $0, %eax
@@ -317,30 +329,30 @@ DST(	movw %bx, (%edi)	)
 SRC(1:	movl (%esi), %ebx	)
 SRC(	movl 4(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 4(%edi)	)
+DST(	movl %edx, %es:4(%edi)	)
 
 SRC(	movl 8(%esi), %ebx	)
 SRC(	movl 12(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 8(%edi)	)
+DST(	movl %ebx, %es:8(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 12(%edi)	)
+DST(	movl %edx, %es:12(%edi)	)
 
 SRC(	movl 16(%esi), %ebx 	)
 SRC(	movl 20(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 16(%edi)	)
+DST(	movl %ebx, %es:16(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 20(%edi)	)
+DST(	movl %edx, %es:20(%edi)	)
 
 SRC(	movl 24(%esi), %ebx	)
 SRC(	movl 28(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 24(%edi)	)
+DST(	movl %ebx, %es:24(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 28(%edi)	)
+DST(	movl %edx, %es:28(%edi)	)
 
 	lea 32(%esi), %esi
 	lea 32(%edi), %edi
@@ -354,7 +366,7 @@ DST(	movl %edx, 28(%edi)	)
 	shrl $2, %edx			# This clears CF
 SRC(3:	movl (%esi), %ebx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	lea 4(%esi), %esi
 	lea 4(%edi), %edi
 	dec %edx
@@ -366,12 +378,12 @@ DST(	movl %ebx, (%edi)	)
 	jb 5f
 SRC(	movw (%esi), %cx	)
 	leal 2(%esi), %esi
-DST(	movw %cx, (%edi)	)
+DST(	movw %cx, %es:(%edi)	)
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%ecx
 SRC(5:	movb (%esi), %cl	)
-DST(	movb %cl, (%edi)	)
+DST(	movb %cl, %es:(%edi)	)
 6:	addl %ecx, %eax
 	adcl $0, %eax
 7:
@@ -382,7 +394,7 @@ DST(	movb %cl, (%edi)	)
 
 6001:
 	movl ARGBASE+20(%esp), %ebx	# src_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 
 	# zero the complete destination - computing the rest
 	# is too much work 
@@ -395,11 +407,15 @@ DST(	movb %cl, (%edi)	)
 
 6002:
 	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT,(%ebx)
+	movl $-EFAULT,%ss:(%ebx)
 	jmp 5000b
 
 .previous
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %ebx
 	popl %esi
 	popl %edi
@@ -411,17 +427,28 @@ DST(	movb %cl, (%edi)	)
 /* Version for PentiumII/PPro */
 
 #define ROUND1(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	addl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	; 
+	DST(movl %ebx, %es:x(%edi));
 
 #define ROUND(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	adcl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	;
+	DST(movl %ebx, %es:x(%edi));
 
 #define ARGBASE 12
-		
+
+csum_partial_copy_generic_to_user:
+	pushl $(__USER_DS)
+	popl %es
+	jmp csum_partial_copy_generic
+
+csum_partial_copy_generic_from_user:
+	pushl $(__USER_DS)
+	popl %ds
+
 csum_partial_copy_generic:
 	pushl %ebx
 	pushl %edi
@@ -440,7 +467,7 @@ csum_partial_copy_generic:
 	subl %ebx, %edi  
 	lea  -1(%esi),%edx
 	andl $-32,%edx
-	lea 3f(%ebx,%ebx), %ebx
+	lea 3f(%ebx,%ebx,2), %ebx
 	testl %esi, %esi 
 	jmp *%ebx
 1:	addl $64,%esi
@@ -461,19 +488,19 @@ csum_partial_copy_generic:
 	jb 5f
 SRC(	movw (%esi), %dx         )
 	leal 2(%esi), %esi
-DST(	movw %dx, (%edi)         )
+DST(	movw %dx, %es:(%edi)     )
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%edx
 5:
 SRC(	movb (%esi), %dl         )
-DST(	movb %dl, (%edi)         )
+DST(	movb %dl, %es:(%edi)     )
 6:	addl %edx, %eax
 	adcl $0, %eax
 7:
 .section .fixup, "ax"
 6001:	movl	ARGBASE+20(%esp), %ebx	# src_err_ptr	
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	# zero the complete destination (computing the rest is too much work)
 	movl ARGBASE+8(%esp),%edi	# dst
 	movl ARGBASE+12(%esp),%ecx	# len
@@ -481,10 +508,14 @@ DST(	movb %dl, (%edi)         )
 	rep; stosb
 	jmp 7b
 6002:	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	jmp  7b			
 .previous				
 
+	pushl %ss
+	popl %ds
+	pushl %ss
+	popl %es
 	popl %esi
 	popl %edi
 	popl %ebx
diff -NurpX dontdiff linux-2.4.37/arch/i386/lib/getuser.S linux-2.4.37-pax/arch/i386/lib/getuser.S
--- linux-2.4.37/arch/i386/lib/getuser.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/lib/getuser.S	2008-12-02 10:29:30.000000000 +0100
@@ -9,6 +9,8 @@
  * return value.
  */
 
+#include <asm/segment.h>
+
 /*
  * __get_user_X
  *
@@ -31,7 +33,11 @@ __get_user_1:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movzbl (%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
@@ -44,7 +50,11 @@ __get_user_2:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movzwl -1(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
@@ -57,11 +67,17 @@ __get_user_4:
 	andl $0xffffe000,%edx
 	cmpl addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl -3(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 
 bad_get_user:
+	pushl %ss
+	pop %ds
 	xorl %edx,%edx
 	movl $-14,%eax
 	ret
diff -NurpX dontdiff linux-2.4.37/arch/i386/lib/mmx.c linux-2.4.37-pax/arch/i386/lib/mmx.c
--- linux-2.4.37/arch/i386/lib/mmx.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/lib/mmx.c	2008-12-02 10:29:30.000000000 +0100
@@ -30,6 +30,7 @@ void *_mmx_memcpy(void *to, const void *
 {
 	void *p;
 	int i;
+	unsigned long cr0;
 
 	if (in_interrupt())
 		return __memcpy(to, from, len);
@@ -40,52 +41,80 @@ void *_mmx_memcpy(void *to, const void *
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"		/* This set is 28 bytes */
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"		/* This set is 28 bytes */
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 		
 	
 	for(; i>5; i--)
 	{
 		__asm__ __volatile__ (
-		"1:  prefetch 320(%0)\n"
-		"2:  movq (%0), %%mm0\n"
-		"  movq 8(%0), %%mm1\n"
-		"  movq 16(%0), %%mm2\n"
-		"  movq 24(%0), %%mm3\n"
-		"  movq %%mm0, (%1)\n"
-		"  movq %%mm1, 8(%1)\n"
-		"  movq %%mm2, 16(%1)\n"
-		"  movq %%mm3, 24(%1)\n"
-		"  movq 32(%0), %%mm0\n"
-		"  movq 40(%0), %%mm1\n"
-		"  movq 48(%0), %%mm2\n"
-		"  movq 56(%0), %%mm3\n"
-		"  movq %%mm0, 32(%1)\n"
-		"  movq %%mm1, 40(%1)\n"
-		"  movq %%mm2, 48(%1)\n"
-		"  movq %%mm3, 56(%1)\n"
+		"1:  prefetch 320(%1)\n"
+		"2:  movq (%1), %%mm0\n"
+		"  movq 8(%1), %%mm1\n"
+		"  movq 16(%1), %%mm2\n"
+		"  movq 24(%1), %%mm3\n"
+		"  movq %%mm0, (%2)\n"
+		"  movq %%mm1, 8(%2)\n"
+		"  movq %%mm2, 16(%2)\n"
+		"  movq %%mm3, 24(%2)\n"
+		"  movq 32(%1), %%mm0\n"
+		"  movq 40(%1), %%mm1\n"
+		"  movq 48(%1), %%mm2\n"
+		"  movq 56(%1), %%mm3\n"
+		"  movq %%mm0, 32(%2)\n"
+		"  movq %%mm1, 40(%2)\n"
+		"  movq %%mm2, 48(%2)\n"
+		"  movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -164,6 +193,7 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
@@ -171,51 +201,79 @@ static void fast_copy_page(void *to, voi
 	 * but that is for later. -AV
 	 */
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 
 	for(i=0; i<(4096-320)/64; i++)
 	{
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movntq %%mm0, (%1)\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movntq %%mm1, 8(%1)\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movntq %%mm2, 16(%1)\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movntq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm4\n"
-		"   movntq %%mm4, 32(%1)\n"
-		"   movq 40(%0), %%mm5\n"
-		"   movntq %%mm5, 40(%1)\n"
-		"   movq 48(%0), %%mm6\n"
-		"   movntq %%mm6, 48(%1)\n"
-		"   movq 56(%0), %%mm7\n"
-		"   movntq %%mm7, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movntq %%mm0, (%2)\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movntq %%mm1, 8(%2)\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movntq %%mm2, 16(%2)\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movntq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm4\n"
+		"   movntq %%mm4, 32(%2)\n"
+		"   movq 40(%1), %%mm5\n"
+		"   movntq %%mm5, 40(%2)\n"
+		"   movq 48(%1), %%mm6\n"
+		"   movntq %%mm6, 48(%2)\n"
+		"   movq 56(%1), %%mm7\n"
+		"   movntq %%mm7, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
@@ -296,56 +354,84 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
-	
-	
+	unsigned long cr0;
+
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from) );
+		: "=&r" (cr0) : "r" (from) : "ax");
 
 	for(i=0; i<4096/64; i++)
 	{
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movq %%mm0, (%1)\n"
-		"   movq %%mm1, 8(%1)\n"
-		"   movq %%mm2, 16(%1)\n"
-		"   movq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm0\n"
-		"   movq 40(%0), %%mm1\n"
-		"   movq 48(%0), %%mm2\n"
-		"   movq 56(%0), %%mm3\n"
-		"   movq %%mm0, 32(%1)\n"
-		"   movq %%mm1, 40(%1)\n"
-		"   movq %%mm2, 48(%1)\n"
-		"   movq %%mm3, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movq %%mm0, (%2)\n"
+		"   movq %%mm1, 8(%2)\n"
+		"   movq %%mm2, 16(%2)\n"
+		"   movq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm0\n"
+		"   movq 40(%1), %%mm1\n"
+		"   movq 48(%1), %%mm2\n"
+		"   movq 56(%1), %%mm3\n"
+		"   movq %%mm0, 32(%2)\n"
+		"   movq %%mm1, 40(%2)\n"
+		"   movq %%mm2, 48(%2)\n"
+		"   movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 		".section __ex_table,\"a\"\n"
 		"	.align 4\n"
 		"	.long 1b, 3b\n"
 		".previous"
-		: : "r" (from), "r" (to) : "memory");
+		: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 		from+=64;
 		to+=64;
 	}
diff -NurpX dontdiff linux-2.4.37/arch/i386/lib/usercopy.c linux-2.4.37-pax/arch/i386/lib/usercopy.c
--- linux-2.4.37/arch/i386/lib/usercopy.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/lib/usercopy.c	2008-12-02 10:29:30.000000000 +0100
@@ -8,6 +8,7 @@
 #include <linux/config.h>
 #include <asm/uaccess.h>
 #include <asm/mmx.h>
+#include <asm/segment.h>
 
 #ifdef CONFIG_X86_USE_3DNOW_AND_WORKS
 
@@ -75,6 +76,11 @@ __generic_copy_from_user(void *to, const
 do {									   \
 	int __d0, __d1, __d2;						   \
 	__asm__ __volatile__(						   \
+		"	movw %w0,%%ds\n"				   \
+		:							   \
+		: "r"(__USER_DS)					   \
+		: "memory");						   \
+	__asm__ __volatile__(						   \
 		"	testl %1,%1\n"					   \
 		"	jz 2f\n"					   \
 		"0:	lodsb\n"					   \
@@ -85,6 +91,8 @@ do {									   \
 		"	jnz 0b\n"					   \
 		"1:	subl %1,%0\n"					   \
 		"2:\n"							   \
+		"	pushl %%ss\n"					   \
+		"	popl %%ds\n"					   \
 		".section .fixup,\"ax\"\n"				   \
 		"3:	movl %5,%0\n"					   \
 		"	jmp 2b\n"					   \
@@ -163,10 +171,13 @@ strncpy_from_user(char *dst, const char 
 do {									\
 	int __d0;							\
   	__asm__ __volatile__(						\
+		"	movw %w6,%%es\n"				\
 		"0:	rep; stosl\n"					\
 		"	movl %2,%0\n"					\
 		"1:	rep; stosb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%es\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%2,%0,4),%0\n"				\
 		"	jmp 2b\n"					\
@@ -177,7 +188,8 @@ do {									\
 		"	.long 1b,2b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0)				\
-		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0));	\
+		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0),	\
+		  "r"(__USER_DS));					\
 } while (0)
 
 /**
@@ -233,6 +245,7 @@ long strnlen_user(const char *s, long n)
 	unsigned long res, tmp;
 
 	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
 		"	testl %0, %0\n"
 		"	jz 3f\n"
 		"	andl %0,%%ecx\n"
@@ -241,6 +254,8 @@ long strnlen_user(const char *s, long n)
 		"	subl %%ecx,%0\n"
 		"	addl %0,%%eax\n"
 		"1:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
 		".section .fixup,\"ax\"\n"
 		"2:	xorl %%eax,%%eax\n"
 		"	jmp 1b\n"
@@ -252,7 +267,7 @@ long strnlen_user(const char *s, long n)
 		"	.long 0b,2b\n"
 		".previous"
 		:"=r" (n), "=D" (s), "=a" (res), "=c" (tmp)
-		:"0" (n), "1" (s), "2" (0), "3" (mask)
+		:"0" (n), "1" (s), "2" (0), "3" (mask), "r" (__USER_DS)
 		:"cc");
 	return res & mask;
 }
diff -NurpX dontdiff linux-2.4.37/arch/i386/mm/fault.c linux-2.4.37-pax/arch/i386/mm/fault.c
--- linux-2.4.37/arch/i386/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -19,6 +19,8 @@
 #include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/unistd.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -78,6 +80,12 @@ good_area:
 check_stack:
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < start - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, start) == 0)
 		goto good_area;
 
@@ -125,7 +133,10 @@ void bust_spinlocks(int yes)
 }
 
 asmlinkage void do_invalid_op(struct pt_regs *, unsigned long);
-extern unsigned long idt;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -137,23 +148,31 @@ extern unsigned long idt;
  *	bit 1 == 0 means read, 1 means write
  *	bit 2 == 0 means kernel, 1 means user-mode
  */
-asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+static int do_page_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+#else
+asmlinkage int do_page_fault(struct pt_regs *regs, unsigned long error_code)
+#endif
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
+#ifndef CONFIG_PAX_PAGEEXEC
 	unsigned long address;
-	unsigned long page;
+#endif
 	unsigned long fixup;
 	int write;
 	siginfo_t info;
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
 
 	/* It's safe to allow irq's after cr2 has been saved */
 	if (regs->eflags & X86_EFLAGS_IF)
 		local_irq_enable();
+#endif
 
 	tsk = current;
 
@@ -202,6 +221,12 @@ asmlinkage void do_page_fault(struct pt_
 		if (address + 32 < regs->esp)
 			goto bad_area;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < address - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, address))
 		goto bad_area;
 /*
@@ -258,7 +283,7 @@ good_area:
 			tsk->thread.screen_bitmap |= 1 << bit;
 	}
 	up_read(&mm->mmap_sem);
-	return;
+	return 0;
 
 /*
  * Something tried to access memory that isn't in our memory map..
@@ -267,6 +292,38 @@ good_area:
 bad_area:
 	up_read(&mm->mmap_sem);
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if ((error_code & 4) && !(regs->eflags & X86_EFLAGS_VM)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(error_code & 3) && (regs->eip == address)) {
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && !(error_code & 3) && (regs->eip + SEGMEXEC_TASK_SIZE == address)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 4:
+				return 0;
+
+			case 3:
+			case 2:
+				return 1;
+			}
+#endif
+
+			pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+			do_exit(SIGKILL);
+		}
+#endif
+
+	}
+#endif
+
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
 		tsk->thread.cr2 = address;
@@ -278,7 +335,7 @@ bad_area:
 		/* info.si_code has been set above */
 		info.si_addr = (void *)address;
 		force_sig_info(SIGSEGV, &info, tsk);
-		return;
+		return 0;
 	}
 
 	/*
@@ -287,11 +344,11 @@ bad_area:
 	if (boot_cpu_data.f00f_bug) {
 		unsigned long nr;
 		
-		nr = (address - idt) >> 3;
+		nr = (address - (unsigned long)idt) >> 3;
 
 		if (nr == 6) {
 			do_invalid_op(regs, 0);
-			return;
+			return 0;
 		}
 	}
 
@@ -299,7 +356,7 @@ no_context:
 	/* Are we prepared to handle this kernel fault?  */
 	if ((fixup = search_exception_table(regs->eip)) != 0) {
 		regs->eip = fixup;
-		return;
+		return 0;
 	}
 
 /*
@@ -311,19 +368,36 @@ no_context:
 
 	if (address < PAGE_SIZE)
 		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	else if (init_mm.start_code <= address && address < init_mm.end_code)
+		printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code",
+				 tsk->comm, tsk->pid, tsk->uid, tsk->euid);
+#endif
+
 	else
 		printk(KERN_ALERT "Unable to handle kernel paging request");
 	printk(" at virtual address %08lx\n",address);
 	printk(" printing eip:\n");
 	printk("%08lx\n", regs->eip);
-	asm("movl %%cr3,%0":"=r" (page));
-	page = ((unsigned long *) __va(page))[address >> 22];
-	printk(KERN_ALERT "*pde = %08lx\n", page);
-	if (page & 1) {
-		page &= PAGE_MASK;
-		address &= 0x003ff000;
-		page = ((unsigned long *) __va(page))[address >> PAGE_SHIFT];
-		printk(KERN_ALERT "*pte = %08lx\n", page);
+	{
+		unsigned long index = pgd_index(address);
+		unsigned long pgd_paddr;
+		pgd_t *pgd;
+		pmd_t *pmd;
+		pte_t *pte;
+
+		asm("movl %%cr3,%0":"=r" (pgd_paddr));
+		pgd = index + (pgd_t *)__va(pgd_paddr);
+		printk(KERN_ALERT "*pgd = %*llx\n", sizeof(*pgd), (unsigned long long)pgd_val(*pgd));
+		if (pgd_present(*pgd)) {
+			pmd = pmd_offset(pgd, address);
+			printk(KERN_ALERT "*pmd = %*llx\n", sizeof(*pmd), (unsigned long long)pmd_val(*pmd));
+			if (pmd_present(*pmd) && !(pmd_val(*pmd) & _PAGE_PSE)) {
+				pte = pte_offset(pmd, address);
+				printk(KERN_ALERT "*pte = %*llx\n", sizeof(*pte), (unsigned long long)pte_val(*pte));
+			}
+		}
 	}
 	die("Oops", regs, error_code);
 	bust_spinlocks(0);
@@ -363,7 +437,7 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!(error_code & 4))
 		goto no_context;
-	return;
+	return 0;
 
 vmalloc_fault:
 	{
@@ -396,6 +470,333 @@ vmalloc_fault:
 		pte_k = pte_offset(pmd_k, address);
 		if (!pte_present(*pte_k))
 			goto no_context;
-		return;
+		return 0;
+	}
+}
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/* PaX: called with the page_table_lock spinlock held */
+static inline pte_t * pax_get_pte(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd_present(*pgd))
+		return NULL;
+	pmd = pmd_offset(pgd, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	return pte_offset(pmd, address);
+}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+/*
+ * PaX: decide what to do with offenders (regs->eip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when sigreturn trampoline was detected
+ *         3 when rt_sigreturn trampoline was detected
+ *         4 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	static const unsigned char trans[8] = {
+		offsetof(struct pt_regs, eax) / 4,
+		offsetof(struct pt_regs, ecx) / 4,
+		offsetof(struct pt_regs, edx) / 4,
+		offsetof(struct pt_regs, ebx) / 4,
+		offsetof(struct pt_regs, esp) / 4,
+		offsetof(struct pt_regs, ebp) / 4,
+		offsetof(struct pt_regs, esi) / 4,
+		offsetof(struct pt_regs, edi) / 4,
+	};
+	int err;
+
+	if (regs->eflags & X86_EFLAGS_VM)
+		return 1;
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: sigreturn emulation */
+		unsigned char pop, mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = get_user(pop, (unsigned char *)(regs->eip));
+		err |= get_user(mov, (unsigned char *)(regs->eip + 1));
+		err |= get_user(nr, (unsigned long *)(regs->eip + 2));
+		err |= get_user(sys, (unsigned short *)(regs->eip + 6));
+
+		if (err)
+			break;
+
+		if (pop == 0x58 &&
+		    mov == 0xb8 &&
+		    nr == __NR_sigreturn &&
+		    sys == 0x80cd)
+		{
+
+#ifdef CONFIG_PAX_EMUSIGRT
+			int sig;
+			struct k_sigaction *ka;
+			__sighandler_t handler;
+
+			if (get_user(sig, (int *)regs->esp))
+				return 1;
+			if (sig < 1 || sig > _NSIG || sig == SIGKILL || sig == SIGSTOP)
+				return 1;
+			spin_lock_irq(&current->sigmask_lock);
+			ka = &current->sig->action[sig-1];
+			handler = ka->sa.sa_handler;
+			if (handler == SIG_DFL || handler == SIG_IGN) {
+				if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+					err = 1;
+			} else if (ka->sa.sa_flags & SA_SIGINFO)
+				err = 1;
+			spin_unlock_irq(&current->sigmask_lock);
+			if (err)
+				return 1;
+#endif
+
+			regs->esp += 4;
+			regs->eax = nr;
+			regs->eip += 8;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned char mov;
+		unsigned short sys;
+		unsigned long nr;
+
+		err = get_user(mov, (unsigned char *)(regs->eip));
+		err |= get_user(nr, (unsigned long *)(regs->eip + 1));
+		err |= get_user(sys, (unsigned short *)(regs->eip + 5));
+
+		if (err)
+			break;
+
+		if (mov == 0xb8 &&
+		    nr == __NR_rt_sigreturn &&
+		    sys == 0x80cd)
+		{
+
+#ifdef CONFIG_PAX_EMUSIGRT
+			int sig;
+			struct k_sigaction *ka;
+			__sighandler_t handler;
+
+			if (get_user(sig, (int *)regs->esp))
+				return 1;
+			if (sig < 1 || sig > _NSIG || sig == SIGKILL || sig == SIGSTOP)
+				return 1;
+			spin_lock_irq(&current->sigmask_lock);
+			ka = &current->sig->action[sig-1];
+			handler = ka->sa.sa_handler;
+			if (handler == SIG_DFL || handler == SIG_IGN) {
+				if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+					err = 1;
+			} else if (!(ka->sa.sa_flags & SA_SIGINFO))
+				err = 1;
+			spin_unlock_irq(&current->sigmask_lock);
+			if (err)
+				return 1;
+#endif
+
+			regs->eax = nr;
+			regs->eip += 7;
+			return 3;
+		}
+	} while (0);
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(mov2, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+		err |= get_user(jmp, (unsigned short *)(regs->eip + 10));
+
+		if (err)
+			break;
+
+		if ((mov1 & 0xF8) == 0xB8 &&
+		    (mov2 & 0xF8) == 0xB8 &&
+		    (mov1 & 0x07) != (mov2 & 0x07) &&
+		    (jmp & 0xF8FF) == 0xE0FF &&
+		    (mov2 & 0x07) == ((jmp>>8) & 0x07))
+		{
+			((unsigned long *)regs)[trans[mov1 & 0x07]] = addr1;
+			((unsigned long *)regs)[trans[mov2 & 0x07]] = addr2;
+			regs->eip = addr2;
+			return 4;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov, (unsigned char *)regs->eip);
+		err |= get_user(addr1, (unsigned long *)(regs->eip + 1));
+		err |= get_user(jmp, (unsigned char *)(regs->eip + 5));
+		err |= get_user(addr2, (unsigned long *)(regs->eip + 6));
+
+		if (err)
+			break;
+
+		if ((mov & 0xF8) == 0xB8 &&
+		    jmp == 0xE9)
+		{
+			((unsigned long *)regs)[trans[mov & 0x07]] = addr1;
+			regs->eip += addr2 + 10;
+			return 4;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char*)pc+i))
+			printk("?? ");
+		else
+			printk("%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-4: ");
+	for (i = -1; i < 20; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long*)sp+i))
+			printk("???????? ");
+		else
+			printk("%08lx ", c);
+	}
+	printk("\n");
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: handle the extra page faults or pass it down to the original handler
+ *
+ * returns 0 when nothing special was detected
+ *         1 when sigreturn trampoline (syscall) has to be emulated
+ */
+asmlinkage int pax_do_page_fault(struct pt_regs *regs, unsigned long error_code)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long address;
+	pte_t *pte;
+	unsigned char pte_mask;
+
+	__asm__("movl %%cr2,%0":"=r" (address));
+
+	/* It's safe to allow irq's after cr2 has been saved */
+	if (likely(regs->eflags & X86_EFLAGS_IF))
+		local_irq_enable();
+
+	if (unlikely((error_code & 5) != 5 ||
+		     address >= TASK_SIZE ||
+		     (regs->eflags & X86_EFLAGS_VM) ||
+		     !mm || !(mm->pax_flags & MF_PAX_PAGEEXEC)))
+		return do_page_fault(regs, error_code, address);
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & 2) && (regs->eip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		switch (pax_handle_fetch_fault(regs)) {
+		case 4:
+			return 0;
+
+		case 3:
+		case 2:
+			return 1;
+		}
+#endif
+
+		pax_report_fault(regs, (void*)regs->eip, (void*)regs->esp);
+		do_exit(SIGKILL);
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & 2) << (_PAGE_BIT_DIRTY-1));
+
+	spin_lock(&mm->page_table_lock);
+	pte = pax_get_pte(mm, address);
+	if (unlikely(!pte || !(pte_val(*pte) & _PAGE_PRESENT) || pte_exec(*pte))) {
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		return 0;
 	}
+
+	if (unlikely((error_code & 2) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		spin_unlock(&mm->page_table_lock);
+		do_page_fault(regs, error_code, address);
+		return 0;
+	}
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"movw %w4,%%es\n"
+#endif
+		"orb %2,(%1)\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg (%0)\n"
+#endif
+		"testb $0,%%es:(%0)\n"
+		"xorb %3,(%1)\n"
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"pushl %%ss\n"
+		"popl %%es\n"
+#endif
+		:
+		: "q" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER), "r" (__USER_DS)
+		: "memory", "cc");
+	spin_unlock(&mm->page_table_lock);
+	return 0;
 }
+#endif
diff -NurpX dontdiff linux-2.4.37/arch/i386/mm/init.c linux-2.4.37-pax/arch/i386/mm/init.c
--- linux-2.4.37/arch/i386/mm/init.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/mm/init.c	2008-12-02 10:29:30.000000000 +0100
@@ -37,6 +37,7 @@
 #include <asm/e820.h>
 #include <asm/apic.h>
 #include <asm/tlb.h>
+#include <asm/desc.h>
 
 mmu_gather_t mmu_gathers[NR_CPUS];
 unsigned long highstart_pfn, highend_pfn;
@@ -122,7 +123,7 @@ void show_mem(void)
 
 /* References to section boundaries */
 
-extern char _text, _etext, _edata, __bss_start, _end;
+extern char _text, _etext, _data, _edata, __bss_start, _end;
 extern char __init_begin, __init_end;
 
 static inline void set_pte_phys (unsigned long vaddr,
@@ -178,17 +179,7 @@ static void __init fixrange_init (unsign
 	pgd = pgd_base + i;
 
 	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-#if CONFIG_X86_PAE
-		if (pgd_none(*pgd)) {
-			pmd = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-			set_pgd(pgd, __pgd(__pa(pmd) + 0x1));
-			if (pmd != pmd_offset(pgd, 0))
-				printk("PAE BUG #02!\n");
-		}
 		pmd = pmd_offset(pgd, vaddr);
-#else
-		pmd = (pmd_t *)pgd;
-#endif
 		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
 			if (pmd_none(*pmd)) {
 				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
@@ -217,25 +208,22 @@ static void __init pagetable_init (void)
 	end = (unsigned long)__va(max_low_pfn*PAGE_SIZE);
 
 	pgd_base = swapper_pg_dir;
-#if CONFIG_X86_PAE
-	for (i = 0; i < PTRS_PER_PGD; i++)
-		set_pgd(pgd_base + i, __pgd(1 + __pa(empty_zero_page)));
-#endif
 	i = __pgd_offset(PAGE_OFFSET);
 	pgd = pgd_base + i;
 
+	if (cpu_has_pse) {
+		set_in_cr4(X86_CR4_PSE);
+		boot_cpu_data.wp_works_ok = 1;
+
+		if (cpu_has_pge)
+			set_in_cr4(X86_CR4_PGE);
+	}
+
 	for (; i < PTRS_PER_PGD; pgd++, i++) {
 		vaddr = i*PGDIR_SIZE;
 		if (end && (vaddr >= end))
 			break;
-#if CONFIG_X86_PAE
-		pmd = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-		set_pgd(pgd, __pgd(__pa(pmd) + 0x1));
-#else
-		pmd = (pmd_t *)pgd;
-#endif
-		if (pmd != pmd_offset(pgd, 0))
-			BUG();
+		pmd = pmd_offset(pgd, PAGE_OFFSET);
 		for (j = 0; j < PTRS_PER_PMD; pmd++, j++) {
 			vaddr = i*PGDIR_SIZE + j*PMD_SIZE;
 			if (end && (vaddr >= end))
@@ -243,14 +231,16 @@ static void __init pagetable_init (void)
 			if (cpu_has_pse) {
 				unsigned long __pe;
 
-				set_in_cr4(X86_CR4_PSE);
-				boot_cpu_data.wp_works_ok = 1;
 				__pe = _KERNPG_TABLE + _PAGE_PSE + __pa(vaddr);
 				/* Make it "global" too if supported */
-				if (cpu_has_pge) {
-					set_in_cr4(X86_CR4_PGE);
+				if (cpu_has_pge)
 					__pe += _PAGE_GLOBAL;
-				}
+
+#ifdef CONFIG_PAX_KERNEXEC
+				if (__KERNEL_TEXT_OFFSET <= vaddr && vaddr < (unsigned long)&_data)
+					__pe &= ~_PAGE_RW;
+#endif
+
 				set_pmd(pmd, __pmd(__pe));
 				continue;
 			}
@@ -263,6 +253,13 @@ static void __init pagetable_init (void)
 					break;
 				*pte = mk_pte_phys(__pa(vaddr), PAGE_KERNEL);
 			}
+
+#ifdef CONFIG_PAX_KERNEXEC
+			if (__KERNEL_TEXT_OFFSET <= vaddr && vaddr < (unsigned long)&_data)
+				set_pmd(pmd, __pmd((_KERNPG_TABLE & ~_PAGE_RW) + __pa(pte_base)));
+			else
+#endif
+
 			set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte_base)));
 			if (pte_base != pte_offset(pmd, 0))
 				BUG();
@@ -289,17 +286,6 @@ static void __init pagetable_init (void)
 	pte = pte_offset(pmd, vaddr);
 	pkmap_page_table = pte;
 #endif
-
-#if CONFIG_X86_PAE
-	/*
-	 * Add low memory identity-mappings - SMP needs it when
-	 * starting up on an AP from real-mode. In the non-PAE
-	 * case we already have these mappings through head.S.
-	 * All user-space mappings are explicitly cleared after
-	 * SMP startup.
-	 */
-	pgd_base[0] = pgd_base[USER_PTRS_PER_PGD];
-#endif
 }
 
 void __init zap_low_mappings (void)
@@ -312,7 +298,7 @@ void __init zap_low_mappings (void)
 	 * us, because pgd_clear() is a no-op on i386.
 	 */
 	for (i = 0; i < USER_PTRS_PER_PGD; i++)
-#if CONFIG_X86_PAE
+#ifdef CONFIG_X86_PAE
 		set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
 #else
 		set_pgd(swapper_pg_dir+i, __pgd(0));
@@ -353,16 +339,6 @@ void __init paging_init(void)
 	pagetable_init();
 
 	load_cr3(swapper_pg_dir);	
-
-#if CONFIG_X86_PAE
-	/*
-	 * We will bail out later - printk doesn't work right now so
-	 * the user would just see a hanging kernel.
-	 */
-	if (cpu_has_pae)
-		set_in_cr4(X86_CR4_PAE);
-#endif
-
 	__flush_tlb_all();
 
 #ifdef CONFIG_HIGHMEM
@@ -508,6 +484,10 @@ void __init mem_init(void)
 {
 	int codesize, reservedpages, datasize, initsize;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (!mem_map)
 		BUG();
 #ifdef CONFIG_HIGHMEM
@@ -524,12 +504,21 @@ void __init mem_init(void)
 	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
 
 	/* clear the zero-page */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	memset(empty_zero_page, 0, PAGE_SIZE);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	reservedpages = free_pages_init();
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_data;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	printk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init, %ldk highmem)\n",
@@ -542,10 +531,6 @@ void __init mem_init(void)
 		(unsigned long) (totalhigh_pages << (PAGE_SHIFT-10))
 	       );
 
-#if CONFIG_X86_PAE
-	if (!cpu_has_pae)
-		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
-#endif
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
 
@@ -589,6 +574,26 @@ void free_initmem(void)
 {
 	unsigned long addr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	/* PaX: limit KERNEL_CS to actual size */
+	unsigned long limit, cr0;
+
+	limit = (unsigned long)&_etext >> PAGE_SHIFT;
+
+	pax_open_kernel(cr0);
+
+	gdt_table[2].a = (gdt_table[2].a & 0xFFFF0000UL) | (limit & 0x0FFFFUL);
+	gdt_table[2].b = (gdt_table[2].b & 0xFFF0FFFFUL) | (limit & 0xF0000UL);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	gdt_table2[2].a = (gdt_table2[2].a & 0xFFFF0000UL) | (limit & 0x0FFFFUL);
+	gdt_table2[2].b = (gdt_table2[2].b & 0xFFF0FFFFUL) | (limit & 0xF0000UL);
+#endif
+
+	pax_close_kernel(cr0);
+#endif
+
+	memset(&__init_begin, 0, &__init_end - &__init_begin);
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
diff -NurpX dontdiff linux-2.4.37/arch/i386/mm/ioremap.c linux-2.4.37-pax/arch/i386/mm/ioremap.c
--- linux-2.4.37/arch/i386/mm/ioremap.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/mm/ioremap.c	2008-12-02 10:29:30.000000000 +0100
@@ -49,7 +49,7 @@ static inline int remap_area_pmd(pmd_t *
 	if (address >= end)
 		BUG();
 	do {
-		pte_t * pte = pte_alloc(&init_mm, pmd, address);
+		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
 		if (!pte)
 			return -ENOMEM;
 		remap_area_pte(pte, address, end - address, address + phys_addr, flags);
diff -NurpX dontdiff linux-2.4.37/arch/i386/mm/pageattr.c linux-2.4.37-pax/arch/i386/mm/pageattr.c
--- linux-2.4.37/arch/i386/mm/pageattr.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/mm/pageattr.c	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <asm/desc.h>
 
 /* Should move most of this stuff into the appropiate includes */
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
@@ -63,7 +64,19 @@ static void flush_kernel_map(void * addr
 
 static void set_pmd_pte(pte_t *kpte, unsigned long address, pte_t pte) 
 { 
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte_atomic(kpte, pte); 	/* change init_mm */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 #ifndef CONFIG_X86_PAE
 	{
 		struct list_head *l;
diff -NurpX dontdiff linux-2.4.37/arch/i386/vmlinux.lds linux-2.4.37-pax/arch/i386/vmlinux.lds
--- linux-2.4.37/arch/i386/vmlinux.lds	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/vmlinux.lds	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/* ld script to make i386 Linux kernel
- * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
- */
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
-OUTPUT_ARCH(i386)
-ENTRY(_start)
-SECTIONS
-{
-  . = 0xC0000000 + 0x100000;
-  _text = .;			/* Text and read-only data */
-  .text : {
-	*(.text)
-	*(.fixup)
-	*(.gnu.warning)
-	} = 0x9090
-
-  _etext = .;			/* End of text section */
-
-  .rodata : { *(.rodata) *(.rodata.*) }
-  .kstrtab : { *(.kstrtab) }
-
-  . = ALIGN(16);		/* Exception table */
-  __start___ex_table = .;
-  __ex_table : { *(__ex_table) }
-  __stop___ex_table = .;
-
-  __start___ksymtab = .;	/* Kernel symbol table */
-  __ksymtab : { *(__ksymtab) }
-  __stop___ksymtab = .;
-
-  .data : {			/* Data */
-	*(.data)
-	CONSTRUCTORS
-	}
-
-  _edata = .;			/* End of data section */
-
-  . = ALIGN(8192);		/* init_task */
-  .data.init_task : { *(.data.init_task) }
-
-  . = ALIGN(4096);		/* Init code and data */
-  __init_begin = .;
-  .text.init : { *(.text.init) }
-  .data.init : { *(.data.init) }
-  . = ALIGN(16);
-  __setup_start = .;
-  .setup.init : { *(.setup.init) }
-  __setup_end = .;
-  __initcall_start = .;
-  .initcall.init : { *(.initcall.init) }
-  __initcall_end = .;
-  . = ALIGN(4096);
-  __init_end = .;
-
-  . = ALIGN(4096);
-  .data.page_aligned : { *(.data.idt) }
-
-  . = ALIGN(32);
-  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
-
-  __bss_start = .;		/* BSS */
-  .bss : {
-	*(.bss)
-	}
-  _end = . ;
-
-  /* Sections to be discarded */
-  /DISCARD/ : {
-	*(.text.exit)
-	*(.data.exit)
-	*(.exitcall.exit)
-	}
-
-  /* Stabs debugging sections.  */
-  .stab 0 : { *(.stab) }
-  .stabstr 0 : { *(.stabstr) }
-  .stab.excl 0 : { *(.stab.excl) }
-  .stab.exclstr 0 : { *(.stab.exclstr) }
-  .stab.index 0 : { *(.stab.index) }
-  .stab.indexstr 0 : { *(.stab.indexstr) }
-  .comment 0 : { *(.comment) }
-}
diff -NurpX dontdiff linux-2.4.37/arch/i386/vmlinux.lds.S linux-2.4.37-pax/arch/i386/vmlinux.lds.S
--- linux-2.4.37/arch/i386/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.37-pax/arch/i386/vmlinux.lds.S	2008-12-02 10:29:30.000000000 +0100
@@ -0,0 +1,140 @@
+/* ld script to make i386 Linux kernel
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
+ */
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+PHDRS {
+	initdata PT_LOAD FLAGS(6);	/* RW_ */
+	inittext PT_LOAD FLAGS(5);	/* R_E */
+	text     PT_LOAD FLAGS(5);	/* R_E */
+	rodata   PT_LOAD FLAGS(4);	/* R__ */
+	data     PT_LOAD FLAGS(6);	/* RW_ */
+}
+SECTIONS
+{
+  . = __PAGE_OFFSET + 0x100000;
+  .text.startup : {
+	BYTE(0xEA) /* jmp far */
+	LONG(startup_32 + __KERNEL_TEXT_OFFSET - __PAGE_OFFSET)
+	SHORT(__KERNEL_CS)
+	} :initdata
+
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .data.init : { *(.data.init) }
+  . = ALIGN(16);
+  __setup_start = .;
+  .setup.init : { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : { *(.initcall.init) }
+  __initcall_end = .;
+
+  _sinittext = . - __KERNEL_TEXT_OFFSET;
+
+#ifdef CONFIG_PAX_KERNEXEC
+  .text.init (. - __KERNEL_TEXT_OFFSET) : AT (_sinittext + __KERNEL_TEXT_OFFSET) {
+	*(.text.init)
+	_einittext = .;
+	. = ALIGN(4*1024*1024) - 1;
+	BYTE(0)
+	} :inittext
+  __init_end = . + __KERNEL_TEXT_OFFSET;
+
+/*
+ * PaX: this must be kept in synch with the KERNEL_CS base
+ * in the GDTs in arch/i386/kernel/head.S
+ */
+  _text = .;			/* Text and read-only data */
+  .text : AT (. + __KERNEL_TEXT_OFFSET) {
+#else
+  .text.init : { *(.text.init) } :inittext
+  _einittext = .;
+  . = ALIGN(4096);
+  __init_end = .;
+  _text = .;			/* Text and read-only data */
+  .text : {
+#endif
+
+	*(.text)
+	*(.fixup)
+	*(.gnu.warning)
+	} :text = 0x9090
+
+  _etext = .;			/* End of text section */
+
+  . = ALIGN(4096);
+  . += __KERNEL_TEXT_OFFSET;
+  .rodata.page_aligned : {
+	*(.empty_zero_page)
+	*(.pg0)
+
+#ifdef CONFIG_X86_PAE
+	*(.swapper_pm_dir)
+#endif
+
+	*(.swapper_pg_dir)
+	*(.idt)
+	} :rodata
+  .rodata : { *(.rodata) *(.rodata.*) }
+  .kstrtab : { *(.kstrtab) }
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : { *(__ksymtab) }
+  __stop___ksymtab = .;
+
+#ifdef CONFIG_PAX_KERNEXEC
+  . = ALIGN(4*1024*1024);
+#else
+  . = ALIGN(32);
+#endif
+
+  _data = .;
+  .data : {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	} :data
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  . = ALIGN(8192);
+  .data.init_task : { *(.data.init_task) }
+
+  . = ALIGN(4096);
+  .data.page_aligned : {
+	}
+
+  _edata = .;			/* End of data section */
+
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss)
+	}
+  __bss_end = . ;
+
+  _end = . ;
+
+  /* Sections to be discarded */
+  /DISCARD/ : {
+	*(.text.exit)
+	*(.data.exit)
+	*(.exitcall.exit)
+	}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -NurpX dontdiff linux-2.4.37/arch/ia64/config.in linux-2.4.37-pax/arch/ia64/config.in
--- linux-2.4.37/arch/ia64/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -319,3 +319,62 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+#            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+            bool '    Allow ELF ET_EXEC text relocations' CONFIG_PAX_ETEXECRELOCS
+         fi
+      fi
+   fi
+fi
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
diff -NurpX dontdiff linux-2.4.37/arch/ia64/ia32/binfmt_elf32.c linux-2.4.37-pax/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.4.37/arch/ia64/ia32/binfmt_elf32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/ia32/binfmt_elf32.c	2008-12-02 10:29:30.000000000 +0100
@@ -53,6 +53,13 @@ static void elf32_set_personality (void)
 #undef SET_PERSONALITY
 #define SET_PERSONALITY(ex, ibcs2)	elf32_set_personality()
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 43 - IA32_PAGE_SHIFT)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
@@ -190,8 +197,15 @@ ia32_setup_arg_pages (struct linux_binpr
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = IA32_STACK_TOP;
-		mpnt->vm_page_prot = PAGE_COPY;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(current->mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(VM_STACK_FLAGS | VM_EXEC) & 0x7];
+		else
+#endif
+
+		mpnt->vm_page_prot = protection_map[VM_STACK_FLAGS & 0x7];
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
diff -NurpX dontdiff linux-2.4.37/arch/ia64/ia32/sys_ia32.c linux-2.4.37-pax/arch/ia64/ia32/sys_ia32.c
--- linux-2.4.37/arch/ia64/ia32/sys_ia32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/ia32/sys_ia32.c	2008-12-02 10:29:30.000000000 +0100
@@ -538,7 +538,6 @@ sys32_mmap (struct mmap_arg_struct *arg)
 		return -EINVAL;
 
 	flags = a.flags;
-
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(a.fd);
diff -NurpX dontdiff linux-2.4.37/arch/ia64/kernel/sys_ia64.c linux-2.4.37-pax/arch/ia64/kernel/sys_ia64.c
--- linux-2.4.37/arch/ia64/kernel/sys_ia64.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/kernel/sys_ia64.c	2008-12-02 10:29:30.000000000 +0100
@@ -34,6 +34,13 @@ arch_get_unmapped_area (struct file *fil
 	if (rgn_index(addr)==REGION_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -NurpX dontdiff linux-2.4.37/arch/ia64/mm/fault.c linux-2.4.37-pax/arch/ia64/mm/fault.c
--- linux-2.4.37/arch/ia64/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -36,6 +36,10 @@ expand_backing_store (struct vm_area_str
 	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur
 	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
+	if ((vma->vm_flags & VM_LOCKED) &&
+	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur &&
+	    !capable(CAP_IPC_LOCK))
+		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
@@ -70,6 +74,23 @@ mapped_kernel_page_is_present (unsigned 
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -122,9 +143,23 @@ ia64_do_page_fault (unsigned long addres
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT)
 		| (((isr >> IA64_ISR_R_BIT) & 1UL) << VM_READ_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void*)regs->cr_iip, (void*)regs->r12);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX dontdiff linux-2.4.37/arch/ia64/mm/init.c linux-2.4.37-pax/arch/ia64/mm/init.c
--- linux-2.4.37/arch/ia64/mm/init.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ia64/mm/init.c	2008-12-02 10:29:30.000000000 +0100
@@ -73,7 +73,7 @@ ia64_set_rbs_bot (void)
 
 	if (stack_size > MAX_USER_STACK_SIZE)
 		stack_size = MAX_USER_STACK_SIZE;
-	current->thread.rbs_bot = STACK_TOP - stack_size;
+	current->thread.rbs_bot = PAGE_ALIGN(current->mm->start_stack - stack_size);
 }
 
 /*
@@ -105,6 +105,7 @@ ia64_init_addr_space (void)
 		vma->vm_pgoff = 0;
 		vma->vm_file = NULL;
 		vma->vm_private_data = NULL;
+		vma->vm_mirror = 0;
 		down_write(&current->mm->mmap_sem);
 		if (insert_vm_struct(current->mm, vma)) {
 			up_write(&current->mm->mmap_sem);
diff -NurpX dontdiff linux-2.4.37/arch/mips/config-shared.in linux-2.4.37-pax/arch/mips/config-shared.in
--- linux-2.4.37/arch/mips/config-shared.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips/config-shared.in	2008-12-02 10:29:30.000000000 +0100
@@ -1038,5 +1038,64 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+#            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+   if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+        "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+        "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+        "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/mips/kernel/syscall.c linux-2.4.37-pax/arch/mips/kernel/syscall.c
--- linux-2.4.37/arch/mips/kernel/syscall.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips/kernel/syscall.c	2008-12-02 10:29:30.000000000 +0100
@@ -82,6 +82,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -92,6 +97,13 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	addr = TASK_UNMAPPED_BASE;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
diff -NurpX dontdiff linux-2.4.37/arch/mips/mm/fault.c linux-2.4.37-pax/arch/mips/mm/fault.c
--- linux-2.4.37/arch/mips/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -69,6 +69,23 @@ void bust_spinlocks(int yes)
 	}
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -NurpX dontdiff linux-2.4.37/arch/mips64/kernel/binfmt_elfn32.c linux-2.4.37-pax/arch/mips64/kernel/binfmt_elfn32.c
--- linux-2.4.37/arch/mips64/kernel/binfmt_elfn32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips64/kernel/binfmt_elfn32.c	2008-12-02 10:29:30.000000000 +0100
@@ -50,6 +50,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -NurpX dontdiff linux-2.4.37/arch/mips64/kernel/binfmt_elfo32.c linux-2.4.37-pax/arch/mips64/kernel/binfmt_elfo32.c
--- linux-2.4.37/arch/mips64/kernel/binfmt_elfo32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips64/kernel/binfmt_elfo32.c	2008-12-02 10:29:30.000000000 +0100
@@ -52,6 +52,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -NurpX dontdiff linux-2.4.37/arch/mips64/kernel/syscall.c linux-2.4.37-pax/arch/mips64/kernel/syscall.c
--- linux-2.4.37/arch/mips64/kernel/syscall.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips64/kernel/syscall.c	2008-12-02 10:29:30.000000000 +0100
@@ -80,6 +80,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -90,6 +95,13 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	addr = TASK_UNMAPPED_BASE;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
diff -NurpX dontdiff linux-2.4.37/arch/mips64/mm/fault.c linux-2.4.37-pax/arch/mips64/mm/fault.c
--- linux-2.4.37/arch/mips64/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/mips64/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -90,6 +90,24 @@ void bust_spinlocks(int yes)
 	}
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i)) {
+			printk("<invalid address>.");
+			break;
+		}
+		printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -NurpX dontdiff linux-2.4.37/arch/parisc/config.in linux-2.4.37-pax/arch/parisc/config.in
--- linux-2.4.37/arch/parisc/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/parisc/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -202,5 +202,69 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+         fi
+         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+#            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+            bool '    Allow ELF ET_EXEC text relocations' CONFIG_PAX_ETEXECRELOCS
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/parisc/kernel/sys_parisc.c linux-2.4.37-pax/arch/parisc/kernel/sys_parisc.c
--- linux-2.4.37/arch/parisc/kernel/sys_parisc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/parisc/kernel/sys_parisc.c	2008-12-02 10:29:30.000000000 +0100
@@ -90,6 +90,11 @@ unsigned long arch_get_unmapped_area(str
 		inode = filp->f_dentry->d_inode;
 	}
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+#endif
+
 	if (inode && (flags & MAP_SHARED) && (inode->i_mapping->i_mmap_shared)) {
 		addr = get_shared_area(inode, addr, len, pgoff);
 	} else {
@@ -104,6 +109,7 @@ static unsigned long do_mmap2(unsigned l
 {
 	struct file * file = NULL;
 	unsigned long error = -EBADF;
+
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
 		if (!file)
diff -NurpX dontdiff linux-2.4.37/arch/parisc/kernel/sys_parisc32.c linux-2.4.37-pax/arch/parisc/kernel/sys_parisc32.c
--- linux-2.4.37/arch/parisc/kernel/sys_parisc32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/parisc/kernel/sys_parisc32.c	2008-12-02 10:29:30.000000000 +0100
@@ -185,6 +185,11 @@ do_execve32(char * filename, u32 * argv,
 		return retval;
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+	bprm.p -= (net_random() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));
 
 	DBG(("do_execve32(%s, %p, %p, %p)\n", filename, argv, envp, regs));
diff -NurpX dontdiff linux-2.4.37/arch/parisc/kernel/traps.c linux-2.4.37-pax/arch/parisc/kernel/traps.c
--- linux-2.4.37/arch/parisc/kernel/traps.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/parisc/kernel/traps.c	2008-12-02 10:29:30.000000000 +0100
@@ -637,9 +637,7 @@ void handle_interruption(int code, struc
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -NurpX dontdiff linux-2.4.37/arch/parisc/mm/fault.c linux-2.4.37-pax/arch/parisc/mm/fault.c
--- linux-2.4.37/arch/parisc/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/parisc/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/ptrace.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -53,7 +54,7 @@
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -139,6 +140,115 @@ parisc_acctyp(unsigned long code, unsign
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int*)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int*)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int*)addr);
+			err |= get_user(bv, (unsigned int*)(addr+4));
+			err |= get_user(ldw2, (unsigned int*)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int*)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int*)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void do_page_fault(struct pt_regs *regs, unsigned long code,
 			      unsigned long address)
 {
@@ -164,8 +274,33 @@ good_area:
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch(pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)instruction_pointer(regs), (void*)regs->gr[30]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX dontdiff linux-2.4.37/arch/ppc/config.in linux-2.4.37-pax/arch/ppc/config.in
--- linux-2.4.37/arch/ppc/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ppc/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -666,3 +666,63 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+#            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+         fi
+         define_bool CONFIG_PAX_SYSCALL y
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
diff -NurpX dontdiff linux-2.4.37/arch/ppc/kernel/head_4xx.S linux-2.4.37-pax/arch/ppc/kernel/head_4xx.S
--- linux-2.4.37/arch/ppc/kernel/head_4xx.S	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ppc/kernel/head_4xx.S	2008-12-02 10:29:30.000000000 +0100
@@ -296,15 +296,12 @@ label:
 
 	/* Most of the Linux PTE is ready to load into the TLB LO.
 	 * We set ZSEL, where only the LS-bit determines user access.
-	 * We set execute, because we don't have the granularity to
-	 * properly set this at the page level (Linux problem).
 	 * If shared is set, we cause a zero PID->TID load.
 	 * Many of these bits are software only.  Bits we don't set
 	 * here we (properly should) assume have the appropriate value.
 	 */
 	li	r22, 0x0ce2
 	andc	r21, r21, r22		/* Make sure 20, 21 are zero */
-	ori	r21, r21, _PAGE_HWEXEC	/* make it executable */
 
 	/* find the TLB index that caused the fault.  It has to be here.
 	*/
@@ -783,7 +780,6 @@ finish_tlb_load:
 	stw	r23, tlb_4xx_index@l(0)
 
 6:
-	ori	r21, r21, _PAGE_HWEXEC		/* make it executable */
 	tlbwe	r21, r23, TLB_DATA		/* Load TLB LO */
 
 	/* Create EPN.  This is the faulting address plus a static
diff -NurpX dontdiff linux-2.4.37/arch/ppc/mm/fault.c linux-2.4.37-pax/arch/ppc/mm/fault.c
--- linux-2.4.37/arch/ppc/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/ppc/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -26,6 +26,9 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -52,6 +55,359 @@ extern void die_if_kernel(char *, struct
 void bad_page_fault(struct pt_regs *, unsigned long, int sig);
 void do_page_fault(struct pt_regs *, unsigned long, unsigned long);
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static struct page* pax_syscall_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(page);
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.nopage = pax_syscall_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int*)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int*)addr);
+			err |= get_user(add, (unsigned int*)(addr+4));
+			err |= get_user(li2, (unsigned int*)(addr+8));
+			err |= get_user(addis2, (unsigned int*)(addr+12));
+			err |= get_user(mtctr, (unsigned int*)(addr+16));
+			err |= get_user(li3, (unsigned int*)(addr+20));
+			err |= get_user(addis3, (unsigned int*)(addr+24));
+			err |= get_user(bctr, (unsigned int*)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(addi, (unsigned int*)(addr+4));
+			err |= get_user(rlwinm, (unsigned int*)(addr+8));
+			err |= get_user(add, (unsigned int*)(addr+12));
+			err |= get_user(li2, (unsigned int*)(addr+16));
+			err |= get_user(addis2, (unsigned int*)(addr+20));
+			err |= get_user(mtctr, (unsigned int*)(addr+24));
+			err |= get_user(li3, (unsigned int*)(addr+28));
+			err |= get_user(addis3, (unsigned int*)(addr+32));
+			err |= get_user(bctr, (unsigned int*)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int*)addr);
+			err |= get_user(lwz, (unsigned int*)(addr+4));
+			err |= get_user(mtctr, (unsigned int*)(addr+8));
+			err |= get_user(bctr, (unsigned int*)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int*)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38007777U && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = 0x7777UL;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38006666U && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma) kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = 0x6666UL;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -112,7 +468,7 @@ void do_page_fault(struct pt_regs *regs,
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (regs->trap == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx || CONFIG_BOOKE */
@@ -245,6 +601,33 @@ bad_area:
 
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (current->mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((regs->trap == 0x400) && (regs->nip == address)) {
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void*)regs->nip, (void*)regs->gpr[1]);
+				do_exit(SIGKILL);
+			}
+		}
+#endif
+
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		info.si_code = code;
diff -NurpX dontdiff linux-2.4.37/arch/sparc/config.in linux-2.4.37-pax/arch/sparc/config.in
--- linux-2.4.37/arch/sparc/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -280,5 +280,67 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+#            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+            if [ "$CONFIG_PAX_EMUPLT" = "y" ]; then
+               define_bool CONFIG_PAX_DLRESOLVE y
+            fi
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/sparc/kernel/sys_sparc.c linux-2.4.37-pax/arch/sparc/kernel/sys_sparc.c
--- linux-2.4.37/arch/sparc/kernel/sys_sparc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc/kernel/sys_sparc.c	2008-12-02 10:29:30.000000000 +0100
@@ -54,6 +54,13 @@ unsigned long arch_get_unmapped_area(str
 		return -ENOMEM;
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -NurpX dontdiff linux-2.4.37/arch/sparc/mm/fault.c linux-2.4.37-pax/arch/sparc/mm/fault.c
--- linux-2.4.37/arch/sparc/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -19,6 +19,9 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/segment.h>
@@ -219,6 +222,248 @@ static unsigned long compute_si_addr(str
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->pc);
+		err |= get_user(sethi2, (unsigned int*)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->pc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned int addr;
+
+			addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(jmpl, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->pc);
+		err |= get_user(ba, (unsigned int*)(regs->pc+4));
+		err |= get_user(nop, (unsigned int*)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->pc-4));
+		err |= get_user(call, (unsigned int*)regs->pc);
+		err |= get_user(nop, (unsigned int*)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -282,6 +527,24 @@ good_area:
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void*)regs->pc, (void*)regs->u_regs[UREG_FP]);
+			do_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -NurpX dontdiff linux-2.4.37/arch/sparc/mm/init.c linux-2.4.37-pax/arch/sparc/mm/init.c
--- linux-2.4.37/arch/sparc/mm/init.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc/mm/init.c	2008-12-02 10:29:30.000000000 +0100
@@ -350,17 +350,17 @@ void __init paging_init(void)
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -NurpX dontdiff linux-2.4.37/arch/sparc/mm/srmmu.c linux-2.4.37-pax/arch/sparc/mm/srmmu.c
--- linux-2.4.37/arch/sparc/mm/srmmu.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc/mm/srmmu.c	2008-12-02 10:29:30.000000000 +0100
@@ -2047,6 +2047,13 @@ void __init ld_mmu_srmmu(void)
 	BTFIXUPSET_INT(page_shared, pgprot_val(SRMMU_PAGE_SHARED));
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	BTFIXUPSET_INT(page_shared_noexec, pgprot_val(SRMMU_PAGE_SHARED_NOEXEC));
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 	pg_iobits = SRMMU_VALID | SRMMU_WRITE | SRMMU_REF;
diff -NurpX dontdiff linux-2.4.37/arch/sparc64/config.in linux-2.4.37-pax/arch/sparc64/config.in
--- linux-2.4.37/arch/sparc64/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc64/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -318,5 +318,67 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+#            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+            bool '    Automatically emulate ELF PLT' CONFIG_PAX_EMUPLT
+            if [ "$CONFIG_PAX_EMUPLT" = "y" ]; then
+               define_bool CONFIG_PAX_DLRESOLVE y
+            fi
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source crypto/Config.in
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/sparc64/kernel/sys_sparc.c linux-2.4.37-pax/arch/sparc64/kernel/sys_sparc.c
--- linux-2.4.37/arch/sparc64/kernel/sys_sparc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc64/kernel/sys_sparc.c	2008-12-02 10:29:30.000000000 +0100
@@ -63,6 +63,13 @@ unsigned long arch_get_unmapped_area(str
 		task_size = 0xf0000000UL;
 	if (len > task_size || len > -PAGE_OFFSET)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+		addr = TASK_UNMAPPED_BASE + current->mm->delta_mmap;
+	else
+#endif
+
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -NurpX dontdiff linux-2.4.37/arch/sparc64/kernel/sys_sparc32.c linux-2.4.37-pax/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.4.37/arch/sparc64/kernel/sys_sparc32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc64/kernel/sys_sparc32.c	2008-12-02 10:29:30.000000000 +0100
@@ -3276,6 +3276,11 @@ do_execve32(char * filename, u32 * argv,
 	int i;
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+	bprm.p -= (net_random() & ~(sizeof(void *)-1)) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES * sizeof(bprm.page[0]));
 
 	file = open_exec(filename);
diff -NurpX dontdiff linux-2.4.37/arch/sparc64/mm/fault.c linux-2.4.37-pax/arch/sparc64/mm/fault.c
--- linux-2.4.37/arch/sparc64/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/sparc64/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -16,6 +16,9 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -306,6 +309,367 @@ cannot_handle:
 	unhandled_fault (address, current, regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_EMUPLT
+static void pax_emuplt_close(struct vm_area_struct * vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static struct page* pax_emuplt_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct page* page;
+	unsigned int *kaddr;
+
+	page = alloc_page(GFP_HIGHUSER);
+	if (!page)
+		return page;
+
+	kaddr = kmap(page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(page);
+	kunmap(page);
+	return page;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.nopage = pax_emuplt_nopage,
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	memset(vma, 0, sizeof(*vma));
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = protection_map[vma->vm_flags & 0x0f];
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int*)regs->tpc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned long addr;
+
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int mov1, call, mov2;
+
+		err = get_user(mov1, (unsigned int*)regs->tpc);
+		err |= get_user(call, (unsigned int*)(regs->tpc+4));
+		err |= get_user(mov2, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if (mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(or1, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or2, (unsigned int*)(regs->tpc+12));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020 &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int*)regs->tpc);
+		err |= get_user(sethi2, (unsigned int*)(regs->tpc+4));
+		err |= get_user(sllx, (unsigned int*)(regs->tpc+8));
+		err |= get_user(or, (unsigned int*)(regs->tpc+12));
+		err |= get_user(jmpl, (unsigned int*)(regs->tpc+16));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+20));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020 &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #7 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int*)regs->tpc);
+		err |= get_user(ba, (unsigned int*)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int*)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			err = get_user(save, (unsigned int*)addr);
+			err |= get_user(call, (unsigned int*)(addr+4));
+			err |= get_user(nop, (unsigned int*)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma) kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int*)(regs->tpc-4));
+		err |= get_user(call, (unsigned int*)regs->tpc);
+		err |= get_user(nop, (unsigned int*)(regs->tpc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -345,6 +709,7 @@ asmlinkage void do_sparc64_fault(struct 
 
 	if ((current->thread.flags & SPARC_FLAG_32BIT) != 0) {
 		regs->tpc &= 0xffffffff;
+		regs->tnpc &= 0xffffffff;
 		address &= 0xffffffff;
 	}
 
@@ -353,6 +718,29 @@ asmlinkage void do_sparc64_fault(struct 
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			goto fault_done;
+#endif
+
+		}
+		pax_report_fault(regs, (void*)regs->tpc, (void*)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/config.in linux-2.4.37-pax/arch/x86_64/config.in
--- linux-2.4.37/arch/x86_64/config.in	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/config.in	2008-12-02 10:29:30.000000000 +0100
@@ -261,4 +261,62 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+mainmenu_option next_comment
+comment 'PaX options'
+
+mainmenu_option next_comment
+comment 'PaX Control'
+bool 'Support soft mode' CONFIG_PAX_SOFTMODE
+bool 'Use legacy ELF header marking' CONFIG_PAX_EI_PAX
+bool 'Use ELF program header marking' CONFIG_PAX_PT_PAX_FLAGS
+choice 'MAC system integration' \
+	"none		CONFIG_PAX_NO_ACL_FLAGS \
+	 direct		CONFIG_PAX_HAVE_ACL_FLAGS \
+	 hook		CONFIG_PAX_HOOK_ACL_FLAGS" none
+endmenu
+
+mainmenu_option next_comment
+comment 'Non-executable pages'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Enforce non-executable pages' CONFIG_PAX_NOEXEC
+   if [ "$CONFIG_PAX_NOEXEC" = "y" ]; then
+      bool 'Paging based non-executable pages' CONFIG_PAX_PAGEEXEC
+      if [ "$CONFIG_PAX_PAGEEXEC" = "y" ]; then
+#         bool '  Emulate trampolines' CONFIG_PAX_EMUTRAMP
+#         if [ "$CONFIG_PAX_EMUTRAMP" = "y" ]; then
+#            bool '    Automatically emulate sigreturn trampolines' CONFIG_PAX_EMUSIGRT
+#         fi
+         bool '  Restrict mprotect()' CONFIG_PAX_MPROTECT
+         if [ "$CONFIG_PAX_MPROTECT" = "y" ]; then
+            bool '    Disallow ELF text relocations' CONFIG_PAX_NOELFRELOCS
+         fi
+      fi
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Address Space Layout Randomization'
+if [ "$CONFIG_PAX_EI_PAX" = "y" -o \
+     "$CONFIG_PAX_PT_PAX_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HAVE_ACL_FLAGS" = "y" -o \
+     "$CONFIG_PAX_HOOK_ACL_FLAGS" = "y" ]; then
+   bool 'Address Space Layout Randomization' CONFIG_PAX_ASLR
+   if [ "$CONFIG_PAX_ASLR" = "y" ]; then
+      bool '  Randomize user stack base' CONFIG_PAX_RANDUSTACK
+      bool '  Randomize mmap() base' CONFIG_PAX_RANDMMAP
+   fi
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'Miscellaneous hardening features'
+bool 'Sanitize all freed memory' CONFIG_PAX_MEMORY_SANITIZE
+endmenu
+
+endmenu
+
 source lib/Config.in
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/ia32/ia32_binfmt.c linux-2.4.37-pax/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.4.37/arch/x86_64/ia32/ia32_binfmt.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/ia32/ia32_binfmt.c	2008-12-02 10:29:30.000000000 +0100
@@ -28,7 +28,14 @@ struct elf_phdr; 
 
 #define ELF_NAME "elf/i386"
 
-#define IA32_STACK_TOP IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK (current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK 0UL
+#endif
+
+#define IA32_STACK_TOP (IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+
 #define ELF_ET_DYN_BASE		(IA32_PAGE_OFFSET/3 + 0x1000000)
 
 #undef ELF_ARCH
@@ -129,6 +136,13 @@ struct elf_prpsinfo
 #include <asm/ia32.h>
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x08048000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 typedef struct user_i387_ia32_struct elf_fpregset_t;
 typedef struct user32_fxsr_struct elf_fpxregset_t;
 
@@ -218,7 +232,7 @@ static void elf32_init(struct pt_regs *r
 	me->thread.flags |= THREAD_IA32;
 }
 
-extern void put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address);
+extern int put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address);
  
 
 int ia32_setup_arg_pages(struct linux_binprm *bprm)
@@ -243,7 +257,13 @@ int ia32_setup_arg_pages(struct linux_bi
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = IA32_STACK_TOP;
-		mpnt->vm_flags = vm_stack_flags32; 
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		mpnt->vm_flags = VM_STACK_FLAGS;
+#else
+		mpnt->vm_flags = vm_stack_flags32;
+#endif
+
 		mpnt->vm_page_prot = (mpnt->vm_flags & VM_EXEC) ? 
 			PAGE_COPY_EXEC : PAGE_COPY;
 		mpnt->vm_ops = NULL;
@@ -260,16 +280,18 @@ int ia32_setup_arg_pages(struct linux_bi
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
 		struct page *page = bprm->page[i];
+		int retval;
 		if (page) {
 			bprm->page[i] = NULL;
-			current->mm->rss++;
-			put_dirty_page(current,page,stack_base);
+			retval = put_dirty_page(current,page,stack_base);
+			if (!ret)
+				ret = retval;
 		}
 		stack_base += PAGE_SIZE;
 	}
 	up_write(&current->mm->mmap_sem);
-	
-	return 0;
+
+	return ret;
 }
 static unsigned long
 elf32_map (struct file *filep, unsigned long addr, struct elf_phdr *eppnt, int prot, int type)
@@ -277,8 +299,10 @@ elf32_map (struct file *filep, unsigned 
 	unsigned long map_addr;
 	struct task_struct *me = current; 
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ) 
 		prot |= PROT_EXEC; 
+#endif
 
 	down_write(&me->mm->mmap_sem);
 	map_addr = do_mmap(filep, ELF_PAGESTART(addr),
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/ia32/sys_ia32.c linux-2.4.37-pax/arch/x86_64/ia32/sys_ia32.c
--- linux-2.4.37/arch/x86_64/ia32/sys_ia32.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/ia32/sys_ia32.c	2008-12-02 10:29:30.000000000 +0100
@@ -333,8 +333,11 @@ sys32_mmap(struct mmap_arg_struct *arg)
 			return -EBADF;
 	}
 	
+
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (a.prot & PROT_READ) 
 		a.prot |= PROT_EXEC; 
+#endif
 
 	mm = current->mm; 
 	down_write(&mm->mmap_sem); 
@@ -351,8 +354,12 @@ extern asmlinkage long sys_mprotect(unsi
 
 asmlinkage long sys32_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
+
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ) 
 		prot |= PROT_EXEC; 
+#endif
+
 	return sys_mprotect(start,len,prot); 
 }
 
@@ -2121,8 +2128,10 @@ asmlinkage long sys32_mmap2(unsigned lon
 			return -EBADF;
 	}
 
+#ifndef CONFIG_PAX_PAGEEXEC
 	if (prot & PROT_READ)
 		prot |= PROT_EXEC;
+#endif
 
 	down_write(&mm->mmap_sem);
 	error = do_mmap_pgoff(file, addr, len, prot, flags|MAP_32BIT, pgoff);
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/kernel/setup64.c linux-2.4.37-pax/arch/x86_64/kernel/setup64.c
--- linux-2.4.37/arch/x86_64/kernel/setup64.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/kernel/setup64.c	2008-12-02 10:29:30.000000000 +0100
@@ -36,11 +36,18 @@ struct desc_ptr idt_descr = { 256 * 16, 
    correct flags everywhere. */
 unsigned long __supported_pte_mask = ~0UL; 
 static int do_not_nx __initdata = 0;  
+
+#ifdef CONFIG_PAX_PAGEEXEC
+unsigned long vm_stack_flags = __VM_DATA_DEFAULT_FLAGS;
+unsigned long vm_stack_flags32 = __VM_DATA_DEFAULT_FLAGS;
+#else
 unsigned long vm_stack_flags = __VM_STACK_FLAGS; 
 unsigned long vm_stack_flags32 = __VM_STACK_FLAGS; 
+#endif
+
 unsigned long vm_data_default_flags = __VM_DATA_DEFAULT_FLAGS; 
 unsigned long vm_data_default_flags32 = __VM_DATA_DEFAULT_FLAGS; 
-unsigned long vm_force_exec32 = PROT_EXEC; 
+unsigned long vm_force_exec32 = 0; 
 
 char boot_cpu_stack[IRQSTACKSIZE] __cacheline_aligned;
 
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/kernel/signal.c linux-2.4.37-pax/arch/x86_64/kernel/signal.c
--- linux-2.4.37/arch/x86_64/kernel/signal.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/kernel/signal.c	2008-12-02 10:29:30.000000000 +0100
@@ -144,7 +144,7 @@ restore_sigcontext(struct pt_regs *regs,
 	COPY(rdx); COPY(rcx); 
 	COPY(rip);
 	if (regs->rip >= TASK_SIZE && regs->rip < VSYSCALL_START) { 
-		regs->rip = 0;
+		regs->rip = ~0UL;
 		return -EFAULT;
 	}
 	COPY(r8);
@@ -361,7 +361,7 @@ static void setup_rt_frame(int sig, stru
 	if (regs->rip >= TASK_SIZE) { 
 		if (sig == SIGSEGV)
 			ka->sa.sa_handler = SIG_DFL;
-		regs->rip = 0;
+		regs->rip = ~0UL;
 	}
 	regs->cs = __USER_CS;
 	regs->ss = __USER_DS; 
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/kernel/sys_x86_64.c linux-2.4.37-pax/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.4.37/arch/x86_64/kernel/sys_x86_64.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/kernel/sys_x86_64.c	2008-12-02 10:29:30.000000000 +0100
@@ -72,6 +72,13 @@ unsigned long arch_get_unmapped_area(str
 	unsigned long end = TASK_SIZE;
 
 	if (current->thread.flags & THREAD_IA32) {
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = TASK_UNMAPPED_32 + current->mm->delta_mmap;
+		else
+#endif
+
 		if (!addr) 
 			addr = TASK_UNMAPPED_32;
 		end = 0xffff0000;
@@ -82,10 +89,24 @@ unsigned long arch_get_unmapped_area(str
 		   base down for this case.  This may give conflicts
 		   with the heap, but we assume that malloc falls back
 		   to mmap. Give it 1GB of playground for now. -AK */ 
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = 0x40000000 + (current->mm->delta_mmap & 0x0FFFFFFFU);
+		else
+#endif
+
 		if (!addr) 
 			addr = 0x40000000; 
 		end = 0x80000000;		
 	} else { 
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && (!addr || filp))
+			addr = TASK_UNMAPPED_64 + current->mm->delta_mmap;
+		else
+#endif
+
 		if (!addr) 
 			addr = TASK_UNMAPPED_64; 
 		end = TASK_SIZE; 
diff -NurpX dontdiff linux-2.4.37/arch/x86_64/mm/fault.c linux-2.4.37-pax/arch/x86_64/mm/fault.c
--- linux-2.4.37/arch/x86_64/mm/fault.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/arch/x86_64/mm/fault.c	2008-12-02 10:29:30.000000000 +0100
@@ -173,6 +173,33 @@ static int is_prefetch(struct pt_regs *r
 	return prefetch;
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned char*)pc+i))
+			printk("???????? ");
+		else
+			printk("%08x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-8: ");
+	for (i = -1; i < 10; i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long*)sp+i))
+			printk("???????????????? ");
+		else
+			printk("%16lx ", c);
+	}
+	printk("\n");
+}
+#endif
+
 int page_fault_trace; 
 int exception_trace = 1;
 
@@ -267,6 +294,15 @@ again:
  * we can handle it..
  */
 good_area:
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (error_code & 16) && !(vma->vm_flags & VM_EXEC)) {
+		up_read(&mm->mmap_sem);
+		pax_report_fault(regs, (void*)regs->rip, (void*)regs->rsp);
+		do_exit(SIGKILL);
+	}
+#endif
+
 	info.si_code = SEGV_ACCERR;
 	write = 0;
 	switch (error_code & 3) {
diff -NurpX dontdiff linux-2.4.37/drivers/char/mem.c linux-2.4.37-pax/drivers/char/mem.c
--- linux-2.4.37/drivers/char/mem.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/char/mem.c	2008-12-02 10:29:30.000000000 +0100
@@ -402,9 +402,25 @@ static inline size_t read_zero_pagealign
 			count = size;
 
 		zap_page_range(mm, addr, count);
-        	if (zeromap_page_range(addr, count, PAGE_COPY))
+        	if (zeromap_page_range(addr, count, vma->vm_page_prot))
 			break;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR) {
+			unsigned long addr_m;
+			struct vm_area_struct * vma_m;
+
+			addr_m = vma->vm_start + vma->vm_mirror;
+			vma_m = find_vma(mm, addr_m);
+			if (vma_m && vma_m->vm_start == addr_m && (vma_m->vm_flags & VM_MIRROR)) {
+				addr_m = addr + vma->vm_mirror;
+				zap_page_range(mm, addr_m, count);
+			} else
+				printk(KERN_ERR "PAX: VMMIRROR: read_zero bug, %08lx, %08lx\n",
+				       addr, vma->vm_start);
+		}
+#endif
+
 		size -= count;
 		buf += count;
 		addr += count;
diff -NurpX dontdiff linux-2.4.37/drivers/hotplug/cpqphp_nvram.c linux-2.4.37-pax/drivers/hotplug/cpqphp_nvram.c
--- linux-2.4.37/drivers/hotplug/cpqphp_nvram.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/hotplug/cpqphp_nvram.c	2008-12-02 10:29:30.000000000 +0100
@@ -425,9 +425,13 @@ static u32 store_HRT (void *rom_start)
 
 void compaq_nvram_init (void *rom_start)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	if (rom_start) {
 		compaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);
 	}
+#endif
+
 	dbg("int15 entry  = %p\n", compaq_int15_entry_point);
 
 	/* initialize our int15 lock */
diff -NurpX dontdiff linux-2.4.37/drivers/ieee1394/ohci1394.c linux-2.4.37-pax/drivers/ieee1394/ohci1394.c
--- linux-2.4.37/drivers/ieee1394/ohci1394.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/ieee1394/ohci1394.c	2008-12-02 10:29:30.000000000 +0100
@@ -169,8 +169,8 @@ static char version[] __devinitdata =
 
 /* Module Parameters */
 MODULE_PARM(phys_dma,"i");
-MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 1).");
-static int phys_dma = 1;
+MODULE_PARM_DESC(phys_dma, "Enable physical dma (default = 0).");
+static int phys_dma = 0;
 
 static void dma_trm_tasklet(unsigned long data);
 static void dma_trm_reset(struct dma_trm_ctx *d);
diff -NurpX dontdiff linux-2.4.37/drivers/net/wan/sdla_ppp.c linux-2.4.37-pax/drivers/net/wan/sdla_ppp.c
--- linux-2.4.37/drivers/net/wan/sdla_ppp.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/net/wan/sdla_ppp.c	2008-12-02 10:29:30.000000000 +0100
@@ -467,7 +467,7 @@ static int update(wan_device_t *wandev)
 	sdla_t* card = wandev->private;
  	netdevice_t* dev;
         volatile ppp_private_area_t *ppp_priv_area;
-	ppp_flags_t *flags = card->flags;
+	ppp_flags_t *flags;
 	unsigned long timeout;
 
 	/* sanity checks */
@@ -491,6 +491,7 @@ static int update(wan_device_t *wandev)
 	
 	ppp_priv_area->update_comms_stats = 2;
 	ppp_priv_area->timer_int_enabled |= TMR_INT_ENABLED_UPDATE;
+	flags = card->flags;
 	flags->imask |= PPP_INTR_TIMER;	
 	
 	/* wait a maximum of 1 second for the statistics to be updated */ 
diff -NurpX dontdiff linux-2.4.37/drivers/scsi/libata-scsi.c linux-2.4.37-pax/drivers/scsi/libata-scsi.c
--- linux-2.4.37/drivers/scsi/libata-scsi.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/scsi/libata-scsi.c	2008-12-02 10:29:30.000000000 +0100
@@ -1497,7 +1497,7 @@ unsigned int ata_scsiop_inq_80(struct at
 	return 0;
 }
 
-static const char *inq_83_str = "Linux ATA-SCSI simulator";
+static const char inq_83_str[] = "Linux ATA-SCSI simulator";
 
 /**
  *	ata_scsiop_inq_83 - Simulate INQUIRY EVPD page 83, device identity
@@ -1516,13 +1516,13 @@ unsigned int ata_scsiop_inq_83(struct at
 			      unsigned int buflen)
 {
 	rbuf[1] = 0x83;			/* this page code */
-	rbuf[3] = 4 + strlen(inq_83_str);	/* page len */
+	rbuf[3] = 3 + sizeof(inq_83_str);	/* page len */
 
 	/* our one and only identification descriptor (vendor-specific) */
-	if (buflen > (strlen(inq_83_str) + 4 + 4 - 1)) {
+	if (buflen >= (sizeof(inq_83_str) + 4 + 4 - 1)) {
 		rbuf[4 + 0] = 2;	/* code set: ASCII */
-		rbuf[4 + 3] = strlen(inq_83_str);
-		memcpy(rbuf + 4 + 4, inq_83_str, strlen(inq_83_str));
+		rbuf[4 + 3] = sizeof(inq_83_str)-1;
+		memcpy(rbuf + 4 + 4, inq_83_str, sizeof(inq_83_str)-1);
 	}
 
 	return 0;
diff -NurpX dontdiff linux-2.4.37/drivers/video/vesafb.c linux-2.4.37-pax/drivers/video/vesafb.c
--- linux-2.4.37/drivers/video/vesafb.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/drivers/video/vesafb.c	2008-12-02 10:29:30.000000000 +0100
@@ -546,7 +546,7 @@ int __init vesafb_init(void)
 	video_visual = (video_bpp == 8) ?
 		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
 
-#ifndef __i386__
+#if !defined(__i386__) || defined(CONFIG_PAX_KERNEXEC)
 	screen_info.vesapm_seg = 0;
 #endif
 
diff -NurpX dontdiff linux-2.4.37/fs/Makefile linux-2.4.37-pax/fs/Makefile
--- linux-2.4.37/fs/Makefile	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/Makefile	2008-12-02 10:29:30.000000000 +0100
@@ -7,7 +7,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o exec.o
 mod-subdirs :=	nls
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
diff -NurpX dontdiff linux-2.4.37/fs/binfmt_aout.c linux-2.4.37-pax/fs/binfmt_aout.c
--- linux-2.4.37/fs/binfmt_aout.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/binfmt_aout.c	2008-12-02 10:29:30.000000000 +0100
@@ -315,6 +315,28 @@ static int load_aout_binary(struct linux
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->mm->pax_flags |= MF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->mm->pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))
+			current->mm->pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
@@ -408,7 +430,7 @@ static int load_aout_binary(struct linux
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -NurpX dontdiff linux-2.4.37/fs/binfmt_elf.c linux-2.4.37-pax/fs/binfmt_elf.c
--- linux-2.4.37/fs/binfmt_elf.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/binfmt_elf.c	2008-12-02 10:29:30.000000000 +0100
@@ -33,15 +33,22 @@
 #include <linux/smp_lock.h>
 #include <linux/compiler.h>
 #include <linux/highmem.h>
+#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/pgalloc.h>
+#include <asm/system.h>
 
 #define DLINFO_ITEMS 13
 
 #include <linux/elf.h>
 
+#ifdef CONFIG_PAX_HOOK_ACL_FLAGS
+void (*pax_set_flags_func)(struct linux_binprm * bprm);
+EXPORT_SYMBOL(pax_set_flags_func);
+#endif
+
 static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs);
 static int load_elf_library(struct file*);
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
@@ -81,18 +88,22 @@ static struct linux_binfmt elf_format = 
 
 static int set_brk(unsigned long start, unsigned long end)
 {
+	unsigned long e = end, retval;
+
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
+
+	down_write(&current->mm->mmap_sem);
 	if (end > start) {
-		unsigned long addr;
-		down_write(&current->mm->mmap_sem);
-		addr = do_brk(start, end - start);
-		up_write(&current->mm->mmap_sem);
-		if (BAD_ADDR(addr))
-			return addr;
+		retval = do_brk(start, end - start);
+		if (BAD_ADDR(retval))
+			goto out;
 	}
-	current->mm->start_brk = current->mm->brk = end;
-	return 0;
+	current->mm->start_brk = current->mm->brk = e;
+	retval = 0UL;
+out:
+	up_write(&current->mm->mmap_sem);
+	return retval;
 }
 
 
@@ -275,7 +286,7 @@ static unsigned long load_elf_interp(str
 	unsigned long load_addr = 0;
 	int load_addr_set = 0;
 	unsigned long last_bss = 0, elf_bss = 0;
-	unsigned long error = ~0UL;
+	unsigned long error = -EINVAL;
 	int retval, i, size;
 
 	/* First of all, some simple consistency checks */
@@ -397,6 +408,8 @@ static unsigned long load_elf_interp(str
 	 * switch to out-of-band error reporting.
 	 */
 	error = ((unsigned long) interp_elf_ex->e_entry) + load_addr;
+	if (BAD_ADDR(error))
+		error = -EFAULT;
 
 out_close:
 	kfree(elf_phdata);
@@ -407,7 +420,7 @@ out:
 static unsigned long load_aout_interp(struct exec * interp_ex,
 			     struct file * interpreter)
 {
-	unsigned long text_data, elf_entry = ~0UL;
+	unsigned long text_data, elf_entry = -EINVAL;
 	char * addr;
 	loff_t offset;
 
@@ -452,6 +465,171 @@ out:
 	return elf_entry;
 }
 
+#if (defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)) && defined(CONFIG_PAX_SOFTMODE)
+static unsigned long pax_parse_softmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (elf_phdata->p_flags & PF_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (elf_phdata->p_flags & PF_SEGMEXEC) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (elf_phdata->p_flags & PF_EMUTRAMP)
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (elf_phdata->p_flags & PF_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (elf_phdata->p_flags & PF_RANDMMAP)
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+static unsigned long pax_parse_hardmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC)) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (!(elf_phdata->p_flags & PF_NORANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC)) {
+		pax_flags &= ~MF_PAX_PAGEEXEC;
+		pax_flags |= MF_PAX_SEGMEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+static long pax_parse_elf_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	unsigned long i;
+#endif
+
+#ifdef CONFIG_PAX_EI_PAX
+	pax_flags = pax_parse_ei_pax(elf_ex);
+#endif
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	for (i = 0UL; i < elf_ex->e_phnum; i++)
+		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+				return -EINVAL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+			if (pax_softmode)
+				pax_flags = pax_parse_softmode(&elf_phdata[i]);
+			else
+#endif
+
+				pax_flags = pax_parse_hardmode(&elf_phdata[i]);
+			break;
+		}
+#endif
+
+	if (0 > pax_check_flags(&pax_flags))
+		return -EINVAL;
+
+	current->mm->pax_flags = pax_flags;
+	return 0;
+}
+#endif
+
 /*
  * These are the functions used to load ELF style executables and shared
  * libraries.  There is no binary dependent code anywhere else.
@@ -684,7 +862,47 @@ static int load_elf_binary(struct linux_
 	current->mm->end_data = 0;
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	current->mm->call_dl_resolve = 0UL;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	current->mm->call_syscall = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	current->mm->delta_mmap = 0UL;
+	current->mm->delta_stack = 0UL;
+#endif
+
 	current->flags &= ~PF_FORKNOEXEC;
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS)
+	if (0 > pax_parse_elf_flags(&elf_ex, elf_phdata)) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+	pax_set_initial_flags(bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	if (pax_set_initial_flags_func)
+		(pax_set_initial_flags_func)(bprm);
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+		current->mm->delta_mmap = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN)-1)) << PAGE_SHIFT;
+		current->mm->delta_stack = (net_random() & ((1UL << PAX_DELTA_STACK_LEN)-1)) << PAGE_SHIFT;
+	}
+#endif
+
 	elf_entry = (unsigned long) elf_ex.e_entry;
 
 	/* Do this so that we can load the interpreter, if need be.  We will
@@ -693,7 +911,7 @@ static int load_elf_binary(struct linux_
 	retval = setup_arg_pages(bprm);
 	if (retval < 0) {
 		send_sig(SIGKILL, current, 0);
-		return retval;
+		goto out_free_dentry;
 	}
 	
 	current->mm->start_stack = bprm->p;
@@ -745,6 +963,20 @@ static int load_elf_binary(struct linux_
 			   base, as well as whatever program they might try to exec.  This
 		           is because the brk will follow the loader, and is not movable.  */
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
+
+#ifdef CONFIG_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && elf_interpreter) {
+#ifdef __sparc_v9__
+				load_bias = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << (PAGE_SHIFT+1);
+#else
+				load_bias = (net_random() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << PAGE_SHIFT;
+#endif
+				load_bias = ELF_PAGESTART(PAX_ELF_ET_DYN_BASE - vaddr + load_bias);
+				elf_flags |= MAP_FIXED;
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
@@ -801,6 +1033,11 @@ static int load_elf_binary(struct linux_
 	start_data += load_bias;
 	end_data += load_bias;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		elf_brk += PAGE_SIZE + ((net_random() & ~PAGE_MASK) << 4);
+#endif
+
 	/* Calling set_brk effectively mmaps the pages that we need
 	 * for the bss and break sections.  We must do this before
 	 * mapping in the interpreter, to make sure it doesn't wind
@@ -907,6 +1144,10 @@ static int load_elf_binary(struct linux_
 	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_switch_segments(current);
+#endif
+
 	start_thread(regs, elf_entry, bprm->p);
 	if (current->ptrace & PT_PTRACED)
 		send_sig(SIGTRAP, current, 0);
@@ -1052,7 +1293,7 @@ static int dump_seek(struct file *file, 
  *
  * I think we should skip something. But I am not sure how. H.J.
  */
-static inline int maydump(struct vm_area_struct *vma)
+static inline int maydump(struct vm_area_struct *vma, long signr)
 {
 	/*
 	 * If we may not read the contents, don't allow us to dump
@@ -1064,12 +1305,15 @@ static inline int maydump(struct vm_area
 	/* Do not dump I/O mapped devices! -DaveM */
 	if (vma->vm_flags & VM_IO)
 		return 0;
-#if 1
+
+	if (signr == SIGKILL)
+		return 1;
+
 	if (vma->vm_flags & (VM_WRITE|VM_GROWSUP|VM_GROWSDOWN))
 		return 1;
 	if (vma->vm_flags & (VM_READ|VM_EXEC|VM_EXECUTABLE|VM_SHARED))
 		return 0;
-#endif
+
 	return 1;
 }
 
@@ -1341,7 +1585,7 @@ static int elf_core_dump(long signr, str
 		phdr.p_offset = offset;
 		phdr.p_vaddr = vma->vm_start;
 		phdr.p_paddr = 0;
-		phdr.p_filesz = maydump(vma) ? sz : 0;
+		phdr.p_filesz = maydump(vma, signr) ? sz : 0;
 		phdr.p_memsz = sz;
 		offset += phdr.p_filesz;
 		phdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;
@@ -1361,7 +1605,7 @@ static int elf_core_dump(long signr, str
 	for(vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
 		unsigned long addr;
 
-		if (!maydump(vma))
+		if (!maydump(vma, signr))
 			continue;
 
 #ifdef DEBUG
diff -NurpX dontdiff linux-2.4.37/fs/binfmt_misc.c linux-2.4.37-pax/fs/binfmt_misc.c
--- linux-2.4.37/fs/binfmt_misc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/binfmt_misc.c	2008-12-02 10:29:30.000000000 +0100
@@ -102,9 +102,11 @@ static int load_misc_binary(struct linux
 	int retval;
 
 	retval = -ENOEXEC;
-	if (!enabled)
+	if (!enabled || bprm->misc)
 		goto _ret;
 
+	bprm->misc++;
+
 	/* to keep locking time low, we copy the interpreter string */
 	read_lock(&entries_lock);
 	fmt = check_file(bprm);
diff -NurpX dontdiff linux-2.4.37/fs/exec.c linux-2.4.37-pax/fs/exec.c
--- linux-2.4.37/fs/exec.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/exec.c	2008-12-02 10:29:30.000000000 +0100
@@ -37,6 +37,7 @@
 #include <linux/personality.h>
 #include <linux/swap.h>
 #include <linux/utsname.h>
+#include <linux/random.h>
 #define __NO_VERSION__
 #include <linux/module.h>
 
@@ -282,7 +283,7 @@ int copy_strings_kernel(int argc,char **
  *
  * tsk->mmap_sem is held for writing.
  */
-void put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address)
+int put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address)
 {
 	pgd_t * pgd;
 	pmd_t * pmd;
@@ -315,12 +316,53 @@ void put_dirty_page(struct task_struct *
 	spin_unlock(&tsk->mm->page_table_lock);
 
 	/* no need for flush_tlb */
-	return;
+	return 0;
+out:
+	spin_unlock(&tsk->mm->page_table_lock);
+	__free_page(page);
+	force_sig(SIGKILL, tsk);
+	return -ENOMEM;
+}
+
+static int put_dirty_page_mirror(struct task_struct * tsk, struct page *page, unsigned long address)
+{
+	pgd_t * pgd;
+	pmd_t * pmd;
+	pte_t * pte;
+	struct vm_area_struct *vma; 
+	pgprot_t prot = PAGE_COPY; 
+
+	if (page_count(page) != 1)
+		printk(KERN_ERR "mem_map disagrees with %p at %08lx\n", page, address);
+
+	page_cache_get(page);
+	pgd = pgd_offset(tsk->mm, address);
+
+	spin_lock(&tsk->mm->page_table_lock);
+	pmd = pmd_alloc(tsk->mm, pgd, address);
+	if (!pmd)
+		goto out;
+	pte = pte_alloc(tsk->mm, pmd, address);
+	if (!pte)
+		goto out;
+	if (!pte_none(*pte))
+		goto out;
+
+	vma = find_vma(tsk->mm, address);
+	if (vma)
+		prot = vma->vm_page_prot;
+	set_pte(pte, mk_pte(page, prot));
+	tsk->mm->rss++;
+	spin_unlock(&tsk->mm->page_table_lock);
+
+	/* no need for flush_tlb */
+	return 0;
 out:
 	spin_unlock(&tsk->mm->page_table_lock);
+	page_cache_release(page);
 	__free_page(page);
 	force_sig(SIGKILL, tsk);
-	return;
+	return -ENOMEM;
 }
 
 int setup_arg_pages(struct linux_binprm *bprm)
@@ -329,6 +371,10 @@ int setup_arg_pages(struct linux_binprm 
 	struct vm_area_struct *mpnt;
 	int i, ret;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *mpnt_m = NULL;
+#endif
+
 	stack_base = STACK_TOP - MAX_ARG_PAGES*PAGE_SIZE;
 
 	bprm->p += stack_base;
@@ -339,37 +385,99 @@ int setup_arg_pages(struct linux_binprm 
 	mpnt = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 	if (!mpnt) 
 		return -ENOMEM; 
-	
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (VM_STACK_FLAGS & VM_MAYEXEC)) {
+		mpnt_m = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+		if (!mpnt_m) {
+			kmem_cache_free(vm_area_cachep, mpnt);
+			return -ENOMEM;
+		}
+	}
+#endif
+
 	down_write(&current->mm->mmap_sem);
 	{
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
 		mpnt->vm_end = STACK_TOP;
 		mpnt->vm_flags = VM_STACK_FLAGS;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+		if (!(current->mm->pax_flags & MF_PAX_PAGEEXEC))
+			mpnt->vm_page_prot = protection_map[(VM_STACK_FLAGS | VM_EXEC) & 0x7];
+		else
+#endif
+
 		mpnt->vm_page_prot = protection_map[VM_STACK_FLAGS & 0x7];
 		mpnt->vm_ops = NULL;
 		mpnt->vm_pgoff = 0;
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = (void *) 0;
+		mpnt->vm_mirror = 0;
 		if ((ret = insert_vm_struct(current->mm, mpnt))) {
 			up_write(&current->mm->mmap_sem);
 			kmem_cache_free(vm_area_cachep, mpnt);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (mpnt_m)
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+#endif
+
 			return ret;
 		}
 		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mpnt_m) {
+			*mpnt_m = *mpnt;
+			mpnt_m->vm_flags &= ~VM_WRITE;
+			if (!(VM_STACK_FLAGS & VM_EXEC)) {
+				mpnt_m->vm_flags &= ~(VM_READ | VM_EXEC);
+				mpnt_m->vm_page_prot = PAGE_NONE;
+			} else
+				mpnt_m->vm_page_prot = PAGE_READONLY;
+			mpnt_m->vm_start += SEGMEXEC_TASK_SIZE;
+			mpnt_m->vm_end += SEGMEXEC_TASK_SIZE;
+			if ((ret = insert_vm_struct(current->mm, mpnt_m))) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, mpnt_m);
+				return ret;
+			}
+			mpnt_m->vm_flags |= VM_MIRROR;
+			mpnt->vm_flags |= VM_MIRROR;
+			mpnt_m->vm_mirror = mpnt->vm_start - mpnt_m->vm_start;
+			mpnt->vm_mirror = mpnt_m->vm_start - mpnt->vm_start;
+			current->mm->total_vm += (mpnt_m->vm_end - mpnt_m->vm_start) >> PAGE_SHIFT;
+		}
+#endif
+
 	} 
 
-	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
+	for (i = 0 ; i < MAX_ARG_PAGES ; i++, stack_base += PAGE_SIZE) {
 		struct page *page = bprm->page[i];
-		if (page) {
-			bprm->page[i] = NULL;
-			put_dirty_page(current,page,stack_base);
-		}
-		stack_base += PAGE_SIZE;
+		int retval;
+		if (!page)
+			continue;
+
+		bprm->page[i] = NULL;
+		retval = put_dirty_page(current,page,stack_base);
+		if (!ret)
+			ret = retval;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (!mpnt_m || retval)
+			continue;
+
+		retval = put_dirty_page_mirror(current,page,stack_base + SEGMEXEC_TASK_SIZE);
+		if (!ret)
+			ret = retval;
+#endif
+
 	}
 	up_write(&current->mm->mmap_sem);
-	
-	return 0;
+
+	return ret;
 }
 
 struct file *open_exec(const char *name)
@@ -950,11 +1058,22 @@ int do_execve(char * filename, char ** a
 		return retval;
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_aslr)
+#endif
+
+	bprm.p -= (net_random() & ~15) & ~PAGE_MASK;
+#endif
+
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
 
 	bprm.file = file;
 	bprm.filename = filename;
 	bprm.sh_bang = 0;
+	bprm.misc = 0;
 	bprm.loader = 0;
 	bprm.exec = 0;
 	if ((bprm.argc = count(argv, bprm.p / sizeof(void *))) < 0) {
@@ -1132,6 +1251,111 @@ void format_corename(char *corename, con
 	*out_ptr = 0;
 }
 
+int pax_check_flags(unsigned long * flags)
+{
+	int retval = 0;
+
+#if !defined(__i386__) || !defined(CONFIG_PAX_SEGMEXEC)
+	if (*flags & MF_PAX_SEGMEXEC)
+	{
+		*flags &= ~MF_PAX_SEGMEXEC;
+		retval = -EINVAL;
+	}
+#endif
+
+	if ((*flags & MF_PAX_PAGEEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	    &&  (*flags & MF_PAX_SEGMEXEC)
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_PAGEEXEC;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_MPROTECT)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_MPROTECT;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_EMUTRAMP)
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_EMUTRAMP;
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(pax_check_flags);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char* buffer_exec = (char*)__get_free_page(GFP_ATOMIC);
+	char* buffer_fault = (char*)__get_free_page(GFP_ATOMIC);
+	char* path_exec=NULL;
+	char* path_fault=NULL;
+	unsigned long start=0UL, end=0UL, offset=0UL;
+
+	if (buffer_exec && buffer_fault) {
+		struct vm_area_struct* vma, * vma_exec=NULL, * vma_fault=NULL;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma && (!vma_exec || !vma_fault)) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+				vma_exec = vma;
+			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+				vma_fault = vma;
+			vma = vma->vm_next;
+		}
+		if (vma_exec) {
+			path_exec = d_path(vma_exec->vm_file->f_dentry, vma_exec->vm_file->f_vfsmnt, buffer_exec, PAGE_SIZE);
+			if (IS_ERR(path_exec))
+				path_exec = "<path too long>";
+		}
+		if (vma_fault) {
+			start = vma_fault->vm_start;
+			end = vma_fault->vm_end;
+			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+			if (vma_fault->vm_file) {
+				path_fault = d_path(vma_fault->vm_file->f_dentry, vma_fault->vm_file->f_vfsmnt, buffer_fault, PAGE_SIZE);
+				if (IS_ERR(path_fault))
+					path_fault = "<path too long>";
+			} else
+				path_fault = "<anonymous mapping>";
+		}
+		up_read(&mm->mmap_sem);
+	}
+	printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, "
+			"PC: %p, SP: %p\n", path_exec, tsk->comm, tsk->pid,
+			tsk->uid, tsk->euid, pc, sp);
+	free_page((unsigned long)buffer_exec);
+	free_page((unsigned long)buffer_fault);
+	pax_report_insns(pc, sp);
+	do_coredump(SIGKILL, regs);
+}
+#endif
+
 int do_coredump(long signr, struct pt_regs * regs)
 {
 	struct linux_binfmt * binfmt;
diff -NurpX dontdiff linux-2.4.37/fs/proc/array.c linux-2.4.37-pax/fs/proc/array.c
--- linux-2.4.37/fs/proc/array.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/proc/array.c	2008-12-02 10:29:30.000000000 +0100
@@ -276,6 +276,20 @@ static inline char *task_cap(struct task
 			    cap_t(p->cap_effective));
 }
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline char *task_pax(struct task_struct *p, char *buffer)
+{
+	if (p->mm)
+		return buffer + sprintf(buffer, "PaX:\t%c%c%c%c%c\n",
+					p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+					p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+					p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+					p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+					p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+	else
+		return buffer + sprintf(buffer, "PaX:\t------\n");
+}
+#endif
 
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
@@ -298,6 +312,11 @@ int proc_pid_status(struct task_struct *
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	buffer = task_pax(task, buffer);
+#endif
+
 	return buffer - orig;
 }
 
@@ -536,9 +555,17 @@ static int show_map(struct seq_file *m, 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
 			map->vm_start,
 			map->vm_end,
+
+#if 0
+			flags & VM_MAYREAD ? flags & VM_READ ? 'R' : '+' : flags & VM_READ ? 'r' : '-',
+			flags & VM_MAYWRITE ? flags & VM_WRITE ? 'W' : '+' : flags & VM_WRITE ? 'w' : '-',
+			flags & VM_MAYEXEC ? flags & VM_EXEC ? 'X' : '+' : flags & VM_EXEC ? 'x' : '-',
+#else
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
+#endif
+
 			flags & VM_MAYSHARE ? 's' : 'p',
 			map->vm_pgoff << PAGE_SHIFT,
 			MAJOR(dev), MINOR(dev), ino, &len);
diff -NurpX dontdiff linux-2.4.37/fs/xfs/linux-2.4/xfs_file.c linux-2.4.37-pax/fs/xfs/linux-2.4/xfs_file.c
--- linux-2.4.37/fs/xfs/linux-2.4/xfs_file.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/fs/xfs/linux-2.4/xfs_file.c	2008-12-02 10:29:30.000000000 +0100
@@ -330,6 +330,11 @@ linvfs_file_mmap(
 			return error;
 	}
 
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	vma->vm_ops = &linvfs_file_vm_ops;
 
 	VOP_SETATTR(vp, &va, XFS_AT_UPDATIME, NULL, error);
diff -NurpX dontdiff linux-2.4.37/include/asm-alpha/a.out.h linux-2.4.37-pax/include/asm-alpha/a.out.h
--- linux-2.4.37/include/asm-alpha/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-alpha/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -98,7 +98,7 @@ struct exec
 	set_personality (((BFPM->sh_bang || EX.ah.entry < 0x100000000 \
 			   ? ADDR_LIMIT_32BIT : 0) | PER_OSF4))
 
-#define STACK_TOP \
+#define __STACK_TOP \
   (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
 
 #endif
diff -NurpX dontdiff linux-2.4.37/include/asm-alpha/elf.h linux-2.4.37-pax/include/asm-alpha/elf.h
--- linux-2.4.37/include/asm-alpha/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-alpha/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -41,6 +41,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x1000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality & ADDR_LIMIT_32BIT ? 0x10000 : 0x120000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_STACK_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 19)
+#endif
+
 /* $0 is set by ld.so to a pointer to a function which might be 
    registered using atexit.  This provides a mean for the dynamic
    linker to call DT_FINI functions for shared libraries that have
diff -NurpX dontdiff linux-2.4.37/include/asm-alpha/kmap_types.h linux-2.4.37-pax/include/asm-alpha/kmap_types.h
--- linux-2.4.37/include/asm-alpha/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-alpha/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-alpha/page.h linux-2.4.37-pax/include/asm-alpha/page.h
--- linux-2.4.37/include/asm-alpha/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-alpha/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -101,6 +101,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS		(VM_READ | VM_WRITE | VM_EXEC | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _ALPHA_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-alpha/pgtable.h linux-2.4.37-pax/include/asm-alpha/pgtable.h
--- linux-2.4.37/include/asm-alpha/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-alpha/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -96,6 +96,17 @@
 #define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)
 #define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
 #define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOE)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)
 
 #define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/a.out.h linux-2.4.37-pax/include/asm-i386/a.out.h
--- linux-2.4.37/include/asm-i386/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -19,7 +19,11 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#ifdef CONFIG_PAX_SEGMEXEC
+#define __STACK_TOP ((current->mm->pax_flags & MF_PAX_SEGMEXEC)?TASK_SIZE/2:TASK_SIZE)
+#else
+#define __STACK_TOP TASK_SIZE
+#endif
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/checksum.h linux-2.4.37-pax/include/asm-i386/checksum.h
--- linux-2.4.37/include/asm-i386/checksum.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/checksum.h	2008-12-02 10:29:30.000000000 +0100
@@ -27,6 +27,12 @@ asmlinkage unsigned int csum_partial(con
 asmlinkage unsigned int csum_partial_copy_generic( const char *src, char *dst, int len, int sum,
 						   int *src_err_ptr, int *dst_err_ptr);
 
+asmlinkage unsigned int csum_partial_copy_generic_to_user( const char *src, char *dst, int len, int sum,
+						   int *src_err_ptr, int *dst_err_ptr);
+
+asmlinkage unsigned int csum_partial_copy_generic_from_user( const char *src, char *dst, int len, int sum,
+						   int *src_err_ptr, int *dst_err_ptr);
+
 /*
  *	Note: when you get a NULL pointer exception here this means someone
  *	passed in an incorrect kernel address to one of these functions.
@@ -45,7 +51,7 @@ static __inline__
 unsigned int csum_partial_copy_from_user ( const char *src, char *dst,
 						int len, int sum, int *err_ptr)
 {
-	return csum_partial_copy_generic ( src, dst, len, sum, err_ptr, NULL);
+	return csum_partial_copy_generic_from_user ( src, dst, len, sum, err_ptr, NULL);
 }
 
 /*
@@ -185,7 +191,7 @@ static __inline__ unsigned int csum_and_
 				    int len, int sum, int *err_ptr)
 {
 	if (access_ok(VERIFY_WRITE, dst, len))
-		return csum_partial_copy_generic(src, dst, len, sum, NULL, err_ptr);
+		return csum_partial_copy_generic_to_user(src, dst, len, sum, NULL, err_ptr);
 
 	if (len)
 		*err_ptr = -EFAULT;
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/desc.h linux-2.4.37-pax/include/asm-i386/desc.h
--- linux-2.4.37/include/asm-i386/desc.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/desc.h	2008-12-02 10:29:30.000000000 +0100
@@ -46,7 +46,8 @@ struct desc_struct {
 };
 
 extern struct desc_struct gdt_table[];
-extern struct desc_struct *idt, *gdt;
+extern struct desc_struct gdt_table2[];
+extern struct desc_struct *idt, *gdt, *gdt2;
 
 struct Xgt_desc_struct {
 	unsigned short size;
@@ -55,6 +56,7 @@ struct Xgt_desc_struct {
 
 #define idt_descr (*(struct Xgt_desc_struct *)((char *)&idt - 2))
 #define gdt_descr (*(struct Xgt_desc_struct *)((char *)&gdt - 2))
+#define gdt_descr2 (*(struct Xgt_desc_struct *)((char *)&gdt2 - 2))
 
 #define load_TR(n) __asm__ __volatile__("ltr %%ax"::"a" (__TSS(n)<<3))
 
@@ -64,10 +66,10 @@ struct Xgt_desc_struct {
  * This is the ldt that every process will get unless we need
  * something other than this.
  */
-extern struct desc_struct default_ldt[];
-extern void set_intr_gate(unsigned int irq, void * addr);
-extern void set_ldt_desc(unsigned int n, void *addr, unsigned int size);
-extern void set_tss_desc(unsigned int n, void *addr);
+extern const struct desc_struct default_ldt[];
+extern void set_intr_gate(unsigned int irq, const void * addr);
+extern void set_ldt_desc(unsigned int n, const void *addr, unsigned int size);
+extern void set_tss_desc(unsigned int n, const void *addr);
 
 static inline void clear_LDT(void)
 {
@@ -82,7 +84,7 @@ static inline void clear_LDT(void)
 static inline void load_LDT (mm_context_t *pc)
 {
 	int cpu = smp_processor_id();
-	void *segments = pc->ldt;
+	const void *segments = pc->ldt;
 	int count = pc->size;
 
 	if (!count) {
@@ -94,6 +96,17 @@ static inline void load_LDT (mm_context_
 	__load_LDT(cpu);
 }
 
+#define pax_open_kernel(cr0)		\
+do {					\
+	cr0 = read_cr0();		\
+	write_cr0(cr0 & ~0x10000UL);	\
+} while(0)
+
+#define pax_close_kernel(cr0)		\
+do {					\
+	write_cr0(cr0);			\
+} while(0)
+
 #endif /* !__ASSEMBLY__ */
 
 #endif
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/elf.h linux-2.4.37-pax/include/asm-i386/elf.h
--- linux-2.4.37/include/asm-i386/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -55,7 +55,18 @@ typedef struct user_fxsr_struct elf_fpxr
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE		((current->mm->pax_flags & MF_PAX_SEGMEXEC)?SEGMEXEC_TASK_SIZE/3*2:TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x08048000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#endif
 
 /* Wow, the "main" arch needs arch dependent functions too.. :) */
 
@@ -70,17 +81,17 @@ typedef struct user_fxsr_struct elf_fpxr
 	pr_reg[4] = regs->edi;				\
 	pr_reg[5] = regs->ebp;				\
 	pr_reg[6] = regs->eax;				\
-	pr_reg[7] = regs->xds;				\
-	pr_reg[8] = regs->xes;				\
+	pr_reg[7] = regs->xds & 0xffff;			\
+	pr_reg[8] = regs->xes & 0xffff;			\
 	/* fake once used fs and gs selectors? */	\
-	pr_reg[9] = regs->xds;	/* was fs and __fs */	\
-	pr_reg[10] = regs->xds;	/* was gs and __gs */	\
+	pr_reg[9] = regs->xds & 0xffff;	/* was fs and __fs */\
+	pr_reg[10] = regs->xds & 0xffff;/* was gs and __gs */\
 	pr_reg[11] = regs->orig_eax;			\
 	pr_reg[12] = regs->eip;				\
-	pr_reg[13] = regs->xcs;				\
+	pr_reg[13] = regs->xcs & 0xffff;		\
 	pr_reg[14] = regs->eflags;			\
 	pr_reg[15] = regs->esp;				\
-	pr_reg[16] = regs->xss;
+	pr_reg[16] = regs->xss & 0xffff;
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/hw_irq.h linux-2.4.37-pax/include/asm-i386/hw_irq.h
--- linux-2.4.37/include/asm-i386/hw_irq.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/hw_irq.h	2008-12-02 10:29:30.000000000 +0100
@@ -95,7 +95,7 @@ extern char _stext, _etext;
 #define __STR(x) #x
 #define STR(x) __STR(x)
 
-#define SAVE_ALL \
+#define __SAVE_ALL \
 	"cld\n\t" \
 	"pushl %es\n\t" \
 	"pushl %ds\n\t" \
@@ -110,6 +110,18 @@ extern char _stext, _etext;
 	"movl %edx,%ds\n\t" \
 	"movl %edx,%es\n\t"
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL \
+	"movl %cr0,%edx\n\t" \
+	"movl %edx,%ebp\n\t" \
+	"orl $0x10000,%edx\n\t" \
+	"xorl %edx,%ebp\n\t" \
+	"movl %edx,%cr0\n\t"
+#else
+#define SAVE_ALL __SAVE_ALL
+#endif
+
 #define IRQ_NAME2(nr) nr##_interrupt(void)
 #define IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)
 
@@ -128,6 +140,7 @@ extern char _stext, _etext;
 asmlinkage void x(void); \
 asmlinkage void call_##x(void); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
 	"pushl $"#v"-256\n\t" \
@@ -141,6 +154,7 @@ SYMBOL_NAME_STR(x) ":\n\t" \
 asmlinkage void x(struct pt_regs * regs); \
 asmlinkage void call_##x(void); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(x) ":\n\t" \
 	"pushl $"#v"-256\n\t" \
@@ -155,6 +169,7 @@ SYMBOL_NAME_STR(x) ":\n\t" \
 #define BUILD_COMMON_IRQ() \
 asmlinkage void call_do_IRQ(void); \
 __asm__( \
+	"\n .text" \
 	"\n" __ALIGN_STR"\n" \
 	"common_interrupt:\n\t" \
 	SAVE_ALL \
@@ -175,6 +190,7 @@ __asm__( \
 #define BUILD_IRQ(nr) \
 asmlinkage void IRQ_NAME(nr); \
 __asm__( \
+"\n .text" \
 "\n"__ALIGN_STR"\n" \
 SYMBOL_NAME_STR(IRQ) #nr "_interrupt:\n\t" \
 	"pushl $"#nr"-256\n\t" \
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/kmap_types.h linux-2.4.37-pax/include/asm-i386/kmap_types.h
--- linux-2.4.37/include/asm-i386/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/mman.h linux-2.4.37-pax/include/asm-i386/mman.h
--- linux-2.4.37/include/asm-i386/mman.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/mman.h	2008-12-02 10:29:30.000000000 +0100
@@ -18,6 +18,10 @@
 #define MAP_LOCKED	0x2000		/* pages are locked */
 #define MAP_NORESERVE	0x4000		/* don't check for reservations */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define MAP_MIRROR	0x8000
+#endif
+
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/page.h linux-2.4.37-pax/include/asm-i386/page.h
--- linux-2.4.37/include/asm-i386/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -81,6 +81,12 @@ typedef struct { unsigned long pgprot; }
 
 #define __PAGE_OFFSET		(0xC0000000)
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define __KERNEL_TEXT_OFFSET	(0xC0400000)
+#else
+#define __KERNEL_TEXT_OFFSET	(0)
+#endif
+
 /*
  * This much address space is reserved for vmalloc() and iomap()
  * as well as fixmap mappings.
@@ -98,7 +104,7 @@ typedef struct { unsigned long pgprot; }
 
 #if 1	/* Set to zero for a slightly smaller kernel */
 #define BUG()				\
- __asm__ __volatile__(	"ud2\n"		\
+ __asm__ __volatile__( "ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
 			 : : "i" (__LINE__), "i" (__FILE__))
@@ -138,6 +144,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & (MF_PAX_PAGEEXEC|MF_PAX_SEGMEXEC))?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _I386_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/pgalloc.h linux-2.4.37-pax/include/asm-i386/pgalloc.h
--- linux-2.4.37/include/asm-i386/pgalloc.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/pgalloc.h	2008-12-02 10:29:30.000000000 +0100
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #include <asm/processor.h>
 #include <asm/fixmap.h>
+#include <asm/desc.h>
 #include <linux/threads.h>
 
 #define pgd_quicklist (current_cpu_data.pgd_quick)
@@ -14,6 +15,9 @@
 #define pmd_populate(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
 
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte)))
+
 /*
  * Allocate and free page tables.
  */
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/pgtable-2level.h linux-2.4.37-pax/include/asm-i386/pgtable-2level.h
--- linux-2.4.37/include/asm-i386/pgtable-2level.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/pgtable-2level.h	2008-12-02 10:29:30.000000000 +0100
@@ -46,8 +46,25 @@ static inline int pgd_present(pgd_t pgd)
  * (pmds are folded into pgds so this doesnt get actually called,
  * but the define is needed for a generic inline function.)
  */
+#ifdef CONFIG_PAX_KERNEXEC
+#define set_pmd(pmdptr,pmdval) \
+({ \
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*(pmdptr) = pmdval; \
+	pax_close_kernel(cr0); \
+})
+#define set_pgd(pgdptr, pgdval) \
+({ \
+	unsigned long cr0; \
+	pax_open_kernel(cr0); \
+	*(pgdptr) = pgdval; \
+	pax_close_kernel(cr0); \
+})
+#else
 #define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
 #define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+#endif
 
 #define pgd_page(pgd) \
 ((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/pgtable-3level.h linux-2.4.37-pax/include/asm-i386/pgtable-3level.h
--- linux-2.4.37/include/asm-i386/pgtable-3level.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/pgtable-3level.h	2008-12-02 10:29:30.000000000 +0100
@@ -49,10 +49,28 @@ static inline void set_pte(pte_t *ptep, 
 	smp_wmb();
 	ptep->pte_low = pte.pte_low;
 }
+
+#ifdef CONFIG_PAX_KERNEXEC
+#define set_pmd(pmdptr,pmdval) \
+({ \
+		unsigned long cr0; \
+		pax_open_kernel(cr0); \
+		set_64bit((unsigned long long *)(pmdptr),pmd_val(pmdval)); \
+		pax_close_kernel(cr0); \
+})
+#define set_pgd(pgdptr,pgdval) \
+({ \
+		unsigned long cr0; \
+		pax_open_kernel(cr0); \
+		set_64bit((unsigned long long *)(pgdptr),pgd_val(pgdval)); \
+		pax_close_kernel(cr0); \
+})
+#else
 #define set_pmd(pmdptr,pmdval) \
 		set_64bit((unsigned long long *)(pmdptr),pmd_val(pmdval))
 #define set_pgd(pgdptr,pgdval) \
 		set_64bit((unsigned long long *)(pgdptr),pgd_val(pgdval))
+#endif
 #define set_pte_atomic(pteptr,pteval) \
 		set_64bit((unsigned long long *)(pteptr),pte_val(pteval))
 
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/pgtable.h linux-2.4.37-pax/include/asm-i386/pgtable.h
--- linux-2.4.37/include/asm-i386/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -21,7 +21,6 @@
 #include <asm/bitops.h>
 #endif
 
-extern pgd_t swapper_pg_dir[1024];
 extern void paging_init(void);
 
 /* Caches aren't brain-dead on the intel. */
@@ -104,14 +103,11 @@ extern unsigned long pgkern_mask;
 extern unsigned long empty_zero_page[1024];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 
-#endif /* !__ASSEMBLY__ */
-
 /*
  * The Linux x86 paging architecture is 'compile-time dual-mode', it
  * implements both the traditional 2-level x86 page tables and the
  * newer 3-level PAE-mode page tables.
  */
-#ifndef __ASSEMBLY__
 #if CONFIG_X86_PAE
 # include <asm/pgtable-3level.h>
 
@@ -129,8 +125,16 @@ extern void pgtable_cache_init(void);
 #define pgtable_cache_init()	do { } while (0)
 
 #endif
+
+#ifdef CONFIG_X86_PAE
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern pmd_t swapper_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+#else
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 #endif
 
+#endif /* !__ASSEMBLY__ */
+
 #define __beep() asm("movb $0x3,%al; outb %al,$0x61")
 
 #define PMD_SIZE	(1UL << PMD_SHIFT)
@@ -144,9 +148,13 @@ extern void pgtable_cache_init(void);
 #define USER_PGD_PTRS (PAGE_OFFSET >> PGDIR_SHIFT)
 #define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
 
-#define TWOLEVEL_PGDIR_SHIFT	22
-#define BOOT_USER_PGD_PTRS (__PAGE_OFFSET >> TWOLEVEL_PGDIR_SHIFT)
+#ifdef CONFIG_X86_PAE
+#define BOOT_USER_PMD_PTRS (__PAGE_OFFSET >> 21)
+#define BOOT_KERNEL_PMD_PTRS (2048-BOOT_USER_PMD_PTRS)
+#else
+#define BOOT_USER_PGD_PTRS (__PAGE_OFFSET >> 22)
 #define BOOT_KERNEL_PGD_PTRS (1024-BOOT_USER_PGD_PTRS)
+#endif
 
 
 #ifndef __ASSEMBLY__
@@ -205,6 +213,16 @@ extern void pgtable_cache_init(void);
 #define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define __PAGE_KERNEL \
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define __PAGE_KERNEL_NOCACHE \
@@ -237,18 +255,18 @@ extern void pgtable_cache_init(void);
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
 #define __P100	PAGE_READONLY
 #define __P101	PAGE_READONLY
 #define __P110	PAGE_COPY
 #define __P111	PAGE_COPY
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
 #define __S100	PAGE_READONLY
 #define __S101	PAGE_READONLY
 #define __S110	PAGE_SHARED
@@ -324,7 +342,7 @@ static inline pte_t pte_modify(pte_t pte
 ((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
 
 /* to find an entry in a page-table-directory. */
-#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 
 #define __pgd_offset(address) pgd_index(address)
 
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/processor.h linux-2.4.37-pax/include/asm-i386/processor.h
--- linux-2.4.37/include/asm-i386/processor.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/processor.h	2008-12-02 10:29:30.000000000 +0100
@@ -261,10 +261,19 @@ extern unsigned int mca_pentium_flag;
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_SIZE	(TASK_SIZE / 2)
+#endif
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+#define TASK_UNMAPPED_BASE	((current->mm->pax_flags & MF_PAX_SEGMEXEC)?SEGMEXEC_TASK_SIZE/3:TASK_SIZE/3)
+#else
 #define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#endif
 
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
@@ -392,7 +401,7 @@ struct thread_struct {
 
 #define INIT_TSS  {						\
 	0,0, /* back_link, __blh */				\
-	sizeof(init_stack) + (long) &init_stack, /* esp0 */	\
+	sizeof(init_stack) + (long) &init_stack - 8, /* esp0 */	\
 	__KERNEL_DS, 0, /* ss0 */				\
 	0,0,0,0,0,0, /* stack1, stack2 */			\
 	0, /* cr3 */						\
@@ -440,12 +449,20 @@ static inline void release_segments(stru
  */
 static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
-	return ((unsigned long *)t->esp)[3];
+	return t->eip;
 }
 
 unsigned long get_wchan(struct task_struct *p);
-#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
-#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1022])
+
+#define task_pt_regs(task)						\
+({									\
+	struct pt_regs *__regs__;					\
+	__regs__ = (struct pt_regs *)((task)->thread.esp0);		\
+	__regs__ - 1;							\
+})
+
+#define KSTK_EIP(tsk)  (task_pt_regs(tsk)->eip)
+#define KSTK_ESP(tsk)  (task_pt_regs(tsk)->esp)
 
 #define THREAD_SIZE (2*PAGE_SIZE)
 #define alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/segment.h linux-2.4.37-pax/include/asm-i386/segment.h
--- linux-2.4.37/include/asm-i386/segment.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/segment.h	2008-12-02 10:29:30.000000000 +0100
@@ -7,4 +7,7 @@
 #define __USER_CS	0x23
 #define __USER_DS	0x2B
 
+#define __PCIBIOS_CS	0x30
+#define __PCIBIOS_DS	0x38
+
 #endif
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/system.h linux-2.4.37-pax/include/asm-i386/system.h
--- linux-2.4.37/include/asm-i386/system.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/system.h	2008-12-02 10:29:30.000000000 +0100
@@ -12,6 +12,8 @@
 struct task_struct;	/* one of the stranger aspects of C forward declarations.. */
 extern void FASTCALL(__switch_to(struct task_struct *prev, struct task_struct *next));
 
+void pax_switch_segments(struct task_struct *);
+
 #define prepare_to_switch()	do { } while(0)
 #define switch_to(prev,next,last) do {					\
 	asm volatile("pushl %%esi\n\t"					\
diff -NurpX dontdiff linux-2.4.37/include/asm-i386/uaccess.h linux-2.4.37-pax/include/asm-i386/uaccess.h
--- linux-2.4.37/include/asm-i386/uaccess.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-i386/uaccess.h	2008-12-02 10:29:30.000000000 +0100
@@ -8,6 +8,7 @@
 #include <linux/sched.h>
 #include <linux/prefetch.h>
 #include <asm/page.h>
+#include <asm/segment.h>
 
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
@@ -277,9 +278,12 @@ extern void __put_user_bad(void);
 
 #define __put_user_u64(x, addr, err)				\
 	__asm__ __volatile__(					\
-		"1:	movl %%eax,0(%2)\n"			\
-		"2:	movl %%edx,4(%2)\n"			\
+		"	movw %w5,%%ds\n"			\
+		"1:	movl %%eax,%%ds:0(%2)\n"		\
+		"2:	movl %%edx,%%ds:4(%2)\n"		\
 		"3:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"4:	movl %3,%0\n"				\
 		"	jmp 3b\n"				\
@@ -290,7 +294,8 @@ extern void __put_user_bad(void);
 		"	.long 2b,4b\n"				\
 		".previous"					\
 		: "=r"(err)					\
-		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
+		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err),	\
+		  "r"(__USER_DS))
 
 #define __put_user_size(x,ptr,size,retval)				\
 do {									\
@@ -314,8 +319,11 @@ struct __large_struct { unsigned long bu
  */
 #define __put_user_asm(x, addr, err, itype, rtype, ltype)	\
 	__asm__ __volatile__(					\
-		"1:	mov"itype" %"rtype"1,%2\n"		\
+		"	movw %w5,%%ds\n"			\
+		"1:	mov"itype" %"rtype"1,%%ds:%2\n"		\
 		"2:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"3:	movl %3,%0\n"				\
 		"	jmp 2b\n"				\
@@ -325,7 +333,8 @@ struct __large_struct { unsigned long bu
 		"	.long 1b,3b\n"				\
 		".previous"					\
 		: "=r"(err)					\
-		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err))
+		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err), \
+		  "r"(__USER_DS))
 
 
 #define __get_user_nocheck(x,ptr,size)				\
@@ -351,8 +360,11 @@ do {									\
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype)	\
 	__asm__ __volatile__(					\
-		"1:	mov"itype" %2,%"rtype"1\n"		\
+		"	movw %w5,%%ds\n"			\
+		"1:	mov"itype" %%ds:%2,%"rtype"1\n"		\
 		"2:\n"						\
+		"	pushl %%ss\n"				\
+		"	popl %%ds\n"				\
 		".section .fixup,\"ax\"\n"			\
 		"3:	movl %3,%0\n"				\
 		"	xor"itype" %"rtype"1,%"rtype"1\n"	\
@@ -363,7 +375,7 @@ do {									\
 		"	.long 1b,3b\n"				\
 		".previous"					\
 		: "=r"(err), ltype (x)				\
-		: "m"(__m(addr)), "i"(-EFAULT), "0"(err))
+		: "m"(__m(addr)), "i"(-EFAULT), "0"(err), "r"(__USER_DS))
 
 
 /*
@@ -375,10 +387,13 @@ do {									\
 do {									\
 	int __d0, __d1;							\
 	__asm__ __volatile__(						\
+		"	movw %w7,%%es\n"				\
 		"0:	rep; movsl\n"					\
 		"	movl %3,%0\n"					\
 		"1:	rep; movsb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%es\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%3,%0,4),%0\n"				\
 		"	jmp 2b\n"					\
@@ -389,7 +404,8 @@ do {									\
 		"	.long 1b,2b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
-		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
+		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from),	\
+		  "r"(__USER_DS)					\
 		: "memory");						\
 } while (0)
 
@@ -397,10 +413,13 @@ do {									\
 do {									\
 	int __d0, __d1;							\
 	__asm__ __volatile__(						\
+		"	movw %w7,%%ds\n"				\
 		"0:	rep; movsl\n"					\
 		"	movl %3,%0\n"					\
 		"1:	rep; movsb\n"					\
 		"2:\n"							\
+		"	pushl %%ss\n"					\
+		"	popl %%ds\n"					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%3,%0,4),%0\n"				\
 		"4:	pushl %0\n"					\
@@ -417,7 +436,8 @@ do {									\
 		"	.long 1b,4b\n"					\
 		".previous"						\
 		: "=&c"(size), "=&D" (__d0), "=&S" (__d1)		\
-		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from)	\
+		: "r"(size & 3), "0"(size / 4), "1"(to), "2"(from),	\
+		  "r"(__USER_DS)					\
 		: "memory");						\
 } while (0)
 
@@ -446,8 +466,11 @@ do {								\
 	switch (size & 3) {					\
 	default:						\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"2:	shl $2,%0\n"			\
 			"	jmp 1b\n"			\
@@ -457,14 +480,18 @@ do {								\
 			"	.long 0b,2b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 1:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsb\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	shl $2,%0\n"			\
 			"4:	incl %0\n"			\
@@ -476,14 +503,18 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 2:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	shl $2,%0\n"			\
 			"4:	addl $2,%0\n"			\
@@ -495,15 +526,19 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 3:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%es\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:	movsb\n"			\
 			"3:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%es\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"4:	shl $2,%0\n"			\
 			"5:	addl $2,%0\n"			\
@@ -517,7 +552,8 @@ do {								\
 			"	.long 2b,6b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	}							\
@@ -530,8 +566,11 @@ do {								\
 	switch (size & 3) {					\
 	default:						\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"2:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -547,14 +586,18 @@ do {								\
 			"	.long 0b,2b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 1:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsb\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -579,14 +622,18 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 2:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"3:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -611,15 +658,19 @@ do {								\
 			"	.long 1b,4b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	case 3:							\
 		__asm__ __volatile__(				\
+			"	movw %w6,%%ds\n"		\
 			"0:	rep; movsl\n"			\
 			"1:	movsw\n"			\
 			"2:	movsb\n"			\
 			"3:\n"					\
+			"	pushl %%ss\n"			\
+			"	popl %%ds\n"			\
 			".section .fixup,\"ax\"\n"		\
 			"4:	pushl %0\n"			\
 			"	pushl %%eax\n"			\
@@ -653,7 +704,8 @@ do {								\
 			"	.long 2b,6b\n"			\
 			".previous"				\
 			: "=c"(size), "=&S" (__d0), "=&D" (__d1)\
-			: "1"(from), "2"(to), "0"(size/4)	\
+			: "1"(from), "2"(to), "0"(size/4),	\
+			  "r"(__USER_DS)			\
 			: "memory");				\
 		break;						\
 	}							\
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/elf.h linux-2.4.37-pax/include/asm-ia64/elf.h
--- linux-2.4.37/include/asm-ia64/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -41,6 +41,12 @@
  */
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x800000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
 
 /*
  * We use (abuse?) this macro to insert the (empty) vm_area that is
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/ia32.h linux-2.4.37-pax/include/asm-ia64/ia32.h
--- linux-2.4.37/include/asm-ia64/ia32.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/ia32.h	2008-12-02 10:29:30.000000000 +0100
@@ -367,7 +367,14 @@ struct old_linux32_dirent {
 #define ELF_ARCH	EM_386
 
 #define IA32_PAGE_OFFSET	0xc0000000
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
+
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK (current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK 0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
 
 /*
  * The system segments (GDT, TSS, LDT) have to be mapped below 4GB so the IA-32 engine can
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/kmap_types.h linux-2.4.37-pax/include/asm-ia64/kmap_types.h
--- linux-2.4.37/include/asm-ia64/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -23,7 +23,8 @@ D(9)	KM_IRQ0,
 D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
+D(13)	KM_CLEARPAGE,
+D(14)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/page.h linux-2.4.37-pax/include/asm-ia64/page.h
--- linux-2.4.37/include/asm-ia64/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -190,4 +190,13 @@ get_order (unsigned long size)
 					 (((current->thread.flags & IA64_THREAD_XSTACK) != 0)	\
 					  ? VM_EXEC : 0))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* _ASM_IA64_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/pgtable.h linux-2.4.37-pax/include/asm-ia64/pgtable.h
--- linux-2.4.37/include/asm-ia64/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -115,6 +115,17 @@
 #define PAGE_SHARED	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
 #define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
+# define PAGE_READONLY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+# define PAGE_COPY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+#endif
+
 #define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)
 #define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)
 #define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)
diff -NurpX dontdiff linux-2.4.37/include/asm-ia64/ustack.h linux-2.4.37-pax/include/asm-ia64/ustack.h
--- linux-2.4.37/include/asm-ia64/ustack.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ia64/ustack.h	2008-12-02 10:29:30.000000000 +0100
@@ -11,6 +11,6 @@
 #define MAX_USER_STACK_SIZE	(RGN_MAP_LIMIT/2)
 /* Make a default stack size of 2GB */
 #define DEFAULT_USER_STACK_SIZE	(1UL << 31)
-#define STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
+#define __STACK_TOP		(0x6000000000000000UL + RGN_MAP_LIMIT)
 
 #endif /* _ASM_IA64_USTACK_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-m68k/kmap_types.h linux-2.4.37-pax/include/asm-m68k/kmap_types.h
--- linux-2.4.37/include/asm-m68k/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-m68k/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips/a.out.h linux-2.4.37-pax/include/asm-mips/a.out.h
--- linux-2.4.37/include/asm-mips/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -19,7 +19,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips/elf.h linux-2.4.37-pax/include/asm-mips/elf.h
--- linux-2.4.37/include/asm-mips/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -107,6 +107,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x00400000UL
+
+#define PAX_DELTA_MMAP_LEN	(27 - PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(27 - PAGE_SHIFT)
+#endif
+
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
 #endif
diff -NurpX dontdiff linux-2.4.37/include/asm-mips/kmap_types.h linux-2.4.37-pax/include/asm-mips/kmap_types.h
--- linux-2.4.37/include/asm-mips/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips/page.h linux-2.4.37-pax/include/asm-mips/page.h
--- linux-2.4.37/include/asm-mips/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -77,7 +77,7 @@ static inline void copy_user_page(void *
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-    #define __pte(x)	({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+    #define __pte(x)	({ pte_t __pte = {(x), (x) >> 32}; __pte; })
   #else
     typedef struct { unsigned long long pte_low; } pte_t;
     #define pte_val(x)    ((x).pte_low)
@@ -137,6 +137,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS  (VM_READ | VM_WRITE | VM_EXEC | \
 				VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips64/a.out.h linux-2.4.37-pax/include/asm-mips64/a.out.h
--- linux-2.4.37/include/asm-mips64/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips64/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -26,7 +26,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP (current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
+#define __STACK_TOP (current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips64/elf.h linux-2.4.37-pax/include/asm-mips64/elf.h
--- linux-2.4.37/include/asm-mips64/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips64/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -107,6 +107,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	((current->thread.mflags & MF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2)			\
 do {	current->thread.mflags &= ~MF_ABI_MASK;		\
diff -NurpX dontdiff linux-2.4.37/include/asm-mips64/kmap_types.h linux-2.4.37-pax/include/asm-mips64/kmap_types.h
--- linux-2.4.37/include/asm-mips64/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips64/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-mips64/page.h linux-2.4.37-pax/include/asm-mips64/page.h
--- linux-2.4.37/include/asm-mips64/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-mips64/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -148,6 +148,15 @@ static __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* defined (__KERNEL__) */
 
 #endif /* _ASM_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-parisc/a.out.h linux-2.4.37-pax/include/asm-parisc/a.out.h
--- linux-2.4.37/include/asm-parisc/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-parisc/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -22,7 +22,7 @@ struct exec
 /* XXX: STACK_TOP actually should be STACK_BOTTOM for parisc.
  * prumpf */
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-parisc/elf.h linux-2.4.37-pax/include/asm-parisc/elf.h
--- linux-2.4.37/include/asm-parisc/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-parisc/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -135,6 +135,13 @@ struct pt_regs;	/* forward declaration..
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE + 0x01000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
    but it's not easy, and we've already done it here.  */
diff -NurpX dontdiff linux-2.4.37/include/asm-parisc/page.h linux-2.4.37-pax/include/asm-parisc/page.h
--- linux-2.4.37/include/asm-parisc/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-parisc/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -117,6 +117,15 @@ extern int npmem_ranges;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _PARISC_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-parisc/pgtable.h linux-2.4.37-pax/include/asm-parisc/pgtable.h
--- linux-2.4.37/include/asm-parisc/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-parisc/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -167,6 +167,17 @@ extern  void *vmalloc_start;
 #define PAGE_EXECREAD   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_EXEC |_PAGE_ACCESSED)
 #define PAGE_COPY       PAGE_EXECREAD
 #define PAGE_RWX        __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_EXEC |_PAGE_ACCESSED)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define PAGE_KERNEL_UNC	__pgprot(_PAGE_KERNEL | _PAGE_NO_CACHE)
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc/a.out.h linux-2.4.37-pax/include/asm-ppc/a.out.h
--- linux-2.4.37/include/asm-ppc/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -2,7 +2,7 @@
 #define __PPC_A_OUT_H__
 
 /* grabbed from the intel stuff  */
-#define STACK_TOP TASK_SIZE
+#define __STACK_TOP TASK_SIZE
 
 
 struct exec
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc/elf.h linux-2.4.37-pax/include/asm-ppc/elf.h
--- linux-2.4.37/include/asm-ppc/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -46,6 +46,13 @@ typedef elf_vrreg_t elf_vrregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE         (0x08000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000000UL
+
+#define PAX_DELTA_MMAP_LEN	15
+#define PAX_DELTA_STACK_LEN	15
+#endif
+
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
 
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc/kmap_types.h linux-2.4.37-pax/include/asm-ppc/kmap_types.h
--- linux-2.4.37/include/asm-ppc/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -11,6 +11,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc/page.h linux-2.4.37-pax/include/asm-ppc/page.h
--- linux-2.4.37/include/asm-ppc/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -171,5 +171,14 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _PPC_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc/pgtable.h linux-2.4.37-pax/include/asm-ppc/pgtable.h
--- linux-2.4.37/include/asm-ppc/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -394,11 +394,21 @@ extern unsigned long vmalloc_start;
 
 #define PAGE_NONE	__pgprot(_PAGE_BASE)
 #define PAGE_READONLY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_READONLY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_SHARED	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW)
-#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC)
+#define PAGE_SHARED_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_EXEC | _PAGE_HWEXEC)
 #define PAGE_COPY	__pgprot(_PAGE_BASE | _PAGE_USER)
-#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC)
+#define PAGE_COPY_X	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_EXEC | _PAGE_HWEXEC)
+
+#if defined(CONFIG_PAX_PAGEEXEC) && !defined(CONFIG_40x) && !defined(CONFIG_44x)
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_RW | _PAGE_GUARDED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_BASE | _PAGE_USER | _PAGE_GUARDED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
 
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_BASE | _PAGE_SHARED)
@@ -411,21 +421,21 @@ extern unsigned long vmalloc_start;
  * This is the closest we can get..
  */
 #define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY_X
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY_X
-#define __P100	PAGE_READONLY
+#define __P001	PAGE_READONLY_NOEXEC
+#define __P010	PAGE_COPY_NOEXEC
+#define __P011	PAGE_COPY_NOEXEC
+#define __P100	PAGE_READONLY_X
 #define __P101	PAGE_READONLY_X
-#define __P110	PAGE_COPY
+#define __P110	PAGE_COPY_X
 #define __P111	PAGE_COPY_X
 
 #define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY_X
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED_X
-#define __S100	PAGE_READONLY
+#define __S001	PAGE_READONLY_NOEXEC
+#define __S010	PAGE_SHARED_NOEXEC
+#define __S011	PAGE_SHARED_NOEXEC
+#define __S100	PAGE_READONLY_X
 #define __S101	PAGE_READONLY_X
-#define __S110	PAGE_SHARED
+#define __S110	PAGE_SHARED_X
 #define __S111	PAGE_SHARED_X
 
 #ifndef __ASSEMBLY__
diff -NurpX dontdiff linux-2.4.37/include/asm-ppc64/kmap_types.h linux-2.4.37-pax/include/asm-ppc64/kmap_types.h
--- linux-2.4.37/include/asm-ppc64/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-ppc64/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -15,7 +15,8 @@ enum km_type {
 	KM_IRQ0,
 	KM_IRQ1,
 	KM_SOFTIRQ0,
-	KM_SOFTIRQ1,	
+	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-s390/kmap_types.h linux-2.4.37-pax/include/asm-s390/kmap_types.h
--- linux-2.4.37/include/asm-s390/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-s390/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-s390x/kmap_types.h linux-2.4.37-pax/include/asm-s390x/kmap_types.h
--- linux-2.4.37/include/asm-s390x/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-s390x/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/a.out.h linux-2.4.37-pax/include/asm-sparc/a.out.h
--- linux-2.4.37/include/asm-sparc/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -91,7 +91,7 @@ struct relocation_info /* used when head
 
 #include <asm/page.h>
 
-#define STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
+#define __STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
 
 #endif /* __KERNEL__ */
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/elf.h linux-2.4.37-pax/include/asm-sparc/elf.h
--- linux-2.4.37/include/asm-sparc/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -83,6 +83,13 @@ typedef struct {
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This can NOT be done in userspace
    on Sparc.  */
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/kmap_types.h linux-2.4.37-pax/include/asm-sparc/kmap_types.h
--- linux-2.4.37/include/asm-sparc/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -10,6 +10,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/page.h linux-2.4.37-pax/include/asm-sparc/page.h
--- linux-2.4.37/include/asm-sparc/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -182,6 +182,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			 ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _SPARC_PAGE_H */
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/pgtable.h linux-2.4.37-pax/include/asm-sparc/pgtable.h
--- linux-2.4.37/include/asm-sparc/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -97,6 +97,13 @@ BTFIXUPDEF_INT(page_none)
 BTFIXUPDEF_INT(page_shared)
 BTFIXUPDEF_INT(page_copy)
 BTFIXUPDEF_INT(page_readonly)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+BTFIXUPDEF_INT(page_shared_noexec)
+BTFIXUPDEF_INT(page_copy_noexec)
+BTFIXUPDEF_INT(page_readonly_noexec)
+#endif
+
 BTFIXUPDEF_INT(page_kernel)
 
 #define PMD_SHIFT       	BTFIXUP_SIMM13(pmd_shift)
@@ -118,6 +125,16 @@ BTFIXUPDEF_INT(page_kernel)
 #define PAGE_COPY      __pgprot(BTFIXUP_INT(page_copy))
 #define PAGE_READONLY  __pgprot(BTFIXUP_INT(page_readonly))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(BTFIXUP_INT(page_shared_noexec))
+# define PAGE_COPY_NOEXEC	__pgprot(BTFIXUP_INT(page_copy_noexec))
+# define PAGE_READONLY_NOEXEC	__pgprot(BTFIXUP_INT(page_readonly_noexec))
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 extern unsigned long page_kernel;
 
 #ifdef MODULE
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/pgtsrmmu.h linux-2.4.37-pax/include/asm-sparc/pgtsrmmu.h
--- linux-2.4.37/include/asm-sparc/pgtsrmmu.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/pgtsrmmu.h	2008-12-02 10:29:30.000000000 +0100
@@ -76,6 +76,16 @@
 				    SRMMU_EXEC | SRMMU_REF)
 #define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
 				    SRMMU_EXEC | SRMMU_REF)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define SRMMU_PAGE_SHARED_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_WRITE | SRMMU_REF)
+#define SRMMU_PAGE_COPY_NOEXEC    __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#define SRMMU_PAGE_RDONLY_NOEXEC  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
+					   SRMMU_REF)
+#endif
+
 #define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \
 				    SRMMU_DIRTY | SRMMU_REF)
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc/uaccess.h linux-2.4.37-pax/include/asm-sparc/uaccess.h
--- linux-2.4.37/include/asm-sparc/uaccess.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc/uaccess.h	2008-12-02 10:29:30.000000000 +0100
@@ -39,7 +39,7 @@
  * No one can read/write anything from userland in the kernel space by setting
  * large size and address near to PAGE_OFFSET - a fault will break his intentions.
  */
-#define __user_ok(addr,size) ((addr) < STACK_TOP)
+#define __user_ok(addr,size) ((addr) < __STACK_TOP)
 #define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc64/a.out.h linux-2.4.37-pax/include/asm-sparc64/a.out.h
--- linux-2.4.37/include/asm-sparc64/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc64/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -95,7 +95,7 @@ struct relocation_info /* used when head
 
 #ifdef __KERNEL__
 
-#define STACK_TOP (current->thread.flags & SPARC_FLAG_32BIT ? 0xf0000000 : 0x80000000000L)
+#define __STACK_TOP (current->thread.flags & SPARC_FLAG_32BIT ? 0xf0000000 : 0x80000000000L)
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc64/elf.h linux-2.4.37-pax/include/asm-sparc64/elf.h
--- linux-2.4.37/include/asm-sparc64/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc64/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -82,6 +82,12 @@ typedef struct {
 #define ELF_ET_DYN_BASE         0x0000010000000000UL
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->thread.flags & SPARC_FLAG_32BIT ? 0x10000UL : 0x100000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->thread.flags & SPARC_FLAG_32BIT ? 14 : 28 )
+#define PAX_DELTA_STACK_LEN	(current->thread.flags & SPARC_FLAG_32BIT ? 15 : 29 )
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  */
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc64/kmap_types.h linux-2.4.37-pax/include/asm-sparc64/kmap_types.h
--- linux-2.4.37/include/asm-sparc64/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc64/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -14,6 +14,7 @@ enum km_type {
 	KM_BH_IRQ,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-sparc64/page.h linux-2.4.37-pax/include/asm-sparc64/page.h
--- linux-2.4.37/include/asm-sparc64/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-sparc64/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -160,6 +160,15 @@ extern __inline__ int get_order(unsigned
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#endif
+
 #endif /* !(__KERNEL__) */
 
 #endif /* !(_SPARC64_PAGE_H) */
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/a.out.h linux-2.4.37-pax/include/asm-x86_64/a.out.h
--- linux-2.4.37/include/asm-x86_64/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -23,7 +23,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#define __STACK_TOP	TASK_SIZE
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/elf.h linux-2.4.37-pax/include/asm-x86_64/elf.h
--- linux-2.4.37/include/asm-x86_64/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -68,6 +68,13 @@ typedef struct user_fxsr_struct elf_fpxr
 
 #define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->thread.flags & THREAD_IA32 ? 0x08048000UL : 0x400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->thread.flags & THREAD_IA32 ? 16 : 24)
+#define PAX_DELTA_STACK_LEN	(current->thread.flags & THREAD_IA32 ? 16 : 24)
+#endif
+
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different). Assumes current is the process
    getting dumped. */
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/kmap_types.h linux-2.4.37-pax/include/asm-x86_64/kmap_types.h
--- linux-2.4.37/include/asm-x86_64/kmap_types.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/kmap_types.h	2008-12-02 10:29:30.000000000 +0100
@@ -9,6 +9,7 @@ enum km_type {
 	KM_USER1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/page.h linux-2.4.37-pax/include/asm-x86_64/page.h
--- linux-2.4.37/include/asm-x86_64/page.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/page.h	2008-12-02 10:29:30.000000000 +0100
@@ -142,6 +142,16 @@ extern __inline__ int get_order(unsigned
 
 #define __VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define VM_DATA_DEFAULT_FLAGS __VM_DATA_DEFAULT_FLAGS
+#ifdef CONFIG_PAX_MPROTECT
+#define __VM_STACK_FLAGS (((current->mm->pax_flags & MF_PAX_MPROTECT)?0:VM_MAYEXEC) | \
+			  ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#else
+#define __VM_STACK_FLAGS (VM_MAYEXEC | ((current->mm->pax_flags & MF_PAX_PAGEEXEC)?0:VM_EXEC))
+#endif
+#else
 #define __VM_STACK_FLAGS 	(VM_GROWSDOWN | VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
@@ -149,6 +159,7 @@ extern __inline__ int get_order(unsigned
 	((current->thread.flags & THREAD_IA32) ? vm_data_default_flags32 : \
 	  vm_data_default_flags) 
 #define VM_STACK_FLAGS	vm_stack_flags
+#endif
 
 #endif /* __KERNEL__ */
 
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/pgalloc.h linux-2.4.37-pax/include/asm-x86_64/pgalloc.h
--- linux-2.4.37/include/asm-x86_64/pgalloc.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/pgalloc.h	2008-12-02 10:29:30.000000000 +0100
@@ -14,6 +14,8 @@
 
 #define pmd_populate(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE | __pa(pte)))
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(pte)))
 #define pgd_populate(mm, pgd, pmd) \
 		set_pgd(pgd, __pgd(_PAGE_TABLE | __pa(pmd)))
 
diff -NurpX dontdiff linux-2.4.37/include/asm-x86_64/pgtable.h linux-2.4.37-pax/include/asm-x86_64/pgtable.h
--- linux-2.4.37/include/asm-x86_64/pgtable.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/asm-x86_64/pgtable.h	2008-12-02 10:29:30.000000000 +0100
@@ -240,6 +240,8 @@ extern inline void pgd_clear (pgd_t * pg
 	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
 #define PAGE_EXECONLY PAGE_READONLY_EXEC
 
+#define PAGE_READONLY_NOEXEC	PAGE_READONLY
+
 #define PAGE_LARGE (_PAGE_PSE|_PAGE_PRESENT) 
 
 #define __PAGE_KERNEL \
diff -NurpX dontdiff linux-2.4.37/include/linux/a.out.h linux-2.4.37-pax/include/linux/a.out.h
--- linux-2.4.37/include/linux/a.out.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/a.out.h	2008-12-02 10:29:30.000000000 +0100
@@ -7,6 +7,16 @@
 
 #include <asm/a.out.h>
 
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __DELTA_STACK (current->mm->delta_stack)
+#else
+#define __DELTA_STACK 0UL
+#endif
+
+#ifndef STACK_TOP
+#define STACK_TOP	(__STACK_TOP - __DELTA_STACK)
+#endif
+
 #endif /* __STRUCT_EXEC_OVERRIDE__ */
 
 /* these go in the N_MACHTYPE field */
@@ -37,6 +47,14 @@ enum machine_type {
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC	1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP	2	/* Emulate trampolines */
+#define F_PAX_MPROTECT	4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP	8	/* Randomize mmap() base */
+/*#define F_PAX_RANDEXEC	16*/	/* Randomize ET_EXEC base */
+#define F_PAX_SEGMEXEC	32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -NurpX dontdiff linux-2.4.37/include/linux/binfmts.h linux-2.4.37-pax/include/linux/binfmts.h
--- linux-2.4.37/include/linux/binfmts.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/binfmts.h	2008-12-02 10:29:30.000000000 +0100
@@ -6,10 +6,10 @@
 
 /*
  * MAX_ARG_PAGES defines the number of pages allocated for arguments
- * and envelope for the new program. 32 should suffice, this gives
- * a maximum env+arg of 128kB w/4KB pages!
+ * and envelope for the new program. 33 should suffice, this gives
+ * a maximum env+arg of 132kB w/4KB pages!
  */
-#define MAX_ARG_PAGES 32
+#define MAX_ARG_PAGES 33
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
@@ -30,6 +30,7 @@ struct linux_binprm{
 	int argc, envc;
 	char * filename;	/* Name of binary */
 	unsigned long loader, exec;
+	int misc;
 };
 
 /*
@@ -59,6 +60,8 @@ extern void compute_creds(struct linux_b
 extern int do_coredump(long signr, struct pt_regs * regs);
 extern void set_binfmt(struct linux_binfmt *new);
 
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+void pax_report_insns(void *pc, void *sp);
 
 #if 0
 /* this went away now */
diff -NurpX dontdiff linux-2.4.37/include/linux/elf.h linux-2.4.37-pax/include/linux/elf.h
--- linux-2.4.37/include/linux/elf.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/elf.h	2008-12-02 10:29:30.000000000 +0100
@@ -34,6 +34,10 @@ typedef __s64	Elf64_Sxword;
 #define PT_MIPS_REGINFO		0x70000000
 #define PT_MIPS_OPTIONS		0x70000001
 
+#define PT_LOOS			0x60000000
+#define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+#define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+
 /* Flags in the e_flags field of the header */
 #define EF_MIPS_NOREORDER 0x00000001
 #define EF_MIPS_PIC       0x00000002
@@ -44,6 +48,14 @@ typedef __s64	Elf64_Sxword;
 #define EF_MIPS_ABI       0x0000f000
 #define EF_MIPS_ARCH      0xf0000000
 
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC			1	/* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP			2	/* Emulate trampolines */
+#define EF_PAX_MPROTECT			4	/* Restrict mprotect() */
+#define EF_PAX_RANDMMAP			8	/* Randomize mmap() base */
+/*#define EF_PAX_RANDEXEC			16*/	/* Randomize ET_EXEC base */
+#define EF_PAX_SEGMEXEC			32	/* Segmentation based non-executable pages */
+
 /* These constants define the different elf file types */
 #define ET_NONE   0
 #define ET_REL    1
@@ -122,6 +134,8 @@ typedef __s64	Elf64_Sxword;
 #define DT_DEBUG	21
 #define DT_TEXTREL	22
 #define DT_JMPREL	23
+#define DT_FLAGS	30
+  #define DF_TEXTREL	0x00000004
 #define DT_LOPROC	0x70000000
 #define DT_HIPROC	0x7fffffff
 #define DT_MIPS_RLD_VERSION	0x70000001
@@ -458,6 +472,19 @@ typedef struct elf64_hdr {
 #define PF_W		0x2
 #define PF_X		0x1
 
+#define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+/*#define PF_RANDEXEC	(1U << 10)*/	/* Enable  RANDEXEC */
+/*#define PF_NORANDEXEC	(1U << 11)*/	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+
 typedef struct elf32_phdr{
   Elf32_Word	p_type;
   Elf32_Off	p_offset;
@@ -555,6 +582,8 @@ typedef struct elf64_shdr {
 #define	EI_VERSION	6
 #define	EI_PAD		7
 
+#define	EI_PAX		14
+
 #define	ELFMAG0		0x7f		/* EI_MAG */
 #define	ELFMAG1		'E'
 #define	ELFMAG2		'L'
@@ -602,6 +631,7 @@ extern Elf32_Dyn _DYNAMIC [];
 #define elfhdr		elf32_hdr
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
+#define elf_dyn		Elf32_Dyn
 
 #else
 
@@ -609,6 +639,7 @@ extern Elf64_Dyn _DYNAMIC [];
 #define elfhdr		elf64_hdr
 #define elf_phdr	elf64_phdr
 #define elf_note	elf64_note
+#define elf_dyn		Elf64_Dyn
 
 #endif
 
diff -NurpX dontdiff linux-2.4.37/include/linux/highmem.h linux-2.4.37-pax/include/linux/highmem.h
--- linux-2.4.37/include/linux/highmem.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/highmem.h	2008-12-02 10:29:30.000000000 +0100
@@ -94,6 +94,13 @@ static inline void clear_highpage(struct
 	kunmap(page);
 }
 
+static inline void sanitize_highpage(struct page *page)
+{
+	void *addr = kmap_atomic(page, KM_CLEARPAGE);
+	clear_page(addr);
+	kunmap_atomic(addr, KM_CLEARPAGE);
+}
+
 /*
  * Same but also flushes aliased cache contents to RAM.
  */
diff -NurpX dontdiff linux-2.4.37/include/linux/kernel.h linux-2.4.37-pax/include/linux/kernel.h
--- linux-2.4.37/include/linux/kernel.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/kernel.h	2008-12-02 10:29:30.000000000 +0100
@@ -96,6 +96,9 @@ extern int session_of_pgrp(int pgrp);
 asmlinkage int printk(const char * fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
+asmlinkage void early_printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
 static inline void console_silent(void)
 {
 	console_loglevel = 0;
diff -NurpX dontdiff linux-2.4.37/include/linux/mm.h linux-2.4.37-pax/include/linux/mm.h
--- linux-2.4.37/include/linux/mm.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/mm.h	2008-12-02 10:29:30.000000000 +0100
@@ -25,6 +25,7 @@ extern struct list_head inactive_list;
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/atomic.h>
+#include <asm/mman.h>
 
 /*
  * Linux kernel virtual memory manager primitives.
@@ -72,6 +73,8 @@ struct vm_area_struct {
 	struct file * vm_file;		/* File we map to (can be NULL). */
 	unsigned long vm_raend;		/* XXX: put full readahead info here. */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
+
+	unsigned long vm_mirror;	/* PaX: mirror distance */
 };
 
 /*
@@ -104,9 +107,29 @@ struct vm_area_struct {
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define VM_MIRROR	0x00100000	/* vma is mirroring another */
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+#define VM_MAYNOTWRITE	0x00200000	/* vma cannot be granted VM_WRITE any more */
+#endif
+
+#if defined(__VM_STACK_FLAGS) && !defined(VM_STACK_FLAGS)
+#ifdef ARCH_STACK_GROWSUP
+#define VM_STACK_FLAGS (0x00000233 | __VM_STACK_FLAGS)
+#else
+#define VM_STACK_FLAGS (0x00000133 | __VM_STACK_FLAGS)
+#endif
+#endif
+
 #ifndef VM_STACK_FLAGS
+#ifdef ARCH_STACK_GROWSUP
+#define VM_STACK_FLAGS	0x00000277
+#else
 #define VM_STACK_FLAGS	0x00000177
 #endif
+#endif
 
 #define VM_READHINTMASK			(VM_SEQ_READ | VM_RAND_READ)
 #define VM_ClearReadHint(v)		(v)->vm_flags &= ~VM_READHINTMASK
@@ -496,6 +519,7 @@ extern int zeromap_page_range(unsigned l
 extern int vmtruncate(struct inode * inode, loff_t offset);
 extern pmd_t *FASTCALL(__pmd_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address));
 extern pte_t *FASTCALL(pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address));
+extern pte_t *FASTCALL(pte_alloc_kernel(struct mm_struct *mm, pmd_t *pmd, unsigned long address));
 extern int handle_mm_fault(struct mm_struct *mm,struct vm_area_struct *vma, unsigned long address, int write_access);
 extern int make_pages_present(unsigned long addr, unsigned long end);
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
@@ -587,6 +611,12 @@ static inline void __vma_unlink(struct m
 
 static inline int can_vma_merge(struct vm_area_struct * vma, unsigned long vm_flags)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_flags | vm_flags) & VM_MIRROR)
+		return 0;
+#endif
+
 	if (!vma->vm_file && vma->vm_flags == vm_flags)
 		return 1;
 	else
@@ -640,13 +670,23 @@ static inline unsigned int pf_gfp_mask(u
 
 	return gfp_mask;
 }
-	
+
+/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
+extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
+extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
+					     struct vm_area_struct **pprev);
+
 /* vma is the first one with  address < vma->vm_end,
  * and even  address < vma->vm_start. Have to extend vma. */
 static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)
 {
 	unsigned long grow;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+	unsigned long address_m = 0UL;
+#endif
+
 	/*
 	 * vma->vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
@@ -667,8 +707,34 @@ static inline int expand_stack(struct vm
 	}
 
 	grow = (vma->vm_start - address) >> PAGE_SHIFT;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(vma->vm_mm, address_m);
+		if (!vma_m || vma_m->vm_start != address_m || !(vma_m->vm_flags & VM_MIRROR) ||
+		    vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start) {
+			printk(KERN_ERR "PAX: VMMIRROR: expand bug, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			spin_unlock(&vma->vm_mm->page_table_lock);
+			return -ENOMEM;
+		}
+
+		address_m = address + vma->vm_mirror;
+		if (2*grow < grow || vma_m->vm_end - address_m > current->rlim[RLIMIT_STACK].rlim_cur ||
+		    ((vma_m->vm_mm->total_vm + 2*grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur ||
+		    ((vma_m->vm_flags & VM_LOCKED) &&
+		     ((vma_m->vm_mm->locked_vm + 2*grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur)) {
+			spin_unlock(&vma->vm_mm->page_table_lock);
+			return -ENOMEM;
+		}
+	} else
+#endif
+
 	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
-	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur) {
+	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur ||
+	    ((vma->vm_flags & VM_LOCKED) &&
+	     ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur)) {
 		spin_unlock(&vma->vm_mm->page_table_lock);
 		return -ENOMEM;
 	}
@@ -685,15 +751,21 @@ static inline int expand_stack(struct vm
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
 		vma->vm_mm->locked_vm += grow;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		vma_m->vm_start = address_m;
+		vma_m->vm_pgoff -= grow;
+		vma_m->vm_mm->total_vm += grow;
+		if (vma_m->vm_flags & VM_LOCKED)
+			vma_m->vm_mm->locked_vm += grow;
+	}
+#endif
+
 	spin_unlock(&vma->vm_mm->page_table_lock);
 	return 0;
 }
 
-/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
-extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
-extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
-					     struct vm_area_struct **pprev);
-
 /* Look up the first VMA which intersects the interval start_addr..end_addr-1,
    NULL if none.  Assume start_addr < end_addr. */
 static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
@@ -705,8 +777,6 @@ static inline struct vm_area_struct * fi
 	return vma;
 }
 
-extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr);
-
 extern struct page * vmalloc_to_page(void *addr);
 
 #endif /* __KERNEL__ */
diff -NurpX dontdiff linux-2.4.37/include/linux/sched.h linux-2.4.37-pax/include/linux/sched.h
--- linux-2.4.37/include/linux/sched.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/sched.h	2008-12-02 10:29:30.000000000 +0100
@@ -231,8 +231,34 @@ struct mm_struct {
 
 	/* Architecture-specific MM context */
 	mm_context_t context;
+
+#if defined(CONFIG_PAX_EI_PAX) || defined(CONFIG_PAX_PT_PAX_FLAGS) || defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	unsigned long pax_flags;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	unsigned long call_dl_resolve;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	unsigned long call_syscall;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	unsigned long delta_mmap;		/* randomized offset */
+	unsigned long delta_exec;		/* randomized offset */
+	unsigned long delta_stack;		/* randomized offset */
+#endif
+
 };
 
+#define MF_PAX_PAGEEXEC	0x01000000	/* Paging based non-executable pages */
+#define MF_PAX_EMUTRAMP	0x02000000	/* Emulate trampolines */
+#define MF_PAX_MPROTECT	0x04000000	/* Restrict mprotect() */
+#define MF_PAX_RANDMMAP	0x08000000	/* Randomize mmap() base */
+/*#define MF_PAX_RANDEXEC	0x10000000*/	/* Randomize ET_EXEC base */
+#define MF_PAX_SEGMEXEC	0x20000000	/* Segmentation based non-executable pages */
+
 extern int mmlist_nr;
 
 #define INIT_MM(name) \
@@ -438,6 +464,43 @@ struct task_struct {
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
+#ifdef CONFIG_PAX_SOFTMODE
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+extern unsigned int pax_aslr;
+#endif
+
+extern unsigned int pax_softmode;
+#endif
+
+extern int pax_check_flags(unsigned long *);
+
+/* if tsk != current then task_lock must be held on it */
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline unsigned long pax_get_flags(struct task_struct *tsk)
+{
+	if (likely(tsk->mm != NULL))
+		return tsk->mm->pax_flags;
+	else
+		return 0UL;
+}
+
+/* if tsk != current then task_lock must be held on it */
+static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+{
+	if (likely(tsk->mm != NULL)) {
+		tsk->mm->pax_flags = flags;
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+extern void pax_set_initial_flags(struct linux_binprm * bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+extern void (*pax_set_initial_flags_func)(struct linux_binprm * bprm);
+#endif
+
 /*
  * Ptrace flags
  */
diff -NurpX dontdiff linux-2.4.37/include/linux/sysctl.h linux-2.4.37-pax/include/linux/sysctl.h
--- linux-2.4.37/include/linux/sysctl.h	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/include/linux/sysctl.h	2008-12-02 10:29:30.000000000 +0100
@@ -130,8 +130,19 @@ enum
 	KERN_EXCEPTION_TRACE=58, /* boolean: exception trace */
  	KERN_CORE_SETUID=59,	/* int: set to allow core dumps of setuid apps */
 	KERN_SPARC_SCONS_PWROFF=64, /* int: serial console power-off halt */
+
+#ifdef CONFIG_PAX_SOFTMODE
+	KERN_PAX=69,		/* PaX control */
+#endif
+
 };
 
+#ifdef CONFIG_PAX_SOFTMODE
+enum {
+	PAX_ASLR=1,		/* PaX: disable/enable all randomization features */
+	PAX_SOFTMODE=2		/* PaX: disable/enable soft mode */
+};
+#endif
 
 /* CTL_VM names: */
 enum
diff -NurpX dontdiff linux-2.4.37/init/main.c linux-2.4.37-pax/init/main.c
--- linux-2.4.37/init/main.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/init/main.c	2008-12-02 10:29:30.000000000 +0100
@@ -142,6 +142,15 @@ static int __init profile_setup(char *st
 
 __setup("profile=", profile_setup);
 
+#ifdef CONFIG_PAX_SOFTMODE
+static int __init setup_pax_softmode(char *str)
+{
+	get_option(&str, &pax_softmode);
+	return 1;
+}
+__setup("pax_softmode=", setup_pax_softmode);
+#endif
+
 static int __init checksetup(char *line)
 {
 	struct kernel_param *p;
diff -NurpX dontdiff linux-2.4.37/kernel/sysctl.c linux-2.4.37-pax/kernel/sysctl.c
--- linux-2.4.37/kernel/sysctl.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/kernel/sysctl.c	2008-12-02 10:29:30.000000000 +0100
@@ -128,6 +128,25 @@ static ctl_table debug_table[];
 static ctl_table dev_table[];
 extern ctl_table random_table[];
 
+#ifdef CONFIG_PAX_SOFTMODE
+unsigned int pax_softmode;
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+unsigned int pax_aslr=1;
+#endif
+
+static ctl_table pax_table[] = {
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK) || defined(CONFIG_PAX_RANDKSTACK)
+	{PAX_ASLR, "aslr", &pax_aslr, sizeof(unsigned int), 0600, NULL, &proc_dointvec},
+#endif
+
+	{PAX_SOFTMODE, "softmode", &pax_softmode, sizeof(unsigned int), 0600, NULL, &proc_dointvec},
+
+	{0}
+};
+#endif
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_FS
@@ -278,6 +297,11 @@ static ctl_table kern_table[] = {
 	{KERN_EXCEPTION_TRACE,"exception-trace",
 	 &exception_trace,sizeof(int),0644,NULL,&proc_dointvec},
 #endif	
+
+#ifdef CONFIG_PAX_SOFTMODE
+	{KERN_PAX,"pax",NULL,0,0500,pax_table},
+#endif
+
 	{0}
 };
 
diff -NurpX dontdiff linux-2.4.37/mm/filemap.c linux-2.4.37-pax/mm/filemap.c
--- linux-2.4.37/mm/filemap.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/filemap.c	2008-12-02 10:29:30.000000000 +0100
@@ -2324,7 +2324,13 @@ int generic_file_mmap(struct file * file
 			return -EINVAL;
 	}
 	if (!mapping->a_ops->readpage)
-		return -ENOEXEC;
+		return -ENODEV;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_EXEC))
+		vma->vm_page_prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+
 	UPDATE_ATIME(inode);
 	vma->vm_ops = &generic_file_vm_ops;
 	return 0;
@@ -2554,8 +2560,42 @@ static long madvise_fixup_middle(struct 
  * We can potentially split a vm area into separate
  * areas, each area with its own behavior.
  */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+static long __madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior);
+
+static long madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+			error = __madvise_behavior(vma_m, start_m, end_m, behavior);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: madvise bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __madvise_behavior(vma, start, end, behavior);
+}
+
+static long __madvise_behavior(struct vm_area_struct * vma,
+	unsigned long start, unsigned long end, int behavior)
+#else
 static long madvise_behavior(struct vm_area_struct * vma,
 	unsigned long start, unsigned long end, int behavior)
+#endif
 {
 	int error = 0;
 
diff -NurpX dontdiff linux-2.4.37/mm/memory.c linux-2.4.37-pax/mm/memory.c
--- linux-2.4.37/mm/memory.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/memory.c	2008-12-02 10:29:30.000000000 +0100
@@ -468,9 +468,9 @@ int get_user_pages(struct task_struct *t
 	do {
 		struct vm_area_struct *	vma;
 
-		vma = find_extend_vma(mm, start);
+		vma = find_vma(mm, start);
 
-		if ( !vma || (pages && vma->vm_flags & VM_IO) || !(flags & vma->vm_flags) )
+		if ( !vma || start < vma->vm_start || (pages && vma->vm_flags & VM_IO) || !(flags & vma->vm_flags) )
 			return i ? : -EFAULT;
 
 		spin_lock(&mm->page_table_lock);
@@ -929,6 +929,63 @@ static inline void break_cow(struct vm_a
 	establish_pte(vma, address, page_table, pte_mkwrite(pte_mkdirty(mk_pte(new_page, vma->vm_page_prot))));
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+/* PaX: if vma is mirrored, synchronize the mirror's PTE
+ *
+ * mm->page_table_lock is held on entry and is not released on exit or inside
+ * to ensure atomic changes to the PTE states (swapout, mremap, munmap, etc)
+ */
+static void pax_mirror_fault(struct vm_area_struct *vma, unsigned long address, pte_t *pte)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m;
+	struct vm_area_struct * vma_m = NULL;
+	pte_t * pte_m, entry_m;
+	struct page * page_m;
+
+	address_m = vma->vm_start + vma->vm_mirror;
+	vma_m = find_vma(mm, address_m);
+	BUG_ON(!vma_m || vma_m->vm_start != address_m);
+
+	address_m = address + vma->vm_mirror;
+	pte_m = pte_offset(pmd_offset(pgd_offset(mm, address_m), address_m), address_m);
+
+	if (pte_same(*pte, *pte_m))
+		return;
+
+	if (pte_present(*pte_m)) {
+		flush_cache_page(vma_m, address_m);
+		flush_icache_page(vma_m, pte_page(*pte_m));
+	}
+	entry_m = ptep_get_and_clear(pte_m);
+	if (pte_present(entry_m))
+		flush_tlb_page(vma_m, address_m);
+
+	if (pte_none(entry_m)) {
+		++mm->rss;
+	} else if (pte_present(entry_m)) {
+		page_m = pte_page(entry_m);
+		if (VALID_PAGE(page_m) && !PageReserved(page_m))
+			page_cache_release(page_m);
+		else
+			++mm->rss;
+	} else {
+		free_swap_and_cache(pte_to_swp_entry(entry_m));
+		++mm->rss;
+	}
+
+	page_m = pte_page(*pte);
+	if (VALID_PAGE(page_m) && !PageReserved(page_m))
+		page_cache_get(page_m);
+	else
+		--mm->rss;
+	entry_m = mk_pte(page_m, vma_m->vm_page_prot);
+	if (pte_write(*pte) && (vma_m->vm_flags & VM_WRITE))
+		entry_m = pte_mkdirty(pte_mkwrite(entry_m));
+	establish_pte(vma_m, address_m, pte_m, entry_m);
+}
+#endif
+
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
@@ -993,6 +1050,12 @@ static int do_wp_page(struct mm_struct *
 
 		/* Free the old page.. */
 		new_page = old_page;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			pax_mirror_fault(vma, address, page_table);
+#endif
+
 	}
 	spin_unlock(&mm->page_table_lock);
 	page_cache_release(new_page);
@@ -1183,6 +1246,12 @@ static int do_swap_page(struct mm_struct
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, pte);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return ret;
 }
@@ -1229,6 +1298,12 @@ static int do_anonymous_page(struct mm_s
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, addr, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, addr, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 1;	/* Minor fault */
 
@@ -1311,6 +1386,12 @@ static int do_no_page(struct mm_struct *
 
 	/* no need to invalidate: a not-present page shouldn't be cached */
 	update_mmu_cache(vma, address, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, page_table);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 2;	/* Major fault */
 }
@@ -1362,6 +1443,12 @@ static inline int handle_pte_fault(struc
 	}
 	entry = pte_mkyoung(entry);
 	establish_pte(vma, address, pte, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR)
+		pax_mirror_fault(vma, address, pte);
+#endif
+
 	spin_unlock(&mm->page_table_lock);
 	return 1;
 }
@@ -1383,6 +1470,43 @@ int handle_mm_fault(struct mm_struct *mm
 	 * and the SMP-safe atomic PTE updates.
 	 */
 	spin_lock(&mm->page_table_lock);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		unsigned long address_m;
+		struct vm_area_struct * vma_m;
+		pgd_t *pgd_m;
+		pmd_t *pmd_m;
+
+		address_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(mm, address_m);
+
+		/* PaX: sanity checks */
+		if (!vma_m) {
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug, %08lx, %p, %08lx, %p\n",
+			       address, vma, address_m, vma_m);
+			return 0;
+		} else if (!(vma_m->vm_flags & VM_MIRROR) ||
+			   vma_m->vm_start != address_m ||
+			   vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start)
+		{
+			spin_unlock(&mm->page_table_lock);
+			printk(KERN_ERR "PAX: VMMIRROR: fault bug2, %08lx, %08lx, %08lx, %08lx, %08lx\n",
+			       address, vma->vm_start, vma_m->vm_start, vma->vm_end, vma_m->vm_end);
+			return 0;
+		}
+
+		address_m = address + vma->vm_mirror;
+		pgd_m = pgd_offset(mm, address_m);
+		pmd_m = pmd_alloc(mm, pgd_m, address_m);
+		if (!pmd_m || !pte_alloc(mm, pmd_m, address_m)) {
+			spin_unlock(&mm->page_table_lock);
+			return -1;
+		}
+	}
+#endif
+
 	pmd = pmd_alloc(mm, pgd, address);
 
 	if (pmd) {
@@ -1467,6 +1591,40 @@ out:
 	return pte_offset(pmd, address);
 }
 
+#ifndef pmd_populate_kernel
+#define pmd_populate_kernel(mm,pmd,new) pmd_populate(mm,pmd,new)
+#endif
+
+pte_t fastcall *pte_alloc_kernel(struct mm_struct *mm, pmd_t *pmd, unsigned long address)
+{
+	if (pmd_none(*pmd)) {
+		pte_t *new;
+
+		/* "fast" allocation can happen without dropping the lock.. */
+		new = pte_alloc_one_fast(mm, address);
+		if (!new) {
+			spin_unlock(&mm->page_table_lock);
+			new = pte_alloc_one(mm, address);
+			spin_lock(&mm->page_table_lock);
+			if (!new)
+				return NULL;
+
+			/*
+			 * Because we dropped the lock, we should re-check the
+			 * entry, as somebody else could have populated it..
+			 */
+			if (!pmd_none(*pmd)) {
+				pte_free(new);
+				check_pgt_cache();
+				goto out;
+			}
+		}
+		pmd_populate_kernel(mm, pmd, new);
+	}
+out:
+	return pte_offset(pmd, address);
+}
+
 int make_pages_present(unsigned long addr, unsigned long end)
 {
 	int ret, len, write;
diff -NurpX dontdiff linux-2.4.37/mm/mlock.c linux-2.4.37-pax/mm/mlock.c
--- linux-2.4.37/mm/mlock.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/mlock.c	2008-12-02 10:29:30.000000000 +0100
@@ -114,25 +114,44 @@ static inline int mlock_fixup_middle(str
 	return 0;
 }
 
+static int __mlock_fixup(struct vm_area_struct * vma, 
+	unsigned long start, unsigned long end, unsigned int newflags);
+
 static int mlock_fixup(struct vm_area_struct * vma, 
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
 	int pages, retval;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+	unsigned long start_m = 0UL, end_m = 0UL, newflags_m = 0UL;
+#endif
+
 	if (newflags == vma->vm_flags)
 		return 0;
 
-	if (start == vma->vm_start) {
-		if (end == vma->vm_end)
-			retval = mlock_fixup_all(vma, newflags);
-		else
-			retval = mlock_fixup_start(vma, end, newflags);
-	} else {
-		if (end == vma->vm_end)
-			retval = mlock_fixup_end(vma, start, newflags);
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_flags & VM_MIRROR) {
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma(vma->vm_mm, start_m);
+		if (!vma_m || vma_m->vm_start != start_m || !(vma_m->vm_flags & VM_MIRROR)) {
+			printk("PAX: VMMIRROR: mlock bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+
+		start_m = start + vma->vm_mirror;
+		end_m = end + vma->vm_mirror;
+		if (newflags & VM_LOCKED)
+			newflags_m = vma_m->vm_flags | VM_LOCKED;
 		else
-			retval = mlock_fixup_middle(vma, start, end, newflags);
+			newflags_m = vma_m->vm_flags & ~VM_LOCKED;
+		retval = __mlock_fixup(vma_m, start_m, end_m, newflags_m);
+		if (retval)
+			return retval;
 	}
+#endif
+
+	retval = __mlock_fixup(vma, start, end, newflags);
 	if (!retval) {
 		/* keep track of amount of locked VM */
 		pages = (end - start) >> PAGE_SHIFT;
@@ -141,6 +160,32 @@ static int mlock_fixup(struct vm_area_st
 			make_pages_present(start, end);
 		}
 		vma->vm_mm->locked_vm -= pages;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_flags & VM_MIRROR)
+			vma->vm_mm->locked_vm -= pages;
+#endif
+
+	}
+
+	return retval;
+}
+
+static int __mlock_fixup(struct vm_area_struct * vma, 
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	int retval;
+
+	if (start == vma->vm_start) {
+		if (end == vma->vm_end)
+			retval = mlock_fixup_all(vma, newflags);
+		else
+			retval = mlock_fixup_start(vma, end, newflags);
+	} else {
+		if (end == vma->vm_end)
+			retval = mlock_fixup_end(vma, start, newflags);
+		else
+			retval = mlock_fixup_middle(vma, start, end, newflags);
 	}
 	return retval;
 }
@@ -159,6 +204,17 @@ static int do_mlock(unsigned long start,
 		return -EINVAL;
 	if (end == start)
 		return 0;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	vma = find_vma(current->mm, start);
 	if (!vma || vma->vm_start > start)
 		return -ENOMEM;
@@ -253,6 +309,16 @@ static int do_mlockall(int flags)
 	for (vma = current->mm->mmap; vma ; vma = vma->vm_next) {
 		unsigned int newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+			if (vma->vm_end > SEGMEXEC_TASK_SIZE)
+				break;
+		} else
+#endif
+
+		if (vma->vm_end > TASK_SIZE)
+			break;
+
 		newflags = vma->vm_flags | VM_LOCKED;
 		if (!(flags & MCL_CURRENT))
 			newflags &= ~VM_LOCKED;
diff -NurpX dontdiff linux-2.4.37/mm/mmap.c linux-2.4.37-pax/mm/mmap.c
--- linux-2.4.37/mm/mmap.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/mmap.c	2008-12-02 10:29:30.000000000 +0100
@@ -208,6 +208,11 @@ static inline unsigned long calc_vm_flag
 		_trans(prot, PROT_WRITE, VM_WRITE) |
 		_trans(prot, PROT_EXEC, VM_EXEC);
 	flag_bits =
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		_trans(flags, MAP_MIRROR, VM_MIRROR) |
+#endif
+
 		_trans(flags, MAP_GROWSDOWN, VM_GROWSDOWN) |
 		_trans(flags, MAP_DENYWRITE, VM_DENYWRITE) |
 		_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE);
@@ -393,7 +398,47 @@ static int vma_merge(struct mm_struct * 
 	return 0;
 }
 
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flags, unsigned long pgoff);
+
 unsigned long do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flag, unsigned long pgoff)
+{
+	unsigned long ret = -EINVAL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || (addr > SEGMEXEC_TASK_SIZE-len)))
+		goto out;
+#endif
+
+	ret = __do_mmap_pgoff(file, addr, len, prot, flag, pgoff);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && ret < TASK_SIZE && ((flag & MAP_TYPE) == MAP_PRIVATE)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && (!(current->mm->pax_flags & MF_PAX_MPROTECT) || ((prot & PROT_EXEC) && file && !(prot & PROT_WRITE)))
+#endif
+
+	   )
+	{
+		unsigned long ret_m;
+		prot = prot & PROT_EXEC ? prot & ~PROT_WRITE : PROT_NONE;
+		ret_m = __do_mmap_pgoff(NULL, ret + SEGMEXEC_TASK_SIZE, 0UL, prot, flag | MAP_MIRROR | MAP_FIXED, ret);
+		if (ret_m >= TASK_SIZE) {
+			do_munmap(current->mm, ret, len);
+			ret = ret_m;
+		}
+	}
+
+out:
+#endif
+
+	return ret;
+}
+
+static unsigned long __do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long pgoff)
 {
 	struct mm_struct * mm = current->mm;
@@ -403,6 +448,28 @@ unsigned long do_mmap_pgoff(struct file 
 	int error;
 	rb_node_t ** rb_link, * rb_parent;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct * vma_m = NULL;
+
+	if (flags & MAP_MIRROR) {
+		/* PaX: sanity checks, to be removed when proved to be stable */
+		if (file || len || ((flags & MAP_TYPE) != MAP_PRIVATE))
+			return -EINVAL;
+
+		vma_m = find_vma(mm, pgoff);
+
+		if (!vma_m ||
+		    vma_m->vm_start != pgoff ||
+		    (vma_m->vm_flags & VM_MIRROR) ||
+		    (prot & PROT_WRITE))
+			return -EINVAL;
+
+		file = vma_m->vm_file;
+		pgoff = vma_m->vm_pgoff;
+		len = vma_m->vm_end - vma_m->vm_start;
+	}
+#endif
+
 	if (file) {
 		if (!file->f_op || !file->f_op->mmap)
 			return -ENODEV;
@@ -440,6 +507,24 @@ unsigned long do_mmap_pgoff(struct file 
 	 */
 	vm_flags = calc_vm_flags(prot,flags) | mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+	if (file && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+		vm_flags &= ~VM_MAYEXEC;
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT) {
+			if ((prot & (PROT_WRITE | PROT_EXEC)) != PROT_EXEC)
+				vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+			else
+				vm_flags &= ~(VM_WRITE | VM_MAYWRITE);
+		}
+#endif
+
+	}
+#endif
+
 	/* mlock MCL_FUTURE? */
 	if (vm_flags & VM_LOCKED) {
 		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
@@ -525,11 +610,19 @@ munmap_back:
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = vm_flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if ((file || !(mm->pax_flags & MF_PAX_PAGEEXEC)) && (vm_flags & (VM_READ|VM_WRITE)))
+		vma->vm_page_prot = protection_map[(vm_flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[vm_flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = pgoff;
 	vma->vm_file = NULL;
 	vma->vm_private_data = NULL;
+	vma->vm_mirror = 0;
 	vma->vm_raend = 0;
 
 	if (file) {
@@ -553,6 +646,14 @@ munmap_back:
 			goto free_vma;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (flags & MAP_MIRROR) {
+		vma_m->vm_flags |= VM_MIRROR;
+		vma_m->vm_mirror = vma->vm_start - vma_m->vm_start;
+		vma->vm_mirror = vma_m->vm_start - vma->vm_start;
+	}
+#endif
+
 	/* Can addr have changed??
 	 *
 	 * Answer: Yes, several device drivers can do it in their
@@ -623,22 +724,38 @@ free_vma:
 static inline unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct vm_area_struct *vma;
+	unsigned long task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
-	if (len > TASK_SIZE)
+	if (len > task_size)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current->mm, addr);
-		if (TASK_SIZE - len >= addr &&
+		if (task_size - len >= addr &&
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
 	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE);
 
+#ifdef CONFIG_PAX_RANDMMAP
+	/* PaX: randomize base address if requested */
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		addr += current->mm->delta_mmap;
+#endif
+
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr)
+		if (task_size - len < addr)
 			return -ENOMEM;
 		if (!vma || addr + len <= vma->vm_start)
 			return addr;
@@ -759,28 +876,6 @@ struct vm_area_struct * find_vma_prev(st
 	return NULL;
 }
 
-struct vm_area_struct * find_extend_vma(struct mm_struct * mm, unsigned long addr)
-{
-	struct vm_area_struct * vma;
-	unsigned long start;
-
-	addr &= PAGE_MASK;
-	vma = find_vma(mm,addr);
-	if (!vma)
-		return NULL;
-	if (vma->vm_start <= addr)
-		return vma;
-	if (!(vma->vm_flags & VM_GROWSDOWN))
-		return NULL;
-	start = vma->vm_start;
-	if (expand_stack(vma, addr))
-		return NULL;
-	if (vma->vm_flags & VM_LOCKED) {
-		make_pages_present(addr, start);
-	}
-	return vma;
-}
-
 /* Normal function to fix up a mapping
  * This function is the default for when an area has no specific
  * function.  This may be used as part of a more specific routine.
@@ -856,6 +951,7 @@ static struct vm_area_struct * unmap_fix
 		mpnt->vm_pgoff = area->vm_pgoff + ((end - area->vm_start) >> PAGE_SHIFT);
 		mpnt->vm_file = area->vm_file;
 		mpnt->vm_private_data = area->vm_private_data;
+		mpnt->vm_mirror = area->vm_mirror;
 		if (mpnt->vm_file)
 			get_file(mpnt->vm_file);
 		if (mpnt->vm_ops && mpnt->vm_ops->open)
@@ -941,7 +1037,24 @@ no_mmaps:
  * work.  This now handles partial unmappings.
  * Jeremy Fitzhardine <jeremy@sw.oz.au>
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __do_munmap(struct mm_struct *mm, unsigned long addr, size_t len);
+
+int do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+{
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		int ret = __do_munmap(mm, addr + SEGMEXEC_TASK_SIZE, len);
+		if (ret)
+			return ret;
+	}
+
+	return __do_munmap(mm, addr, len);
+}
+
+static int __do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+#else
 int do_munmap(struct mm_struct *mm, unsigned long addr, size_t len)
+#endif
 {
 	struct vm_area_struct *mpnt, *prev, **npp, *free, *extra;
 
@@ -1039,6 +1152,12 @@ asmlinkage long sys_munmap(unsigned long
 	int ret;
 	struct mm_struct *mm = current->mm;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-len))
+		return -EINVAL;
+#endif
+
 	down_write(&mm->mmap_sem);
 	ret = do_munmap(mm, addr, len);
 	up_write(&mm->mmap_sem);
@@ -1059,18 +1178,47 @@ static inline void verify_mmap_write_loc
  *  anonymous maps.  eventually we may be able to do some
  *  brk-specific accounting here.
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+static unsigned long __do_brk(unsigned long addr, unsigned long len);
+
+unsigned long do_brk(unsigned long addr, unsigned long len)
+{
+	unsigned long ret;
+
+	ret = __do_brk(addr, len);
+	if (ret == addr && (current->mm->pax_flags & (MF_PAX_SEGMEXEC | MF_PAX_MPROTECT)) == MF_PAX_SEGMEXEC) {
+		unsigned long ret_m;
+
+		ret_m = __do_mmap_pgoff(NULL, addr + SEGMEXEC_TASK_SIZE, 0UL, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_MIRROR, addr);
+		if (ret_m > TASK_SIZE) {
+			do_munmap(current->mm, addr, len);
+			ret = ret_m;
+		}
+	}
+
+	return ret;
+}
+
+static unsigned long __do_brk(unsigned long addr, unsigned long len)
+#else
 unsigned long do_brk(unsigned long addr, unsigned long len)
+#endif
 {
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
-	unsigned long flags;
+	unsigned long flags, task_size = TASK_SIZE;
 	rb_node_t ** rb_link, * rb_parent;
 
 	len = PAGE_ALIGN(len);
 	if (!len)
 		return addr;
 
-	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if ((addr + len) > task_size || (addr + len) < addr)
 		return -EINVAL;
 
 	if (addr < mmap_min_addr && !capable(CAP_SYS_RAWIO))
@@ -1116,6 +1264,18 @@ unsigned long do_brk(unsigned long addr,
 
 	flags = VM_DATA_DEFAULT_FLAGS | mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	/* Can we just expand an old anonymous mapping? */
 	if (rb_parent && vma_merge(mm, prev, rb_parent, addr, addr + len, flags))
 		goto out;
@@ -1131,11 +1291,19 @@ unsigned long do_brk(unsigned long addr,
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 	vma->vm_flags = flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC))
+		vma->vm_page_prot = protection_map[(flags | VM_EXEC) & 0x0f];
+	else
+#endif
+
 	vma->vm_page_prot = protection_map[flags & 0x0f];
 	vma->vm_ops = NULL;
 	vma->vm_pgoff = 0;
 	vma->vm_file = NULL;
 	vma->vm_private_data = NULL;
+	vma->vm_mirror = 0;
 
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 
diff -NurpX dontdiff linux-2.4.37/mm/mprotect.c linux-2.4.37-pax/mm/mprotect.c
--- linux-2.4.37/mm/mprotect.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/mprotect.c	2008-12-02 10:29:30.000000000 +0100
@@ -8,6 +8,11 @@
 #include <linux/shm.h>
 #include <linux/mman.h>
 
+#ifdef CONFIG_PAX_MPROTECT
+#include <linux/elf.h>
+#include <linux/fs.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
@@ -236,6 +241,45 @@ static inline int mprotect_fixup_middle(
 	return 0;
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+static int __mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags);
+
+static int mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	if (vma->vm_flags & VM_MIRROR) {
+		struct vm_area_struct * vma_m, * prev_m;
+		unsigned long start_m, end_m;
+		int error;
+
+		start_m = vma->vm_start + vma->vm_mirror;
+		vma_m = find_vma_prev(vma->vm_mm, start_m, &prev_m);
+		if (vma_m && vma_m->vm_start == start_m && (vma_m->vm_flags & VM_MIRROR)) {
+			start_m = start + vma->vm_mirror;
+			end_m = end + vma->vm_mirror;
+
+			if (vma_m->vm_start >= SEGMEXEC_TASK_SIZE && !(newflags & VM_EXEC))
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, vma_m->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
+			else
+				error = __mprotect_fixup(vma_m, &prev_m, start_m, end_m, newflags);
+			if (error)
+				return error;
+		} else {
+			printk("PAX: VMMIRROR: mprotect bug in %s, %08lx\n", current->comm, vma->vm_start);
+			return -ENOMEM;
+		}
+	}
+
+	return __mprotect_fixup(vma, pprev, start, end, newflags);
+}
+
+static int __mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
+	unsigned long start, unsigned long end, unsigned int newflags)
+{
+	pgprot_t newprot;
+	int error;
+#else
 static int mprotect_fixup(struct vm_area_struct * vma, struct vm_area_struct ** pprev,
 	unsigned long start, unsigned long end, unsigned int newflags)
 {
@@ -246,6 +290,14 @@ static int mprotect_fixup(struct vm_area
 		*pprev = vma;
 		return 0;
 	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(__i386__)
+	if (!(vma->vm_mm->pax_flags & MF_PAX_PAGEEXEC) && (newflags & (VM_READ|VM_WRITE)))
+		newprot = protection_map[(newflags | VM_EXEC) & 0xf];
+	else
+#endif
+
 	newprot = protection_map[newflags & 0xf];
 	if (start == vma->vm_start) {
 		if (end == vma->vm_end)
@@ -264,6 +316,68 @@ static int mprotect_fixup(struct vm_area
 	return 0;
 }
 
+#ifdef CONFIG_PAX_MPROTECT
+/* PaX: non-PIC ELF libraries need relocations on their executable segments
+ * therefore we'll grant them VM_MAYWRITE once during their life.
+ *
+ * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+ * basis because we want to allow the common case and not the special ones.
+ */
+static inline void pax_handle_maywrite(struct vm_area_struct * vma, unsigned long start)
+{
+	struct elfhdr elf_h;
+	struct elf_phdr elf_p, p_dyn;
+	elf_dyn dyn;
+	unsigned long i, j = 65536UL / sizeof(struct elf_phdr);
+
+#ifndef CONFIG_PAX_NOELFRELOCS
+	if ((vma->vm_start != start) ||
+	    !vma->vm_file ||
+	    !(vma->vm_flags & VM_MAYEXEC) ||
+	    (vma->vm_flags & VM_MAYNOTWRITE))
+#endif
+
+		return;
+
+	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char*)&elf_h, sizeof(elf_h)) ||
+	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+
+#ifdef CONFIG_PAX_ETEXECRELOCS
+	    (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC) ||
+#else
+	    elf_h.e_type != ET_DYN ||
+#endif
+
+	    !elf_check_arch(&elf_h) ||
+	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+	    elf_h.e_phnum > j)
+		return;
+
+	for (i = 0UL; i < elf_h.e_phnum; i++) {
+		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char*)&elf_p, sizeof(elf_p)))
+			return;
+		if (elf_p.p_type == PT_DYNAMIC) {
+			p_dyn = elf_p;
+			j = i;
+		}
+	}
+	if (elf_h.e_phnum <= j)
+		return;
+
+	i = 0UL;
+	do {
+		if (sizeof(dyn) != kernel_read(vma->vm_file, p_dyn.p_offset + i*sizeof(dyn), (char*)&dyn, sizeof(dyn)))
+			return;
+		if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+			vma->vm_flags |= VM_MAYWRITE | VM_MAYNOTWRITE;
+			return;
+		}
+		i++;
+	} while (dyn.d_tag != DT_NULL);
+	return;
+}
+#endif
+
 asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 {
 	unsigned long nstart, end, tmp;
@@ -276,6 +390,17 @@ asmlinkage long sys_mprotect(unsigned lo
 	end = start + len;
 	if (end < start)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
 		return -EINVAL;
 	if (end == start)
@@ -288,6 +413,11 @@ asmlinkage long sys_mprotect(unsigned lo
 	if (!vma || vma->vm_start > start)
 		goto out;
 
+#ifdef CONFIG_PAX_MPROTECT
+	if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && (prot & PROT_WRITE))
+		pax_handle_maywrite(vma, start);
+#endif
+
 	for (nstart = start ; ; ) {
 		unsigned int newflags;
 		int last = 0;
@@ -300,6 +430,12 @@ asmlinkage long sys_mprotect(unsigned lo
 			goto out;
 		}
 
+#ifdef CONFIG_PAX_MPROTECT
+		/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+		if ((vma->vm_mm->pax_flags & MF_PAX_MPROTECT) && !(prot & PROT_WRITE) && (vma->vm_flags & VM_MAYNOTWRITE))
+			newflags &= ~VM_MAYWRITE;
+#endif
+
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
diff -NurpX dontdiff linux-2.4.37/mm/mremap.c linux-2.4.37-pax/mm/mremap.c
--- linux-2.4.37/mm/mremap.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/mremap.c	2008-12-02 10:29:30.000000000 +0100
@@ -226,7 +226,7 @@ unsigned long do_mremap(unsigned long ad
 	unsigned long flags, unsigned long new_addr)
 {
 	struct vm_area_struct *vma;
-	unsigned long ret = -EINVAL;
+	unsigned long ret = -EINVAL, task_size = TASK_SIZE;
 
 	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 		goto out;
@@ -237,10 +237,15 @@ unsigned long do_mremap(unsigned long ad
 	old_len = PAGE_ALIGN(old_len);
 	new_len = PAGE_ALIGN(new_len);
 
-	if (old_len > TASK_SIZE || addr > TASK_SIZE - old_len)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (old_len > task_size || addr > task_size - old_len)
 		goto out;
 
-	if (addr >= TASK_SIZE)
+	if (addr >= task_size)
 		goto out;
 
 	/* new_addr is only valid if MREMAP_FIXED is specified */
@@ -250,10 +255,10 @@ unsigned long do_mremap(unsigned long ad
 		if (!(flags & MREMAP_MAYMOVE))
 			goto out;
 
-		if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
+		if (new_len > task_size || new_addr > task_size - new_len)
 			goto out;
 
-		if (new_addr >= TASK_SIZE)
+		if (new_addr >= task_size)
 			goto out;
 
 		/*
@@ -304,6 +309,14 @@ unsigned long do_mremap(unsigned long ad
 	vma = find_vma(current->mm, addr);
 	if (!vma || vma->vm_start > addr)
 		goto out;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_flags & VM_MIRROR)) {
+		ret = -EINVAL;
+		goto out;
+	}
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto out;
@@ -334,7 +347,7 @@ unsigned long do_mremap(unsigned long ad
 	if (old_len == vma->vm_end - addr &&
 	    !((flags & MREMAP_FIXED) && (addr != new_addr)) &&
 	    (old_len != new_len || !(flags & MREMAP_MAYMOVE))) {
-		unsigned long max_addr = TASK_SIZE;
+		unsigned long max_addr = task_size;
 		if (vma->vm_next)
 			max_addr = vma->vm_next->vm_start;
 		/* can we just expand the current mapping? */
diff -NurpX dontdiff linux-2.4.37/mm/page_alloc.c linux-2.4.37-pax/mm/page_alloc.c
--- linux-2.4.37/mm/page_alloc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/page_alloc.c	2008-12-02 10:29:30.000000000 +0100
@@ -162,12 +162,16 @@ static void fastcall __free_pages_ok (st
 	page_idx = page - base;
 	if (page_idx & ~mask)
 		BUG();
-	index = page_idx >> (1 + order);
-
-	area = zone->free_area + order;
 
 	spin_lock_irqsave(&zone->lock, flags);
 
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	for (index = 1U << order; index; --index)
+		sanitize_highpage(page + index - 1);
+#endif
+
+	index = page_idx >> (1 + order);
+	area = zone->free_area + order;
 	zone->free_pages -= mask;
 
 	while (mask + (1 << (MAX_ORDER-1))) {
diff -NurpX dontdiff linux-2.4.37/mm/vmalloc.c linux-2.4.37-pax/mm/vmalloc.c
--- linux-2.4.37/mm/vmalloc.c	2008-12-02 09:01:34.000000000 +0100
+++ linux-2.4.37-pax/mm/vmalloc.c	2008-12-02 10:29:30.000000000 +0100
@@ -140,7 +140,7 @@ static inline int alloc_area_pmd(pmd_t *
 	if (end > PGDIR_SIZE)
 		end = PGDIR_SIZE;
 	do {
-		pte_t * pte = pte_alloc(&init_mm, pmd, address);
+		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
 		if (!pte)
 			return -ENOMEM;
 		if (alloc_area_pte(pte, address, end - address,
