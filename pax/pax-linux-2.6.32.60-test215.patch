- fixed gcc plugin support for gcc 4.8

diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/include/asm/atomic.h linux-2.6.32.60-pax/arch/alpha/include/asm/atomic.h
--- linux-2.6.32.60/arch/alpha/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/include/asm/atomic.h	2012-03-13 13:15:34.268098438 +0100
@@ -251,6 +251,16 @@ static __inline__ int atomic64_add_unles
 #define atomic_dec(v) atomic_sub(1,(v))
 #define atomic64_dec(v) atomic64_sub(1,(v))
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 #define smp_mb__before_atomic_dec()	smp_mb()
 #define smp_mb__after_atomic_dec()	smp_mb()
 #define smp_mb__before_atomic_inc()	smp_mb()
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/include/asm/elf.h linux-2.6.32.60-pax/arch/alpha/include/asm/elf.h
--- linux-2.6.32.60/arch/alpha/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/include/asm/elf.h	2012-03-13 13:15:34.268098438 +0100
@@ -91,6 +91,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x1000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality & ADDR_LIMIT_32BIT ? 0x10000 : 0x120000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 28)
+#define PAX_DELTA_STACK_LEN	(current->personality & ADDR_LIMIT_32BIT ? 14 : 19)
+#endif
+
 /* $0 is set by ld.so to a pointer to a function which might be 
    registered using atexit.  This provides a mean for the dynamic
    linker to call DT_FINI functions for shared libraries that have
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/include/asm/pgalloc.h linux-2.6.32.60-pax/arch/alpha/include/asm/pgalloc.h
--- linux-2.6.32.60/arch/alpha/include/asm/pgalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/include/asm/pgalloc.h	2012-05-07 17:49:11.980114624 +0200
@@ -29,6 +29,12 @@ pgd_populate(struct mm_struct *mm, pgd_t
 	pgd_set(pgd, pmd);
 }
 
+static inline void
+pgd_populate_kernel(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmd)
+{
+	pgd_populate(mm, pgd, pmd);
+}
+
 extern pgd_t *pgd_alloc(struct mm_struct *mm);
 
 static inline void
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/include/asm/pgtable.h linux-2.6.32.60-pax/arch/alpha/include/asm/pgtable.h
--- linux-2.6.32.60/arch/alpha/include/asm/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/include/asm/pgtable.h	2012-03-13 13:15:34.268098438 +0100
@@ -101,6 +101,17 @@ struct vm_area_struct;
 #define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)
 #define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
 #define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOE)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW | _PAGE_FOE)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)
 
 #define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/kernel/module.c linux-2.6.32.60-pax/arch/alpha/kernel/module.c
--- linux-2.6.32.60/arch/alpha/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/kernel/module.c	2012-03-13 13:15:34.268098438 +0100
@@ -182,7 +182,7 @@ apply_relocate_add(Elf64_Shdr *sechdrs,
 
 	/* The small sections were sorted to the end of the segment.
 	   The following should definitely cover them.  */
-	gp = (u64)me->module_core + me->core_size - 0x8000;
+	gp = (u64)me->module_core_rw + me->core_size_rw - 0x8000;
 	got = sechdrs[me->arch.gotsecindex].sh_addr;
 
 	for (i = 0; i < n; i++) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/kernel/osf_sys.c linux-2.6.32.60-pax/arch/alpha/kernel/osf_sys.c
--- linux-2.6.32.60/arch/alpha/kernel/osf_sys.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/kernel/osf_sys.c	2012-03-13 13:15:34.272098333 +0100
@@ -1172,7 +1172,7 @@ arch_get_unmapped_area_1(unsigned long a
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (limit - len < addr)
 			return -ENOMEM;
-		if (!vma || addr + len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			return addr;
 		addr = vma->vm_end;
 		vma = vma->vm_next;
@@ -1208,6 +1208,10 @@ arch_get_unmapped_area(struct file *filp
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != (unsigned long) -ENOMEM)
@@ -1215,8 +1219,8 @@ arch_get_unmapped_area(struct file *filp
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(current->mm->mmap_base), len, limit);
+
 	if (addr != (unsigned long) -ENOMEM)
 		return addr;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/alpha/mm/fault.c linux-2.6.32.60-pax/arch/alpha/mm/fault.c
--- linux-2.6.32.60/arch/alpha/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/alpha/mm/fault.c	2012-03-13 13:15:34.272098333 +0100
@@ -54,6 +54,124 @@ __load_new_mm_context(struct mm_struct *
 	__reload_thread(pcb);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long *)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -131,8 +249,29 @@ do_page_fault(unsigned long address, uns
  good_area:
 	si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)regs->pc, (void *)rdusp());
+			do_group_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/atomic.h linux-2.6.32.60-pax/arch/arm/include/asm/atomic.h
--- linux-2.6.32.60/arch/arm/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/atomic.h	2012-08-12 13:31:48.089243355 +0200
@@ -15,6 +15,10 @@
 #include <linux/types.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_GENERIC_ATOMIC64
+#include <asm-generic/atomic64.h>
+#endif
+
 #define ATOMIC_INIT(i)	{ (i) }
 
 #ifdef __KERNEL__
@@ -24,8 +28,16 @@
  * strex/ldrex monitor on some implementations. The reason we can use it for
  * atomic_set() is the clrex or dummy strex done on every exception return.
  */
-#define atomic_read(v)	((v)->counter)
+#define atomic_read(v)	(*(volatile int *)&(v)->counter)
+static inline int atomic_read_unchecked(const atomic_unchecked_t *v)
+{
+	return v->counter;
+}
 #define atomic_set(v,i)	(((v)->counter) = (i))
+static inline void atomic_set_unchecked(atomic_unchecked_t *v, int i)
+{
+	v->counter = i;
+}
 
 #if __LINUX_ARM_ARCH__ >= 6
 
@@ -40,6 +52,35 @@ static inline void atomic_add(int i, ato
 	int result;
 
 	__asm__ __volatile__("@ atomic_add\n"
+"1:	ldrex	%1, [%2]\n"
+"	add	%0, %1, %3\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	bvc	3f\n"
+"2:	bkpt	0xf103\n"
+"3:\n"
+#endif
+
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"\n4:\n"
+	_ASM_EXTABLE(2b, 4b)
+#endif
+
+	: "=&r" (result), "=&r" (tmp)
+	: "r" (&v->counter), "Ir" (i)
+	: "cc");
+}
+
+static inline void atomic_add_unchecked(int i, atomic_unchecked_t *v)
+{
+	unsigned long tmp;
+	int result;
+
+	__asm__ __volatile__("@ atomic_add_unchecked\n"
 "1:	ldrex	%0, [%2]\n"
 "	add	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
@@ -58,6 +99,42 @@ static inline int atomic_add_return(int
 	smp_mb();
 
 	__asm__ __volatile__("@ atomic_add_return\n"
+"1:	ldrex	%1, [%2]\n"
+"	add	%0, %1, %3\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	bvc	3f\n"
+"	mov	%0, %1\n"
+"2:	bkpt	0xf103\n"
+"3:\n"
+#endif
+
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"\n4:\n"
+	_ASM_EXTABLE(2b, 4b)
+#endif
+
+	: "=&r" (result), "=&r" (tmp)
+	: "r" (&v->counter), "Ir" (i)
+	: "cc");
+
+	smp_mb();
+
+	return result;
+}
+
+static inline int atomic_add_return_unchecked(int i, atomic_unchecked_t *v)
+{
+	unsigned long tmp;
+	int result;
+
+	smp_mb();
+
+	__asm__ __volatile__("@ atomic_add_return_unchecked\n"
 "1:	ldrex	%0, [%2]\n"
 "	add	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
@@ -78,6 +155,35 @@ static inline void atomic_sub(int i, ato
 	int result;
 
 	__asm__ __volatile__("@ atomic_sub\n"
+"1:	ldrex	%1, [%2]\n"
+"	sub	%0, %1, %3\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	bvc	3f\n"
+"2:	bkpt	0xf103\n"
+"3:\n"
+#endif
+
+"	strex	%1, %0, [%2]\n"
+"	teq	%1, #0\n"
+"	bne	1b"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"\n4:\n"
+	_ASM_EXTABLE(2b, 4b)
+#endif
+
+	: "=&r" (result), "=&r" (tmp)
+	: "r" (&v->counter), "Ir" (i)
+	: "cc");
+}
+
+static inline void atomic_sub_unchecked(int i, atomic_unchecked_t *v)
+{
+	unsigned long tmp;
+	int result;
+
+	__asm__ __volatile__("@ atomic_sub_unchecked\n"
 "1:	ldrex	%0, [%2]\n"
 "	sub	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
@@ -96,11 +202,25 @@ static inline int atomic_sub_return(int
 	smp_mb();
 
 	__asm__ __volatile__("@ atomic_sub_return\n"
-"1:	ldrex	%0, [%2]\n"
-"	sub	%0, %0, %3\n"
+"1:	ldrex	%1, [%2]\n"
+"	subs	%0, %1, %3\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	bvc	3f\n"
+"	mov	%0, %1\n"
+"2:	bkpt	0xf103\n"
+"3:\n"
+#endif
+
 "	strex	%1, %0, [%2]\n"
 "	teq	%1, #0\n"
 "	bne	1b"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"\n4:\n"
+	_ASM_EXTABLE(2b, 4b)
+#endif
+
 	: "=&r" (result), "=&r" (tmp)
 	: "r" (&v->counter), "Ir" (i)
 	: "cc");
@@ -132,6 +252,28 @@ static inline int atomic_cmpxchg(atomic_
 	return oldval;
 }
 
+static inline int atomic_cmpxchg_unchecked(atomic_unchecked_t *ptr, int old, int new)
+{
+	unsigned long oldval, res;
+
+	smp_mb();
+
+	do {
+		__asm__ __volatile__("@ atomic_cmpxchg_unchecked\n"
+		"ldrex	%1, [%2]\n"
+		"mov	%0, #0\n"
+		"teq	%1, %3\n"
+		"strexeq %0, %4, [%2]\n"
+		    : "=&r" (res), "=&r" (oldval)
+		    : "r" (&ptr->counter), "Ir" (old), "r" (new)
+		    : "cc");
+	} while (res);
+
+	smp_mb();
+
+	return oldval;
+}
+
 static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
 {
 	unsigned long tmp, tmp2;
@@ -165,7 +307,17 @@ static inline int atomic_add_return(int
 
 	return val;
 }
+
+static inline int atomic_add_return_unchecked(int i, atomic_unchecked_t *v)
+{
+	return atomic_add_return(i, v);
+}
+
 #define atomic_add(i, v)	(void) atomic_add_return(i, v)
+static inline void atomic_add_unchecked(int i, atomic_unchecked_t *v)
+{
+	(void) atomic_add_return(i, v);
+}
 
 static inline int atomic_sub_return(int i, atomic_t *v)
 {
@@ -180,6 +332,10 @@ static inline int atomic_sub_return(int
 	return val;
 }
 #define atomic_sub(i, v)	(void) atomic_sub_return(i, v)
+static inline void atomic_sub_unchecked(int i, atomic_unchecked_t *v)
+{
+	(void) atomic_sub_return(i, v);
+}
 
 static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
 {
@@ -195,6 +351,11 @@ static inline int atomic_cmpxchg(atomic_
 	return ret;
 }
 
+static inline int atomic_cmpxchg_unchecked(atomic_unchecked_t *v, int old, int new)
+{
+	return atomic_cmpxchg(v, old, new);
+}
+
 static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
 {
 	unsigned long flags;
@@ -207,6 +368,10 @@ static inline void atomic_clear_mask(uns
 #endif /* __LINUX_ARM_ARCH__ */
 
 #define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+static inline int atomic_xchg_unchecked(atomic_unchecked_t *v, int new)
+{
+	return xchg(&v->counter, new);
+}
 
 static inline int atomic_add_unless(atomic_t *v, int a, int u)
 {
@@ -220,11 +385,27 @@ static inline int atomic_add_unless(atom
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
 #define atomic_inc(v)		atomic_add(1, v)
+static inline void atomic_inc_unchecked(atomic_unchecked_t *v)
+{
+	atomic_add_unchecked(1, v);
+}
 #define atomic_dec(v)		atomic_sub(1, v)
+static inline void atomic_dec_unchecked(atomic_unchecked_t *v)
+{
+	atomic_sub_unchecked(1, v);
+}
 
 #define atomic_inc_and_test(v)	(atomic_add_return(1, v) == 0)
+static inline int atomic_inc_and_test_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_add_return_unchecked(1, v) == 0;
+}
 #define atomic_dec_and_test(v)	(atomic_sub_return(1, v) == 0)
 #define atomic_inc_return(v)    (atomic_add_return(1, v))
+static inline int atomic_inc_return_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_add_return_unchecked(1, v);
+}
 #define atomic_dec_return(v)    (atomic_sub_return(1, v))
 #define atomic_sub_and_test(i, v) (atomic_sub_return(i, v) == 0)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/cacheflush.h linux-2.6.32.60-pax/arch/arm/include/asm/cacheflush.h
--- linux-2.6.32.60/arch/arm/include/asm/cacheflush.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/cacheflush.h	2012-03-13 13:15:34.272098333 +0100
@@ -216,13 +216,13 @@ struct cpu_cache_fns {
 	void (*dma_inv_range)(const void *, const void *);
 	void (*dma_clean_range)(const void *, const void *);
 	void (*dma_flush_range)(const void *, const void *);
-};
+} __no_const;
 
 struct outer_cache_fns {
 	void (*inv_range)(unsigned long, unsigned long);
 	void (*clean_range)(unsigned long, unsigned long);
 	void (*flush_range)(unsigned long, unsigned long);
-};
+} __no_const;
 
 /*
  * Select the calling method
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/cache.h linux-2.6.32.60-pax/arch/arm/include/asm/cache.h
--- linux-2.6.32.60/arch/arm/include/asm/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/cache.h	2012-03-13 13:15:34.276098186 +0100
@@ -5,7 +5,7 @@
 #define __ASMARM_CACHE_H
 
 #define L1_CACHE_SHIFT		CONFIG_ARM_L1_CACHE_SHIFT
-#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+#define L1_CACHE_BYTES		(_AC(1,UL) << L1_CACHE_SHIFT)
 
 /*
  * Memory returned by kmalloc() may be used for DMA, so we must make
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/elf.h linux-2.6.32.60-pax/arch/arm/include/asm/elf.h
--- linux-2.6.32.60/arch/arm/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/elf.h	2012-03-13 13:15:34.276098186 +0100
@@ -109,7 +109,14 @@ int dump_task_regs(struct task_struct *t
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)
+#define ELF_ET_DYN_BASE		(TASK_SIZE / 3 * 2)
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x00008000UL
+
+#define PAX_DELTA_MMAP_LEN	((current->personality == PER_LINUX_32BIT) ? 16 : 10)
+#define PAX_DELTA_STACK_LEN	((current->personality == PER_LINUX_32BIT) ? 16 : 10)
+#endif
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/kmap_types.h linux-2.6.32.60-pax/arch/arm/include/asm/kmap_types.h
--- linux-2.6.32.60/arch/arm/include/asm/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/kmap_types.h	2012-03-13 13:15:34.276098186 +0100
@@ -19,6 +19,7 @@ enum km_type {
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
 	KM_L2_CACHE,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/page.h linux-2.6.32.60-pax/arch/arm/include/asm/page.h
--- linux-2.6.32.60/arch/arm/include/asm/page.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/page.h	2012-03-13 13:15:34.276098186 +0100
@@ -122,7 +122,7 @@ struct cpu_user_fns {
 	void (*cpu_clear_user_highpage)(struct page *page, unsigned long vaddr);
 	void (*cpu_copy_user_highpage)(struct page *to, struct page *from,
 			unsigned long vaddr);
-};
+} __no_const;
 
 #ifdef MULTI_USER
 extern struct cpu_user_fns cpu_user;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/ptrace.h linux-2.6.32.60-pax/arch/arm/include/asm/ptrace.h
--- linux-2.6.32.60/arch/arm/include/asm/ptrace.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/ptrace.h	2013-01-22 17:12:14.660627393 +0100
@@ -69,7 +69,7 @@
 /*
  * ARMv7 groups of APSR bits
  */
-#define PSR_ISET_MASK	0x01000010	/* ISA state (J, T) mask */
+#define PSR_ISET_MASK	0x01000020	/* ISA state (J, T) mask */
 #define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
 #define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/system.h linux-2.6.32.60-pax/arch/arm/include/asm/system.h
--- linux-2.6.32.60/arch/arm/include/asm/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/system.h	2012-03-13 13:15:34.276098186 +0100
@@ -86,6 +86,8 @@ void hook_fault_code(int nr, int (*fn)(u
 
 #define xchg(ptr,x) \
 	((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+#define xchg_unchecked(ptr,x) \
+	((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
 
 extern asmlinkage void __backtrace(void);
 extern asmlinkage void c_backtrace(unsigned long fp, int pmode);
@@ -98,7 +100,7 @@ extern int cpu_architecture(void);
 extern void cpu_init(void);
 
 void arm_machine_restart(char mode, const char *cmd);
-extern void (*arm_pm_restart)(char str, const char *cmd);
+extern void (*arm_pm_restart)(char str, const char *cmd) __noreturn;
 
 #define UDBG_UNDEFINED	(1 << 0)
 #define UDBG_SYSCALL	(1 << 1)
@@ -505,6 +507,13 @@ static inline unsigned long long __cmpxc
 
 #endif	/* __LINUX_ARM_ARCH__ >= 6 */
 
+#define _ASM_EXTABLE(from, to)		\
+"	.pushsection __ex_table,\"a\"\n"\
+"	.align	3\n"			\
+"	.long	" #from ", " #to"\n"	\
+"	.popsection"
+
+
 #endif /* __ASSEMBLY__ */
 
 #define arch_align_stack(x) (x)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/include/asm/uaccess.h linux-2.6.32.60-pax/arch/arm/include/asm/uaccess.h
--- linux-2.6.32.60/arch/arm/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/include/asm/uaccess.h	2012-03-13 13:15:34.280098071 +0100
@@ -22,6 +22,8 @@
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
 
+extern void check_object_size(const void *ptr, unsigned long n, bool to);
+
 /*
  * The exception table consists of pairs of addresses: the first is the
  * address of an instruction that is allowed to fault, and the second is
@@ -387,8 +389,23 @@ do {									\
 
 
 #ifdef CONFIG_MMU
-extern unsigned long __must_check __copy_from_user(void *to, const void __user *from, unsigned long n);
-extern unsigned long __must_check __copy_to_user(void __user *to, const void *from, unsigned long n);
+extern unsigned long __must_check ___copy_from_user(void *to, const void __user *from, unsigned long n);
+extern unsigned long __must_check ___copy_to_user(void __user *to, const void *from, unsigned long n);
+
+static inline unsigned long __must_check __copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if (!__builtin_constant_p(n))
+		check_object_size(to, n, false);
+	return ___copy_from_user(to, from, n);
+}
+
+static inline unsigned long __must_check __copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if (!__builtin_constant_p(n))
+		check_object_size(from, n, true);
+	return ___copy_to_user(to, from, n);
+}
+
 extern unsigned long __must_check __copy_to_user_std(void __user *to, const void *from, unsigned long n);
 extern unsigned long __must_check __clear_user(void __user *addr, unsigned long n);
 extern unsigned long __must_check __clear_user_std(void __user *addr, unsigned long n);
@@ -403,6 +420,9 @@ extern unsigned long __must_check __strn
 
 static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	if (access_ok(VERIFY_READ, from, n))
 		n = __copy_from_user(to, from, n);
 	else /* security hole - plug it */
@@ -412,6 +432,9 @@ static inline unsigned long __must_check
 
 static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	if (access_ok(VERIFY_WRITE, to, n))
 		n = __copy_to_user(to, from, n);
 	return n;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/Kconfig linux-2.6.32.60-pax/arch/arm/Kconfig
--- linux-2.6.32.60/arch/arm/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/Kconfig	2012-03-13 13:15:34.280098071 +0100
@@ -14,6 +14,7 @@ config ARM
 	select SYS_SUPPORTS_APM_EMULATION
 	select HAVE_OPROFILE
 	select HAVE_ARCH_KGDB
+	select GENERIC_ATOMIC64
 	select HAVE_KPROBES if (!XIP_KERNEL)
 	select HAVE_KRETPROBES if (HAVE_KPROBES)
 	select HAVE_FUNCTION_TRACER if (!XIP_KERNEL)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/kernel/armksyms.c linux-2.6.32.60-pax/arch/arm/kernel/armksyms.c
--- linux-2.6.32.60/arch/arm/kernel/armksyms.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/kernel/armksyms.c	2012-03-13 13:15:34.280098071 +0100
@@ -118,8 +118,8 @@ EXPORT_SYMBOL(__strncpy_from_user);
 #ifdef CONFIG_MMU
 EXPORT_SYMBOL(copy_page);
 
-EXPORT_SYMBOL(__copy_from_user);
-EXPORT_SYMBOL(__copy_to_user);
+EXPORT_SYMBOL(___copy_from_user);
+EXPORT_SYMBOL(___copy_to_user);
 EXPORT_SYMBOL(__clear_user);
 
 EXPORT_SYMBOL(__get_user_1);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/kernel/head.S linux-2.6.32.60-pax/arch/arm/kernel/head.S
--- linux-2.6.32.60/arch/arm/kernel/head.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/kernel/head.S	2013-01-22 22:04:34.143690921 +0100
@@ -45,7 +45,9 @@
 	.equ	swapper_pg_dir, KERNEL_RAM_VADDR - 0x4000
 
 	.macro	pgtbl, rd
-	ldr	\rd, =(KERNEL_RAM_PADDR - 0x4000)
+	mov	\rd, #KERNEL_RAM_PADDR
+	sub	\rd, #0x4000
+	add	\rd, \rd, \phys
 	.endm
 
 #ifdef CONFIG_XIP_KERNEL
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/kernel/process.c linux-2.6.32.60-pax/arch/arm/kernel/process.c
--- linux-2.6.32.60/arch/arm/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/kernel/process.c	2012-03-13 16:44:09.119437848 +0100
@@ -83,7 +83,7 @@ static int __init hlt_setup(char *__unus
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
-void arm_machine_restart(char mode, const char *cmd)
+__noreturn void arm_machine_restart(char mode, const char *cmd)
 {
 	/*
 	 * Clean and disable cache, and turn off interrupts
@@ -117,7 +117,7 @@ void arm_machine_restart(char mode, cons
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-void (*arm_pm_restart)(char str, const char *cmd) = arm_machine_restart;
+void (*arm_pm_restart)(char str, const char *cmd) __noreturn = arm_machine_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 
@@ -195,6 +195,7 @@ __setup("reboot=", reboot_setup);
 
 void machine_halt(void)
 {
+	BUG();
 }
 
 
@@ -202,6 +203,7 @@ void machine_power_off(void)
 {
 	if (pm_power_off)
 		pm_power_off();
+	BUG();
 }
 
 void machine_restart(char *cmd)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/kernel/setup.c linux-2.6.32.60-pax/arch/arm/kernel/setup.c
--- linux-2.6.32.60/arch/arm/kernel/setup.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/kernel/setup.c	2013-01-22 12:51:36.685462340 +0100
@@ -92,16 +92,16 @@ EXPORT_SYMBOL(elf_hwcap);
 struct processor processor;
 #endif
 #ifdef MULTI_TLB
-struct cpu_tlb_fns cpu_tlb;
+struct cpu_tlb_fns cpu_tlb __read_mostly;
 #endif
 #ifdef MULTI_USER
-struct cpu_user_fns cpu_user;
+struct cpu_user_fns cpu_user __read_mostly;
 #endif
 #ifdef MULTI_CACHE
-struct cpu_cache_fns cpu_cache;
+struct cpu_cache_fns cpu_cache __read_mostly;
 #endif
 #ifdef CONFIG_OUTER_CACHE
-struct outer_cache_fns outer_cache;
+struct outer_cache_fns outer_cache __read_mostly;
 #endif
 
 struct stack {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/kernel/vmlinux.lds.S linux-2.6.32.60-pax/arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.32.60/arch/arm/kernel/vmlinux.lds.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/kernel/vmlinux.lds.S	2012-03-13 16:24:09.527493862 +0100
@@ -74,14 +74,18 @@ SECTIONS
 #ifndef CONFIG_XIP_KERNEL
 		__init_begin = _stext;
 		INIT_DATA
+		EXIT_TEXT
+		EXIT_DATA
 		. = ALIGN(PAGE_SIZE);
 		__init_end = .;
 #endif
 	}
 
 	/DISCARD/ : {			/* Exit code and data		*/
+#ifdef CONFIG_XIP_KERNEL
 		EXIT_TEXT
 		EXIT_DATA
+#endif
 		*(.exitcall.exit)
 		*(.discard)
 		*(.ARM.exidx.exit.text)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/lib/copy_from_user.S linux-2.6.32.60-pax/arch/arm/lib/copy_from_user.S
--- linux-2.6.32.60/arch/arm/lib/copy_from_user.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/lib/copy_from_user.S	2012-03-13 13:15:34.284098029 +0100
@@ -16,7 +16,7 @@
 /*
  * Prototype:
  *
- *	size_t __copy_from_user(void *to, const void *from, size_t n)
+ *	size_t ___copy_from_user(void *to, const void *from, size_t n)
  *
  * Purpose:
  *
@@ -84,11 +84,11 @@
 
 	.text
 
-ENTRY(__copy_from_user)
+ENTRY(___copy_from_user)
 
 #include "copy_template.S"
 
-ENDPROC(__copy_from_user)
+ENDPROC(___copy_from_user)
 
 	.section .fixup,"ax"
 	.align 0
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/lib/copy_page.S linux-2.6.32.60-pax/arch/arm/lib/copy_page.S
--- linux-2.6.32.60/arch/arm/lib/copy_page.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/lib/copy_page.S	2012-03-13 13:15:34.284098029 +0100
@@ -10,6 +10,7 @@
  *  ASM optimised string functions
  */
 #include <linux/linkage.h>
+#include <linux/const.h>
 #include <asm/assembler.h>
 #include <asm/asm-offsets.h>
 #include <asm/cache.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/lib/copy_to_user.S linux-2.6.32.60-pax/arch/arm/lib/copy_to_user.S
--- linux-2.6.32.60/arch/arm/lib/copy_to_user.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/lib/copy_to_user.S	2012-03-13 13:15:34.284098029 +0100
@@ -16,7 +16,7 @@
 /*
  * Prototype:
  *
- *	size_t __copy_to_user(void *to, const void *from, size_t n)
+ *	size_t ___copy_to_user(void *to, const void *from, size_t n)
  *
  * Purpose:
  *
@@ -88,11 +88,11 @@
 	.text
 
 ENTRY(__copy_to_user_std)
-WEAK(__copy_to_user)
+WEAK(___copy_to_user)
 
 #include "copy_template.S"
 
-ENDPROC(__copy_to_user)
+ENDPROC(___copy_to_user)
 
 	.section .fixup,"ax"
 	.align 0
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/lib/uaccess.S linux-2.6.32.60-pax/arch/arm/lib/uaccess.S
--- linux-2.6.32.60/arch/arm/lib/uaccess.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/lib/uaccess.S	2012-03-13 13:15:34.288098025 +0100
@@ -19,7 +19,7 @@
 
 #define PAGE_SHIFT 12
 
-/* Prototype: int __copy_to_user(void *to, const char *from, size_t n)
+/* Prototype: int ___copy_to_user(void *to, const char *from, size_t n)
  * Purpose  : copy a block to user memory from kernel memory
  * Params   : to   - user memory
  *          : from - kernel memory
@@ -39,7 +39,7 @@ USER(		strgtbt	r3, [r0], #1)			@ May fau
 		sub	r2, r2, ip
 		b	.Lc2u_dest_aligned
 
-ENTRY(__copy_to_user)
+ENTRY(___copy_to_user)
 		stmfd	sp!, {r2, r4 - r7, lr}
 		cmp	r2, #4
 		blt	.Lc2u_not_enough
@@ -277,14 +277,14 @@ USER(		strgebt	r3, [r0], #1)			@ May fau
 		ldrgtb	r3, [r1], #0
 USER(		strgtbt	r3, [r0], #1)			@ May fault
 		b	.Lc2u_finished
-ENDPROC(__copy_to_user)
+ENDPROC(___copy_to_user)
 
 		.section .fixup,"ax"
 		.align	0
 9001:		ldmfd	sp!, {r0, r4 - r7, pc}
 		.previous
 
-/* Prototype: unsigned long __copy_from_user(void *to,const void *from,unsigned long n);
+/* Prototype: unsigned long ___copy_from_user(void *to,const void *from,unsigned long n);
  * Purpose  : copy a block from user memory to kernel memory
  * Params   : to   - kernel memory
  *          : from - user memory
@@ -303,7 +303,7 @@ USER(		ldrgtbt	r3, [r1], #1)			@ May fau
 		sub	r2, r2, ip
 		b	.Lcfu_dest_aligned
 
-ENTRY(__copy_from_user)
+ENTRY(___copy_from_user)
 		stmfd	sp!, {r0, r2, r4 - r7, lr}
 		cmp	r2, #4
 		blt	.Lcfu_not_enough
@@ -543,7 +543,7 @@ USER(		ldrgebt	r3, [r1], #1)			@ May fau
 USER(		ldrgtbt	r3, [r1], #1)			@ May fault
 		strgtb	r3, [r0], #1
 		b	.Lcfu_finished
-ENDPROC(__copy_from_user)
+ENDPROC(___copy_from_user)
 
 		.section .fixup,"ax"
 		.align	0
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/lib/uaccess_with_memcpy.c linux-2.6.32.60-pax/arch/arm/lib/uaccess_with_memcpy.c
--- linux-2.6.32.60/arch/arm/lib/uaccess_with_memcpy.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/lib/uaccess_with_memcpy.c	2012-03-13 13:15:34.288098025 +0100
@@ -97,7 +97,7 @@ out:
 }
 
 unsigned long
-__copy_to_user(void __user *to, const void *from, unsigned long n)
+___copy_to_user(void __user *to, const void *from, unsigned long n)
 {
 	/*
 	 * This test is stubbed out of the main function above to keep
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/mm/fault.c linux-2.6.32.60-pax/arch/arm/mm/fault.c
--- linux-2.6.32.60/arch/arm/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/mm/fault.c	2013-01-22 12:52:00.045461093 +0100
@@ -569,6 +569,20 @@ do_PrefetchAbort(unsigned long addr, uns
 	const struct fsr_info *inf = ifsr_info + fsr_fs(ifsr);
 	struct siginfo info;
 
+#ifdef CONFIG_PAX_REFCOUNT
+	if (fsr_fs(ifsr) == 2) {
+		unsigned int bkpt;
+
+		if (!probe_kernel_address((unsigned int *)addr, bkpt) && bkpt == 0xe12f1073) {
+			current->thread.error_code = ifsr;
+			current->thread.trap_no = 0;
+			pax_report_refcount_overflow(regs);
+			fixup_exception(regs);
+			return;
+		}
+	}
+#endif
+
 	if (!inf->fn(addr, ifsr | FSR_LNX_PF, regs))
 		return;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/arm/mm/mmap.c linux-2.6.32.60-pax/arch/arm/mm/mmap.c
--- linux-2.6.32.60/arch/arm/mm/mmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/arm/mm/mmap.c	2012-03-13 13:15:34.288098025 +0100
@@ -63,6 +63,10 @@ arch_get_unmapped_area(struct file *filp
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		if (do_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -70,15 +74,14 @@ arch_get_unmapped_area(struct file *filp
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
-	        mm->cached_hole_size = 0;
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
 	}
 
 full_search:
@@ -94,14 +97,14 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/avr32/include/asm/elf.h linux-2.6.32.60-pax/arch/avr32/include/asm/elf.h
--- linux-2.6.32.60/arch/avr32/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/avr32/include/asm/elf.h	2012-03-13 13:15:34.288098025 +0100
@@ -85,8 +85,14 @@ typedef struct user_fpu_struct elf_fpreg
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
-#define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
+#define ELF_ET_DYN_BASE		(TASK_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x00001000UL
+
+#define PAX_DELTA_MMAP_LEN	15
+#define PAX_DELTA_STACK_LEN	15
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/avr32/include/asm/kmap_types.h linux-2.6.32.60-pax/arch/avr32/include/asm/kmap_types.h
--- linux-2.6.32.60/arch/avr32/include/asm/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/avr32/include/asm/kmap_types.h	2012-03-13 13:15:34.292098030 +0100
@@ -22,7 +22,8 @@ D(10)	KM_IRQ0,
 D(11)	KM_IRQ1,
 D(12)	KM_SOFTIRQ0,
 D(13)	KM_SOFTIRQ1,
-D(14)	KM_TYPE_NR
+D(14)	KM_CLEARPAGE,
+D(15)	KM_TYPE_NR
 };
 
 #undef D
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/avr32/mm/fault.c linux-2.6.32.60-pax/arch/avr32/mm/fault.c
--- linux-2.6.32.60/arch/avr32/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/avr32/mm/fault.c	2012-03-13 13:15:34.292098030 +0100
@@ -41,6 +41,23 @@ static inline int notify_page_fault(stru
 
 int exception_trace = 1;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%02x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults. It determines the address and the
  * problem, and then passes it off to one of the appropriate routines.
@@ -157,6 +174,16 @@ bad_area:
 	up_read(&mm->mmap_sem);
 
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if (ecr == ECR_PROTECTION_X || ecr == ECR_TLB_MISS_X) {
+				pax_report_fault(regs, (void *)regs->pc, (void *)regs->sp);
+				do_group_exit(SIGKILL);
+			}
+		}
+#endif
+
 		if (exception_trace && printk_ratelimit())
 			printk("%s%s[%d]: segfault at %08lx pc %08lx "
 			       "sp %08lx ecr %lu\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/frv/include/asm/atomic.h linux-2.6.32.60-pax/arch/frv/include/asm/atomic.h
--- linux-2.6.32.60/arch/frv/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/frv/include/asm/atomic.h	2012-03-13 13:15:34.292098030 +0100
@@ -241,6 +241,16 @@ extern uint32_t __xchg_32(uint32_t i, vo
 #define atomic64_cmpxchg(v, old, new)	(__cmpxchg_64(old, new, &(v)->counter))
 #define atomic64_xchg(v, new)		(__xchg_64(new, &(v)->counter))
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 static __inline__ int atomic_add_unless(atomic_t *v, int a, int u)
 {
 	int c, old;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/frv/include/asm/kmap_types.h linux-2.6.32.60-pax/arch/frv/include/asm/kmap_types.h
--- linux-2.6.32.60/arch/frv/include/asm/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/frv/include/asm/kmap_types.h	2012-03-13 13:15:34.292098030 +0100
@@ -23,6 +23,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/frv/mm/elf-fdpic.c linux-2.6.32.60-pax/arch/frv/mm/elf-fdpic.c
--- linux-2.6.32.60/arch/frv/mm/elf-fdpic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/frv/mm/elf-fdpic.c	2012-03-13 13:15:34.292098030 +0100
@@ -73,8 +73,7 @@ unsigned long arch_get_unmapped_area(str
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current->mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vma, addr, len))
 			goto success;
 	}
 
@@ -89,7 +88,7 @@ unsigned long arch_get_unmapped_area(str
 			for (; vma; vma = vma->vm_next) {
 				if (addr > limit)
 					break;
-				if (addr + len <= vma->vm_start)
+				if (check_heap_stack_gap(vma, addr, len))
 					goto success;
 				addr = vma->vm_end;
 			}
@@ -104,7 +103,7 @@ unsigned long arch_get_unmapped_area(str
 		for (; vma; vma = vma->vm_next) {
 			if (addr > limit)
 				break;
-			if (addr + len <= vma->vm_start)
+			if (check_heap_stack_gap(vma, addr, len))
 				goto success;
 			addr = vma->vm_end;
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/ia32/binfmt_elf32.c linux-2.6.32.60-pax/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.32.60/arch/ia64/ia32/binfmt_elf32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/ia32/binfmt_elf32.c	2012-03-13 13:15:34.296098035 +0100
@@ -45,6 +45,13 @@ randomize_stack_top(unsigned long stack_
 
 #define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/ia32/ia32priv.h linux-2.6.32.60-pax/arch/ia64/ia32/ia32priv.h
--- linux-2.6.32.60/arch/ia64/ia32/ia32priv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/ia32/ia32priv.h	2012-03-13 13:15:34.296098035 +0100
@@ -296,7 +296,14 @@ typedef struct compat_siginfo {
 #define ELF_DATA	ELFDATA2LSB
 #define ELF_ARCH	EM_386
 
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK	(current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK	0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/atomic.h linux-2.6.32.60-pax/arch/ia64/include/asm/atomic.h
--- linux-2.6.32.60/arch/ia64/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/atomic.h	2012-03-13 13:15:34.296098035 +0100
@@ -210,6 +210,16 @@ atomic64_add_negative (__s64 i, atomic64
 #define atomic64_inc(v)			atomic64_add(1, (v))
 #define atomic64_dec(v)			atomic64_sub(1, (v))
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 /* Atomic operations are already serializing */
 #define smp_mb__before_atomic_dec()	barrier()
 #define smp_mb__after_atomic_dec()	barrier()
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/elf.h linux-2.6.32.60-pax/arch/ia64/include/asm/elf.h
--- linux-2.6.32.60/arch/ia64/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/elf.h	2012-03-13 13:15:34.296098035 +0100
@@ -43,6 +43,13 @@
  */
 #define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x800000000UL)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
+
 #define PT_IA_64_UNWIND		0x70000001
 
 /* IA-64 relocations: */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/pgalloc.h linux-2.6.32.60-pax/arch/ia64/include/asm/pgalloc.h
--- linux-2.6.32.60/arch/ia64/include/asm/pgalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/pgalloc.h	2012-05-07 17:49:11.988114623 +0200
@@ -39,6 +39,12 @@ pgd_populate(struct mm_struct *mm, pgd_t
 	pgd_val(*pgd_entry) = __pa(pud);
 }
 
+static inline void
+pgd_populate_kernel(struct mm_struct *mm, pgd_t * pgd_entry, pud_t * pud)
+{
+	pgd_populate(mm, pgd_entry, pud);
+}
+
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
 	return quicklist_alloc(0, GFP_KERNEL, NULL);
@@ -57,6 +63,12 @@ pud_populate(struct mm_struct *mm, pud_t
 	pud_val(*pud_entry) = __pa(pmd);
 }
 
+static inline void
+pud_populate_kernel(struct mm_struct *mm, pud_t * pud_entry, pmd_t * pmd)
+{
+	pud_populate(mm, pud_entry, pmd);
+}
+
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
 	return quicklist_alloc(0, GFP_KERNEL, NULL);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/pgtable.h linux-2.6.32.60-pax/arch/ia64/include/asm/pgtable.h
--- linux-2.6.32.60/arch/ia64/include/asm/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/pgtable.h	2012-03-13 13:15:34.296098035 +0100
@@ -12,7 +12,7 @@
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
-
+#include <linux/const.h>
 #include <asm/mman.h>
 #include <asm/page.h>
 #include <asm/processor.h>
@@ -143,6 +143,17 @@
 #define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
 #define PAGE_COPY_EXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)
+# define PAGE_READONLY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+# define PAGE_COPY_NOEXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+#endif
+
 #define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)
 #define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)
 #define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/spinlock.h linux-2.6.32.60-pax/arch/ia64/include/asm/spinlock.h
--- linux-2.6.32.60/arch/ia64/include/asm/spinlock.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/spinlock.h	2012-03-13 13:15:34.300098035 +0100
@@ -72,7 +72,7 @@ static __always_inline void __ticket_spi
 	unsigned short	*p = (unsigned short *)&lock->lock + 1, tmp;
 
 	asm volatile ("ld2.bias %0=[%1]" : "=r"(tmp) : "r"(p));
-	ACCESS_ONCE(*p) = (tmp + 2) & ~1;
+	ACCESS_ONCE_RW(*p) = (tmp + 2) & ~1;
 }
 
 static __always_inline void __ticket_spin_unlock_wait(raw_spinlock_t *lock)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/include/asm/uaccess.h linux-2.6.32.60-pax/arch/ia64/include/asm/uaccess.h
--- linux-2.6.32.60/arch/ia64/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/include/asm/uaccess.h	2013-01-22 17:38:23.376543636 +0100
@@ -42,6 +42,8 @@
 #include <asm/pgtable.h>
 #include <asm/io.h>
 
+extern void check_object_size(const void *ptr, unsigned long n, bool to);
+
 /*
  * For historical reasons, the following macros are grossly misnamed:
  */
@@ -240,12 +242,24 @@ extern unsigned long __must_check __copy
 static inline unsigned long
 __copy_to_user (void __user *to, const void *from, unsigned long count)
 {
+	if (count > INT_MAX)
+		return count;
+
+	if (!__builtin_constant_p(count))
+		check_object_size(from, count, true);
+
 	return __copy_user(to, (__force void __user *) from, count);
 }
 
 static inline unsigned long
 __copy_from_user (void *to, const void __user *from, unsigned long count)
 {
+	if (count > INT_MAX)
+		return count;
+
+	if (!__builtin_constant_p(count))
+		check_object_size(to, count, false);
+
 	return __copy_user((__force void __user *) to, from, count);
 }
 
@@ -255,10 +269,13 @@ __copy_from_user (void *to, const void _
 ({											\
 	void __user *__cu_to = (to);							\
 	const void *__cu_from = (from);							\
-	long __cu_len = (n);								\
+	unsigned long __cu_len = (n);							\
 											\
-	if (__access_ok(__cu_to, __cu_len, get_fs()))					\
+	if (__cu_len <= INT_MAX && __access_ok(__cu_to, __cu_len, get_fs())) {		\
+		if (!__builtin_constant_p(n))						\
+			check_object_size(__cu_from, __cu_len, true);			\
 		__cu_len = __copy_user(__cu_to, (__force void __user *) __cu_from, __cu_len);	\
+	}										\
 	__cu_len;									\
 })
 
@@ -266,11 +283,14 @@ __copy_from_user (void *to, const void _
 ({											\
 	void *__cu_to = (to);								\
 	const void __user *__cu_from = (from);						\
-	long __cu_len = (n);								\
+	unsigned long __cu_len = (n);							\
 											\
 	__chk_user_ptr(__cu_from);							\
-	if (__access_ok(__cu_from, __cu_len, get_fs()))					\
+	if (__cu_len <= INT_MAX  && __access_ok(__cu_from, __cu_len, get_fs())) {	\
+		if (!__builtin_constant_p(n))						\
+			check_object_size(__cu_to, __cu_len, false);			\
 		__cu_len = __copy_user((__force void __user *) __cu_to, __cu_from, __cu_len);	\
+	}										\
 	__cu_len;									\
 })
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/kernel/module.c linux-2.6.32.60-pax/arch/ia64/kernel/module.c
--- linux-2.6.32.60/arch/ia64/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/kernel/module.c	2012-03-13 13:15:34.300098035 +0100
@@ -315,8 +315,7 @@ module_alloc (unsigned long size)
 void
 module_free (struct module *mod, void *module_region)
 {
-	if (mod && mod->arch.init_unw_table &&
-	    module_region == mod->module_init) {
+	if (mod && mod->arch.init_unw_table && module_region == mod->module_init_rx) {
 		unw_remove_unwind_table(mod->arch.init_unw_table);
 		mod->arch.init_unw_table = NULL;
 	}
@@ -502,15 +501,39 @@ module_frob_arch_sections (Elf_Ehdr *ehd
 }
 
 static inline int
+in_init_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rx < mod->init_size_rx;
+}
+
+static inline int
+in_init_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rw < mod->init_size_rw;
+}
+
+static inline int
 in_init (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_init < mod->init_size;
+	return in_init_rx(mod, addr) || in_init_rw(mod, addr);
+}
+
+static inline int
+in_core_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rx < mod->core_size_rx;
+}
+
+static inline int
+in_core_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rw < mod->core_size_rw;
 }
 
 static inline int
 in_core (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_core < mod->core_size;
+	return in_core_rx(mod, addr) || in_core_rw(mod, addr);
 }
 
 static inline int
@@ -693,7 +716,14 @@ do_reloc (struct module *mod, uint8_t r_
 		break;
 
 	      case RV_BDREL:
-		val -= (uint64_t) (in_init(mod, val) ? mod->module_init : mod->module_core);
+		if (in_init_rx(mod, val))
+			val -= (uint64_t) mod->module_init_rx;
+		else if (in_init_rw(mod, val))
+			val -= (uint64_t) mod->module_init_rw;
+		else if (in_core_rx(mod, val))
+			val -= (uint64_t) mod->module_core_rx;
+		else if (in_core_rw(mod, val))
+			val -= (uint64_t) mod->module_core_rw;
 		break;
 
 	      case RV_LTV:
@@ -828,15 +858,15 @@ apply_relocate_add (Elf64_Shdr *sechdrs,
 		 *     addresses have been selected...
 		 */
 		uint64_t gp;
-		if (mod->core_size > MAX_LTOFF)
+		if (mod->core_size_rx + mod->core_size_rw > MAX_LTOFF)
 			/*
 			 * This takes advantage of fact that SHF_ARCH_SMALL gets allocated
 			 * at the end of the module.
 			 */
-			gp = mod->core_size - MAX_LTOFF / 2;
+			gp = mod->core_size_rx + mod->core_size_rw - MAX_LTOFF / 2;
 		else
-			gp = mod->core_size / 2;
-		gp = (uint64_t) mod->module_core + ((gp + 7) & -8);
+			gp = (mod->core_size_rx + mod->core_size_rw) / 2;
+		gp = (uint64_t) mod->module_core_rx + ((gp + 7) & -8);
 		mod->arch.gp = gp;
 		DEBUGP("%s: placing gp at 0x%lx\n", __func__, gp);
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/kernel/pci-dma.c linux-2.6.32.60-pax/arch/ia64/kernel/pci-dma.c
--- linux-2.6.32.60/arch/ia64/kernel/pci-dma.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/kernel/pci-dma.c	2012-03-13 13:15:34.300098035 +0100
@@ -100,11 +100,11 @@ void __init pci_iommu_alloc(void)
 {
 	dma_ops = &intel_dma_ops;
 
-	dma_ops->sync_single_for_cpu = machvec_dma_sync_single;
-	dma_ops->sync_sg_for_cpu = machvec_dma_sync_sg;
-	dma_ops->sync_single_for_device = machvec_dma_sync_single;
-	dma_ops->sync_sg_for_device = machvec_dma_sync_sg;
-	dma_ops->dma_supported = iommu_dma_supported;
+	*(void **)&dma_ops->sync_single_for_cpu = machvec_dma_sync_single;
+	*(void **)&dma_ops->sync_sg_for_cpu = machvec_dma_sync_sg;
+	*(void **)&dma_ops->sync_single_for_device = machvec_dma_sync_single;
+	*(void **)&dma_ops->sync_sg_for_device = machvec_dma_sync_sg;
+	*(void **)&dma_ops->dma_supported = iommu_dma_supported;
 
 	/*
 	 * The order of these functions is important for
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/kernel/sys_ia64.c linux-2.6.32.60-pax/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.32.60/arch/ia64/kernel/sys_ia64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/kernel/sys_ia64.c	2012-03-13 13:15:34.304098035 +0100
@@ -43,6 +43,13 @@ arch_get_unmapped_area (struct file *fil
 	if (REGION_NUMBER(addr) == RGN_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		addr = mm->free_area_cache;
+	else
+#endif
+
 	if (!addr)
 		addr = mm->free_area_cache;
 
@@ -61,14 +68,14 @@ arch_get_unmapped_area (struct file *fil
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
+			if (start_addr != mm->mmap_base) {
 				/* Start a new search --- just in case we missed some holes.  */
-				addr = TASK_UNMAPPED_BASE;
+				addr = mm->mmap_base;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/* Remember the address where we stopped this search:  */
 			mm->free_area_cache = addr + len;
 			return addr;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/kernel/vmlinux.lds.S linux-2.6.32.60-pax/arch/ia64/kernel/vmlinux.lds.S
--- linux-2.6.32.60/arch/ia64/kernel/vmlinux.lds.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/kernel/vmlinux.lds.S	2012-03-13 13:15:34.304098035 +0100
@@ -190,7 +190,7 @@ SECTIONS
   /* Per-cpu data: */
   . = ALIGN(PERCPU_PAGE_SIZE);
   PERCPU_VADDR(PERCPU_ADDR, :percpu)
-  __phys_per_cpu_start = __per_cpu_load;
+  __phys_per_cpu_start = per_cpu_load;
   . = __phys_per_cpu_start + PERCPU_PAGE_SIZE;	/* ensure percpu data fits
   						 * into percpu page size
 						 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/mm/fault.c linux-2.6.32.60-pax/arch/ia64/mm/fault.c
--- linux-2.6.32.60/arch/ia64/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/mm/fault.c	2012-03-13 13:15:34.304098035 +0100
@@ -72,6 +72,23 @@ mapped_kernel_page_is_present (unsigned
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void __kprobes
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -145,9 +162,23 @@ ia64_do_page_fault (unsigned long addres
 	mask = (  (((isr >> IA64_ISR_X_BIT) & 1UL) << VM_EXEC_BIT)
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void *)regs->cr_iip, (void *)regs->r12);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/mm/hugetlbpage.c linux-2.6.32.60-pax/arch/ia64/mm/hugetlbpage.c
--- linux-2.6.32.60/arch/ia64/mm/hugetlbpage.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/mm/hugetlbpage.c	2012-03-13 13:15:34.304098035 +0100
@@ -172,7 +172,7 @@ unsigned long hugetlb_get_unmapped_area(
 		/* At this point:  (!vmm || addr < vmm->vm_end). */
 		if (REGION_OFFSET(addr) + len > RGN_MAP_LIMIT)
 			return -ENOMEM;
-		if (!vmm || (addr + len) <= vmm->vm_start)
+		if (check_heap_stack_gap(vmm, addr, len))
 			return addr;
 		addr = ALIGN(vmm->vm_end, HPAGE_SIZE);
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/ia64/mm/init.c linux-2.6.32.60-pax/arch/ia64/mm/init.c
--- linux-2.6.32.60/arch/ia64/mm/init.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/ia64/mm/init.c	2012-03-13 13:15:34.304098035 +0100
@@ -122,6 +122,19 @@ ia64_init_addr_space (void)
 		vma->vm_start = current->thread.rbs_bot & PAGE_MASK;
 		vma->vm_end = vma->vm_start + PAGE_SIZE;
 		vma->vm_flags = VM_DATA_DEFAULT_FLAGS|VM_GROWSUP|VM_ACCOUNT;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (current->mm->pax_flags & MF_PAX_PAGEEXEC) {
+			vma->vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+			if (current->mm->pax_flags & MF_PAX_MPROTECT)
+				vma->vm_flags &= ~VM_MAYEXEC;
+#endif
+
+		}
+#endif
+
 		vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 		down_write(&current->mm->mmap_sem);
 		if (insert_vm_struct(current->mm, vma)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/m32r/lib/usercopy.c linux-2.6.32.60-pax/arch/m32r/lib/usercopy.c
--- linux-2.6.32.60/arch/m32r/lib/usercopy.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/m32r/lib/usercopy.c	2012-03-13 13:15:34.308098034 +0100
@@ -14,6 +14,9 @@
 unsigned long
 __generic_copy_to_user(void __user *to, const void *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	prefetch(from);
 	if (access_ok(VERIFY_WRITE, to, n))
 		__copy_user(to,from,n);
@@ -23,6 +26,9 @@ __generic_copy_to_user(void __user *to,
 unsigned long
 __generic_copy_from_user(void *to, const void __user *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	prefetchw(to);
 	if (access_ok(VERIFY_READ, from, n))
 		__copy_user_zeroing(to,from,n);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/include/asm/atomic.h linux-2.6.32.60-pax/arch/mips/include/asm/atomic.h
--- linux-2.6.32.60/arch/mips/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/include/asm/atomic.h	2012-03-13 13:15:34.308098034 +0100
@@ -21,6 +21,10 @@
 #include <asm/war.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_GENERIC_ATOMIC64
+#include <asm-generic/atomic64.h>
+#endif
+
 #define ATOMIC_INIT(i)    { (i) }
 
 /*
@@ -782,6 +786,16 @@ static __inline__ int atomic64_add_unles
  */
 #define atomic64_add_negative(i, v) (atomic64_add_return(i, (v)) < 0)
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 #endif /* CONFIG_64BIT */
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/include/asm/elf.h linux-2.6.32.60-pax/arch/mips/include/asm/elf.h
--- linux-2.6.32.60/arch/mips/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/include/asm/elf.h	2012-03-13 13:15:34.308098034 +0100
@@ -368,4 +368,11 @@ extern int dump_task_fpu(struct task_str
 #define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
 #endif
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #endif /* _ASM_ELF_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/include/asm/page.h linux-2.6.32.60-pax/arch/mips/include/asm/page.h
--- linux-2.6.32.60/arch/mips/include/asm/page.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/include/asm/page.h	2012-03-13 13:15:34.312098033 +0100
@@ -93,7 +93,7 @@ extern void copy_user_highpage(struct pa
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-    #define __pte(x)      ({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+    #define __pte(x)      ({ pte_t __pte = {(x), (x) >> 32}; __pte; })
   #else
      typedef struct { unsigned long long pte; } pte_t;
      #define pte_val(x)	((x).pte)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/include/asm/pgalloc.h linux-2.6.32.60-pax/arch/mips/include/asm/pgalloc.h
--- linux-2.6.32.60/arch/mips/include/asm/pgalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/include/asm/pgalloc.h	2012-05-07 17:49:11.992114623 +0200
@@ -37,6 +37,11 @@ static inline void pud_populate(struct m
 {
 	set_pud(pud, __pud((unsigned long)pmd));
 }
+
+static inline void pud_populate_kernel(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
+{
+	pud_populate(mm, pud, pmd);
+}
 #endif
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/include/asm/system.h linux-2.6.32.60-pax/arch/mips/include/asm/system.h
--- linux-2.6.32.60/arch/mips/include/asm/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/include/asm/system.h	2012-03-13 13:15:34.312098033 +0100
@@ -230,6 +230,6 @@ extern void per_cpu_trap_init(void);
  */
 #define __ARCH_WANT_UNLOCKED_CTXSW
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) ((x) & ~0xfUL)
 
 #endif /* _ASM_SYSTEM_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/Kconfig linux-2.6.32.60-pax/arch/mips/Kconfig
--- linux-2.6.32.60/arch/mips/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/Kconfig	2012-03-13 13:15:34.312098033 +0100
@@ -5,6 +5,7 @@ config MIPS
 	select HAVE_IDE
 	select HAVE_OPROFILE
 	select HAVE_ARCH_KGDB
+	select GENERIC_ATOMIC64 if !64BIT
 	# Horrible source of confusion.  Die, die, die ...
 	select EMBEDDED
 	select RTC_LIB if !LEMOTE_FULOONG2E
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/kernel/binfmt_elfn32.c linux-2.6.32.60-pax/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.32.60/arch/mips/kernel/binfmt_elfn32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/kernel/binfmt_elfn32.c	2012-03-13 13:15:34.312098033 +0100
@@ -50,6 +50,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/elfcore.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/kernel/binfmt_elfo32.c linux-2.6.32.60-pax/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.32.60/arch/mips/kernel/binfmt_elfo32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/kernel/binfmt_elfo32.c	2012-03-13 13:15:34.316098033 +0100
@@ -52,6 +52,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/kernel/process.c linux-2.6.32.60-pax/arch/mips/kernel/process.c
--- linux-2.6.32.60/arch/mips/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/kernel/process.c	2012-03-13 13:15:34.316098033 +0100
@@ -470,15 +470,3 @@ unsigned long get_wchan(struct task_stru
 out:
 	return pc;
 }
-
-/*
- * Don't forget that the stack pointer must be aligned on a 8 bytes
- * boundary for 32-bits ABI and 16 bytes for 64-bits ABI.
- */
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() & ~PAGE_MASK;
-
-	return sp & ALMASK;
-}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/kernel/syscall.c linux-2.6.32.60-pax/arch/mips/kernel/syscall.c
--- linux-2.6.32.60/arch/mips/kernel/syscall.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/kernel/syscall.c	2012-03-13 13:15:34.316098033 +0100
@@ -102,17 +102,21 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
 		else
 			addr = PAGE_ALIGN(addr);
 		vmm = find_vma(current->mm, addr);
-		if (task_size - len >= addr &&
-		    (!vmm || addr + len <= vmm->vm_start))
+		if (task_size - len >= addr && check_heap_stack_gap(vmm, addr, len))
 			return addr;
 	}
-	addr = TASK_UNMAPPED_BASE;
+	addr = current->mm->mmap_base;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
 	else
@@ -122,7 +126,7 @@ unsigned long arch_get_unmapped_area(str
 		/* At this point:  (!vmm || addr < vmm->vm_end). */
 		if (task_size - len < addr)
 			return -ENOMEM;
-		if (!vmm || addr + len <= vmm->vm_start)
+		if (check_heap_stack_gap(vmm, addr, len))
 			return addr;
 		addr = vmm->vm_end;
 		if (do_color_align)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/mips/mm/fault.c linux-2.6.32.60-pax/arch/mips/mm/fault.c
--- linux-2.6.32.60/arch/mips/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/mips/mm/fault.c	2012-03-13 13:15:34.316098033 +0100
@@ -26,6 +26,23 @@
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/include/asm/atomic.h linux-2.6.32.60-pax/arch/parisc/include/asm/atomic.h
--- linux-2.6.32.60/arch/parisc/include/asm/atomic.h	2012-10-09 11:00:35.416882460 +0200
+++ linux-2.6.32.60-pax/arch/parisc/include/asm/atomic.h	2012-10-09 11:00:39.224883019 +0200
@@ -336,6 +336,16 @@ static __inline__ int atomic64_add_unles
 
 #define atomic64_inc_not_zero(v) atomic64_add_unless((v), 1, 0)
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 #else /* CONFIG_64BIT */
 
 #include <asm-generic/atomic64.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/include/asm/elf.h linux-2.6.32.60-pax/arch/parisc/include/asm/elf.h
--- linux-2.6.32.60/arch/parisc/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/include/asm/elf.h	2012-03-13 13:15:34.320098033 +0100
@@ -343,6 +343,13 @@ struct pt_regs;	/* forward declaration..
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE + 0x01000000)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
    but it's not easy, and we've already done it here.  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/include/asm/pgalloc.h linux-2.6.32.60-pax/arch/parisc/include/asm/pgalloc.h
--- linux-2.6.32.60/arch/parisc/include/asm/pgalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/include/asm/pgalloc.h	2012-05-07 17:49:11.992114623 +0200
@@ -61,6 +61,11 @@ static inline void pgd_populate(struct m
 		        (__u32)(__pa((unsigned long)pmd) >> PxD_VALUE_SHIFT));
 }
 
+static inline void pgd_populate_kernel(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmd)
+{
+	pgd_populate(mm, pgd, pmd);
+}
+
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
 	pmd_t *pmd = (pmd_t *)__get_free_pages(GFP_KERNEL|__GFP_REPEAT,
@@ -93,6 +98,7 @@ static inline void pmd_free(struct mm_st
 #define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
 #define pmd_free(mm, x)			do { } while (0)
 #define pgd_populate(mm, pmd, pte)	BUG()
+#define pgd_populate_kernel(mm, pmd, pte)	BUG()
 
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/include/asm/pgtable.h linux-2.6.32.60-pax/arch/parisc/include/asm/pgtable.h
--- linux-2.6.32.60/arch/parisc/include/asm/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/include/asm/pgtable.h	2012-03-13 13:15:34.320098033 +0100
@@ -207,6 +207,17 @@
 #define PAGE_EXECREAD   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_EXEC |_PAGE_ACCESSED)
 #define PAGE_COPY       PAGE_EXECREAD
 #define PAGE_RWX        __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_EXEC |_PAGE_ACCESSED)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+# define PAGE_SHARED_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_WRITE | _PAGE_ACCESSED)
+# define PAGE_COPY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+# define PAGE_READONLY_NOEXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | _PAGE_ACCESSED)
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 #define PAGE_KERNEL	__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_RO	__pgprot(_PAGE_KERNEL & ~_PAGE_WRITE)
 #define PAGE_KERNEL_UNC	__pgprot(_PAGE_KERNEL | _PAGE_NO_CACHE)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/kernel/module.c linux-2.6.32.60-pax/arch/parisc/kernel/module.c
--- linux-2.6.32.60/arch/parisc/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/kernel/module.c	2012-03-13 13:15:34.324098033 +0100
@@ -95,16 +95,38 @@
 
 /* three functions to determine where in the module core
  * or init pieces the location is */
+static inline int in_init_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rx &&
+		loc < (me->module_init_rx + me->init_size_rx));
+}
+
+static inline int in_init_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rw &&
+		loc < (me->module_init_rw + me->init_size_rw));
+}
+
 static inline int in_init(struct module *me, void *loc)
 {
-	return (loc >= me->module_init &&
-		loc <= (me->module_init + me->init_size));
+	return in_init_rx(me, loc) || in_init_rw(me, loc);
+}
+
+static inline int in_core_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rx &&
+		loc < (me->module_core_rx + me->core_size_rx));
+}
+
+static inline int in_core_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rw &&
+		loc < (me->module_core_rw + me->core_size_rw));
 }
 
 static inline int in_core(struct module *me, void *loc)
 {
-	return (loc >= me->module_core &&
-		loc <= (me->module_core + me->core_size));
+	return in_core_rx(me, loc) || in_core_rw(me, loc);
 }
 
 static inline int in_local(struct module *me, void *loc)
@@ -364,13 +386,13 @@ int module_frob_arch_sections(CONST Elf_
 	}
 
 	/* align things a bit */
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.got_offset = me->core_size;
-	me->core_size += gots * sizeof(struct got_entry);
-
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.fdesc_offset = me->core_size;
-	me->core_size += fdescs * sizeof(Elf_Fdesc);
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += gots * sizeof(struct got_entry);
+
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.fdesc_offset = me->core_size_rw;
+	me->core_size_rw += fdescs * sizeof(Elf_Fdesc);
 
 	me->arch.got_max = gots;
 	me->arch.fdesc_max = fdescs;
@@ -388,7 +410,7 @@ static Elf64_Word get_got(struct module
 
 	BUG_ON(value == 0);
 
-	got = me->module_core + me->arch.got_offset;
+	got = me->module_core_rw + me->arch.got_offset;
 	for (i = 0; got[i].addr; i++)
 		if (got[i].addr == value)
 			goto out;
@@ -406,7 +428,7 @@ static Elf64_Word get_got(struct module
 #ifdef CONFIG_64BIT
 static Elf_Addr get_fdesc(struct module *me, unsigned long value)
 {
-	Elf_Fdesc *fdesc = me->module_core + me->arch.fdesc_offset;
+	Elf_Fdesc *fdesc = me->module_core_rw + me->arch.fdesc_offset;
 
 	if (!value) {
 		printk(KERN_ERR "%s: zero OPD requested!\n", me->name);
@@ -424,7 +446,7 @@ static Elf_Addr get_fdesc(struct module
 
 	/* Create new one */
 	fdesc->addr = value;
-	fdesc->gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	fdesc->gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 	return (Elf_Addr)fdesc;
 }
 #endif /* CONFIG_64BIT */
@@ -848,7 +870,7 @@ register_unwind_table(struct module *me,
 
 	table = (unsigned char *)sechdrs[me->arch.unwind_section].sh_addr;
 	end = table + sechdrs[me->arch.unwind_section].sh_size;
-	gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 
 	DEBUGP("register_unwind_table(), sect = %d at 0x%p - 0x%p (gp=0x%lx)\n",
 	       me->arch.unwind_section, table, end, gp);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/kernel/sys_parisc.c linux-2.6.32.60-pax/arch/parisc/kernel/sys_parisc.c
--- linux-2.6.32.60/arch/parisc/kernel/sys_parisc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/kernel/sys_parisc.c	2012-03-13 13:15:34.324098033 +0100
@@ -43,7 +43,7 @@ static unsigned long get_unshared_area(u
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr)
 			return -ENOMEM;
-		if (!vma || addr + len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			return addr;
 		addr = vma->vm_end;
 	}
@@ -79,7 +79,7 @@ static unsigned long get_shared_area(str
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr)
 			return -ENOMEM;
-		if (!vma || addr + len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			return addr;
 		addr = DCACHE_ALIGN(vma->vm_end - offset) + offset;
 		if (addr < vma->vm_end) /* handle wraparound */
@@ -98,7 +98,7 @@ unsigned long arch_get_unmapped_area(str
 	if (flags & MAP_FIXED)
 		return addr;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (filp) {
 		addr = get_shared_area(filp->f_mapping, addr, len, pgoff);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/kernel/traps.c linux-2.6.32.60-pax/arch/parisc/kernel/traps.c
--- linux-2.6.32.60/arch/parisc/kernel/traps.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/kernel/traps.c	2012-03-13 13:15:34.324098033 +0100
@@ -733,9 +733,7 @@ void notrace handle_interruption(int cod
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/parisc/mm/fault.c linux-2.6.32.60-pax/arch/parisc/mm/fault.c
--- linux-2.6.32.60/arch/parisc/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/parisc/mm/fault.c	2012-03-13 13:15:34.328098033 +0100
@@ -15,6 +15,7 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -52,7 +53,7 @@ DEFINE_PER_CPU(struct exception_data, ex
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -138,6 +139,116 @@ parisc_acctyp(unsigned long code, unsign
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int *)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int *)addr);
+			err |= get_user(bv, (unsigned int *)(addr+4));
+			err |= get_user(ldw2, (unsigned int *)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int *)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int *)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 int fixup_exception(struct pt_regs *regs)
 {
 	const struct exception_table_entry *fix;
@@ -192,8 +303,33 @@ good_area:
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)instruction_pointer(regs), (void *)regs->gr[30]);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/elf.h linux-2.6.32.60-pax/arch/powerpc/include/asm/elf.h
--- linux-2.6.32.60/arch/powerpc/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/elf.h	2012-03-13 13:15:34.328098033 +0100
@@ -179,8 +179,19 @@ typedef elf_fpreg_t elf_vsrreghalf_t32[E
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
-extern unsigned long randomize_et_dyn(unsigned long base);
-#define ELF_ET_DYN_BASE		(randomize_et_dyn(0x20000000))
+#define ELF_ET_DYN_BASE		(0x20000000)
+
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(0x10000000UL)
+
+#ifdef __powerpc64__
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT) ? 16 : 28)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT) ? 16 : 28)
+#else
+#define PAX_DELTA_MMAP_LEN	15
+#define PAX_DELTA_STACK_LEN	15
+#endif
+#endif
 
 /*
  * Our registers are always unsigned longs, whether we're a 32 bit
@@ -275,9 +286,6 @@ extern int arch_setup_additional_pages(s
 	(0x7ff >> (PAGE_SHIFT - 12)) : \
 	(0x3ffff >> (PAGE_SHIFT - 12)))
 
-extern unsigned long arch_randomize_brk(struct mm_struct *mm);
-#define arch_randomize_brk arch_randomize_brk
-
 #endif /* __KERNEL__ */
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/kmap_types.h linux-2.6.32.60-pax/arch/powerpc/include/asm/kmap_types.h
--- linux-2.6.32.60/arch/powerpc/include/asm/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/kmap_types.h	2012-03-13 13:15:34.332098033 +0100
@@ -26,6 +26,7 @@ enum km_type {
 	KM_SOFTIRQ1,
 	KM_PPC_SYNC_PAGE,
 	KM_PPC_SYNC_ICACHE,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/page_64.h linux-2.6.32.60-pax/arch/powerpc/include/asm/page_64.h
--- linux-2.6.32.60/arch/powerpc/include/asm/page_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/page_64.h	2012-03-13 13:15:34.336098033 +0100
@@ -180,15 +180,18 @@ do {						\
  * stack by default, so in the absense of a PT_GNU_STACK program header
  * we turn execute permission off.
  */
-#define VM_STACK_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \
-					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_STACK_DEFAULT_FLAGS32 \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define VM_STACK_DEFAULT_FLAGS64	(VM_READ | VM_WRITE | \
 					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
+#ifndef CONFIG_PAX_PAGEEXEC
 #define VM_STACK_DEFAULT_FLAGS \
 	(test_thread_flag(TIF_32BIT) ? \
 	 VM_STACK_DEFAULT_FLAGS32 : VM_STACK_DEFAULT_FLAGS64)
+#endif
 
 #include <asm-generic/getorder.h>
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/page.h linux-2.6.32.60-pax/arch/powerpc/include/asm/page.h
--- linux-2.6.32.60/arch/powerpc/include/asm/page.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/page.h	2012-03-13 13:15:34.336098033 +0100
@@ -116,8 +116,9 @@ extern phys_addr_t kernstart_addr;
  * and needs to be executable.  This means the whole heap ends
  * up being executable.
  */
-#define VM_DATA_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_DATA_DEFAULT_FLAGS32 \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define VM_DATA_DEFAULT_FLAGS64	(VM_READ | VM_WRITE | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
@@ -145,6 +146,9 @@ extern phys_addr_t kernstart_addr;
 #define is_kernel_addr(x)	((x) >= PAGE_OFFSET)
 #endif
 
+#define ktla_ktva(addr)		(addr)
+#define ktva_ktla(addr)		(addr)
+
 #ifndef __ASSEMBLY__
 
 #undef STRICT_MM_TYPECHECKS
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/pgalloc-64.h linux-2.6.32.60-pax/arch/powerpc/include/asm/pgalloc-64.h
--- linux-2.6.32.60/arch/powerpc/include/asm/pgalloc-64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/pgalloc-64.h	2012-05-07 17:49:11.996114623 +0200
@@ -37,6 +37,7 @@ static inline void pgd_free(struct mm_st
 #ifndef CONFIG_PPC_64K_PAGES
 
 #define pgd_populate(MM, PGD, PUD)	pgd_set(PGD, PUD)
+#define pgd_populate_kernel(MM, PGD, PUD)	pgd_populate((MM), (PGD), (PUD))
 
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
@@ -54,6 +55,11 @@ static inline void pud_populate(struct m
 	pud_set(pud, (unsigned long)pmd);
 }
 
+static inline void pud_populate_kernel(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
+{
+	pud_populate(mm, pud, pmd);
+}
+
 #define pmd_populate(mm, pmd, pte_page) \
 	pmd_populate_kernel(mm, pmd, page_address(pte_page))
 #define pmd_populate_kernel(mm, pmd, pte) pmd_set(pmd, (unsigned long)(pte))
@@ -63,6 +69,7 @@ static inline void pud_populate(struct m
 #else /* CONFIG_PPC_64K_PAGES */
 
 #define pud_populate(mm, pud, pmd)	pud_set(pud, (unsigned long)pmd)
+#define pud_populate_kernel(mm, pud, pmd)	pud_populate((mm), (pud), (pmd))
 
 static inline void pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd,
 				       pte_t *pte)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/pgtable.h linux-2.6.32.60-pax/arch/powerpc/include/asm/pgtable.h
--- linux-2.6.32.60/arch/powerpc/include/asm/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/pgtable.h	2012-03-13 13:15:34.340098032 +0100
@@ -2,6 +2,7 @@
 #define _ASM_POWERPC_PGTABLE_H
 #ifdef __KERNEL__
 
+#include <linux/const.h>
 #ifndef __ASSEMBLY__
 #include <asm/processor.h>		/* For TASK_SIZE */
 #include <asm/mmu.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/pte-hash32.h linux-2.6.32.60-pax/arch/powerpc/include/asm/pte-hash32.h
--- linux-2.6.32.60/arch/powerpc/include/asm/pte-hash32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/pte-hash32.h	2012-03-13 13:15:34.340098032 +0100
@@ -21,6 +21,7 @@
 #define _PAGE_FILE	0x004	/* when !present: nonlinear file mapping */
 #define _PAGE_USER	0x004	/* usermode access allowed */
 #define _PAGE_GUARDED	0x008	/* G: prohibit speculative access */
+#define _PAGE_EXEC	_PAGE_GUARDED
 #define _PAGE_COHERENT	0x010	/* M: enforce memory coherence (SMP systems) */
 #define _PAGE_NO_CACHE	0x020	/* I: cache inhibit */
 #define _PAGE_WRITETHRU	0x040	/* W: cache write-through */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/reg.h linux-2.6.32.60-pax/arch/powerpc/include/asm/reg.h
--- linux-2.6.32.60/arch/powerpc/include/asm/reg.h	2012-10-09 11:00:35.424882462 +0200
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/reg.h	2012-10-09 11:00:39.224883019 +0200
@@ -191,6 +191,7 @@
 #define SPRN_DBCR	0x136	/* e300 Data Breakpoint Control Reg */
 #define SPRN_DSISR	0x012	/* Data Storage Interrupt Status Register */
 #define   DSISR_NOHPTE		0x40000000	/* no translation found */
+#define   DSISR_GUARDED		0x10000000	/* fetch from guarded storage */
 #define   DSISR_PROTFAULT	0x08000000	/* protection fault */
 #define   DSISR_ISSTORE		0x02000000	/* access was a store */
 #define   DSISR_DABRMATCH	0x00400000	/* hit data breakpoint */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/system.h linux-2.6.32.60-pax/arch/powerpc/include/asm/system.h
--- linux-2.6.32.60/arch/powerpc/include/asm/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/system.h	2012-03-13 13:15:34.344098032 +0100
@@ -531,7 +531,7 @@ __cmpxchg_local(volatile void *ptr, unsi
 #define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))
 #endif
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) ((x) & ~0xfUL)
 
 /* Used in very early kernel initialization. */
 extern unsigned long reloc_offset(void);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/include/asm/uaccess.h linux-2.6.32.60-pax/arch/powerpc/include/asm/uaccess.h
--- linux-2.6.32.60/arch/powerpc/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/include/asm/uaccess.h	2012-03-13 13:15:34.344098032 +0100
@@ -13,6 +13,8 @@
 #define VERIFY_READ	0
 #define VERIFY_WRITE	1
 
+extern void check_object_size(const void *ptr, unsigned long n, bool to);
+
 /*
  * The fs value determines whether argument validity checking should be
  * performed or not.  If get_fs() == USER_DS, checking is performed, with
@@ -327,52 +329,6 @@ do {								\
 extern unsigned long __copy_tofrom_user(void __user *to,
 		const void __user *from, unsigned long size);
 
-#ifndef __powerpc64__
-
-static inline unsigned long copy_from_user(void *to,
-		const void __user *from, unsigned long n)
-{
-	unsigned long over;
-
-	if (access_ok(VERIFY_READ, from, n))
-		return __copy_tofrom_user((__force void __user *)to, from, n);
-	if ((unsigned long)from < TASK_SIZE) {
-		over = (unsigned long)from + n - TASK_SIZE;
-		return __copy_tofrom_user((__force void __user *)to, from,
-				n - over) + over;
-	}
-	return n;
-}
-
-static inline unsigned long copy_to_user(void __user *to,
-		const void *from, unsigned long n)
-{
-	unsigned long over;
-
-	if (access_ok(VERIFY_WRITE, to, n))
-		return __copy_tofrom_user(to, (__force void __user *)from, n);
-	if ((unsigned long)to < TASK_SIZE) {
-		over = (unsigned long)to + n - TASK_SIZE;
-		return __copy_tofrom_user(to, (__force void __user *)from,
-				n - over) + over;
-	}
-	return n;
-}
-
-#else /* __powerpc64__ */
-
-#define __copy_in_user(to, from, size) \
-	__copy_tofrom_user((to), (from), (size))
-
-extern unsigned long copy_from_user(void *to, const void __user *from,
-				    unsigned long n);
-extern unsigned long copy_to_user(void __user *to, const void *from,
-				  unsigned long n);
-extern unsigned long copy_in_user(void __user *to, const void __user *from,
-				  unsigned long n);
-
-#endif /* __powerpc64__ */
-
 static inline unsigned long __copy_from_user_inatomic(void *to,
 		const void __user *from, unsigned long n)
 {
@@ -396,6 +352,10 @@ static inline unsigned long __copy_from_
 		if (ret == 0)
 			return 0;
 	}
+
+	if (!__builtin_constant_p(n))
+		check_object_size(to, n, false);
+
 	return __copy_tofrom_user((__force void __user *)to, from, n);
 }
 
@@ -422,6 +382,10 @@ static inline unsigned long __copy_to_us
 		if (ret == 0)
 			return 0;
 	}
+
+	if (!__builtin_constant_p(n))
+		check_object_size(from, n, true);
+
 	return __copy_tofrom_user(to, (__force const void __user *)from, n);
 }
 
@@ -439,6 +403,92 @@ static inline unsigned long __copy_to_us
 	return __copy_to_user_inatomic(to, from, size);
 }
 
+#ifndef __powerpc64__
+
+static inline unsigned long __must_check copy_from_user(void *to,
+		const void __user *from, unsigned long n)
+{
+	unsigned long over;
+
+	if ((long)n < 0)
+		return n;
+
+	if (access_ok(VERIFY_READ, from, n)) {
+		if (!__builtin_constant_p(n))
+			check_object_size(to, n, false);
+		return __copy_tofrom_user((__force void __user *)to, from, n);
+	}
+	if ((unsigned long)from < TASK_SIZE) {
+		over = (unsigned long)from + n - TASK_SIZE;
+		if (!__builtin_constant_p(n - over))
+			check_object_size(to, n - over, false);
+		return __copy_tofrom_user((__force void __user *)to, from,
+				n - over) + over;
+	}
+	return n;
+}
+
+static inline unsigned long __must_check copy_to_user(void __user *to,
+		const void *from, unsigned long n)
+{
+	unsigned long over;
+
+	if ((long)n < 0)
+		return n;
+
+	if (access_ok(VERIFY_WRITE, to, n)) {
+		if (!__builtin_constant_p(n))
+			check_object_size(from, n, true);
+		return __copy_tofrom_user(to, (__force void __user *)from, n);
+	}
+	if ((unsigned long)to < TASK_SIZE) {
+		over = (unsigned long)to + n - TASK_SIZE;
+		if (!__builtin_constant_p(n))
+			check_object_size(from, n - over, true);
+		return __copy_tofrom_user(to, (__force void __user *)from,
+				n - over) + over;
+	}
+	return n;
+}
+
+#else /* __powerpc64__ */
+
+#define __copy_in_user(to, from, size) \
+	__copy_tofrom_user((to), (from), (size))
+
+static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if ((long)n < 0 || n > INT_MAX)
+		return n;
+
+	if (!__builtin_constant_p(n))
+		check_object_size(to, n, false);
+
+	if (likely(access_ok(VERIFY_READ, from, n)))
+		n = __copy_from_user(to, from, n);
+	else
+		memset(to, 0, n);
+	return n;
+}
+
+static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if ((long)n < 0 || n > INT_MAX)
+		return n;
+
+	if (likely(access_ok(VERIFY_WRITE, to, n))) {
+		if (!__builtin_constant_p(n))
+			check_object_size(from, n, true);
+		n = __copy_to_user(to, from, n);
+	}
+	return n;
+}
+
+extern unsigned long copy_in_user(void __user *to, const void __user *from,
+				  unsigned long n);
+
+#endif /* __powerpc64__ */
+
 extern unsigned long __clear_user(void __user *addr, unsigned long size);
 
 static inline unsigned long clear_user(void __user *addr, unsigned long size)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/exceptions-64e.S linux-2.6.32.60-pax/arch/powerpc/kernel/exceptions-64e.S
--- linux-2.6.32.60/arch/powerpc/kernel/exceptions-64e.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/exceptions-64e.S	2012-03-13 13:15:34.344098032 +0100
@@ -455,6 +455,7 @@ storage_fault_common:
 	std	r14,_DAR(r1)
 	std	r15,_DSISR(r1)
 	addi	r3,r1,STACK_FRAME_OVERHEAD
+	bl	.save_nvgprs
 	mr	r4,r14
 	mr	r5,r15
 	ld	r14,PACA_EXGEN+EX_R14(r13)
@@ -464,8 +465,7 @@ storage_fault_common:
 	cmpdi	r3,0
 	bne-	1f
 	b	.ret_from_except_lite
-1:	bl	.save_nvgprs
-	mr	r5,r3
+1:	mr	r5,r3
 	addi	r3,r1,STACK_FRAME_OVERHEAD
 	ld	r4,_DAR(r1)
 	bl	.bad_page_fault
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/exceptions-64s.S linux-2.6.32.60-pax/arch/powerpc/kernel/exceptions-64s.S
--- linux-2.6.32.60/arch/powerpc/kernel/exceptions-64s.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/exceptions-64s.S	2012-03-13 13:15:34.344098032 +0100
@@ -818,10 +818,10 @@ handle_page_fault:
 11:	ld	r4,_DAR(r1)
 	ld	r5,_DSISR(r1)
 	addi	r3,r1,STACK_FRAME_OVERHEAD
+	bl	.save_nvgprs
 	bl	.do_page_fault
 	cmpdi	r3,0
 	beq+	13f
-	bl	.save_nvgprs
 	mr	r5,r3
 	addi	r3,r1,STACK_FRAME_OVERHEAD
 	lwz	r4,_DAR(r1)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/irq.c linux-2.6.32.60-pax/arch/powerpc/kernel/irq.c
--- linux-2.6.32.60/arch/powerpc/kernel/irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/irq.c	2012-03-13 13:15:34.348098032 +0100
@@ -490,9 +490,6 @@ struct irq_host *irq_alloc_host(struct d
 	host->ops = ops;
 	host->of_node = of_node_get(of_node);
 
-	if (host->ops->match == NULL)
-		host->ops->match = default_irq_host_match;
-
 	spin_lock_irqsave(&irq_big_lock, flags);
 
 	/* If it's a legacy controller, check for duplicates and
@@ -567,7 +564,12 @@ struct irq_host *irq_find_host(struct de
 	 */
 	spin_lock_irqsave(&irq_big_lock, flags);
 	list_for_each_entry(h, &irq_hosts, link)
-		if (h->ops->match(h, node)) {
+		if (h->ops->match) {
+			if (h->ops->match(h, node)) {
+				found = h;
+				break;
+			}
+		} else if (default_irq_host_match(h, node)) {
 			found = h;
 			break;
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/kgdb.c linux-2.6.32.60-pax/arch/powerpc/kernel/kgdb.c
--- linux-2.6.32.60/arch/powerpc/kernel/kgdb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/kgdb.c	2012-03-13 13:15:34.348098032 +0100
@@ -126,7 +126,7 @@ static int kgdb_handle_breakpoint(struct
 	if (kgdb_handle_exception(0, SIGTRAP, 0, regs) != 0)
 		return 0;
 
-	if (*(u32 *) (regs->nip) == *(u32 *) (&arch_kgdb_ops.gdb_bpt_instr))
+	if (*(u32 *) (regs->nip) == *(const u32 *) (&arch_kgdb_ops.gdb_bpt_instr))
 		regs->nip += 4;
 
 	return 1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/module_32.c linux-2.6.32.60-pax/arch/powerpc/kernel/module_32.c
--- linux-2.6.32.60/arch/powerpc/kernel/module_32.c	2012-10-09 11:00:35.424882462 +0200
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/module_32.c	2012-10-09 11:00:39.224883019 +0200
@@ -162,7 +162,7 @@ int module_frob_arch_sections(Elf32_Ehdr
 			me->arch.core_plt_section = i;
 	}
 	if (!me->arch.core_plt_section || !me->arch.init_plt_section) {
-		printk("Module doesn't contain .plt or .init.plt sections.\n");
+		printk("Module %s doesn't contain .plt or .init.plt sections.\n", me->name);
 		return -ENOEXEC;
 	}
 
@@ -203,11 +203,16 @@ static uint32_t do_plt_call(void *locati
 
 	DEBUGP("Doing plt for call to 0x%x at 0x%x\n", val, (unsigned int)location);
 	/* Init, or core PLT? */
-	if (location >= mod->module_core
-	    && location < mod->module_core + mod->core_size)
+	if ((location >= mod->module_core_rx && location < mod->module_core_rx + mod->core_size_rx) ||
+	    (location >= mod->module_core_rw && location < mod->module_core_rw + mod->core_size_rw))
 		entry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;
-	else
+	else if ((location >= mod->module_init_rx && location < mod->module_init_rx + mod->init_size_rx) ||
+		 (location >= mod->module_init_rw && location < mod->module_init_rw + mod->init_size_rw))
 		entry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;
+	else {
+		printk(KERN_ERR "%s: invalid R_PPC_REL24 entry found\n", mod->name);
+		return ~0UL;
+	}
 
 	/* Find this entry, or if that fails, the next avail. entry */
 	while (entry->jump[0]) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/module.c linux-2.6.32.60-pax/arch/powerpc/kernel/module.c
--- linux-2.6.32.60/arch/powerpc/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/module.c	2012-03-13 13:15:34.352098032 +0100
@@ -31,11 +31,24 @@
 
 LIST_HEAD(module_bug_list);
 
+#ifdef CONFIG_PAX_KERNEXEC
 void *module_alloc(unsigned long size)
 {
 	if (size == 0)
 		return NULL;
 
+	return vmalloc(size);
+}
+
+void *module_alloc_exec(unsigned long size)
+#else
+void *module_alloc(unsigned long size)
+#endif
+
+{
+	if (size == 0)
+		return NULL;
+
 	return vmalloc_exec(size);
 }
 
@@ -45,6 +58,13 @@ void module_free(struct module *mod, voi
 	vfree(module_region);
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+void module_free_exec(struct module *mod, void *module_region)
+{
+	module_free(mod, module_region);
+}
+#endif
+
 static const Elf_Shdr *find_section(const Elf_Ehdr *hdr,
 				    const Elf_Shdr *sechdrs,
 				    const char *name)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/process.c linux-2.6.32.60-pax/arch/powerpc/kernel/process.c
--- linux-2.6.32.60/arch/powerpc/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/process.c	2012-03-13 13:15:34.352098032 +0100
@@ -1134,58 +1134,3 @@ void thread_info_cache_init(void)
 }
 
 #endif /* THREAD_SHIFT < PAGE_SHIFT */
-
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() & ~PAGE_MASK;
-	return sp & ~0xf;
-}
-
-static inline unsigned long brk_rnd(void)
-{
-        unsigned long rnd = 0;
-
-	/* 8MB for 32bit, 1GB for 64bit */
-	if (is_32bit_task())
-		rnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));
-	else
-		rnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));
-
-	return rnd << PAGE_SHIFT;
-}
-
-unsigned long arch_randomize_brk(struct mm_struct *mm)
-{
-	unsigned long base = mm->brk;
-	unsigned long ret;
-
-#ifdef CONFIG_PPC_STD_MMU_64
-	/*
-	 * If we are using 1TB segments and we are allowed to randomise
-	 * the heap, we can put it above 1TB so it is backed by a 1TB
-	 * segment. Otherwise the heap will be in the bottom 1TB
-	 * which always uses 256MB segments and this may result in a
-	 * performance penalty.
-	 */
-	if (!is_32bit_task() && (mmu_highuser_ssize == MMU_SEGSIZE_1T))
-		base = max_t(unsigned long, mm->brk, 1UL << SID_SHIFT_1T);
-#endif
-
-	ret = PAGE_ALIGN(base + brk_rnd());
-
-	if (ret < mm->brk)
-		return mm->brk;
-
-	return ret;
-}
-
-unsigned long randomize_et_dyn(unsigned long base)
-{
-	unsigned long ret = PAGE_ALIGN(base + brk_rnd());
-
-	if (ret < base)
-		return base;
-
-	return ret;
-}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/signal_32.c linux-2.6.32.60-pax/arch/powerpc/kernel/signal_32.c
--- linux-2.6.32.60/arch/powerpc/kernel/signal_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/signal_32.c	2012-03-13 13:15:34.352098032 +0100
@@ -857,7 +857,7 @@ int handle_rt_signal32(unsigned long sig
 	/* Save user registers on the stack */
 	frame = &rt_sf->uc.uc_mcontext;
 	addr = frame;
-	if (vdso32_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso32_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		if (save_user_regs(regs, frame, 0, 1))
 			goto badframe;
 		regs->link = current->mm->context.vdso_base + vdso32_rt_sigtramp;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/signal_64.c linux-2.6.32.60-pax/arch/powerpc/kernel/signal_64.c
--- linux-2.6.32.60/arch/powerpc/kernel/signal_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/signal_64.c	2012-03-13 13:15:34.352098032 +0100
@@ -429,7 +429,7 @@ int handle_rt_signal64(int signr, struct
 	current->thread.fpscr.val = 0;
 
 	/* Set up to return from userspace. */
-	if (vdso64_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso64_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		regs->link = current->mm->context.vdso_base + vdso64_rt_sigtramp;
 	} else {
 		err |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/sys_ppc32.c linux-2.6.32.60-pax/arch/powerpc/kernel/sys_ppc32.c
--- linux-2.6.32.60/arch/powerpc/kernel/sys_ppc32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/sys_ppc32.c	2012-03-13 13:15:34.356098031 +0100
@@ -563,10 +563,10 @@ asmlinkage long compat_sys_sysctl(struct
 	if (oldlenp) {
 		if (!error) {
 			if (get_user(oldlen, oldlenp) ||
-			    put_user(oldlen, (compat_size_t __user *)compat_ptr(tmp.oldlenp)))
+			    put_user(oldlen, (compat_size_t __user *)compat_ptr(tmp.oldlenp)) ||
+			    copy_to_user(args->__unused, tmp.__unused, sizeof(tmp.__unused)))
 				error = -EFAULT;
 		}
-		copy_to_user(args->__unused, tmp.__unused, sizeof(tmp.__unused));
 	}
 	return error;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/vdso.c linux-2.6.32.60-pax/arch/powerpc/kernel/vdso.c
--- linux-2.6.32.60/arch/powerpc/kernel/vdso.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/vdso.c	2012-03-13 13:15:34.356098031 +0100
@@ -36,6 +36,7 @@
 #include <asm/firmware.h>
 #include <asm/vdso.h>
 #include <asm/vdso_datapage.h>
+#include <asm/mman.h>
 
 #include "setup.h"
 
@@ -220,7 +221,7 @@ int arch_setup_additional_pages(struct l
 	vdso_base = VDSO32_MBASE;
 #endif
 
-	current->mm->context.vdso_base = 0;
+	current->mm->context.vdso_base = ~0UL;
 
 	/* vDSO has a problem and was disabled, just don't "enable" it for the
 	 * process
@@ -240,7 +241,7 @@ int arch_setup_additional_pages(struct l
 	vdso_base = get_unmapped_area(NULL, vdso_base,
 				      (vdso_pages << PAGE_SHIFT) +
 				      ((VDSO_ALIGNMENT - 1) & PAGE_MASK),
-				      0, 0);
+				      0, MAP_PRIVATE | MAP_EXECUTABLE);
 	if (IS_ERR_VALUE(vdso_base)) {
 		rc = vdso_base;
 		goto fail_mmapsem;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/kernel/vio.c linux-2.6.32.60-pax/arch/powerpc/kernel/vio.c
--- linux-2.6.32.60/arch/powerpc/kernel/vio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/kernel/vio.c	2012-03-13 13:15:34.356098031 +0100
@@ -601,7 +601,7 @@ static void vio_dma_iommu_unmap_sg(struc
 	vio_cmo_dealloc(viodev, alloc_size);
 }
 
-struct dma_map_ops vio_dma_mapping_ops = {
+static struct dma_map_ops vio_dma_mapping_ops = {
 	.alloc_coherent = vio_dma_iommu_alloc_coherent,
 	.free_coherent  = vio_dma_iommu_free_coherent,
 	.map_sg         = vio_dma_iommu_map_sg,
@@ -857,7 +857,6 @@ static void vio_cmo_bus_remove(struct vi
 
 static void vio_cmo_set_dma_ops(struct vio_dev *viodev)
 {
-	vio_dma_mapping_ops.dma_supported = dma_iommu_ops.dma_supported;
 	viodev->dev.archdata.dma_ops = &vio_dma_mapping_ops;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/lib/usercopy_64.c linux-2.6.32.60-pax/arch/powerpc/lib/usercopy_64.c
--- linux-2.6.32.60/arch/powerpc/lib/usercopy_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/lib/usercopy_64.c	2012-03-13 13:15:34.360098031 +0100
@@ -9,22 +9,6 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 
-unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
-{
-	if (likely(access_ok(VERIFY_READ, from, n)))
-		n = __copy_from_user(to, from, n);
-	else
-		memset(to, 0, n);
-	return n;
-}
-
-unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
-{
-	if (likely(access_ok(VERIFY_WRITE, to, n)))
-		n = __copy_to_user(to, from, n);
-	return n;
-}
-
 unsigned long copy_in_user(void __user *to, const void __user *from,
 			   unsigned long n)
 {
@@ -35,7 +19,5 @@ unsigned long copy_in_user(void __user *
 	return n;
 }
 
-EXPORT_SYMBOL(copy_from_user);
-EXPORT_SYMBOL(copy_to_user);
 EXPORT_SYMBOL(copy_in_user);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/mm/fault.c linux-2.6.32.60-pax/arch/powerpc/mm/fault.c
--- linux-2.6.32.60/arch/powerpc/mm/fault.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/mm/fault.c	2012-03-13 13:15:34.360098031 +0100
@@ -30,6 +30,10 @@
 #include <linux/kprobes.h>
 #include <linux/kdebug.h>
 #include <linux/perf_event.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/unistd.h>
 
 #include <asm/firmware.h>
 #include <asm/page.h>
@@ -40,6 +44,7 @@
 #include <asm/uaccess.h>
 #include <asm/tlbflush.h>
 #include <asm/siginfo.h>
+#include <asm/ptrace.h>
 
 
 #ifdef CONFIG_KPROBES
@@ -64,6 +69,33 @@ static inline int notify_page_fault(stru
 }
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	return 1;
+}
+
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int __user *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -134,7 +166,7 @@ int __kprobes do_page_fault(struct pt_re
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (trap == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & DSISR_ISSTORE;
 #else
@@ -250,7 +282,7 @@ good_area:
          * "undefined".  Of those that can be set, this is the only
          * one which seems bad.
          */
-	if (error_code & 0x10000000)
+	if (error_code & DSISR_GUARDED)
                 /* Guarded storage error. */
 		goto bad_area;
 #endif /* CONFIG_8xx */
@@ -265,7 +297,7 @@ good_area:
 		 * processors use the same I/D cache coherency mechanism
 		 * as embedded.
 		 */
-		if (error_code & DSISR_PROTFAULT)
+		if (error_code & (DSISR_PROTFAULT | DSISR_GUARDED))
 			goto bad_area;
 #endif /* CONFIG_PPC_STD_MMU */
 
@@ -335,6 +367,23 @@ bad_area:
 bad_area_nosemaphore:
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+#ifdef CONFIG_PPC_STD_MMU
+			if (is_exec && (error_code & (DSISR_PROTFAULT | DSISR_GUARDED))) {
+#else
+			if (is_exec && regs->nip == address) {
+#endif
+				switch (pax_handle_fetch_fault(regs)) {
+				}
+
+				pax_report_fault(regs, (void *)regs->nip, (void *)regs->gpr[PT_R1]);
+				do_group_exit(SIGKILL);
+			}
+		}
+#endif
+
 		_exception(SIGSEGV, regs, code, address);
 		return 0;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/mm/mmap_64.c linux-2.6.32.60-pax/arch/powerpc/mm/mmap_64.c
--- linux-2.6.32.60/arch/powerpc/mm/mmap_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/mm/mmap_64.c	2013-02-17 17:05:31.728202501 +0100
@@ -65,6 +65,10 @@ static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (current->flags & PF_RANDOMIZE) {
 		/* 8MB for 32bit, 1GB for 64bit */
 		if (is_32bit_task())
@@ -99,10 +103,22 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/mm/slice.c linux-2.6.32.60-pax/arch/powerpc/mm/slice.c
--- linux-2.6.32.60/arch/powerpc/mm/slice.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/mm/slice.c	2012-03-13 13:15:34.360098031 +0100
@@ -98,7 +98,7 @@ static int slice_area_is_free(struct mm_
 	if ((mm->task_size - len) < addr)
 		return 0;
 	vma = find_vma(mm, addr);
-	return (!vma || (addr + len) <= vma->vm_start);
+	return check_heap_stack_gap(vma, addr, len);
 }
 
 static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
@@ -256,7 +256,7 @@ full_search:
 				addr = _ALIGN_UP(addr + 1,  1ul << SLICE_HIGH_SHIFT);
 			continue;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -313,10 +313,14 @@ static unsigned long slice_find_area_top
 		}
 	}
 
-	addr = mm->mmap_base;
-	while (addr > len) {
+	if (mm->mmap_base < len)
+		addr = -ENOMEM;
+	else
+		addr = mm->mmap_base - len;
+
+	while (!IS_ERR_VALUE(addr)) {
 		/* Go down by chunk size */
-		addr = _ALIGN_DOWN(addr - len, 1ul << pshift);
+		addr = _ALIGN_DOWN(addr, 1ul << pshift);
 
 		/* Check for hit with different page size */
 		mask = slice_range_to_mask(addr, len);
@@ -336,7 +340,7 @@ static unsigned long slice_find_area_top
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (!vma || (addr + len) <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/* remember the address as a hint for next time */
 			if (use_cache)
 				mm->free_area_cache = addr;
@@ -348,7 +352,7 @@ static unsigned long slice_find_area_top
 		        mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = vma->vm_start;
+		addr = skip_heap_stack_gap(vma, len);
 	}
 
 	/*
@@ -426,6 +430,11 @@ unsigned long slice_get_unmapped_area(un
 	if (fixed && addr > (mm->task_size - len))
 		return -EINVAL;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!fixed && (mm->pax_flags & MF_PAX_RANDMMAP))
+		addr = 0;
+#endif
+
 	/* If hint, make sure it matches our alignment restrictions */
 	if (!fixed && addr) {
 		addr = _ALIGN_UP(addr, 1ul << pshift);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/powerpc/platforms/pseries/Kconfig linux-2.6.32.60-pax/arch/powerpc/platforms/pseries/Kconfig
--- linux-2.6.32.60/arch/powerpc/platforms/pseries/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/powerpc/platforms/pseries/Kconfig	2012-03-13 13:15:34.364098031 +0100
@@ -2,6 +2,8 @@ config PPC_PSERIES
 	depends on PPC64 && PPC_BOOK3S
 	bool "IBM pSeries & new (POWER5-based) iSeries"
 	select MPIC
+	select PCI_MSI
+	select XICS
 	select PPC_I8259
 	select PPC_RTAS
 	select RTAS_ERROR_LOGGING
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/include/asm/atomic.h linux-2.6.32.60-pax/arch/s390/include/asm/atomic.h
--- linux-2.6.32.60/arch/s390/include/asm/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/include/asm/atomic.h	2012-03-13 13:15:34.364098031 +0100
@@ -362,6 +362,16 @@ static inline int atomic64_add_unless(at
 #define atomic64_dec_and_test(_v)	(atomic64_sub_return(1, _v) == 0)
 #define atomic64_inc_not_zero(v)	atomic64_add_unless((v), 1, 0)
 
+#define atomic64_read_unchecked(v)		atomic64_read(v)
+#define atomic64_set_unchecked(v, i)		atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v)		atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v)	atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v)		atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v)		atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v)	atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v)		atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n)	atomic64_cmpxchg((v), (o), (n))
+
 #define smp_mb__before_atomic_dec()	smp_mb()
 #define smp_mb__after_atomic_dec()	smp_mb()
 #define smp_mb__before_atomic_inc()	smp_mb()
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/include/asm/elf.h linux-2.6.32.60-pax/arch/s390/include/asm/elf.h
--- linux-2.6.32.60/arch/s390/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/include/asm/elf.h	2012-03-13 13:15:34.364098031 +0100
@@ -164,6 +164,13 @@ extern unsigned int vdso_enabled;
    that it will "exec", and that there is sufficient room for the brk.  */
 #define ELF_ET_DYN_BASE		(STACK_TOP / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_31BIT) ? 0x10000UL : 0x80000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_31BIT) ? 15 : 26)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_31BIT) ? 15 : 26)
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports. */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/include/asm/setup.h linux-2.6.32.60-pax/arch/s390/include/asm/setup.h
--- linux-2.6.32.60/arch/s390/include/asm/setup.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/include/asm/setup.h	2012-03-13 13:15:34.364098031 +0100
@@ -50,13 +50,13 @@ extern unsigned long memory_end;
 void detect_memory_layout(struct mem_chunk chunk[]);
 
 #ifdef CONFIG_S390_SWITCH_AMODE
-extern unsigned int switch_amode;
+#define switch_amode	(1)
 #else
 #define switch_amode	(0)
 #endif
 
 #ifdef CONFIG_S390_EXEC_PROTECT
-extern unsigned int s390_noexec;
+#define s390_noexec	(1)
 #else
 #define s390_noexec	(0)
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/include/asm/uaccess.h linux-2.6.32.60-pax/arch/s390/include/asm/uaccess.h
--- linux-2.6.32.60/arch/s390/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/include/asm/uaccess.h	2012-03-13 13:15:34.368098031 +0100
@@ -232,6 +232,10 @@ static inline unsigned long __must_check
 copy_to_user(void __user *to, const void *from, unsigned long n)
 {
 	might_fault();
+
+	if ((long)n < 0)
+		return n;
+
 	if (access_ok(VERIFY_WRITE, to, n))
 		n = __copy_to_user(to, from, n);
 	return n;
@@ -257,6 +261,9 @@ copy_to_user(void __user *to, const void
 static inline unsigned long __must_check
 __copy_from_user(void *to, const void __user *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	if (__builtin_constant_p(n) && (n <= 256))
 		return uaccess.copy_from_user_small(n, from, to);
 	else
@@ -283,6 +290,10 @@ static inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
 	might_fault();
+
+	if ((long)n < 0)
+		return n;
+
 	if (access_ok(VERIFY_READ, from, n))
 		n = __copy_from_user(to, from, n);
 	else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/Kconfig linux-2.6.32.60-pax/arch/s390/Kconfig
--- linux-2.6.32.60/arch/s390/Kconfig	2012-03-18 17:44:12.484058357 +0100
+++ linux-2.6.32.60-pax/arch/s390/Kconfig	2012-03-18 17:44:18.440057958 +0100
@@ -197,28 +197,26 @@ config AUDIT_ARCH
 
 config S390_SWITCH_AMODE
 	bool "Switch kernel/user addressing modes"
+	default y
 	help
 	  This option allows to switch the addressing modes of kernel and user
-	  space. The kernel parameter switch_amode=on will enable this feature,
-	  default is disabled. Enabling this (via kernel parameter) on machines
-	  earlier than IBM System z9-109 EC/BC will reduce system performance.
+	  space.  Enabling this on machines earlier than IBM System z9-109 EC/BC
+	  will reduce system performance.
 
 	  Note that this option will also be selected by selecting the execute
-	  protection option below. Enabling the execute protection via the
-	  noexec kernel parameter will also switch the addressing modes,
-	  independent of the switch_amode kernel parameter.
+	  protection option below. Enabling the execute protection will also
+	  switch the addressing modes, independent of this option.
 
 
 config S390_EXEC_PROTECT
 	bool "Data execute protection"
+	default y
 	select S390_SWITCH_AMODE
 	help
 	  This option allows to enable a buffer overflow protection for user
 	  space programs and it also selects the addressing mode option above.
-	  The kernel parameter noexec=on will enable this feature and also
-	  switch the addressing modes, default is disabled. Enabling this (via
-	  kernel parameter) on machines earlier than IBM System z9-109 EC/BC
-	  will reduce system performance.
+	  Enabling this on machines earlier than IBM System z9-109 EC/BC will
+	  reduce system performance.
 
 comment "Code generation options"
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/kernel/module.c linux-2.6.32.60-pax/arch/s390/kernel/module.c
--- linux-2.6.32.60/arch/s390/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/kernel/module.c	2012-03-13 13:15:34.368098031 +0100
@@ -166,11 +166,11 @@ module_frob_arch_sections(Elf_Ehdr *hdr,
 
 	/* Increase core size by size of got & plt and set start
 	   offsets for got and plt. */
-	me->core_size = ALIGN(me->core_size, 4);
-	me->arch.got_offset = me->core_size;
-	me->core_size += me->arch.got_size;
-	me->arch.plt_offset = me->core_size;
-	me->core_size += me->arch.plt_size;
+	me->core_size_rw = ALIGN(me->core_size_rw, 4);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += me->arch.got_size;
+	me->arch.plt_offset = me->core_size_rx;
+	me->core_size_rx += me->arch.plt_size;
 	return 0;
 }
 
@@ -256,7 +256,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		if (info->got_initialized == 0) {
 			Elf_Addr *gotent;
 
-			gotent = me->module_core + me->arch.got_offset +
+			gotent = me->module_core_rw + me->arch.got_offset +
 				info->got_offset;
 			*gotent = val;
 			info->got_initialized = 1;
@@ -280,7 +280,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		else if (r_type == R_390_GOTENT ||
 			 r_type == R_390_GOTPLTENT)
 			*(unsigned int *) loc =
-				(val + (Elf_Addr) me->module_core - loc) >> 1;
+				(val + (Elf_Addr) me->module_core_rw - loc) >> 1;
 		else if (r_type == R_390_GOT64 ||
 			 r_type == R_390_GOTPLT64)
 			*(unsigned long *) loc = val;
@@ -294,7 +294,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_PLTOFF64:	/* 16 bit offset from GOT to PLT. */
 		if (info->plt_initialized == 0) {
 			unsigned int *ip;
-			ip = me->module_core + me->arch.plt_offset +
+			ip = me->module_core_rx + me->arch.plt_offset +
 				info->plt_offset;
 #ifndef CONFIG_64BIT
 			ip[0] = 0x0d105810; /* basr 1,0; l 1,6(1); br 1 */
@@ -319,7 +319,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 			       val - loc + 0xffffUL < 0x1ffffeUL) ||
 			      (r_type == R_390_PLT32DBL &&
 			       val - loc + 0xffffffffULL < 0x1fffffffeULL)))
-				val = (Elf_Addr) me->module_core +
+				val = (Elf_Addr) me->module_core_rx +
 					me->arch.plt_offset +
 					info->plt_offset;
 			val += rela->r_addend - loc;
@@ -341,7 +341,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_GOTOFF32:	/* 32 bit offset to GOT.  */
 	case R_390_GOTOFF64:	/* 64 bit offset to GOT. */
 		val = val + rela->r_addend -
-			((Elf_Addr) me->module_core + me->arch.got_offset);
+			((Elf_Addr) me->module_core_rw + me->arch.got_offset);
 		if (r_type == R_390_GOTOFF16)
 			*(unsigned short *) loc = val;
 		else if (r_type == R_390_GOTOFF32)
@@ -351,7 +351,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		break;
 	case R_390_GOTPC:	/* 32 bit PC relative offset to GOT. */
 	case R_390_GOTPCDBL:	/* 32 bit PC rel. off. to GOT shifted by 1. */
-		val = (Elf_Addr) me->module_core + me->arch.got_offset +
+		val = (Elf_Addr) me->module_core_rw + me->arch.got_offset +
 			rela->r_addend - loc;
 		if (r_type == R_390_GOTPC)
 			*(unsigned int *) loc = val;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/kernel/setup.c linux-2.6.32.60-pax/arch/s390/kernel/setup.c
--- linux-2.6.32.60/arch/s390/kernel/setup.c	2012-03-18 17:44:12.472058990 +0100
+++ linux-2.6.32.60-pax/arch/s390/kernel/setup.c	2012-03-18 17:44:18.424057492 +0100
@@ -307,9 +307,6 @@ static int __init early_parse_mem(char *
 early_param("mem", early_parse_mem);
 
 #ifdef CONFIG_S390_SWITCH_AMODE
-unsigned int switch_amode = 0;
-EXPORT_SYMBOL_GPL(switch_amode);
-
 static int set_amode_and_uaccess(unsigned long user_amode,
 				 unsigned long user32_amode)
 {
@@ -335,17 +332,6 @@ static int set_amode_and_uaccess(unsigne
 		return 0;
 	}
 }
-
-/*
- * Switch kernel/user addressing modes?
- */
-static int __init early_parse_switch_amode(char *p)
-{
-	switch_amode = 1;
-	return 0;
-}
-early_param("switch_amode", early_parse_switch_amode);
-
 #else /* CONFIG_S390_SWITCH_AMODE */
 static inline int set_amode_and_uaccess(unsigned long user_amode,
 					unsigned long user32_amode)
@@ -354,24 +340,6 @@ static inline int set_amode_and_uaccess(
 }
 #endif /* CONFIG_S390_SWITCH_AMODE */
 
-#ifdef CONFIG_S390_EXEC_PROTECT
-unsigned int s390_noexec = 0;
-EXPORT_SYMBOL_GPL(s390_noexec);
-
-/*
- * Enable execute protection?
- */
-static int __init early_parse_noexec(char *p)
-{
-	if (!strncmp(p, "off", 3))
-		return 0;
-	switch_amode = 1;
-	s390_noexec = 1;
-	return 0;
-}
-early_param("noexec", early_parse_noexec);
-#endif /* CONFIG_S390_EXEC_PROTECT */
-
 static void setup_addressing_mode(void)
 {
 	if (s390_noexec) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/s390/mm/mmap.c linux-2.6.32.60-pax/arch/s390/mm/mmap.c
--- linux-2.6.32.60/arch/s390/mm/mmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/s390/mm/mmap.c	2012-03-13 13:15:34.372098031 +0100
@@ -78,10 +78,22 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
@@ -153,10 +165,22 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = s390_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = s390_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/score/include/asm/system.h linux-2.6.32.60-pax/arch/score/include/asm/system.h
--- linux-2.6.32.60/arch/score/include/asm/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/score/include/asm/system.h	2012-03-13 13:15:34.372098031 +0100
@@ -17,7 +17,7 @@ do {								\
 #define finish_arch_switch(prev)	do {} while (0)
 
 typedef void (*vi_handler_t)(void);
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) (x)
 
 #define mb()		barrier()
 #define rmb()		barrier()
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/score/kernel/process.c linux-2.6.32.60-pax/arch/score/kernel/process.c
--- linux-2.6.32.60/arch/score/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/score/kernel/process.c	2012-03-13 13:15:34.372098031 +0100
@@ -161,8 +161,3 @@ unsigned long get_wchan(struct task_stru
 
 	return task_pt_regs(task)->cp0_epc;
 }
-
-unsigned long arch_align_stack(unsigned long sp)
-{
-	return sp;
-}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sh/mm/mmap.c linux-2.6.32.60-pax/arch/sh/mm/mmap.c
--- linux-2.6.32.60/arch/sh/mm/mmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sh/mm/mmap.c	2012-03-13 13:15:34.372098031 +0100
@@ -74,8 +74,7 @@ unsigned long arch_get_unmapped_area(str
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 
@@ -106,7 +105,7 @@ full_search:
 			}
 			return -ENOMEM;
 		}
-		if (likely(!vma || addr + len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -157,8 +156,7 @@ arch_get_unmapped_area_topdown(struct fi
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 
@@ -179,7 +177,7 @@ arch_get_unmapped_area_topdown(struct fi
 	/* make sure it can fit in the remaining address space */
 	if (likely(addr > len)) {
 		vma = find_vma(mm, addr-len);
-		if (!vma || addr <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr - len, len)) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr-len);
 		}
@@ -188,18 +186,18 @@ arch_get_unmapped_area_topdown(struct fi
 	if (unlikely(mm->mmap_base < len))
 		goto bottomup;
 
-	addr = mm->mmap_base-len;
-	if (do_colour_align)
-		addr = COLOUR_ALIGN_DOWN(addr, pgoff);
+	addr = mm->mmap_base - len;
 
 	do {
+		if (do_colour_align)
+			addr = COLOUR_ALIGN_DOWN(addr, pgoff);
 		/*
 		 * Lookup failure means no vma is above this address,
 		 * else if new region fits below vma->vm_start,
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (likely(!vma || addr+len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr);
 		}
@@ -209,10 +207,8 @@ arch_get_unmapped_area_topdown(struct fi
 		        mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = vma->vm_start-len;
-		if (do_colour_align)
-			addr = COLOUR_ALIGN_DOWN(addr, pgoff);
-	} while (likely(len < vma->vm_start));
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 bottomup:
 	/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/atomic_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/atomic_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/atomic_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/atomic_32.h	2012-03-13 13:15:34.372098031 +0100
@@ -13,6 +13,8 @@
 
 #include <linux/types.h>
 
+#include <asm-generic/atomic64.h>
+
 #ifdef __KERNEL__
 
 #include <asm/system.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/atomic_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/atomic_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/atomic_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/atomic_64.h	2012-03-13 13:15:34.376098030 +0100
@@ -14,18 +14,40 @@
 #define ATOMIC64_INIT(i)	{ (i) }
 
 #define atomic_read(v)		((v)->counter)
+static inline int atomic_read_unchecked(const atomic_unchecked_t *v)
+{
+	return v->counter;
+}
 #define atomic64_read(v)	((v)->counter)
+static inline long atomic64_read_unchecked(const atomic64_unchecked_t *v)
+{
+	return v->counter;
+}
 
 #define atomic_set(v, i)	(((v)->counter) = i)
+static inline void atomic_set_unchecked(atomic_unchecked_t *v, int i)
+{
+	v->counter = i;
+}
 #define atomic64_set(v, i)	(((v)->counter) = i)
+static inline void atomic64_set_unchecked(atomic64_unchecked_t *v, long i)
+{
+	v->counter = i;
+}
 
 extern void atomic_add(int, atomic_t *);
+extern void atomic_add_unchecked(int, atomic_unchecked_t *);
 extern void atomic64_add(long, atomic64_t *);
+extern void atomic64_add_unchecked(long, atomic64_unchecked_t *);
 extern void atomic_sub(int, atomic_t *);
+extern void atomic_sub_unchecked(int, atomic_unchecked_t *);
 extern void atomic64_sub(long, atomic64_t *);
+extern void atomic64_sub_unchecked(long, atomic64_unchecked_t *);
 
 extern int atomic_add_ret(int, atomic_t *);
+extern int atomic_add_ret_unchecked(int, atomic_unchecked_t *);
 extern long atomic64_add_ret(long, atomic64_t *);
+extern long atomic64_add_ret_unchecked(long, atomic64_unchecked_t *);
 extern int atomic_sub_ret(int, atomic_t *);
 extern long atomic64_sub_ret(long, atomic64_t *);
 
@@ -33,13 +55,29 @@ extern long atomic64_sub_ret(long, atomi
 #define atomic64_dec_return(v) atomic64_sub_ret(1, v)
 
 #define atomic_inc_return(v) atomic_add_ret(1, v)
+static inline int atomic_inc_return_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_add_ret_unchecked(1, v);
+}
 #define atomic64_inc_return(v) atomic64_add_ret(1, v)
+static inline long atomic64_inc_return_unchecked(atomic64_unchecked_t *v)
+{
+	return atomic64_add_ret_unchecked(1, v);
+}
 
 #define atomic_sub_return(i, v) atomic_sub_ret(i, v)
 #define atomic64_sub_return(i, v) atomic64_sub_ret(i, v)
 
 #define atomic_add_return(i, v) atomic_add_ret(i, v)
+static inline int atomic_add_return_unchecked(int i, atomic_unchecked_t *v)
+{
+	return atomic_add_ret_unchecked(i, v);
+}
 #define atomic64_add_return(i, v) atomic64_add_ret(i, v)
+static inline long atomic64_add_return_unchecked(long i, atomic64_unchecked_t *v)
+{
+	return atomic64_add_ret_unchecked(i, v);
+}
 
 /*
  * atomic_inc_and_test - increment and test
@@ -50,6 +88,10 @@ extern long atomic64_sub_ret(long, atomi
  * other cases.
  */
 #define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
+static inline int atomic_inc_and_test_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_inc_return_unchecked(v) == 0;
+}
 #define atomic64_inc_and_test(v) (atomic64_inc_return(v) == 0)
 
 #define atomic_sub_and_test(i, v) (atomic_sub_ret(i, v) == 0)
@@ -59,30 +101,65 @@ extern long atomic64_sub_ret(long, atomi
 #define atomic64_dec_and_test(v) (atomic64_sub_ret(1, v) == 0)
 
 #define atomic_inc(v) atomic_add(1, v)
+static inline void atomic_inc_unchecked(atomic_unchecked_t *v)
+{
+	atomic_add_unchecked(1, v);
+}
 #define atomic64_inc(v) atomic64_add(1, v)
+static inline void atomic64_inc_unchecked(atomic64_unchecked_t *v)
+{
+	atomic64_add_unchecked(1, v);
+}
 
 #define atomic_dec(v) atomic_sub(1, v)
+static inline void atomic_dec_unchecked(atomic_unchecked_t *v)
+{
+	atomic_sub_unchecked(1, v);
+}
 #define atomic64_dec(v) atomic64_sub(1, v)
+static inline void atomic64_dec_unchecked(atomic64_unchecked_t *v)
+{
+	atomic64_sub_unchecked(1, v);
+}
 
 #define atomic_add_negative(i, v) (atomic_add_ret(i, v) < 0)
 #define atomic64_add_negative(i, v) (atomic64_add_ret(i, v) < 0)
 
 #define atomic_cmpxchg(v, o, n) (cmpxchg(&((v)->counter), (o), (n)))
+static inline int atomic_cmpxchg_unchecked(atomic_unchecked_t *v, int old, int new)
+{
+	return cmpxchg(&v->counter, old, new);
+}
 #define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+static inline int atomic_xchg_unchecked(atomic_unchecked_t *v, int new)
+{
+	return xchg(&v->counter, new);
+}
 
 static inline int atomic_add_unless(atomic_t *v, int a, int u)
 {
-	int c, old;
+	int c, old, new;
 	c = atomic_read(v);
 	for (;;) {
-		if (unlikely(c == (u)))
+		if (unlikely(c == u))
 			break;
-		old = atomic_cmpxchg((v), c, c + (a));
+
+		asm volatile("addcc %2, %0, %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+			     "tvs %%icc, 6\n"
+#endif
+
+			     : "=r" (new)
+			     : "0" (c), "ir" (a)
+			     : "cc");
+
+		old = atomic_cmpxchg(v, c, new);
 		if (likely(old == c))
 			break;
 		c = old;
 	}
-	return c != (u);
+	return c != u;
 }
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
@@ -90,20 +167,35 @@ static inline int atomic_add_unless(atom
 #define atomic64_cmpxchg(v, o, n) \
 	((__typeof__((v)->counter))cmpxchg(&((v)->counter), (o), (n)))
 #define atomic64_xchg(v, new) (xchg(&((v)->counter), new))
+static inline long atomic64_xchg_unchecked(atomic64_unchecked_t *v, long new)
+{
+	return xchg(&v->counter, new);
+}
 
 static inline long atomic64_add_unless(atomic64_t *v, long a, long u)
 {
-	long c, old;
+	long c, old, new;
 	c = atomic64_read(v);
 	for (;;) {
-		if (unlikely(c == (u)))
+		if (unlikely(c == u))
 			break;
-		old = atomic64_cmpxchg((v), c, c + (a));
+
+		asm volatile("addcc %2, %0, %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+			     "tvs %%xcc, 6\n"
+#endif
+
+			     : "=r" (new)
+			     : "0" (c), "ir" (a)
+			     : "cc");
+
+		old = atomic64_cmpxchg(v, c, new);
 		if (likely(old == c))
 			break;
 		c = old;
 	}
-	return c != (u);
+	return c != u;
 }
 
 #define atomic64_inc_not_zero(v) atomic64_add_unless((v), 1, 0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/cache.h linux-2.6.32.60-pax/arch/sparc/include/asm/cache.h
--- linux-2.6.32.60/arch/sparc/include/asm/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/cache.h	2012-03-13 13:15:34.376098030 +0100
@@ -8,7 +8,7 @@
 #define _SPARC_CACHE_H
 
 #define L1_CACHE_SHIFT 5
-#define L1_CACHE_BYTES 32
+#define L1_CACHE_BYTES 32UL
 #define L1_CACHE_ALIGN(x) ((((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1)))
 
 #ifdef CONFIG_SPARC32
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/elf_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/elf_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/elf_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/elf_32.h	2012-03-13 13:15:34.376098030 +0100
@@ -116,6 +116,13 @@ typedef struct {
 
 #define ELF_ET_DYN_BASE         (TASK_UNMAPPED_BASE)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	0x10000UL
+
+#define PAX_DELTA_MMAP_LEN	16
+#define PAX_DELTA_STACK_LEN	16
+#endif
+
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This can NOT be done in userspace
    on Sparc.  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/elf_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/elf_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/elf_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/elf_64.h	2012-03-13 13:15:34.376098030 +0100
@@ -163,6 +163,12 @@ typedef struct {
 #define ELF_ET_DYN_BASE		0x0000010000000000UL
 #define COMPAT_ELF_ET_DYN_BASE	0x0000000070000000UL
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT) ? 0x10000UL : 0x100000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT) ? 14 : 28)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT) ? 15 : 29)
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/page_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/page_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/page_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/page_32.h	2012-03-13 13:15:34.380098030 +0100
@@ -8,6 +8,8 @@
 #ifndef _SPARC_PAGE_H
 #define _SPARC_PAGE_H
 
+#include <linux/const.h>
+
 #define PAGE_SHIFT   12
 
 #ifndef __ASSEMBLY__
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/pgalloc_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/pgalloc_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/pgalloc_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/pgalloc_32.h	2012-05-07 17:49:12.028114621 +0200
@@ -37,6 +37,7 @@ BTFIXUPDEF_CALL(void, free_pgd_fast, pgd
 BTFIXUPDEF_CALL(void, pgd_set, pgd_t *, pmd_t *)
 #define pgd_set(pgdp,pmdp) BTFIXUP_CALL(pgd_set)(pgdp,pmdp)
 #define pgd_populate(MM, PGD, PMD)      pgd_set(PGD, PMD)
+#define pgd_populate_kernel(MM, PGD, PMD)      pgd_populate((MM), (PGD), (PMD))
 
 BTFIXUPDEF_CALL(pmd_t *, pmd_alloc_one, struct mm_struct *, unsigned long)
 #define pmd_alloc_one(mm, address)	BTFIXUP_CALL(pmd_alloc_one)(mm, address)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/pgalloc_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/pgalloc_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/pgalloc_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/pgalloc_64.h	2012-05-07 17:49:12.028114621 +0200
@@ -25,6 +25,7 @@ static inline void pgd_free(struct mm_st
 }
 
 #define pud_populate(MM, PUD, PMD)	pud_set(PUD, PMD)
+#define pud_populate_kernel(MM, PUD, PMD)	pud_populate((MM), (PUD), (PMD))
 
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/pgtable_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/pgtable_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/pgtable_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/pgtable_32.h	2012-03-13 13:15:34.380098030 +0100
@@ -43,6 +43,13 @@ BTFIXUPDEF_SIMM13(user_ptrs_per_pgd)
 BTFIXUPDEF_INT(page_none)
 BTFIXUPDEF_INT(page_copy)
 BTFIXUPDEF_INT(page_readonly)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+BTFIXUPDEF_INT(page_shared_noexec)
+BTFIXUPDEF_INT(page_copy_noexec)
+BTFIXUPDEF_INT(page_readonly_noexec)
+#endif
+
 BTFIXUPDEF_INT(page_kernel)
 
 #define PMD_SHIFT		SUN4C_PMD_SHIFT
@@ -64,6 +71,16 @@ extern pgprot_t PAGE_SHARED;
 #define PAGE_COPY      __pgprot(BTFIXUP_INT(page_copy))
 #define PAGE_READONLY  __pgprot(BTFIXUP_INT(page_readonly))
 
+#ifdef CONFIG_PAX_PAGEEXEC
+extern pgprot_t PAGE_SHARED_NOEXEC;
+# define PAGE_COPY_NOEXEC	__pgprot(BTFIXUP_INT(page_copy_noexec))
+# define PAGE_READONLY_NOEXEC	__pgprot(BTFIXUP_INT(page_readonly_noexec))
+#else
+# define PAGE_SHARED_NOEXEC	PAGE_SHARED
+# define PAGE_COPY_NOEXEC	PAGE_COPY
+# define PAGE_READONLY_NOEXEC	PAGE_READONLY
+#endif
+
 extern unsigned long page_kernel;
 
 #ifdef MODULE
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/pgtsrmmu.h linux-2.6.32.60-pax/arch/sparc/include/asm/pgtsrmmu.h
--- linux-2.6.32.60/arch/sparc/include/asm/pgtsrmmu.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/pgtsrmmu.h	2012-03-13 13:15:34.380098030 +0100
@@ -115,6 +115,13 @@
 				    SRMMU_EXEC | SRMMU_REF)
 #define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \
 				    SRMMU_EXEC | SRMMU_REF)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+#define SRMMU_PAGE_SHARED_NOEXEC	__pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_WRITE | SRMMU_REF)
+#define SRMMU_PAGE_COPY_NOEXEC	__pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_REF)
+#define SRMMU_PAGE_RDONLY_NOEXEC	__pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_REF)
+#endif
+
 #define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \
 				    SRMMU_DIRTY | SRMMU_REF)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/spinlock_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/spinlock_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/spinlock_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/spinlock_64.h	2012-03-13 13:15:34.380098030 +0100
@@ -92,14 +92,19 @@ static inline void __raw_spin_lock_flags
 
 /* Multi-reader locks, these are much saner than the 32-bit Sparc ones... */
 
-static void inline arch_read_lock(raw_rwlock_t *lock)
+static inline void arch_read_lock(raw_rwlock_t *lock)
 {
 	unsigned long tmp1, tmp2;
 
 	__asm__ __volatile__ (
 "1:	ldsw		[%2], %0\n"
 "	brlz,pn		%0, 2f\n"
-"4:	 add		%0, 1, %1\n"
+"4:	 addcc		%0, 1, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	tvs		%%icc, 6\n"
+#endif
+
 "	cas		[%2], %0, %1\n"
 "	cmp		%0, %1\n"
 "	bne,pn		%%icc, 1b\n"
@@ -112,7 +117,7 @@ static void inline arch_read_lock(raw_rw
 "	.previous"
 	: "=&r" (tmp1), "=&r" (tmp2)
 	: "r" (lock)
-	: "memory");
+	: "memory", "cc");
 }
 
 static int inline arch_read_trylock(raw_rwlock_t *lock)
@@ -123,7 +128,12 @@ static int inline arch_read_trylock(raw_
 "1:	ldsw		[%2], %0\n"
 "	brlz,a,pn	%0, 2f\n"
 "	 mov		0, %0\n"
-"	add		%0, 1, %1\n"
+"	addcc		%0, 1, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	tvs		%%icc, 6\n"
+#endif
+
 "	cas		[%2], %0, %1\n"
 "	cmp		%0, %1\n"
 "	bne,pn		%%icc, 1b\n"
@@ -136,13 +146,18 @@ static int inline arch_read_trylock(raw_
 	return tmp1;
 }
 
-static void inline arch_read_unlock(raw_rwlock_t *lock)
+static inline void arch_read_unlock(raw_rwlock_t *lock)
 {
 	unsigned long tmp1, tmp2;
 
 	__asm__ __volatile__(
 "1:	lduw	[%2], %0\n"
-"	sub	%0, 1, %1\n"
+"	subcc	%0, 1, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+"	tvs	%%icc, 6\n"
+#endif
+
 "	cas	[%2], %0, %1\n"
 "	cmp	%0, %1\n"
 "	bne,pn	%%xcc, 1b\n"
@@ -152,7 +167,7 @@ static void inline arch_read_unlock(raw_
 	: "memory");
 }
 
-static void inline arch_write_lock(raw_rwlock_t *lock)
+static inline void arch_write_lock(raw_rwlock_t *lock)
 {
 	unsigned long mask, tmp1, tmp2;
 
@@ -177,7 +192,7 @@ static void inline arch_write_lock(raw_r
 	: "memory");
 }
 
-static void inline arch_write_unlock(raw_rwlock_t *lock)
+static inline void arch_write_unlock(raw_rwlock_t *lock)
 {
 	__asm__ __volatile__(
 "	stw		%%g0, [%0]"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/thread_info_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/thread_info_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/thread_info_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/thread_info_32.h	2012-03-13 13:15:34.384098030 +0100
@@ -50,6 +50,8 @@ struct thread_info {
 	unsigned long		w_saved;
 
 	struct restart_block	restart_block;
+
+	unsigned long		lowest_stack;
 };
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/thread_info_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/thread_info_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/thread_info_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/thread_info_64.h	2012-03-13 13:15:34.384098030 +0100
@@ -68,6 +68,8 @@ struct thread_info {
 	struct pt_regs		*kern_una_regs;
 	unsigned int		kern_una_insn;
 
+	unsigned long		lowest_stack;
+
 	unsigned long		fpregs[0] __attribute__ ((aligned(64)));
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/uaccess_32.h linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess_32.h
--- linux-2.6.32.60/arch/sparc/include/asm/uaccess_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess_32.h	2012-03-13 13:15:34.384098030 +0100
@@ -249,27 +249,46 @@ extern unsigned long __copy_user(void __
 
 static inline unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
 {
-	if (n && __access_ok((unsigned long) to, n))
+	if ((long)n < 0)
+		return n;
+
+	if (n && __access_ok((unsigned long) to, n)) {
+		if (!__builtin_constant_p(n))
+			check_object_size(from, n, true);
 		return __copy_user(to, (__force void __user *) from, n);
-	else
+	} else
 		return n;
 }
 
 static inline unsigned long __copy_to_user(void __user *to, const void *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
+	if (!__builtin_constant_p(n))
+		check_object_size(from, n, true);
+
 	return __copy_user(to, (__force void __user *) from, n);
 }
 
 static inline unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
 {
-	if (n && __access_ok((unsigned long) from, n))
+	if ((long)n < 0)
+		return n;
+
+	if (n && __access_ok((unsigned long) from, n)) {
+		if (!__builtin_constant_p(n))
+			check_object_size(to, n, false);
 		return __copy_user((__force void __user *) to, from, n);
-	else
+	} else
 		return n;
 }
 
 static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	return __copy_user((__force void __user *) to, from, n);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/uaccess_64.h linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess_64.h
--- linux-2.6.32.60/arch/sparc/include/asm/uaccess_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess_64.h	2012-03-13 13:15:34.384098030 +0100
@@ -9,6 +9,7 @@
 #include <linux/compiler.h>
 #include <linux/string.h>
 #include <linux/thread_info.h>
+#include <linux/kernel.h>
 #include <asm/asi.h>
 #include <asm/system.h>
 #include <asm/spitfire.h>
@@ -212,8 +213,15 @@ extern unsigned long copy_from_user_fixu
 static inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long size)
 {
-	unsigned long ret = ___copy_from_user(to, from, size);
+	unsigned long ret;
 
+	if ((long)size < 0 || size > INT_MAX)
+		return size;
+
+	if (!__builtin_constant_p(size))
+		check_object_size(to, size, false);
+
+	ret = ___copy_from_user(to, from, size);
 	if (unlikely(ret))
 		ret = copy_from_user_fixup(to, from, size);
 	return ret;
@@ -228,8 +236,15 @@ extern unsigned long copy_to_user_fixup(
 static inline unsigned long __must_check
 copy_to_user(void __user *to, const void *from, unsigned long size)
 {
-	unsigned long ret = ___copy_to_user(to, from, size);
+	unsigned long ret;
+
+	if ((long)size < 0 || size > INT_MAX)
+		return size;
+
+	if (!__builtin_constant_p(size))
+		check_object_size(from, size, true);
 
+	ret = ___copy_to_user(to, from, size);
 	if (unlikely(ret))
 		ret = copy_to_user_fixup(to, from, size);
 	return ret;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/include/asm/uaccess.h linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess.h
--- linux-2.6.32.60/arch/sparc/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/include/asm/uaccess.h	2012-03-13 13:15:34.388098030 +0100
@@ -1,5 +1,13 @@
 #ifndef ___ASM_SPARC_UACCESS_H
 #define ___ASM_SPARC_UACCESS_H
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+extern void check_object_size(const void *ptr, unsigned long n, bool to);
+#endif
+#endif
+
 #if defined(__sparc__) && defined(__arch64__)
 #include <asm/uaccess_64.h>
 #else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/Kconfig linux-2.6.32.60-pax/arch/sparc/Kconfig
--- linux-2.6.32.60/arch/sparc/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/Kconfig	2012-03-13 13:15:34.388098030 +0100
@@ -32,6 +32,7 @@ config SPARC
 
 config SPARC32
 	def_bool !64BIT
+	select GENERIC_ATOMIC64
 
 config SPARC64
 	def_bool 64BIT
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/kernel/Makefile linux-2.6.32.60-pax/arch/sparc/kernel/Makefile
--- linux-2.6.32.60/arch/sparc/kernel/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/kernel/Makefile	2012-03-13 13:15:34.388098030 +0100
@@ -3,7 +3,7 @@
 #
 
 asflags-y := -ansi
-ccflags-y := -Werror
+#ccflags-y := -Werror
 
 extra-y     := head_$(BITS).o
 extra-y     += init_task.o
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/kernel/sys_sparc_32.c linux-2.6.32.60-pax/arch/sparc/kernel/sys_sparc_32.c
--- linux-2.6.32.60/arch/sparc/kernel/sys_sparc_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/kernel/sys_sparc_32.c	2012-03-13 13:15:34.388098030 +0100
@@ -57,7 +57,7 @@ unsigned long arch_get_unmapped_area(str
 	if (ARCH_SUN4C && len > 0x20000000)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (flags & MAP_SHARED)
 		addr = COLOUR_ALIGN(addr);
@@ -72,7 +72,7 @@ unsigned long arch_get_unmapped_area(str
 		}
 		if (TASK_SIZE - PAGE_SIZE - len < addr)
 			return -ENOMEM;
-		if (!vmm || addr + len <= vmm->vm_start)
+		if (check_heap_stack_gap(vmm, addr, len))
 			return addr;
 		addr = vmm->vm_end;
 		if (flags & MAP_SHARED)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/kernel/sys_sparc_64.c linux-2.6.32.60-pax/arch/sparc/kernel/sys_sparc_64.c
--- linux-2.6.32.60/arch/sparc/kernel/sys_sparc_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/kernel/sys_sparc_64.c	2013-02-17 17:05:49.728201540 +0100
@@ -125,7 +125,7 @@ unsigned long arch_get_unmapped_area(str
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) &&
+		if ((filp || (flags & MAP_SHARED)) &&
 		    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))
 			return -EINVAL;
 		return addr;
@@ -140,6 +140,10 @@ unsigned long arch_get_unmapped_area(str
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -147,15 +151,14 @@ unsigned long arch_get_unmapped_area(str
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (task_size - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (task_size - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+		start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -175,14 +178,14 @@ full_search:
 			vma = find_vma(mm, VA_EXCLUDE_END);
 		}
 		if (unlikely(task_size < addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
-		if (likely(!vma || addr + len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -216,7 +219,7 @@ arch_get_unmapped_area_topdown(struct fi
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) &&
+		if ((filp || (flags & MAP_SHARED)) &&
 		    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))
 			return -EINVAL;
 		return addr;
@@ -237,8 +240,7 @@ arch_get_unmapped_area_topdown(struct fi
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (task_size - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (task_size - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 
@@ -259,7 +261,7 @@ arch_get_unmapped_area_topdown(struct fi
 	/* make sure it can fit in the remaining address space */
 	if (likely(addr > len)) {
 		vma = find_vma(mm, addr-len);
-		if (!vma || addr <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr - len, len)) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr-len);
 		}
@@ -268,18 +270,18 @@ arch_get_unmapped_area_topdown(struct fi
 	if (unlikely(mm->mmap_base < len))
 		goto bottomup;
 
-	addr = mm->mmap_base-len;
-	if (do_color_align)
-		addr = COLOUR_ALIGN_DOWN(addr, pgoff);
+	addr = mm->mmap_base - len;
 
 	do {
+		if (do_color_align)
+			addr = COLOUR_ALIGN_DOWN(addr, pgoff);
 		/*
 		 * Lookup failure means no vma is above this address,
 		 * else if new region fits below vma->vm_start,
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (likely(!vma || addr+len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr);
 		}
@@ -289,10 +291,8 @@ arch_get_unmapped_area_topdown(struct fi
  		        mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = vma->vm_start-len;
-		if (do_color_align)
-			addr = COLOUR_ALIGN_DOWN(addr, pgoff);
-	} while (likely(len < vma->vm_start));
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 bottomup:
 	/*
@@ -366,6 +366,10 @@ void arch_pick_mmap_layout(struct mm_str
 {
 	unsigned long random_factor = 0UL;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (current->flags & PF_RANDOMIZE) {
 		random_factor = get_random_int();
 		if (test_thread_flag(TIF_32BIT))
@@ -384,6 +388,12 @@ void arch_pick_mmap_layout(struct mm_str
 	    current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY ||
 	    sysctl_legacy_va_layout) {
 		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
@@ -398,6 +408,12 @@ void arch_pick_mmap_layout(struct mm_str
 			gap = (task_size / 6 * 5);
 
 		mm->mmap_base = PAGE_ALIGN(task_size - gap - random_factor);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/kernel/traps_64.c linux-2.6.32.60-pax/arch/sparc/kernel/traps_64.c
--- linux-2.6.32.60/arch/sparc/kernel/traps_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/kernel/traps_64.c	2012-03-13 13:15:34.392098030 +0100
@@ -93,6 +93,12 @@ void bad_trap(struct pt_regs *regs, long
 
 	lvl -= 0x100;
 	if (regs->tstate & TSTATE_PRIV) {
+
+#ifdef CONFIG_PAX_REFCOUNT
+		if (lvl == 6)
+			pax_report_refcount_overflow(regs);
+#endif
+
 		sprintf(buffer, "Kernel bad sw trap %lx", lvl);
 		die_if_kernel(buffer, regs);
 	}
@@ -111,11 +117,16 @@ void bad_trap(struct pt_regs *regs, long
 void bad_trap_tl1(struct pt_regs *regs, long lvl)
 {
 	char buffer[32];
-	
+
 	if (notify_die(DIE_TRAP_TL1, "bad trap tl1", regs,
 		       0, lvl, SIGTRAP) == NOTIFY_STOP)
 		return;
 
+#ifdef CONFIG_PAX_REFCOUNT
+	if (lvl == 6)
+		pax_report_refcount_overflow(regs);
+#endif
+
 	dump_tl1_traplog((struct tl1_traplog *)(regs + 1));
 
 	sprintf (buffer, "Bad trap %lx at tl>0", lvl);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/kernel/una_asm_64.S linux-2.6.32.60-pax/arch/sparc/kernel/una_asm_64.S
--- linux-2.6.32.60/arch/sparc/kernel/una_asm_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/kernel/una_asm_64.S	2012-03-13 13:15:34.392098030 +0100
@@ -127,7 +127,7 @@ do_int_load:
 	wr	%o5, 0x0, %asi
 	retl
 	 mov	0, %o0
-	.size	__do_int_load, .-__do_int_load
+	.size	do_int_load, .-do_int_load
 
 	.section	__ex_table,"a"
 	.word		4b, __retl_efault
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/lib/atomic_64.S linux-2.6.32.60-pax/arch/sparc/lib/atomic_64.S
--- linux-2.6.32.60/arch/sparc/lib/atomic_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/lib/atomic_64.S	2012-03-13 13:15:34.396098029 +0100
@@ -18,7 +18,12 @@
 atomic_add: /* %o0 = increment, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	lduw	[%o1], %g1
-	add	%g1, %o0, %g7
+	addcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%icc, 2f
@@ -28,12 +33,32 @@ atomic_add: /* %o0 = increment, %o1 = at
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic_add, .-atomic_add
 
+	.globl	atomic_add_unchecked
+	.type	atomic_add_unchecked,#function
+atomic_add_unchecked: /* %o0 = increment, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	lduw	[%o1], %g1
+	add	%g1, %o0, %g7
+	cas	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%icc, 2f
+	 nop
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic_add_unchecked, .-atomic_add_unchecked
+
 	.globl	atomic_sub
 	.type	atomic_sub,#function
 atomic_sub: /* %o0 = decrement, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	lduw	[%o1], %g1
-	sub	%g1, %o0, %g7
+	subcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%icc, 2f
@@ -43,12 +68,32 @@ atomic_sub: /* %o0 = decrement, %o1 = at
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic_sub, .-atomic_sub
 
+	.globl	atomic_sub_unchecked
+	.type	atomic_sub_unchecked,#function
+atomic_sub_unchecked: /* %o0 = decrement, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	lduw	[%o1], %g1
+	sub	%g1, %o0, %g7
+	cas	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%icc, 2f
+	 nop
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic_sub_unchecked, .-atomic_sub_unchecked
+
 	.globl	atomic_add_ret
 	.type	atomic_add_ret,#function
 atomic_add_ret: /* %o0 = increment, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	lduw	[%o1], %g1
-	add	%g1, %o0, %g7
+	addcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%icc, 2f
@@ -59,12 +104,33 @@ atomic_add_ret: /* %o0 = increment, %o1
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic_add_ret, .-atomic_add_ret
 
+	.globl	atomic_add_ret_unchecked
+	.type	atomic_add_ret_unchecked,#function
+atomic_add_ret_unchecked: /* %o0 = increment, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	lduw	[%o1], %g1
+	addcc	%g1, %o0, %g7
+	cas	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%icc, 2f
+	 add	%g7, %o0, %g7
+	sra	%g7, 0, %o0
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic_add_ret_unchecked, .-atomic_add_ret_unchecked
+
 	.globl	atomic_sub_ret
 	.type	atomic_sub_ret,#function
 atomic_sub_ret: /* %o0 = decrement, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	lduw	[%o1], %g1
-	sub	%g1, %o0, %g7
+	subcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%icc, 2f
@@ -80,7 +146,12 @@ atomic_sub_ret: /* %o0 = decrement, %o1
 atomic64_add: /* %o0 = increment, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	ldx	[%o1], %g1
-	add	%g1, %o0, %g7
+	addcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%xcc, 6
+#endif
+
 	casx	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%xcc, 2f
@@ -90,12 +161,32 @@ atomic64_add: /* %o0 = increment, %o1 =
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic64_add, .-atomic64_add
 
+	.globl	atomic64_add_unchecked
+	.type	atomic64_add_unchecked,#function
+atomic64_add_unchecked: /* %o0 = increment, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	ldx	[%o1], %g1
+	addcc	%g1, %o0, %g7
+	casx	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%xcc, 2f
+	 nop
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic64_add_unchecked, .-atomic64_add_unchecked
+
 	.globl	atomic64_sub
 	.type	atomic64_sub,#function
 atomic64_sub: /* %o0 = decrement, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	ldx	[%o1], %g1
-	sub	%g1, %o0, %g7
+	subcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%xcc, 6
+#endif
+
 	casx	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%xcc, 2f
@@ -105,12 +196,32 @@ atomic64_sub: /* %o0 = decrement, %o1 =
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic64_sub, .-atomic64_sub
 
+	.globl	atomic64_sub_unchecked
+	.type	atomic64_sub_unchecked,#function
+atomic64_sub_unchecked: /* %o0 = decrement, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	ldx	[%o1], %g1
+	subcc	%g1, %o0, %g7
+	casx	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%xcc, 2f
+	 nop
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic64_sub_unchecked, .-atomic64_sub_unchecked
+
 	.globl	atomic64_add_ret
 	.type	atomic64_add_ret,#function
 atomic64_add_ret: /* %o0 = increment, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	ldx	[%o1], %g1
-	add	%g1, %o0, %g7
+	addcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%xcc, 6
+#endif
+
 	casx	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%xcc, 2f
@@ -121,12 +232,33 @@ atomic64_add_ret: /* %o0 = increment, %o
 2:	BACKOFF_SPIN(%o2, %o3, 1b)
 	.size	atomic64_add_ret, .-atomic64_add_ret
 
+	.globl	atomic64_add_ret_unchecked
+	.type	atomic64_add_ret_unchecked,#function
+atomic64_add_ret_unchecked: /* %o0 = increment, %o1 = atomic_ptr */
+	BACKOFF_SETUP(%o2)
+1:	ldx	[%o1], %g1
+	addcc	%g1, %o0, %g7
+	casx	[%o1], %g1, %g7
+	cmp	%g1, %g7
+	bne,pn	%xcc, 2f
+	 add	%g7, %o0, %g7
+	mov	%g7, %o0
+	retl
+	 nop
+2:	BACKOFF_SPIN(%o2, %o3, 1b)
+	.size	atomic64_add_ret_unchecked, .-atomic64_add_ret_unchecked
+
 	.globl	atomic64_sub_ret
 	.type	atomic64_sub_ret,#function
 atomic64_sub_ret: /* %o0 = decrement, %o1 = atomic_ptr */
 	BACKOFF_SETUP(%o2)
 1:	ldx	[%o1], %g1
-	sub	%g1, %o0, %g7
+	subcc	%g1, %o0, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%xcc, 6
+#endif
+
 	casx	[%o1], %g1, %g7
 	cmp	%g1, %g7
 	bne,pn	%xcc, 2f
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/lib/ksyms.c linux-2.6.32.60-pax/arch/sparc/lib/ksyms.c
--- linux-2.6.32.60/arch/sparc/lib/ksyms.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/lib/ksyms.c	2012-03-13 13:15:34.396098029 +0100
@@ -144,12 +144,18 @@ EXPORT_SYMBOL(__downgrade_write);
 
 /* Atomic counter implementation. */
 EXPORT_SYMBOL(atomic_add);
+EXPORT_SYMBOL(atomic_add_unchecked);
 EXPORT_SYMBOL(atomic_add_ret);
+EXPORT_SYMBOL(atomic_add_ret_unchecked);
 EXPORT_SYMBOL(atomic_sub);
+EXPORT_SYMBOL(atomic_sub_unchecked);
 EXPORT_SYMBOL(atomic_sub_ret);
 EXPORT_SYMBOL(atomic64_add);
+EXPORT_SYMBOL(atomic64_add_unchecked);
 EXPORT_SYMBOL(atomic64_add_ret);
+EXPORT_SYMBOL(atomic64_add_ret_unchecked);
 EXPORT_SYMBOL(atomic64_sub);
+EXPORT_SYMBOL(atomic64_sub_unchecked);
 EXPORT_SYMBOL(atomic64_sub_ret);
 
 /* Atomic bit operations. */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/lib/Makefile linux-2.6.32.60-pax/arch/sparc/lib/Makefile
--- linux-2.6.32.60/arch/sparc/lib/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/lib/Makefile	2012-03-13 13:15:34.396098029 +0100
@@ -2,7 +2,7 @@
 #
 
 asflags-y := -ansi -DST_DIV0=0x02
-ccflags-y := -Werror
+#ccflags-y := -Werror
 
 lib-$(CONFIG_SPARC32) += mul.o rem.o sdiv.o udiv.o umul.o urem.o ashrdi3.o
 lib-$(CONFIG_SPARC32) += memcpy.o memset.o
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/lib/rwsem_64.S linux-2.6.32.60-pax/arch/sparc/lib/rwsem_64.S
--- linux-2.6.32.60/arch/sparc/lib/rwsem_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/lib/rwsem_64.S	2012-03-13 13:15:34.396098029 +0100
@@ -11,7 +11,12 @@
 	.globl		__down_read
 __down_read:
 1:	lduw		[%o0], %g1
-	add		%g1, 1, %g7
+	addcc		%g1, 1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g1, %g7
 	cmp		%g1, %g7
 	bne,pn		%icc, 1b
@@ -33,7 +38,12 @@ __down_read:
 	.globl		__down_read_trylock
 __down_read_trylock:
 1:	lduw		[%o0], %g1
-	add		%g1, 1, %g7
+	addcc		%g1, 1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cmp		%g7, 0
 	bl,pn		%icc, 2f
 	 mov		0, %o1
@@ -51,7 +61,12 @@ __down_write:
 	or		%g1, %lo(RWSEM_ACTIVE_WRITE_BIAS), %g1
 1:
 	lduw		[%o0], %g3
-	add		%g3, %g1, %g7
+	addcc		%g3, %g1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g3, %g7
 	cmp		%g3, %g7
 	bne,pn		%icc, 1b
@@ -77,7 +92,12 @@ __down_write_trylock:
 	cmp		%g3, 0
 	bne,pn		%icc, 2f
 	 mov		0, %o1
-	add		%g3, %g1, %g7
+	addcc		%g3, %g1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g3, %g7
 	cmp		%g3, %g7
 	bne,pn		%icc, 1b
@@ -90,7 +110,12 @@ __down_write_trylock:
 __up_read:
 1:
 	lduw		[%o0], %g1
-	sub		%g1, 1, %g7
+	subcc		%g1, 1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g1, %g7
 	cmp		%g1, %g7
 	bne,pn		%icc, 1b
@@ -118,7 +143,12 @@ __up_write:
 	or		%g1, %lo(RWSEM_ACTIVE_WRITE_BIAS), %g1
 1:
 	lduw		[%o0], %g3
-	sub		%g3, %g1, %g7
+	subcc		%g3, %g1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g3, %g7
 	cmp		%g3, %g7
 	bne,pn		%icc, 1b
@@ -143,7 +173,12 @@ __downgrade_write:
 	or		%g1, %lo(RWSEM_WAITING_BIAS), %g1
 1:
 	lduw		[%o0], %g3
-	sub		%g3, %g1, %g7
+	subcc		%g3, %g1, %g7
+
+#ifdef CONFIG_PAX_REFCOUNT
+	tvs	%icc, 6
+#endif
+
 	cas		[%o0], %g3, %g7
 	cmp		%g3, %g7
 	bne,pn		%icc, 1b
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/fault_32.c linux-2.6.32.60-pax/arch/sparc/mm/fault_32.c
--- linux-2.6.32.60/arch/sparc/mm/fault_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/fault_32.c	2012-09-11 20:59:31.380023475 +0200
@@ -21,6 +21,9 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/kdebug.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/page.h>
@@ -167,6 +170,276 @@ static unsigned long compute_si_addr(str
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_DLRESOLVE
+static void pax_emuplt_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static int pax_emuplt_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(vmf->page);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static const struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.fault = pax_emuplt_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int *)regs->pc);
+		err |= get_user(sethi2, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int *)regs->pc);
+
+		if (err)
+			break;
+
+		if ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30480000U) {
+			unsigned int addr;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, bajmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->pc);
+		err |= get_user(bajmpl, (unsigned int *)(regs->pc+4));
+		err |= get_user(nop, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((bajmpl & 0xFFFFE000U) == 0x81C06000U || (bajmpl & 0xFFF80000U) == 0x30480000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			if ((bajmpl & 0xFFFFE000U) == 0x81C06000U)
+				addr += (((bajmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			else
+				addr = regs->pc + ((((bajmpl | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->pc);
+		err |= get_user(ba, (unsigned int *)(regs->pc+4));
+		err |= get_user(nop, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int *)addr);
+			err |= get_user(call, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			if (err)
+				break;
+
+#ifdef CONFIG_PAX_DLRESOLVE
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+#endif
+
+			/* PaX: glibc 2.4+ generates sethi/jmpl instead of save/call */
+			if ((save & 0xFFC00000U) == 0x05000000U &&
+			    (call & 0xFFFFE000U) == 0x85C0A000U &&
+			    nop == 0x01000000U)
+			{
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->u_regs[UREG_G2] = addr + 4;
+				addr = (save & 0x003FFFFFU) << 10;
+				addr += (((call | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+				regs->pc = addr;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int *)(regs->pc-4));
+		err |= get_user(call, (unsigned int *)regs->pc);
+		err |= get_user(nop, (unsigned int *)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -231,6 +504,24 @@ good_area:
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)regs->pc, (void *)regs->u_regs[UREG_FP]);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/fault_64.c linux-2.6.32.60-pax/arch/sparc/mm/fault_64.c
--- linux-2.6.32.60/arch/sparc/mm/fault_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/fault_64.c	2012-07-29 01:36:59.470598069 +0200
@@ -20,6 +20,9 @@
 #include <linux/kprobes.h>
 #include <linux/kdebug.h>
 #include <linux/percpu.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -249,6 +252,465 @@ static void noinline bogus_32bit_fault_a
 	show_regs(regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_DLRESOLVE
+static void pax_emuplt_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static int pax_emuplt_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(vmf->page);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static const struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.fault = pax_emuplt_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int *)regs->tpc);
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int *)regs->tpc);
+
+		if (err)
+			break;
+
+		if ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30480000U) {
+			unsigned long addr;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, bajmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(bajmpl, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((bajmpl & 0xFFFFE000U) == 0x81C06000U || (bajmpl & 0xFFF80000U) == 0x30480000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			if ((bajmpl & 0xFFFFE000U) == 0x81C06000U)
+				addr += (((bajmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			else
+				addr = regs->tpc + ((((bajmpl | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int sethi, mov1, call, mov2;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(mov1, (unsigned int *)(regs->tpc+4));
+		err |= get_user(call, (unsigned int *)(regs->tpc+8));
+		err |= get_user(mov2, (unsigned int *)(regs->tpc+12));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi, sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(sethi1, (unsigned int *)(regs->tpc+4));
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+8));
+		err |= get_user(or1, (unsigned int *)(regs->tpc+12));
+		err |= get_user(or2, (unsigned int *)(regs->tpc+16));
+		err |= get_user(sllx, (unsigned int *)(regs->tpc+20));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+24));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+28));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi, sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(sethi1, (unsigned int *)(regs->tpc+4));
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+8));
+		err |= get_user(sllx, (unsigned int *)(regs->tpc+12));
+		err |= get_user(or, (unsigned int *)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020U &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(ba, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+			unsigned int sethi1, sethi2, or1, or2, sllx, add, jmpl;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			err = get_user(save, (unsigned int *)addr);
+			err |= get_user(call, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			if (err)
+				break;
+
+#ifdef CONFIG_PAX_DLRESOLVE
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+#endif
+
+			/* PaX: glibc 2.4+ generates sethi/jmpl instead of save/call */
+			if ((save & 0xFFC00000U) == 0x05000000U &&
+			    (call & 0xFFFFE000U) == 0x85C0A000U &&
+			    nop == 0x01000000U)
+			{
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->u_regs[UREG_G2] = addr + 4;
+				addr = (save & 0x003FFFFFU) << 10;
+				addr += (((call | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+
+				if (test_thread_flag(TIF_32BIT))
+					addr &= 0xFFFFFFFFUL;
+
+				regs->tpc = addr;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+
+			/* PaX: 64-bit PLT stub */
+			err = get_user(sethi1, (unsigned int *)addr);
+			err |= get_user(sethi2, (unsigned int *)(addr+4));
+			err |= get_user(or1, (unsigned int *)(addr+8));
+			err |= get_user(or2, (unsigned int *)(addr+12));
+			err |= get_user(sllx, (unsigned int *)(addr+16));
+			err |= get_user(add, (unsigned int *)(addr+20));
+			err |= get_user(jmpl, (unsigned int *)(addr+24));
+			err |= get_user(nop, (unsigned int *)(addr+28));
+			if (err)
+				break;
+
+			if ((sethi1 & 0xFFC00000U) == 0x09000000U &&
+			    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+			    (or1 & 0xFFFFE000U) == 0x88112000U &&
+			    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+			    sllx == 0x89293020U &&
+			    add == 0x8A010005U &&
+			    jmpl == 0x89C14000U &&
+			    nop == 0x01000000U)
+			{
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->u_regs[UREG_G4] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+				regs->u_regs[UREG_G4] <<= 32;
+				regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+				regs->u_regs[UREG_G5] += regs->u_regs[UREG_G4];
+				regs->u_regs[UREG_G4] = addr + 24;
+				addr = regs->u_regs[UREG_G5];
+				regs->tpc = addr;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int *)(regs->tpc-4));
+		err |= get_user(call, (unsigned int *)regs->tpc);
+		err |= get_user(nop, (unsigned int *)(regs->tpc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				dl_resolve &= 0xFFFFFFFFUL;
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: patched PLT emulation #7, must be AFTER the unpatched PLT emulation */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(ba, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			if (test_thread_flag(TIF_32BIT))
+				addr &= 0xFFFFFFFFUL;
+
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -315,6 +777,29 @@ asmlinkage void __kprobes do_sparc64_fau
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			return;
+#endif
+
+		}
+		pax_report_fault(regs, (void *)regs->tpc, (void *)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_group_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/hugetlbpage.c linux-2.6.32.60-pax/arch/sparc/mm/hugetlbpage.c
--- linux-2.6.32.60/arch/sparc/mm/hugetlbpage.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/hugetlbpage.c	2012-03-13 13:15:34.400098029 +0100
@@ -69,7 +69,7 @@ full_search:
 			}
 			return -ENOMEM;
 		}
-		if (likely(!vma || addr + len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -108,7 +108,7 @@ hugetlb_get_unmapped_area_topdown(struct
 	/* make sure it can fit in the remaining address space */
 	if (likely(addr > len)) {
 		vma = find_vma(mm, addr-len);
-		if (!vma || addr <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr - len, len)) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr-len);
 		}
@@ -117,16 +117,17 @@ hugetlb_get_unmapped_area_topdown(struct
 	if (unlikely(mm->mmap_base < len))
 		goto bottomup;
 
-	addr = (mm->mmap_base-len) & HPAGE_MASK;
+	addr = mm->mmap_base - len;
 
 	do {
+		addr &= HPAGE_MASK;
 		/*
 		 * Lookup failure means no vma is above this address,
 		 * else if new region fits below vma->vm_start,
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (likely(!vma || addr+len <= vma->vm_start)) {
+		if (likely(check_heap_stack_gap(vma, addr, len))) {
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr);
 		}
@@ -136,8 +137,8 @@ hugetlb_get_unmapped_area_topdown(struct
  		        mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = (vma->vm_start-len) & HPAGE_MASK;
-	} while (likely(len < vma->vm_start));
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 bottomup:
 	/*
@@ -183,8 +184,7 @@ hugetlb_get_unmapped_area(struct file *f
 	if (addr) {
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
-		if (task_size - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (task_size - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 	if (mm->get_unmapped_area == arch_get_unmapped_area)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/init_32.c linux-2.6.32.60-pax/arch/sparc/mm/init_32.c
--- linux-2.6.32.60/arch/sparc/mm/init_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/init_32.c	2012-03-13 13:15:34.400098029 +0100
@@ -317,6 +317,9 @@ extern void device_scan(void);
 pgprot_t PAGE_SHARED __read_mostly;
 EXPORT_SYMBOL(PAGE_SHARED);
 
+pgprot_t PAGE_SHARED_NOEXEC __read_mostly;
+EXPORT_SYMBOL(PAGE_SHARED_NOEXEC);
+
 void __init paging_init(void)
 {
 	switch(sparc_cpu_model) {
@@ -345,17 +348,17 @@ void __init paging_init(void)
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/Makefile linux-2.6.32.60-pax/arch/sparc/mm/Makefile
--- linux-2.6.32.60/arch/sparc/mm/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/Makefile	2012-03-13 13:15:34.400098029 +0100
@@ -2,7 +2,7 @@
 #
 
 asflags-y := -ansi
-ccflags-y := -Werror
+#ccflags-y := -Werror
 
 obj-$(CONFIG_SPARC64)   += ultra.o tlb.o tsb.o
 obj-y                   += fault_$(BITS).o
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/sparc/mm/srmmu.c linux-2.6.32.60-pax/arch/sparc/mm/srmmu.c
--- linux-2.6.32.60/arch/sparc/mm/srmmu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/sparc/mm/srmmu.c	2012-03-13 13:15:34.404098029 +0100
@@ -2200,6 +2200,13 @@ void __init ld_mmu_srmmu(void)
 	PAGE_SHARED = pgprot_val(SRMMU_PAGE_SHARED);
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	PAGE_SHARED_NOEXEC = pgprot_val(SRMMU_PAGE_SHARED_NOEXEC);
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/include/asm/kmap_types.h linux-2.6.32.60-pax/arch/um/include/asm/kmap_types.h
--- linux-2.6.32.60/arch/um/include/asm/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/include/asm/kmap_types.h	2012-03-13 13:15:34.404098029 +0100
@@ -23,6 +23,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_CLEARPAGE,
 	KM_TYPE_NR
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/include/asm/page.h linux-2.6.32.60-pax/arch/um/include/asm/page.h
--- linux-2.6.32.60/arch/um/include/asm/page.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/include/asm/page.h	2012-03-13 13:15:34.404098029 +0100
@@ -14,6 +14,9 @@
 #define PAGE_SIZE	(_AC(1, UL) << PAGE_SHIFT)
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 
+#define ktla_ktva(addr)			(addr)
+#define ktva_ktla(addr)			(addr)
+
 #ifndef __ASSEMBLY__
 
 struct page;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/include/asm/pgtable-3level.h linux-2.6.32.60-pax/arch/um/include/asm/pgtable-3level.h
--- linux-2.6.32.60/arch/um/include/asm/pgtable-3level.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/include/asm/pgtable-3level.h	2012-05-07 17:51:43.320106543 +0200
@@ -58,6 +58,7 @@
 #define pud_present(x)	(pud_val(x) & _PAGE_PRESENT)
 #define pud_populate(mm, pud, pmd) \
 	set_pud(pud, __pud(_PAGE_TABLE + __pa(pmd)))
+#define pud_populate_kernel(mm, pud, pmd) pud_populate((mm), (pud), (pmd))
 
 #ifdef CONFIG_64BIT
 #define set_pud(pudptr, pudval) set_64bit((phys_t *) (pudptr), pud_val(pudval))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/kernel/process.c linux-2.6.32.60-pax/arch/um/kernel/process.c
--- linux-2.6.32.60/arch/um/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/kernel/process.c	2012-03-13 13:15:34.408098029 +0100
@@ -393,22 +393,6 @@ int singlestepping(void * t)
 	return 2;
 }
 
-/*
- * Only x86 and x86_64 have an arch_align_stack().
- * All other arches have "#define arch_align_stack(x) (x)"
- * in their asm/system.h
- * As this is included in UML from asm-um/system-generic.h,
- * we can use it to behave as the subarch does.
- */
-#ifndef arch_align_stack
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
-}
-#endif
-
 unsigned long get_wchan(struct task_struct *p)
 {
 	unsigned long stack_page, sp, ip;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/Makefile linux-2.6.32.60-pax/arch/um/Makefile
--- linux-2.6.32.60/arch/um/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/Makefile	2012-09-26 14:55:45.568343667 +0200
@@ -49,6 +49,10 @@ USER_CFLAGS = $(patsubst $(KERNEL_DEFINE
 	$(patsubst -I%,,$(KBUILD_CFLAGS)))) $(ARCH_INCLUDE) $(MODE_INCLUDE) \
 	$(filter -I%,$(CFLAGS)) -D_FILE_OFFSET_BITS=64
 
+ifdef CONSTIFY_PLUGIN
+USER_CFLAGS	+= -fplugin-arg-constify_plugin-no-constify
+endif
+
 include $(srctree)/$(ARCH_DIR)/Makefile-$(SUBARCH)
 
 #This will adjust *FLAGS accordingly to the platform.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/sys-i386/shared/sysdep/system.h linux-2.6.32.60-pax/arch/um/sys-i386/shared/sysdep/system.h
--- linux-2.6.32.60/arch/um/sys-i386/shared/sysdep/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/sys-i386/shared/sysdep/system.h	2012-03-13 13:15:34.408098029 +0100
@@ -17,7 +17,7 @@
 # define AT_VECTOR_SIZE_ARCH 1
 #endif
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) ((x) & ~0xfUL)
 
 void default_idle(void);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/sys-i386/syscalls.c linux-2.6.32.60-pax/arch/um/sys-i386/syscalls.c
--- linux-2.6.32.60/arch/um/sys-i386/syscalls.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/sys-i386/syscalls.c	2012-03-13 13:15:34.408098029 +0100
@@ -11,6 +11,21 @@
 #include "asm/uaccess.h"
 #include "asm/unistd.h"
 
+int i386_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)
+{
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size || addr > pax_task_size - len)
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/i386 didn't use to be able to handle more than
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/um/sys-x86_64/shared/sysdep/system.h linux-2.6.32.60-pax/arch/um/sys-x86_64/shared/sysdep/system.h
--- linux-2.6.32.60/arch/um/sys-x86_64/shared/sysdep/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/um/sys-x86_64/shared/sysdep/system.h	2012-03-13 13:15:34.408098029 +0100
@@ -17,7 +17,7 @@
 # define AT_VECTOR_SIZE_ARCH 1
 #endif
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) ((x) & ~0xfUL)
 
 void default_idle(void);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/bitops.h linux-2.6.32.60-pax/arch/x86/boot/bitops.h
--- linux-2.6.32.60/arch/x86/boot/bitops.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/bitops.h	2012-03-13 13:15:34.412098028 +0100
@@ -26,7 +26,7 @@ static inline int variable_test_bit(int
 	u8 v;
 	const u32 *p = (const u32 *)addr;
 
-	asm("btl %2,%1; setc %0" : "=qm" (v) : "m" (*p), "Ir" (nr));
+	asm volatile("btl %2,%1; setc %0" : "=qm" (v) : "m" (*p), "Ir" (nr));
 	return v;
 }
 
@@ -37,7 +37,7 @@ static inline int variable_test_bit(int
 
 static inline void set_bit(int nr, void *addr)
 {
-	asm("btsl %1,%0" : "+m" (*(u32 *)addr) : "Ir" (nr));
+	asm volatile("btsl %1,%0" : "+m" (*(u32 *)addr) : "Ir" (nr));
 }
 
 #endif /* BOOT_BITOPS_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/boot.h linux-2.6.32.60-pax/arch/x86/boot/boot.h
--- linux-2.6.32.60/arch/x86/boot/boot.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/boot.h	2012-03-13 13:15:34.412098028 +0100
@@ -82,7 +82,7 @@ static inline void io_delay(void)
 static inline u16 ds(void)
 {
 	u16 seg;
-	asm("movw %%ds,%0" : "=rm" (seg));
+	asm volatile("movw %%ds,%0" : "=rm" (seg));
 	return seg;
 }
 
@@ -178,7 +178,7 @@ static inline void wrgs32(u32 v, addr_t
 static inline int memcmp(const void *s1, const void *s2, size_t len)
 {
 	u8 diff;
-	asm("repe; cmpsb; setnz %0"
+	asm volatile("repe; cmpsb; setnz %0"
 	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/head_32.S linux-2.6.32.60-pax/arch/x86/boot/compressed/head_32.S
--- linux-2.6.32.60/arch/x86/boot/compressed/head_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/head_32.S	2012-03-13 13:15:34.412098028 +0100
@@ -76,7 +76,7 @@ ENTRY(startup_32)
 	notl	%eax
 	andl    %eax, %ebx
 #else
-	movl	$LOAD_PHYSICAL_ADDR, %ebx
+	movl	$____LOAD_PHYSICAL_ADDR, %ebx
 #endif
 
 	/* Target address to relocate to for decompression */
@@ -149,7 +149,7 @@ relocated:
  * and where it was actually loaded.
  */
 	movl	%ebp, %ebx
-	subl	$LOAD_PHYSICAL_ADDR, %ebx
+	subl	$____LOAD_PHYSICAL_ADDR, %ebx
 	jz	2f	/* Nothing to be done if loaded at compiled addr. */
 /*
  * Process relocations.
@@ -157,8 +157,7 @@ relocated:
 
 1:	subl	$4, %edi
 	movl	(%edi), %ecx
-	testl	%ecx, %ecx
-	jz	2f
+	jecxz	2f
 	addl	%ebx, -__PAGE_OFFSET(%ebx, %ecx)
 	jmp	1b
 2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/head_64.S linux-2.6.32.60-pax/arch/x86/boot/compressed/head_64.S
--- linux-2.6.32.60/arch/x86/boot/compressed/head_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/head_64.S	2012-03-13 13:15:34.412098028 +0100
@@ -91,7 +91,7 @@ ENTRY(startup_32)
 	notl	%eax
 	andl	%eax, %ebx
 #else
-	movl	$LOAD_PHYSICAL_ADDR, %ebx
+	movl	$____LOAD_PHYSICAL_ADDR, %ebx
 #endif
 
 	/* Target address to relocate to for decompression */
@@ -234,7 +234,7 @@ ENTRY(startup_64)
 	notq	%rax
 	andq	%rax, %rbp
 #else
-	movq	$LOAD_PHYSICAL_ADDR, %rbp
+	movq	$____LOAD_PHYSICAL_ADDR, %rbp
 #endif
 
 	/* Target address to relocate to for decompression */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/Makefile linux-2.6.32.60-pax/arch/x86/boot/compressed/Makefile
--- linux-2.6.32.60/arch/x86/boot/compressed/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/Makefile	2012-09-24 22:35:58.168025407 +0200
@@ -13,6 +13,9 @@ cflags-$(CONFIG_X86_64) := -mcmodel=smal
 KBUILD_CFLAGS += $(cflags-y)
 KBUILD_CFLAGS += $(call cc-option,-ffreestanding)
 KBUILD_CFLAGS += $(call cc-option,-fno-stack-protector)
+ifdef CONSTIFY_PLUGIN
+KBUILD_CFLAGS += -fplugin-arg-constify_plugin-no-constify
+endif
 
 KBUILD_AFLAGS  := $(KBUILD_CFLAGS) -D__ASSEMBLY__
 GCOV_PROFILE := n
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/misc.c linux-2.6.32.60-pax/arch/x86/boot/compressed/misc.c
--- linux-2.6.32.60/arch/x86/boot/compressed/misc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/misc.c	2012-03-13 13:15:34.416098028 +0100
@@ -288,7 +288,7 @@ static void parse_elf(void *output)
 		case PT_LOAD:
 #ifdef CONFIG_RELOCATABLE
 			dest = output;
-			dest += (phdr->p_paddr - LOAD_PHYSICAL_ADDR);
+			dest += (phdr->p_paddr - ____LOAD_PHYSICAL_ADDR);
 #else
 			dest = (void *)(phdr->p_paddr);
 #endif
@@ -335,7 +335,7 @@ asmlinkage void decompress_kernel(void *
 		error("Destination address too large");
 #endif
 #ifndef CONFIG_RELOCATABLE
-	if ((unsigned long)output != LOAD_PHYSICAL_ADDR)
+	if ((unsigned long)output != ____LOAD_PHYSICAL_ADDR)
 		error("Wrong destination address");
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/mkpiggy.c linux-2.6.32.60-pax/arch/x86/boot/compressed/mkpiggy.c
--- linux-2.6.32.60/arch/x86/boot/compressed/mkpiggy.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/mkpiggy.c	2012-03-13 13:15:34.416098028 +0100
@@ -74,7 +74,7 @@ int main(int argc, char *argv[])
 
 	offs = (olen > ilen) ? olen - ilen : 0;
 	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
-	offs += 32*1024 + 18;	/* Add 32K + 18 bytes slack */
+	offs += 64*1024;	/* Add 64K bytes slack */
 	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
 
 	printf(".section \".rodata.compressed\",\"a\",@progbits\n");
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/compressed/relocs.c linux-2.6.32.60-pax/arch/x86/boot/compressed/relocs.c
--- linux-2.6.32.60/arch/x86/boot/compressed/relocs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/compressed/relocs.c	2012-07-31 00:33:20.948078635 +0200
@@ -10,8 +10,11 @@
 #define USE_BSD
 #include <endian.h>
 
+#include "../../../../include/linux/autoconf.h"
+
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 static Elf32_Ehdr ehdr;
+static Elf32_Phdr *phdr;
 static unsigned long reloc_count, reloc_idx;
 static unsigned long *relocs;
 
@@ -37,7 +40,7 @@ static const char* safe_abs_relocs[] = {
 
 static int is_safe_abs_reloc(const char* sym_name)
 {
-	int i;
+	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(safe_abs_relocs); i++) {
 		if (!strcmp(sym_name, safe_abs_relocs[i]))
@@ -245,9 +248,39 @@ static void read_ehdr(FILE *fp)
 	}
 }
 
+static void read_phdrs(FILE *fp)
+{
+	unsigned int i;
+
+	phdr = calloc(ehdr.e_phnum, sizeof(Elf32_Phdr));
+	if (!phdr) {
+		die("Unable to allocate %d program headers\n",
+		    ehdr.e_phnum);
+	}
+	if (fseek(fp, ehdr.e_phoff, SEEK_SET) < 0) {
+		die("Seek to %d failed: %s\n",
+			ehdr.e_phoff, strerror(errno));
+	}
+	if (fread(phdr, sizeof(*phdr), ehdr.e_phnum, fp) != ehdr.e_phnum) {
+		die("Cannot read ELF program headers: %s\n",
+			strerror(errno));
+	}
+	for(i = 0; i < ehdr.e_phnum; i++) {
+		phdr[i].p_type      = elf32_to_cpu(phdr[i].p_type);
+		phdr[i].p_offset    = elf32_to_cpu(phdr[i].p_offset);
+		phdr[i].p_vaddr     = elf32_to_cpu(phdr[i].p_vaddr);
+		phdr[i].p_paddr     = elf32_to_cpu(phdr[i].p_paddr);
+		phdr[i].p_filesz    = elf32_to_cpu(phdr[i].p_filesz);
+		phdr[i].p_memsz     = elf32_to_cpu(phdr[i].p_memsz);
+		phdr[i].p_flags     = elf32_to_cpu(phdr[i].p_flags);
+		phdr[i].p_align     = elf32_to_cpu(phdr[i].p_align);
+	}
+
+}
+
 static void read_shdrs(FILE *fp)
 {
-	int i;
+	unsigned int i;
 	Elf32_Shdr shdr;
 
 	secs = calloc(ehdr.e_shnum, sizeof(struct section));
@@ -282,7 +315,7 @@ static void read_shdrs(FILE *fp)
 
 static void read_strtabs(FILE *fp)
 {
-	int i;
+	unsigned int i;
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		if (sec->shdr.sh_type != SHT_STRTAB) {
@@ -307,7 +340,7 @@ static void read_strtabs(FILE *fp)
 
 static void read_symtabs(FILE *fp)
 {
-	int i,j;
+	unsigned int i,j;
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		if (sec->shdr.sh_type != SHT_SYMTAB) {
@@ -340,7 +373,9 @@ static void read_symtabs(FILE *fp)
 
 static void read_relocs(FILE *fp)
 {
-	int i,j;
+	unsigned int i,j;
+	uint32_t base;
+
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		if (sec->shdr.sh_type != SHT_REL) {
@@ -360,9 +395,18 @@ static void read_relocs(FILE *fp)
 			die("Cannot read symbol table: %s\n",
 				strerror(errno));
 		}
+		base = 0;
+		for (j = 0; j < ehdr.e_phnum; j++) {
+			if (phdr[j].p_type != PT_LOAD )
+				continue;
+			if (secs[sec->shdr.sh_info].shdr.sh_offset < phdr[j].p_offset || secs[sec->shdr.sh_info].shdr.sh_offset >= phdr[j].p_offset + phdr[j].p_filesz)
+				continue;
+			base = CONFIG_PAGE_OFFSET + phdr[j].p_paddr - phdr[j].p_vaddr;
+			break;
+		}
 		for (j = 0; j < sec->shdr.sh_size/sizeof(Elf32_Rel); j++) {
 			Elf32_Rel *rel = &sec->reltab[j];
-			rel->r_offset = elf32_to_cpu(rel->r_offset);
+			rel->r_offset = elf32_to_cpu(rel->r_offset) + base;
 			rel->r_info   = elf32_to_cpu(rel->r_info);
 		}
 	}
@@ -371,14 +415,14 @@ static void read_relocs(FILE *fp)
 
 static void print_absolute_symbols(void)
 {
-	int i;
+	unsigned int i;
 	printf("Absolute symbols\n");
 	printf(" Num:    Value Size  Type       Bind        Visibility  Name\n");
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		char *sym_strtab;
 		Elf32_Sym *sh_symtab;
-		int j;
+		unsigned int j;
 
 		if (sec->shdr.sh_type != SHT_SYMTAB) {
 			continue;
@@ -406,14 +450,14 @@ static void print_absolute_symbols(void)
 
 static void print_absolute_relocs(void)
 {
-	int i, printed = 0;
+	unsigned int i, printed = 0;
 
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		struct section *sec_applies, *sec_symtab;
 		char *sym_strtab;
 		Elf32_Sym *sh_symtab;
-		int j;
+		unsigned int j;
 		if (sec->shdr.sh_type != SHT_REL) {
 			continue;
 		}
@@ -474,13 +518,13 @@ static void print_absolute_relocs(void)
 
 static void walk_relocs(void (*visit)(Elf32_Rel *rel, Elf32_Sym *sym))
 {
-	int i;
+	unsigned int i;
 	/* Walk through the relocations */
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		char *sym_strtab;
 		Elf32_Sym *sh_symtab;
 		struct section *sec_applies, *sec_symtab;
-		int j;
+		unsigned int j;
 		struct section *sec = &secs[i];
 
 		if (sec->shdr.sh_type != SHT_REL) {
@@ -504,6 +548,21 @@ static void walk_relocs(void (*visit)(El
 			if (sym->st_shndx == SHN_ABS) {
 				continue;
 			}
+			/* Don't relocate actual per-cpu variables, they are absolute indices, not addresses */
+			if (!strcmp(sec_name(sym->st_shndx), ".data.percpu") && strcmp(sym_name(sym_strtab, sym), "__per_cpu_load"))
+				continue;
+
+#if defined(CONFIG_PAX_KERNEXEC) && defined(CONFIG_X86_32)
+			/* Don't relocate actual code, they are relocated implicitly by the base address of KERNEL_CS */
+			if (!strcmp(sec_name(sym->st_shndx), ".text.end") && !strcmp(sym_name(sym_strtab, sym), "_etext"))
+				continue;
+			if (!strcmp(sec_name(sym->st_shndx), ".init.text"))
+				continue;
+			if (!strcmp(sec_name(sym->st_shndx), ".exit.text"))
+				continue;
+			if (!strcmp(sec_name(sym->st_shndx), ".text") && strcmp(sym_name(sym_strtab, sym), "__LOAD_PHYSICAL_ADDR"))
+				continue;
+#endif
 			if (r_type == R_386_NONE || r_type == R_386_PC32) {
 				/*
 				 * NONE can be ignored and and PC relative
@@ -541,7 +600,7 @@ static int cmp_relocs(const void *va, co
 
 static void emit_relocs(int as_text)
 {
-	int i;
+	unsigned int i;
 	/* Count how many relocations I have and allocate space for them. */
 	reloc_count = 0;
 	walk_relocs(count_reloc);
@@ -634,6 +693,7 @@ int main(int argc, char **argv)
 			fname, strerror(errno));
 	}
 	read_ehdr(fp);
+	read_phdrs(fp);
 	read_shdrs(fp);
 	read_strtabs(fp);
 	read_symtabs(fp);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/cpucheck.c linux-2.6.32.60-pax/arch/x86/boot/cpucheck.c
--- linux-2.6.32.60/arch/x86/boot/cpucheck.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/cpucheck.c	2012-03-13 13:15:34.420098028 +0100
@@ -74,7 +74,7 @@ static int has_fpu(void)
 	u16 fcw = -1, fsw = -1;
 	u32 cr0;
 
-	asm("movl %%cr0,%0" : "=r" (cr0));
+	asm volatile("movl %%cr0,%0" : "=r" (cr0));
 	if (cr0 & (X86_CR0_EM|X86_CR0_TS)) {
 		cr0 &= ~(X86_CR0_EM|X86_CR0_TS);
 		asm volatile("movl %0,%%cr0" : : "r" (cr0));
@@ -90,7 +90,7 @@ static int has_eflag(u32 mask)
 {
 	u32 f0, f1;
 
-	asm("pushfl ; "
+	asm volatile("pushfl ; "
 	    "pushfl ; "
 	    "popl %0 ; "
 	    "movl %0,%1 ; "
@@ -115,7 +115,7 @@ static void get_flags(void)
 		set_bit(X86_FEATURE_FPU, cpu.flags);
 
 	if (has_eflag(X86_EFLAGS_ID)) {
-		asm("cpuid"
+		asm volatile("cpuid"
 		    : "=a" (max_intel_level),
 		      "=b" (cpu_vendor[0]),
 		      "=d" (cpu_vendor[1]),
@@ -124,7 +124,7 @@ static void get_flags(void)
 
 		if (max_intel_level >= 0x00000001 &&
 		    max_intel_level <= 0x0000ffff) {
-			asm("cpuid"
+			asm volatile("cpuid"
 			    : "=a" (tfms),
 			      "=c" (cpu.flags[4]),
 			      "=d" (cpu.flags[0])
@@ -136,7 +136,7 @@ static void get_flags(void)
 				cpu.model += ((tfms >> 16) & 0xf) << 4;
 		}
 
-		asm("cpuid"
+		asm volatile("cpuid"
 		    : "=a" (max_amd_level)
 		    : "a" (0x80000000)
 		    : "ebx", "ecx", "edx");
@@ -144,7 +144,7 @@ static void get_flags(void)
 		if (max_amd_level >= 0x80000001 &&
 		    max_amd_level <= 0x8000ffff) {
 			u32 eax = 0x80000001;
-			asm("cpuid"
+			asm volatile("cpuid"
 			    : "+a" (eax),
 			      "=c" (cpu.flags[6]),
 			      "=d" (cpu.flags[1])
@@ -203,9 +203,9 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 ecx = MSR_K7_HWCR;
 		u32 eax, edx;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
 		eax &= ~(1 << 15);
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		get_flags();	/* Make sure it really did something */
 		err = check_flags();
@@ -218,9 +218,9 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 ecx = MSR_VIA_FCR;
 		u32 eax, edx;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
 		eax |= (1<<1)|(1<<7);
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		set_bit(X86_FEATURE_CX8, cpu.flags);
 		err = check_flags();
@@ -231,12 +231,12 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 eax, edx;
 		u32 level = 1;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
-		asm("wrmsr" : : "a" (~0), "d" (edx), "c" (ecx));
-		asm("cpuid"
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("wrmsr" : : "a" (~0), "d" (edx), "c" (ecx));
+		asm volatile("cpuid"
 		    : "+a" (level), "=d" (cpu.flags[0])
 		    : : "ecx", "ebx");
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		err = check_flags();
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/header.S linux-2.6.32.60-pax/arch/x86/boot/header.S
--- linux-2.6.32.60/arch/x86/boot/header.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/header.S	2012-08-04 00:02:40.534653430 +0200
@@ -224,10 +224,14 @@ setup_data:		.quad 0			# 64-bit physical
 						# single linked list of
 						# struct setup_data
 
-pref_address:		.quad LOAD_PHYSICAL_ADDR	# preferred load addr
+pref_address:		.quad ____LOAD_PHYSICAL_ADDR	# preferred load addr
 
 #define ZO_INIT_SIZE	(ZO__end - ZO_startup_32 + ZO_z_extract_offset)
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#define VO_INIT_SIZE	(VO__end - VO__text - __PAGE_OFFSET - ____LOAD_PHYSICAL_ADDR)
+#else
 #define VO_INIT_SIZE	(VO__end - VO__text)
+#endif
 #if ZO_INIT_SIZE > VO_INIT_SIZE
 #define INIT_SIZE ZO_INIT_SIZE
 #else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/Makefile linux-2.6.32.60-pax/arch/x86/boot/Makefile
--- linux-2.6.32.60/arch/x86/boot/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/Makefile	2012-09-24 22:35:41.936025357 +0200
@@ -69,6 +69,9 @@ KBUILD_CFLAGS	:= $(LINUXINCLUDE) -g -Os
 		   $(call cc-option, -fno-stack-protector) \
 		   $(call cc-option, -mpreferred-stack-boundary=2)
 KBUILD_CFLAGS	+= $(call cc-option, -m32)
+ifdef CONSTIFY_PLUGIN
+KBUILD_CFLAGS	+= -fplugin-arg-constify_plugin-no-constify
+endif
 KBUILD_AFLAGS	:= $(KBUILD_CFLAGS) -D__ASSEMBLY__
 GCOV_PROFILE := n
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/memory.c linux-2.6.32.60-pax/arch/x86/boot/memory.c
--- linux-2.6.32.60/arch/x86/boot/memory.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/memory.c	2012-03-13 13:15:34.420098028 +0100
@@ -19,7 +19,7 @@
 
 static int detect_memory_e820(void)
 {
-	int count = 0;
+	unsigned int count = 0;
 	struct biosregs ireg, oreg;
 	struct e820entry *desc = boot_params.e820_map;
 	static struct e820entry buf; /* static so it is zeroed */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/video.c linux-2.6.32.60-pax/arch/x86/boot/video.c
--- linux-2.6.32.60/arch/x86/boot/video.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/video.c	2012-03-13 13:15:34.420098028 +0100
@@ -90,7 +90,7 @@ static void store_mode_params(void)
 static unsigned int get_entry(void)
 {
 	char entry_buf[4];
-	int i, len = 0;
+	unsigned int i, len = 0;
 	int key;
 	unsigned int v;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/video-vesa.c linux-2.6.32.60-pax/arch/x86/boot/video-vesa.c
--- linux-2.6.32.60/arch/x86/boot/video-vesa.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/video-vesa.c	2012-03-13 13:15:34.424098028 +0100
@@ -200,6 +200,7 @@ static void vesa_store_pm_info(void)
 
 	boot_params.screen_info.vesapm_seg = oreg.es;
 	boot_params.screen_info.vesapm_off = oreg.di;
+	boot_params.screen_info.vesapm_size = oreg.cx;
 }
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/boot/video-vga.c linux-2.6.32.60-pax/arch/x86/boot/video-vga.c
--- linux-2.6.32.60/arch/x86/boot/video-vga.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/boot/video-vga.c	2012-10-09 11:38:12.737229068 +0200
@@ -41,13 +41,12 @@ static __videocard video_vga;
 static u8 vga_set_basic_mode(void)
 {
 	struct biosregs ireg, oreg;
-	u16 ax;
 	u8 rows;
 	u8 mode;
 
 	initregs(&ireg);
 
-	ax = 0x0f00;
+	ireg.ax = 0x0f00;
 	intcall(0x10, &ireg, &oreg);
 	mode = oreg.al;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/crypto/aesni-intel_asm.S linux-2.6.32.60-pax/arch/x86/crypto/aesni-intel_asm.S
--- linux-2.6.32.60/arch/x86/crypto/aesni-intel_asm.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/crypto/aesni-intel_asm.S	2012-03-13 13:15:34.428098028 +0100
@@ -16,6 +16,7 @@
  */
 
 #include <linux/linkage.h>
+#include <asm/alternative-asm.h>
 
 .text
 
@@ -52,6 +53,7 @@ _key_expansion_256a:
 	pxor %xmm1, %xmm0
 	movaps %xmm0, (%rcx)
 	add $0x10, %rcx
+	pax_force_retaddr_bts
 	ret
 
 _key_expansion_192a:
@@ -75,6 +77,7 @@ _key_expansion_192a:
 	shufps $0b01001110, %xmm2, %xmm1
 	movaps %xmm1, 16(%rcx)
 	add $0x20, %rcx
+	pax_force_retaddr_bts
 	ret
 
 _key_expansion_192b:
@@ -93,6 +96,7 @@ _key_expansion_192b:
 
 	movaps %xmm0, (%rcx)
 	add $0x10, %rcx
+	pax_force_retaddr_bts
 	ret
 
 _key_expansion_256b:
@@ -104,6 +108,7 @@ _key_expansion_256b:
 	pxor %xmm1, %xmm2
 	movaps %xmm2, (%rcx)
 	add $0x10, %rcx
+	pax_force_retaddr_bts
 	ret
 
 /*
@@ -239,7 +244,9 @@ ENTRY(aesni_set_key)
 	cmp %rcx, %rdi
 	jb .Ldec_key_loop
 	xor %rax, %rax
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_set_key)
 
 /*
  * void aesni_enc(struct crypto_aes_ctx *ctx, u8 *dst, const u8 *src)
@@ -249,7 +256,9 @@ ENTRY(aesni_enc)
 	movups (INP), STATE		# input
 	call _aesni_enc1
 	movups STATE, (OUTP)		# output
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_enc)
 
 /*
  * _aesni_enc1:		internal ABI
@@ -319,6 +328,7 @@ _aesni_enc1:
 	movaps 0x70(TKEYP), KEY
 	# aesenclast KEY, STATE	# last round
 	.byte 0x66, 0x0f, 0x38, 0xdd, 0xc2
+	pax_force_retaddr_bts
 	ret
 
 /*
@@ -482,6 +492,7 @@ _aesni_enc4:
 	.byte 0x66, 0x0f, 0x38, 0xdd, 0xea
 	# aesenclast KEY, STATE4
 	.byte 0x66, 0x0f, 0x38, 0xdd, 0xf2
+	pax_force_retaddr_bts
 	ret
 
 /*
@@ -493,7 +504,9 @@ ENTRY(aesni_dec)
 	movups (INP), STATE		# input
 	call _aesni_dec1
 	movups STATE, (OUTP)		#output
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_dec)
 
 /*
  * _aesni_dec1:		internal ABI
@@ -563,6 +576,7 @@ _aesni_dec1:
 	movaps 0x70(TKEYP), KEY
 	# aesdeclast KEY, STATE		# last round
 	.byte 0x66, 0x0f, 0x38, 0xdf, 0xc2
+	pax_force_retaddr_bts
 	ret
 
 /*
@@ -726,6 +740,7 @@ _aesni_dec4:
 	.byte 0x66, 0x0f, 0x38, 0xdf, 0xea
 	# aesdeclast KEY, STATE4
 	.byte 0x66, 0x0f, 0x38, 0xdf, 0xf2
+	pax_force_retaddr_bts
 	ret
 
 /*
@@ -769,7 +784,9 @@ ENTRY(aesni_ecb_enc)
 	cmp $16, LEN
 	jge .Lecb_enc_loop1
 .Lecb_enc_ret:
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_ecb_enc)
 
 /*
  * void aesni_ecb_dec(struct crypto_aes_ctx *ctx, const u8 *dst, u8 *src,
@@ -813,7 +830,9 @@ ENTRY(aesni_ecb_dec)
 	cmp $16, LEN
 	jge .Lecb_dec_loop1
 .Lecb_dec_ret:
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_ecb_dec)
 
 /*
  * void aesni_cbc_enc(struct crypto_aes_ctx *ctx, const u8 *dst, u8 *src,
@@ -837,7 +856,9 @@ ENTRY(aesni_cbc_enc)
 	jge .Lcbc_enc_loop
 	movups STATE, (IVP)
 .Lcbc_enc_ret:
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_cbc_enc)
 
 /*
  * void aesni_cbc_dec(struct crypto_aes_ctx *ctx, const u8 *dst, u8 *src,
@@ -894,4 +915,6 @@ ENTRY(aesni_cbc_dec)
 .Lcbc_dec_ret:
 	movups IV, (IVP)
 .Lcbc_dec_just_ret:
+	pax_force_retaddr 0, 1
 	ret
+ENDPROC(aesni_cbc_dec)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/crypto/aes-x86_64-asm_64.S linux-2.6.32.60-pax/arch/x86/crypto/aes-x86_64-asm_64.S
--- linux-2.6.32.60/arch/x86/crypto/aes-x86_64-asm_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/crypto/aes-x86_64-asm_64.S	2012-03-13 13:15:34.428098028 +0100
@@ -8,6 +8,8 @@
  * including this sentence is retained in full.
  */
 
+#include <asm/alternative-asm.h>
+
 .extern crypto_ft_tab
 .extern crypto_it_tab
 .extern crypto_fl_tab
@@ -71,6 +73,8 @@ FUNC:	movq	r1,r2;			\
 	je	B192;			\
 	leaq	32(r9),r9;
 
+#define ret	pax_force_retaddr 0, 1; ret
+
 #define epilogue(r1,r2,r3,r4,r5,r6,r7,r8,r9) \
 	movq	r1,r2;			\
 	movq	r3,r4;			\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/crypto/salsa20-x86_64-asm_64.S linux-2.6.32.60-pax/arch/x86/crypto/salsa20-x86_64-asm_64.S
--- linux-2.6.32.60/arch/x86/crypto/salsa20-x86_64-asm_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/crypto/salsa20-x86_64-asm_64.S	2012-03-13 13:15:34.428098028 +0100
@@ -1,3 +1,5 @@
+#include <asm/alternative-asm.h>
+
 # enter ECRYPT_encrypt_bytes
 .text
 .p2align 5
@@ -790,6 +792,7 @@ ECRYPT_encrypt_bytes:
 	add	%r11,%rsp
 	mov	%rdi,%rax
 	mov	%rsi,%rdx
+	pax_force_retaddr 0, 1
 	ret
 #   bytesatleast65:
 ._bytesatleast65:
@@ -891,6 +894,7 @@ ECRYPT_keysetup:
 	add	%r11,%rsp
 	mov	%rdi,%rax
 	mov	%rsi,%rdx
+	pax_force_retaddr
 	ret
 # enter ECRYPT_ivsetup
 .text
@@ -917,4 +921,5 @@ ECRYPT_ivsetup:
 	add	%r11,%rsp
 	mov	%rdi,%rax
 	mov	%rsi,%rdx
+	pax_force_retaddr
 	ret
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/crypto/twofish-x86_64-asm_64.S linux-2.6.32.60-pax/arch/x86/crypto/twofish-x86_64-asm_64.S
--- linux-2.6.32.60/arch/x86/crypto/twofish-x86_64-asm_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/crypto/twofish-x86_64-asm_64.S	2012-03-13 13:15:34.432098027 +0100
@@ -21,6 +21,7 @@
 .text
 
 #include <asm/asm-offsets.h>
+#include <asm/alternative-asm.h>
 
 #define a_offset	0
 #define b_offset	4
@@ -269,6 +270,7 @@ twofish_enc_blk:
 
 	popq	R1
 	movq	$1,%rax
+	pax_force_retaddr 0, 1
 	ret
 
 twofish_dec_blk:
@@ -321,4 +323,5 @@ twofish_dec_blk:
 
 	popq	R1
 	movq	$1,%rax
+	pax_force_retaddr 0, 1
 	ret
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/ia32/ia32entry.S linux-2.6.32.60-pax/arch/x86/ia32/ia32entry.S
--- linux-2.6.32.60/arch/x86/ia32/ia32entry.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/ia32/ia32entry.S	2012-08-25 11:16:46.269915728 +0200
@@ -13,7 +13,9 @@
 #include <asm/thread_info.h>	
 #include <asm/segment.h>
 #include <asm/irqflags.h>
+#include <asm/pgtable.h>
 #include <linux/linkage.h>
+#include <asm/alternative-asm.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -93,6 +95,32 @@ ENTRY(native_irq_enable_sysexit)
 ENDPROC(native_irq_enable_sysexit)
 #endif
 
+	.macro pax_enter_kernel_user
+	pax_set_fptr_mask
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_enter_kernel_user
+#endif
+	.endm
+
+	.macro pax_exit_kernel_user
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_exit_kernel_user
+#endif
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushq %rax
+	pushq %r11
+	call pax_randomize_kstack
+	popq %r11
+	popq %rax
+#endif
+	.endm
+
+.macro pax_erase_kstack
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+	call pax_erase_kstack
+#endif
+.endm
+
 /*
  * 32bit SYSENTER instruction entry.
  *
@@ -119,12 +147,6 @@ ENTRY(ia32_sysenter_target)
 	CFI_REGISTER	rsp,rbp
 	SWAPGS_UNSAFE_STACK
 	movq	PER_CPU_VAR(kernel_stack), %rsp
-	addq	$(KERNEL_STACK_OFFSET),%rsp
-	/*
-	 * No need to follow this irqs on/off section: the syscall
-	 * disabled irqs, here we enable it straight after entry:
-	 */
-	ENABLE_INTERRUPTS(CLBR_NONE)
  	movl	%ebp,%ebp		/* zero extension */
 	pushq	$__USER32_DS
 	CFI_ADJUST_CFA_OFFSET 8
@@ -135,28 +157,47 @@ ENTRY(ia32_sysenter_target)
 	pushfq
 	CFI_ADJUST_CFA_OFFSET 8
 	/*CFI_REL_OFFSET rflags,0*/
-	movl	8*3-THREAD_SIZE+TI_sysenter_return(%rsp), %r10d
-	CFI_REGISTER rip,r10
+	orl	$X86_EFLAGS_IF,(%rsp)
+	GET_THREAD_INFO(%r11)
+	movl	TI_sysenter_return(%r11), %r11d
+	CFI_REGISTER rip,r11
 	pushq	$__USER32_CS
 	CFI_ADJUST_CFA_OFFSET 8
 	/*CFI_REL_OFFSET cs,0*/
 	movl	%eax, %eax
-	pushq	%r10
+	pushq	%r11
 	CFI_ADJUST_CFA_OFFSET 8
 	CFI_REL_OFFSET rip,0
 	pushq	%rax
 	CFI_ADJUST_CFA_OFFSET 8
 	cld
 	SAVE_ARGS 0,0,1
+	pax_enter_kernel_user
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
+	/*
+	 * No need to follow this irqs on/off section: the syscall
+	 * disabled irqs, here we enable it straight after entry:
+	 */
+	ENABLE_INTERRUPTS(CLBR_NONE)
  	/* no need to do an access_ok check here because rbp has been
  	   32bit zero extended */ 
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov $PAX_USER_SHADOW_BASE,%r11
+	add %r11,%rbp
+#endif
+
 1:	movl	(%rbp),%ebp
  	.section __ex_table,"a"
  	.quad 1b,ia32_badarg
  	.previous	
-	GET_THREAD_INFO(%r10)
-	orl    $TS_COMPAT,TI_status(%r10)
-	testl  $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	GET_THREAD_INFO(%r11)
+	orl    $TS_COMPAT,TI_status(%r11)
+	testl  $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r11)
 	CFI_REMEMBER_STATE
 	jnz  sysenter_tracesys
 	cmpq	$(IA32_NR_syscalls-1),%rax
@@ -166,13 +207,15 @@ sysenter_do_call:
 sysenter_dispatch:
 	call	*ia32_sys_call_table(,%rax,8)
 	movq	%rax,RAX-ARGOFFSET(%rsp)
-	GET_THREAD_INFO(%r10)
+	GET_THREAD_INFO(%r11)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	TRACE_IRQS_OFF
-	testl	$_TIF_ALLWORK_MASK,TI_flags(%r10)
+	testl	$_TIF_ALLWORK_MASK,TI_flags(%r11)
 	jnz	sysexit_audit
 sysexit_from_sys_call:
-	andl    $~TS_COMPAT,TI_status(%r10)
+	pax_exit_kernel_user
+	pax_erase_kstack
+	andl    $~TS_COMPAT,TI_status(%r11)
 	/* clear IF, that popfq doesn't enable interrupts early */
 	andl  $~0x200,EFLAGS-R11(%rsp) 
 	movl	RIP-R11(%rsp),%edx		/* User %eip */
@@ -200,6 +243,9 @@ sysexit_from_sys_call:
 	movl %eax,%esi			/* 2nd arg: syscall number */
 	movl $AUDIT_ARCH_I386,%edi	/* 1st arg: audit arch */
 	call audit_syscall_entry
+
+	pax_erase_kstack
+
 	movl RAX-ARGOFFSET(%rsp),%eax	/* reload syscall number */
 	cmpq $(IA32_NR_syscalls-1),%rax
 	ja ia32_badsys
@@ -211,7 +257,7 @@ sysexit_from_sys_call:
 	.endm
 
 	.macro auditsys_exit exit
-	testl $(_TIF_ALLWORK_MASK & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
+	testl $(_TIF_ALLWORK_MASK & ~_TIF_SYSCALL_AUDIT),TI_flags(%r11)
 	jnz ia32_ret_from_sys_call
 	TRACE_IRQS_ON
 	sti
@@ -221,12 +267,12 @@ sysexit_from_sys_call:
 	movzbl %al,%edi		/* zero-extend that into %edi */
 	inc %edi /* first arg, 0->1(AUDITSC_SUCCESS), 1->2(AUDITSC_FAILURE) */
 	call audit_syscall_exit
-	GET_THREAD_INFO(%r10)
+	GET_THREAD_INFO(%r11)
 	movl RAX-ARGOFFSET(%rsp),%eax	/* reload syscall return value */
 	movl $(_TIF_ALLWORK_MASK & ~_TIF_SYSCALL_AUDIT),%edi
 	cli
 	TRACE_IRQS_OFF
-	testl %edi,TI_flags(%r10)
+	testl %edi,TI_flags(%r11)
 	jz \exit
 	CLEAR_RREGS -ARGOFFSET
 	jmp int_with_check
@@ -244,7 +290,7 @@ sysexit_audit:
 
 sysenter_tracesys:
 #ifdef CONFIG_AUDITSYSCALL
-	testl	$(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
+	testl	$(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r11)
 	jz	sysenter_auditsys
 #endif
 	SAVE_REST
@@ -256,6 +302,9 @@ sysenter_tracesys:
 	RESTORE_REST
 	cmpq	$(IA32_NR_syscalls-1),%rax
 	ja	int_ret_from_sys_call /* sysenter_tracesys has set RAX(%rsp) */
+
+	pax_erase_kstack
+
 	jmp	sysenter_do_call
 	CFI_ENDPROC
 ENDPROC(ia32_sysenter_target)
@@ -283,19 +332,25 @@ ENDPROC(ia32_sysenter_target)
 ENTRY(ia32_cstar_target)
 	CFI_STARTPROC32	simple
 	CFI_SIGNAL_FRAME
-	CFI_DEF_CFA	rsp,KERNEL_STACK_OFFSET
+	CFI_DEF_CFA	rsp,0
 	CFI_REGISTER	rip,rcx
 	/*CFI_REGISTER	rflags,r11*/
 	SWAPGS_UNSAFE_STACK
 	movl	%esp,%r8d
 	CFI_REGISTER	rsp,r8
 	movq	PER_CPU_VAR(kernel_stack),%rsp
+	SAVE_ARGS 8*6,1,1
+	pax_enter_kernel_user
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
 	/*
 	 * No need to follow this irqs on/off section: the syscall
 	 * disabled irqs and here we enable it straight after entry:
 	 */
 	ENABLE_INTERRUPTS(CLBR_NONE)
-	SAVE_ARGS 8,1,1
 	movl 	%eax,%eax	/* zero extension */
 	movq	%rax,ORIG_RAX-ARGOFFSET(%rsp)
 	movq	%rcx,RIP-ARGOFFSET(%rsp)
@@ -311,13 +366,19 @@ ENTRY(ia32_cstar_target)
 	/* no need to do an access_ok check here because r8 has been
 	   32bit zero extended */ 
 	/* hardware stack frame is complete now */	
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov $PAX_USER_SHADOW_BASE,%r11
+	add %r11,%r8
+#endif
+
 1:	movl	(%r8),%r9d
 	.section __ex_table,"a"
 	.quad 1b,ia32_badarg
 	.previous	
-	GET_THREAD_INFO(%r10)
-	orl   $TS_COMPAT,TI_status(%r10)
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	GET_THREAD_INFO(%r11)
+	orl   $TS_COMPAT,TI_status(%r11)
+	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r11)
 	CFI_REMEMBER_STATE
 	jnz   cstar_tracesys
 	cmpq $IA32_NR_syscalls-1,%rax
@@ -327,13 +388,15 @@ cstar_do_call:
 cstar_dispatch:
 	call *ia32_sys_call_table(,%rax,8)
 	movq %rax,RAX-ARGOFFSET(%rsp)
-	GET_THREAD_INFO(%r10)
+	GET_THREAD_INFO(%r11)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	TRACE_IRQS_OFF
-	testl $_TIF_ALLWORK_MASK,TI_flags(%r10)
+	testl $_TIF_ALLWORK_MASK,TI_flags(%r11)
 	jnz sysretl_audit
 sysretl_from_sys_call:
-	andl $~TS_COMPAT,TI_status(%r10)
+	pax_exit_kernel_user
+	pax_erase_kstack
+	andl $~TS_COMPAT,TI_status(%r11)
 	RESTORE_ARGS 1,-ARG_SKIP,1,1,1
 	movl RIP-ARGOFFSET(%rsp),%ecx
 	CFI_REGISTER rip,rcx
@@ -361,7 +424,7 @@ sysretl_audit:
 
 cstar_tracesys:
 #ifdef CONFIG_AUDITSYSCALL
-	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
+	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r11)
 	jz cstar_auditsys
 #endif
 	xchgl %r9d,%ebp
@@ -375,6 +438,9 @@ cstar_tracesys:
 	xchgl %ebp,%r9d
 	cmpq $(IA32_NR_syscalls-1),%rax
 	ja int_ret_from_sys_call /* cstar_tracesys has set RAX(%rsp) */
+
+	pax_erase_kstack
+
 	jmp cstar_do_call
 END(ia32_cstar_target)
 				
@@ -415,11 +481,6 @@ ENTRY(ia32_syscall)
 	CFI_REL_OFFSET	rip,RIP-RIP
 	PARAVIRT_ADJUST_EXCEPTION_FRAME
 	SWAPGS
-	/*
-	 * No need to follow this irqs on/off section: the syscall
-	 * disabled irqs and here we enable it straight after entry:
-	 */
-	ENABLE_INTERRUPTS(CLBR_NONE)
 	movl %eax,%eax
 	pushq %rax
 	CFI_ADJUST_CFA_OFFSET 8
@@ -427,9 +488,20 @@ ENTRY(ia32_syscall)
 	/* note the registers are not zero extended to the sf.
 	   this could be a problem. */
 	SAVE_ARGS 0,0,1
-	GET_THREAD_INFO(%r10)
-	orl   $TS_COMPAT,TI_status(%r10)
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	pax_enter_kernel_user
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
+	/*
+	 * No need to follow this irqs on/off section: the syscall
+	 * disabled irqs and here we enable it straight after entry:
+	 */
+	ENABLE_INTERRUPTS(CLBR_NONE)
+	GET_THREAD_INFO(%r11)
+	orl   $TS_COMPAT,TI_status(%r11)
+	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r11)
 	jnz ia32_tracesys
 	cmpq $(IA32_NR_syscalls-1),%rax
 	ja ia32_badsys
@@ -452,6 +524,9 @@ ia32_tracesys:
 	RESTORE_REST
 	cmpq $(IA32_NR_syscalls-1),%rax
 	ja  int_ret_from_sys_call	/* ia32_tracesys has set RAX(%rsp) */
+
+	pax_erase_kstack
+
 	jmp ia32_do_call
 END(ia32_syscall)
 
@@ -462,6 +537,7 @@ ia32_badsys:
 
 quiet_ni_syscall:
 	movq $-ENOSYS,%rax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 	
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/ia32/ia32_signal.c linux-2.6.32.60-pax/arch/x86/ia32/ia32_signal.c
--- linux-2.6.32.60/arch/x86/ia32/ia32_signal.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/ia32/ia32_signal.c	2012-03-13 13:15:34.432098027 +0100
@@ -167,7 +167,7 @@ asmlinkage long sys32_sigaltstack(const
 	}
 	seg = get_fs();
 	set_fs(KERNEL_DS);
-	ret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss, regs->sp);
+	ret = do_sigaltstack(uss_ptr ? (const stack_t __force_user *)&uss : NULL, (stack_t __force_user *)&uoss, regs->sp);
 	set_fs(seg);
 	if (ret >= 0 && uoss_ptr)  {
 		if (!access_ok(VERIFY_WRITE, uoss_ptr, sizeof(stack_ia32_t)))
@@ -374,7 +374,7 @@ static int ia32_setup_sigcontext(struct
  */
 static void __user *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,
 				 size_t frame_size,
-				 void **fpstate)
+				 void __user **fpstate)
 {
 	unsigned long sp;
 
@@ -395,7 +395,7 @@ static void __user *get_sigframe(struct
 
 	if (used_math()) {
 		sp = sp - sig_xstate_ia32_size;
-		*fpstate = (struct _fpstate_ia32 *) sp;
+		*fpstate = (struct _fpstate_ia32 __user *) sp;
 		if (save_i387_xstate_ia32(*fpstate) < 0)
 			return (void __user *) -1L;
 	}
@@ -403,7 +403,7 @@ static void __user *get_sigframe(struct
 	sp -= frame_size;
 	/* Align the stack pointer according to the i386 ABI,
 	 * i.e. so that on function entry ((sp + 4) & 15) == 0. */
-	sp = ((sp + 4) & -16ul) - 4;
+	sp = ((sp - 12) & -16ul) - 4;
 	return (void __user *) sp;
 }
 
@@ -461,7 +461,7 @@ int ia32_setup_frame(int sig, struct k_s
 		 * These are actually not used anymore, but left because some
 		 * gdb versions depend on them as a marker.
 		 */
-		put_user_ex(*((u64 *)&code), (u64 *)frame->retcode);
+		put_user_ex(*((const u64 *)&code), (u64 __user *)frame->retcode);
 	} put_user_catch(err);
 
 	if (err)
@@ -503,7 +503,7 @@ int ia32_setup_rt_frame(int sig, struct
 		0xb8,
 		__NR_ia32_rt_sigreturn,
 		0x80cd,
-		0,
+		0
 	};
 
 	frame = get_sigframe(ka, regs, sizeof(*frame), &fpstate);
@@ -533,16 +533,18 @@ int ia32_setup_rt_frame(int sig, struct
 
 		if (ka->sa.sa_flags & SA_RESTORER)
 			restorer = ka->sa.sa_restorer;
+		else if (current->mm->context.vdso)
+			/* Return stub is in 32bit vsyscall page */
+			restorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);
 		else
-			restorer = VDSO32_SYMBOL(current->mm->context.vdso,
-						 rt_sigreturn);
+			restorer = &frame->retcode;
 		put_user_ex(ptr_to_compat(restorer), &frame->pretcode);
 
 		/*
 		 * Not actually used anymore, but left because some gdb
 		 * versions need it.
 		 */
-		put_user_ex(*((u64 *)&code), (u64 *)frame->retcode);
+		put_user_ex(*((const u64 *)&code), (u64 __user *)frame->retcode);
 	} put_user_catch(err);
 
 	if (err)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/ia32/sys_ia32.c linux-2.6.32.60-pax/arch/x86/ia32/sys_ia32.c
--- linux-2.6.32.60/arch/x86/ia32/sys_ia32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/ia32/sys_ia32.c	2012-03-13 13:15:34.432098027 +0100
@@ -69,8 +69,8 @@ asmlinkage long sys32_ftruncate64(unsign
  */
 static int cp_stat64(struct stat64 __user *ubuf, struct kstat *stat)
 {
-	typeof(ubuf->st_uid) uid = 0;
-	typeof(ubuf->st_gid) gid = 0;
+	typeof(((struct stat64 *)0)->st_uid) uid = 0;
+	typeof(((struct stat64 *)0)->st_gid) gid = 0;
 	SET_UID(uid, stat->uid);
 	SET_GID(gid, stat->gid);
 	if (!access_ok(VERIFY_WRITE, ubuf, sizeof(struct stat64)) ||
@@ -308,8 +308,8 @@ asmlinkage long sys32_rt_sigprocmask(int
 	}
 	set_fs(KERNEL_DS);
 	ret = sys_rt_sigprocmask(how,
-				 set ? (sigset_t __user *)&s : NULL,
-				 oset ? (sigset_t __user *)&s : NULL,
+				 set ? (sigset_t __force_user *)&s : NULL,
+				 oset ? (sigset_t __force_user *)&s : NULL,
 				 sigsetsize);
 	set_fs(old_fs);
 	if (ret)
@@ -371,7 +371,7 @@ asmlinkage long sys32_sched_rr_get_inter
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
-	ret = sys_sched_rr_get_interval(pid, (struct timespec __user *)&t);
+	ret = sys_sched_rr_get_interval(pid, (struct timespec __force_user *)&t);
 	set_fs(old_fs);
 	if (put_compat_timespec(&t, interval))
 		return -EFAULT;
@@ -387,7 +387,7 @@ asmlinkage long sys32_rt_sigpending(comp
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
-	ret = sys_rt_sigpending((sigset_t __user *)&s, sigsetsize);
+	ret = sys_rt_sigpending((sigset_t __force_user *)&s, sigsetsize);
 	set_fs(old_fs);
 	if (!ret) {
 		switch (_NSIG_WORDS) {
@@ -412,7 +412,7 @@ asmlinkage long sys32_rt_sigqueueinfo(in
 	if (copy_siginfo_from_user32(&info, uinfo))
 		return -EFAULT;
 	set_fs(KERNEL_DS);
-	ret = sys_rt_sigqueueinfo(pid, sig, (siginfo_t __user *)&info);
+	ret = sys_rt_sigqueueinfo(pid, sig, (siginfo_t __force_user *)&info);
 	set_fs(old_fs);
 	return ret;
 }
@@ -513,7 +513,7 @@ asmlinkage long sys32_sendfile(int out_f
 		return -EFAULT;
 
 	set_fs(KERNEL_DS);
-	ret = sys_sendfile(out_fd, in_fd, offset ? (off_t __user *)&of : NULL,
+	ret = sys_sendfile(out_fd, in_fd, offset ? (off_t __force_user *)&of : NULL,
 			   count);
 	set_fs(old_fs);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/alternative-asm.h linux-2.6.32.60-pax/arch/x86/include/asm/alternative-asm.h
--- linux-2.6.32.60/arch/x86/include/asm/alternative-asm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/alternative-asm.h	2012-03-13 13:15:34.436098027 +0100
@@ -8,10 +8,10 @@
 
 #ifdef CONFIG_SMP
 	.macro LOCK_PREFIX
-1:	lock
+672:	lock
 	.section .smp_locks,"a"
 	.align 4
-	X86_ALIGN 1b
+	X86_ALIGN 672b
 	.previous
 	.endm
 #else
@@ -19,4 +19,43 @@
 	.endm
 #endif
 
+#ifdef KERNEXEC_PLUGIN
+	.macro pax_force_retaddr_bts rip=0
+	btsq $63,\rip(%rsp)
+	.endm
+#ifdef CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_BTS
+	.macro pax_force_retaddr rip=0, reload=0
+	btsq $63,\rip(%rsp)
+	.endm
+	.macro pax_force_fptr ptr
+	btsq $63,\ptr
+	.endm
+	.macro pax_set_fptr_mask
+	.endm
+#endif
+#ifdef CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR
+	.macro pax_force_retaddr rip=0, reload=0
+	.if \reload
+	pax_set_fptr_mask
+	.endif
+	orq %r10,\rip(%rsp)
+	.endm
+	.macro pax_force_fptr ptr
+	orq %r10,\ptr
+	.endm
+	.macro pax_set_fptr_mask
+	movabs $0x8000000000000000,%r10
+	.endm
+#endif
+#else
+	.macro pax_force_retaddr rip=0, reload=0
+	.endm
+	.macro pax_force_fptr ptr
+	.endm
+	.macro pax_force_retaddr_bts rip=0
+	.endm
+	.macro pax_set_fptr_mask
+	.endm
+#endif
+
 #endif  /*  __ASSEMBLY__  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/alternative.h linux-2.6.32.60-pax/arch/x86/include/asm/alternative.h
--- linux-2.6.32.60/arch/x86/include/asm/alternative.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/alternative.h	2012-03-13 13:15:34.440098027 +0100
@@ -85,7 +85,7 @@ static inline void alternatives_smp_swit
       "	 .byte 662b-661b\n"			/* sourcelen       */	\
       "	 .byte 664f-663f\n"			/* replacementlen  */	\
       ".previous\n"							\
-      ".section .altinstr_replacement, \"ax\"\n"			\
+      ".section .altinstr_replacement, \"a\"\n"			\
       "663:\n\t" newinstr "\n664:\n"		/* replacement     */	\
       ".previous"
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/apic.h linux-2.6.32.60-pax/arch/x86/include/asm/apic.h
--- linux-2.6.32.60/arch/x86/include/asm/apic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/apic.h	2012-03-13 13:15:34.444098027 +0100
@@ -46,7 +46,7 @@ static inline void generic_apic_probe(vo
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
-extern unsigned int apic_verbosity;
+extern int apic_verbosity;
 extern int local_apic_timer_c2_ok;
 
 extern int disable_apic;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/apm.h linux-2.6.32.60-pax/arch/x86/include/asm/apm.h
--- linux-2.6.32.60/arch/x86/include/asm/apm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/apm.h	2012-03-13 13:15:34.444098027 +0100
@@ -34,7 +34,7 @@ static inline void apm_bios_call_asm(u32
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%al\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
@@ -58,7 +58,7 @@ static inline u8 apm_bios_call_simple_as
 	__asm__ __volatile__(APM_DO_ZERO_SEGS
 		"pushl %%edi\n\t"
 		"pushl %%ebp\n\t"
-		"lcall *%%cs:apm_bios_entry\n\t"
+		"lcall *%%ss:apm_bios_entry\n\t"
 		"setc %%bl\n\t"
 		"popl %%ebp\n\t"
 		"popl %%edi\n\t"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/atomic_32.h linux-2.6.32.60-pax/arch/x86/include/asm/atomic_32.h
--- linux-2.6.32.60/arch/x86/include/asm/atomic_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/atomic_32.h	2012-07-21 11:14:49.133048492 +0200
@@ -25,6 +25,17 @@ static inline int atomic_read(const atom
 }
 
 /**
+ * atomic_read_unchecked - read atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically reads the value of @v.
+ */
+static inline int atomic_read_unchecked(const atomic_unchecked_t *v)
+{
+	return v->counter;
+}
+
+/**
  * atomic_set - set atomic variable
  * @v: pointer of type atomic_t
  * @i: required value
@@ -37,6 +48,18 @@ static inline void atomic_set(atomic_t *
 }
 
 /**
+ * atomic_set_unchecked - set atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+static inline void atomic_set_unchecked(atomic_unchecked_t *v, int i)
+{
+	v->counter = i;
+}
+
+/**
  * atomic_add - add integer to atomic variable
  * @i: integer value to add
  * @v: pointer of type atomic_t
@@ -45,7 +68,29 @@ static inline void atomic_set(atomic_t *
  */
 static inline void atomic_add(int i, atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "addl %1,%0"
+	asm volatile(LOCK_PREFIX "addl %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subl %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (v->counter)
+		     : "ir" (i));
+}
+
+/**
+ * atomic_add_unchecked - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically adds @i to @v.
+ */
+static inline void atomic_add_unchecked(int i, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "addl %1,%0\n"
 		     : "+m" (v->counter)
 		     : "ir" (i));
 }
@@ -59,7 +104,29 @@ static inline void atomic_add(int i, ato
  */
 static inline void atomic_sub(int i, atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "subl %1,%0"
+	asm volatile(LOCK_PREFIX "subl %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addl %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (v->counter)
+		     : "ir" (i));
+}
+
+/**
+ * atomic_sub_unchecked - subtract integer from atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically subtracts @i from @v.
+ */
+static inline void atomic_sub_unchecked(int i, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "subl %1,%0\n"
 		     : "+m" (v->counter)
 		     : "ir" (i));
 }
@@ -77,7 +144,16 @@ static inline int atomic_sub_and_test(in
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "subl %2,%0; sete %1"
+	asm volatile(LOCK_PREFIX "subl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addl %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "+m" (v->counter), "=qm" (c)
 		     : "ir" (i) : "memory");
 	return c;
@@ -91,7 +167,27 @@ static inline int atomic_sub_and_test(in
  */
 static inline void atomic_inc(atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "incl %0"
+	asm volatile(LOCK_PREFIX "incl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (v->counter));
+}
+
+/**
+ * atomic_inc_unchecked - increment atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically increments @v by 1.
+ */
+static inline void atomic_inc_unchecked(atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "incl %0\n"
 		     : "+m" (v->counter));
 }
 
@@ -103,7 +199,27 @@ static inline void atomic_inc(atomic_t *
  */
 static inline void atomic_dec(atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "decl %0"
+	asm volatile(LOCK_PREFIX "decl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (v->counter));
+}
+
+/**
+ * atomic_dec_unchecked - decrement atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically decrements @v by 1.
+ */
+static inline void atomic_dec_unchecked(atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "decl %0\n"
 		     : "+m" (v->counter));
 }
 
@@ -119,7 +235,16 @@ static inline int atomic_dec_and_test(at
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "decl %0; sete %1"
+	asm volatile(LOCK_PREFIX "decl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "+m" (v->counter), "=qm" (c)
 		     : : "memory");
 	return c != 0;
@@ -137,7 +262,35 @@ static inline int atomic_inc_and_test(at
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "incl %0; sete %1"
+	asm volatile(LOCK_PREFIX "incl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decl %0\n"
+		     "into\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
+		     : "+m" (v->counter), "=qm" (c)
+		     : : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic_inc_and_test_unchecked - increment and test
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+static inline int atomic_inc_and_test_unchecked(atomic_unchecked_t *v)
+{
+	unsigned char c;
+
+	asm volatile(LOCK_PREFIX "incl %0\n"
+		     "sete %1\n"
 		     : "+m" (v->counter), "=qm" (c)
 		     : : "memory");
 	return c != 0;
@@ -156,7 +309,16 @@ static inline int atomic_add_negative(in
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "addl %2,%0; sets %1"
+	asm volatile(LOCK_PREFIX "addl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subl %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sets %1\n"
 		     : "+m" (v->counter), "=qm" (c)
 		     : "ir" (i) : "memory");
 	return c;
@@ -179,7 +341,15 @@ static inline int atomic_add_return(int
 #endif
 	/* Modern 486+ processor */
 	__i = i;
-	asm volatile(LOCK_PREFIX "xaddl %0, %1"
+	asm volatile(LOCK_PREFIX "xaddl %0, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "movl %0, %1\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "+r" (i), "+m" (v->counter)
 		     : : "memory");
 	return i + __i;
@@ -195,6 +365,38 @@ no_xadd: /* Legacy 386 processor */
 }
 
 /**
+ * atomic_add_return_unchecked - add integer and return
+ * @v: pointer of type atomic_unchecked_t
+ * @i: integer value to add
+ *
+ * Atomically adds @i to @v and returns @i + @v
+ */
+static inline int atomic_add_return_unchecked(int i, atomic_unchecked_t *v)
+{
+	int __i;
+#ifdef CONFIG_M386
+	unsigned long flags;
+	if (unlikely(boot_cpu_data.x86 <= 3))
+		goto no_xadd;
+#endif
+	/* Modern 486+ processor */
+	__i = i;
+	asm volatile(LOCK_PREFIX "xaddl %0, %1"
+		     : "+r" (i), "+m" (v->counter)
+		     : : "memory");
+	return i + __i;
+
+#ifdef CONFIG_M386
+no_xadd: /* Legacy 386 processor */
+	local_irq_save(flags);
+	__i = atomic_read_unchecked(v);
+	atomic_set_unchecked(v, i + __i);
+	local_irq_restore(flags);
+	return i + __i;
+#endif
+}
+
+/**
  * atomic_sub_return - subtract integer and return
  * @v: pointer of type atomic_t
  * @i: integer value to subtract
@@ -211,11 +413,21 @@ static inline int atomic_cmpxchg(atomic_
 	return cmpxchg(&v->counter, old, new);
 }
 
+static inline int atomic_cmpxchg_unchecked(atomic_unchecked_t *v, int old, int new)
+{
+	return cmpxchg(&v->counter, old, new);
+}
+
 static inline int atomic_xchg(atomic_t *v, int new)
 {
 	return xchg(&v->counter, new);
 }
 
+static inline int atomic_xchg_unchecked(atomic_unchecked_t *v, int new)
+{
+	return xchg(&v->counter, new);
+}
+
 /**
  * atomic_add_unless - add unless the number is already a given value
  * @v: pointer of type atomic_t
@@ -227,32 +439,73 @@ static inline int atomic_xchg(atomic_t *
  */
 static inline int atomic_add_unless(atomic_t *v, int a, int u)
 {
-	int c, old;
+	int c, old, new;
 	c = atomic_read(v);
 	for (;;) {
-		if (unlikely(c == (u)))
+		if (unlikely(c == u))
 			break;
-		old = atomic_cmpxchg((v), c, c + (a));
+
+		asm volatile("addl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+			     "jno 0f\n"
+			     "subl %2,%0\n"
+			     "int $4\n0:\n"
+			     _ASM_EXTABLE(0b, 0b)
+#endif
+
+			     : "=r" (new)
+			     : "0" (c), "ir" (a));
+
+		old = atomic_cmpxchg(v, c, new);
 		if (likely(old == c))
 			break;
 		c = old;
 	}
-	return c != (u);
+	return c != u;
 }
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
 #define atomic_inc_return(v)  (atomic_add_return(1, v))
+static inline int atomic_inc_return_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_add_return_unchecked(1, v);
+}
 #define atomic_dec_return(v)  (atomic_sub_return(1, v))
 
 /* These are x86-specific, used by some header files */
-#define atomic_clear_mask(mask, addr)				\
-	asm volatile(LOCK_PREFIX "andl %0,%1"			\
-		     : : "r" (~(mask)), "m" (*(addr)) : "memory")
-
-#define atomic_set_mask(mask, addr)				\
-	asm volatile(LOCK_PREFIX "orl %0,%1"				\
-		     : : "r" (mask), "m" (*(addr)) : "memory")
+static inline void atomic_clear_mask(unsigned int mask, atomic_t *v)
+{
+	asm volatile(LOCK_PREFIX "andl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (~(mask))
+		     : "memory");
+}
+
+static inline void atomic_clear_mask_unchecked(unsigned int mask, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "andl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (~(mask))
+		     : "memory");
+}
+
+static inline void atomic_set_mask(unsigned int mask, atomic_t *v)
+{
+	asm volatile(LOCK_PREFIX "orl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (mask)
+		     : "memory");
+}
+
+static inline void atomic_set_mask_unchecked(unsigned int mask, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "orl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (mask)
+		     : "memory");
+}
 
 /* Atomic operations are already serializing on x86 */
 #define smp_mb__before_atomic_dec()	barrier()
@@ -266,9 +519,18 @@ typedef struct {
 	u64 __aligned(8) counter;
 } atomic64_t;
 
+#ifdef CONFIG_PAX_REFCOUNT
+typedef struct {
+	u64 __aligned(8) counter;
+} atomic64_unchecked_t;
+#else
+typedef atomic64_t atomic64_unchecked_t;
+#endif
+
 #define ATOMIC64_INIT(val)	{ (val) }
 
 extern u64 atomic64_cmpxchg(atomic64_t *ptr, u64 old_val, u64 new_val);
+extern u64 atomic64_cmpxchg_unchecked(atomic64_unchecked_t *ptr, u64 old_val, u64 new_val);
 
 /**
  * atomic64_xchg - xchg atomic64 variable
@@ -279,6 +541,7 @@ extern u64 atomic64_cmpxchg(atomic64_t *
  * the old value.
  */
 extern u64 atomic64_xchg(atomic64_t *ptr, u64 new_val);
+extern u64 atomic64_xchg_unchecked(atomic64_unchecked_t *ptr, u64 new_val);
 
 /**
  * atomic64_set - set atomic64 variable
@@ -290,6 +553,15 @@ extern u64 atomic64_xchg(atomic64_t *ptr
 extern void atomic64_set(atomic64_t *ptr, u64 new_val);
 
 /**
+ * atomic64_unchecked_set - set atomic64 variable
+ * @ptr:      pointer to type atomic64_unchecked_t
+ * @new_val:  value to assign
+ *
+ * Atomically sets the value of @ptr to @new_val.
+ */
+extern void atomic64_set_unchecked(atomic64_unchecked_t *ptr, u64 new_val);
+
+/**
  * atomic64_read - read atomic64 variable
  * @ptr:      pointer to type atomic64_t
  *
@@ -317,7 +589,33 @@ static inline u64 atomic64_read(atomic64
 	return res;
 }
 
-extern u64 atomic64_read(atomic64_t *ptr);
+/**
+ * atomic64_read_unchecked - read atomic64 variable
+ * @ptr:      pointer to type atomic64_unchecked_t
+ *
+ * Atomically reads the value of @ptr and returns it.
+ */
+static inline u64 atomic64_read_unchecked(atomic64_unchecked_t *ptr)
+{
+	u64 res;
+
+	/*
+	 * Note, we inline this atomic64_unchecked_t primitive because
+	 * it only clobbers EAX/EDX and leaves the others
+	 * untouched. We also (somewhat subtly) rely on the
+	 * fact that cmpxchg8b returns the current 64-bit value
+	 * of the memory location we are touching:
+	 */
+	asm volatile(
+		"mov %%ebx, %%eax\n\t"
+		"mov %%ecx, %%edx\n\t"
+		LOCK_PREFIX "cmpxchg8b %1\n"
+			: "=&A" (res)
+			: "m" (*ptr)
+		);
+
+	return res;
+}
 
 /**
  * atomic64_add_return - add and return
@@ -332,8 +630,11 @@ extern u64 atomic64_add_return(u64 delta
  * Other variants with different arithmetic operators:
  */
 extern u64 atomic64_sub_return(u64 delta, atomic64_t *ptr);
+extern u64 atomic64_sub_return_unchecked(u64 delta, atomic64_unchecked_t *ptr);
 extern u64 atomic64_inc_return(atomic64_t *ptr);
+extern u64 atomic64_inc_return_unchecked(atomic64_unchecked_t *ptr);
 extern u64 atomic64_dec_return(atomic64_t *ptr);
+extern u64 atomic64_dec_return_unchecked(atomic64_unchecked_t *ptr);
 
 /**
  * atomic64_add - add integer to atomic64 variable
@@ -345,6 +646,15 @@ extern u64 atomic64_dec_return(atomic64_
 extern void atomic64_add(u64 delta, atomic64_t *ptr);
 
 /**
+ * atomic64_add_unchecked - add integer to atomic64 variable
+ * @delta: integer value to add
+ * @ptr:   pointer to type atomic64_unchecked_t
+ *
+ * Atomically adds @delta to @ptr.
+ */
+extern void atomic64_add_unchecked(u64 delta, atomic64_unchecked_t *ptr);
+
+/**
  * atomic64_sub - subtract the atomic64 variable
  * @delta: integer value to subtract
  * @ptr:   pointer to type atomic64_t
@@ -354,6 +664,15 @@ extern void atomic64_add(u64 delta, atom
 extern void atomic64_sub(u64 delta, atomic64_t *ptr);
 
 /**
+ * atomic64_sub_unchecked - subtract the atomic64 variable
+ * @delta: integer value to subtract
+ * @ptr:   pointer to type atomic64_unchecked_t
+ *
+ * Atomically subtracts @delta from @ptr.
+ */
+extern void atomic64_sub_unchecked(u64 delta, atomic64_unchecked_t *ptr);
+
+/**
  * atomic64_sub_and_test - subtract value from variable and test result
  * @delta: integer value to subtract
  * @ptr:   pointer to type atomic64_t
@@ -373,6 +692,14 @@ extern int atomic64_sub_and_test(u64 del
 extern void atomic64_inc(atomic64_t *ptr);
 
 /**
+ * atomic64_inc_unchecked - increment atomic64 variable
+ * @ptr: pointer to type atomic64_unchecked_t
+ *
+ * Atomically increments @ptr by 1.
+ */
+extern void atomic64_inc_unchecked(atomic64_unchecked_t *ptr);
+
+/**
  * atomic64_dec - decrement atomic64 variable
  * @ptr: pointer to type atomic64_t
  *
@@ -381,6 +708,14 @@ extern void atomic64_inc(atomic64_t *ptr
 extern void atomic64_dec(atomic64_t *ptr);
 
 /**
+ * atomic64_dec_unchecked - decrement atomic64 variable
+ * @ptr: pointer to type atomic64_unchecked_t
+ *
+ * Atomically decrements @ptr by 1.
+ */
+extern void atomic64_dec_unchecked(atomic64_unchecked_t *ptr);
+
+/**
  * atomic64_dec_and_test - decrement and test
  * @ptr: pointer to type atomic64_t
  *
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/atomic_64.h linux-2.6.32.60-pax/arch/x86/include/asm/atomic_64.h
--- linux-2.6.32.60/arch/x86/include/asm/atomic_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/atomic_64.h	2012-07-21 11:13:51.201047022 +0200
@@ -24,6 +24,17 @@ static inline int atomic_read(const atom
 }
 
 /**
+ * atomic_read_unchecked - read atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically reads the value of @v.
+ */
+static inline int atomic_read_unchecked(const atomic_unchecked_t *v)
+{
+	return v->counter;
+}
+
+/**
  * atomic_set - set atomic variable
  * @v: pointer of type atomic_t
  * @i: required value
@@ -36,6 +47,18 @@ static inline void atomic_set(atomic_t *
 }
 
 /**
+ * atomic_set_unchecked - set atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+static inline void atomic_set_unchecked(atomic_unchecked_t *v, int i)
+{
+	v->counter = i;
+}
+
+/**
  * atomic_add - add integer to atomic variable
  * @i: integer value to add
  * @v: pointer of type atomic_t
@@ -44,7 +67,29 @@ static inline void atomic_set(atomic_t *
  */
 static inline void atomic_add(int i, atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "addl %1,%0"
+	asm volatile(LOCK_PREFIX "addl %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subl %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic_add_unchecked - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically adds @i to @v.
+ */
+static inline void atomic_add_unchecked(int i, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "addl %1,%0\n"
 		     : "=m" (v->counter)
 		     : "ir" (i), "m" (v->counter));
 }
@@ -58,7 +103,29 @@ static inline void atomic_add(int i, ato
  */
 static inline void atomic_sub(int i, atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "subl %1,%0"
+	asm volatile(LOCK_PREFIX "subl %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addl %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic_sub_unchecked - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically subtracts @i from @v.
+ */
+static inline void atomic_sub_unchecked(int i, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "subl %1,%0\n"
 		     : "=m" (v->counter)
 		     : "ir" (i), "m" (v->counter));
 }
@@ -76,7 +143,16 @@ static inline int atomic_sub_and_test(in
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "subl %2,%0; sete %1"
+	asm volatile(LOCK_PREFIX "subl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addl %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "ir" (i), "m" (v->counter) : "memory");
 	return c;
@@ -90,7 +166,28 @@ static inline int atomic_sub_and_test(in
  */
 static inline void atomic_inc(atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "incl %0"
+	asm volatile(LOCK_PREFIX "incl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "m" (v->counter));
+}
+
+/**
+ * atomic_inc_unchecked - increment atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically increments @v by 1.
+ */
+static inline void atomic_inc_unchecked(atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "incl %0\n"
 		     : "=m" (v->counter)
 		     : "m" (v->counter));
 }
@@ -103,7 +200,28 @@ static inline void atomic_inc(atomic_t *
  */
 static inline void atomic_dec(atomic_t *v)
 {
-	asm volatile(LOCK_PREFIX "decl %0"
+	asm volatile(LOCK_PREFIX "decl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "m" (v->counter));
+}
+
+/**
+ * atomic_dec_unchecked - decrement atomic variable
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically decrements @v by 1.
+ */
+static inline void atomic_dec_unchecked(atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "decl %0\n"
 		     : "=m" (v->counter)
 		     : "m" (v->counter));
 }
@@ -120,7 +238,16 @@ static inline int atomic_dec_and_test(at
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "decl %0; sete %1"
+	asm volatile(LOCK_PREFIX "decl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "m" (v->counter) : "memory");
 	return c != 0;
@@ -138,7 +265,35 @@ static inline int atomic_inc_and_test(at
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "incl %0; sete %1"
+	asm volatile(LOCK_PREFIX "incl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
+		     : "=m" (v->counter), "=qm" (c)
+		     : "m" (v->counter) : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic_inc_and_test_unchecked - increment and test
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+static inline int atomic_inc_and_test_unchecked(atomic_unchecked_t *v)
+{
+	unsigned char c;
+
+	asm volatile(LOCK_PREFIX "incl %0\n"
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "m" (v->counter) : "memory");
 	return c != 0;
@@ -157,7 +312,16 @@ static inline int atomic_add_negative(in
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "addl %2,%0; sets %1"
+	asm volatile(LOCK_PREFIX "addl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subl %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sets %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "ir" (i), "m" (v->counter) : "memory");
 	return c;
@@ -173,7 +337,31 @@ static inline int atomic_add_negative(in
 static inline int atomic_add_return(int i, atomic_t *v)
 {
 	int __i = i;
-	asm volatile(LOCK_PREFIX "xaddl %0, %1"
+	asm volatile(LOCK_PREFIX "xaddl %0, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "movl %0, %1\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+r" (i), "+m" (v->counter)
+		     : : "memory");
+	return i + __i;
+}
+
+/**
+ * atomic_add_return_unchecked - add and return
+ * @i: integer value to add
+ * @v: pointer of type atomic_unchecked_t
+ *
+ * Atomically adds @i to @v and returns @i + @v
+ */
+static inline int atomic_add_return_unchecked(int i, atomic_unchecked_t *v)
+{
+	int __i = i;
+	asm volatile(LOCK_PREFIX "xaddl %0, %1\n"
 		     : "+r" (i), "+m" (v->counter)
 		     : : "memory");
 	return i + __i;
@@ -185,6 +373,10 @@ static inline int atomic_sub_return(int
 }
 
 #define atomic_inc_return(v)  (atomic_add_return(1, v))
+static inline int atomic_inc_return_unchecked(atomic_unchecked_t *v)
+{
+	return atomic_add_return_unchecked(1, v);
+}
 #define atomic_dec_return(v)  (atomic_sub_return(1, v))
 
 /* The 64-bit atomic type */
@@ -204,6 +396,18 @@ static inline long atomic64_read(const a
 }
 
 /**
+ * atomic64_read_unchecked - read atomic64 variable
+ * @v: pointer of type atomic64_unchecked_t
+ *
+ * Atomically reads the value of @v.
+ * Doesn't imply a read memory barrier.
+ */
+static inline long atomic64_read_unchecked(const atomic64_unchecked_t *v)
+{
+	return v->counter;
+}
+
+/**
  * atomic64_set - set atomic64 variable
  * @v: pointer to type atomic64_t
  * @i: required value
@@ -216,6 +420,18 @@ static inline void atomic64_set(atomic64
 }
 
 /**
+ * atomic64_set_unchecked - set atomic64 variable
+ * @v: pointer to type atomic64_unchecked_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+static inline void atomic64_set_unchecked(atomic64_unchecked_t *v, long i)
+{
+	v->counter = i;
+}
+
+/**
  * atomic64_add - add integer to atomic64 variable
  * @i: integer value to add
  * @v: pointer to type atomic64_t
@@ -224,6 +440,28 @@ static inline void atomic64_set(atomic64
  */
 static inline void atomic64_add(long i, atomic64_t *v)
 {
+	asm volatile(LOCK_PREFIX "addq %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subq %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "er" (i), "m" (v->counter));
+}
+
+/**
+ * atomic64_add_unchecked - add integer to atomic64 variable
+ * @i: integer value to add
+ * @v: pointer to type atomic64_unchecked_t
+ *
+ * Atomically adds @i to @v.
+ */
+static inline void atomic64_add_unchecked(long i, atomic64_unchecked_t *v)
+{
 	asm volatile(LOCK_PREFIX "addq %1,%0"
 		     : "=m" (v->counter)
 		     : "er" (i), "m" (v->counter));
@@ -238,7 +476,15 @@ static inline void atomic64_add(long i,
  */
 static inline void atomic64_sub(long i, atomic64_t *v)
 {
-	asm volatile(LOCK_PREFIX "subq %1,%0"
+	asm volatile(LOCK_PREFIX "subq %1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addq %1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "=m" (v->counter)
 		     : "er" (i), "m" (v->counter));
 }
@@ -256,7 +502,16 @@ static inline int atomic64_sub_and_test(
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "subq %2,%0; sete %1"
+	asm volatile(LOCK_PREFIX "subq %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "addq %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "er" (i), "m" (v->counter) : "memory");
 	return c;
@@ -270,6 +525,27 @@ static inline int atomic64_sub_and_test(
  */
 static inline void atomic64_inc(atomic64_t *v)
 {
+	asm volatile(LOCK_PREFIX "incq %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decq %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "m" (v->counter));
+}
+
+/**
+ * atomic64_inc_unchecked - increment atomic64 variable
+ * @v: pointer to type atomic64_unchecked_t
+ *
+ * Atomically increments @v by 1.
+ */
+static inline void atomic64_inc_unchecked(atomic64_unchecked_t *v)
+{
 	asm volatile(LOCK_PREFIX "incq %0"
 		     : "=m" (v->counter)
 		     : "m" (v->counter));
@@ -283,7 +559,28 @@ static inline void atomic64_inc(atomic64
  */
 static inline void atomic64_dec(atomic64_t *v)
 {
-	asm volatile(LOCK_PREFIX "decq %0"
+	asm volatile(LOCK_PREFIX "decq %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incq %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "=m" (v->counter)
+		     : "m" (v->counter));
+}
+
+/**
+ * atomic64_dec_unchecked - decrement atomic64 variable
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically decrements @v by 1.
+ */
+static inline void atomic64_dec_unchecked(atomic64_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "decq %0\n"
 		     : "=m" (v->counter)
 		     : "m" (v->counter));
 }
@@ -300,7 +597,16 @@ static inline int atomic64_dec_and_test(
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "decq %0; sete %1"
+	asm volatile(LOCK_PREFIX "decq %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "incq %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "m" (v->counter) : "memory");
 	return c != 0;
@@ -318,7 +624,16 @@ static inline int atomic64_inc_and_test(
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "incq %0; sete %1"
+	asm volatile(LOCK_PREFIX "incq %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decq %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "m" (v->counter) : "memory");
 	return c != 0;
@@ -337,7 +652,16 @@ static inline int atomic64_add_negative(
 {
 	unsigned char c;
 
-	asm volatile(LOCK_PREFIX "addq %2,%0; sets %1"
+	asm volatile(LOCK_PREFIX "addq %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subq %2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sets %1\n"
 		     : "=m" (v->counter), "=qm" (c)
 		     : "er" (i), "m" (v->counter) : "memory");
 	return c;
@@ -353,7 +677,31 @@ static inline int atomic64_add_negative(
 static inline long atomic64_add_return(long i, atomic64_t *v)
 {
 	long __i = i;
-	asm volatile(LOCK_PREFIX "xaddq %0, %1;"
+	asm volatile(LOCK_PREFIX "xaddq %0, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "movq %0, %1\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+r" (i), "+m" (v->counter)
+		     : : "memory");
+	return i + __i;
+}
+
+/**
+ * atomic64_add_return_unchecked - add and return
+ * @i: integer value to add
+ * @v: pointer to type atomic64_unchecked_t
+ *
+ * Atomically adds @i to @v and returns @i + @v
+ */
+static inline long atomic64_add_return_unchecked(long i, atomic64_unchecked_t *v)
+{
+	long __i = i;
+	asm volatile(LOCK_PREFIX "xaddq %0, %1"
 		     : "+r" (i), "+m" (v->counter)
 		     : : "memory");
 	return i + __i;
@@ -365,6 +713,10 @@ static inline long atomic64_sub_return(l
 }
 
 #define atomic64_inc_return(v)  (atomic64_add_return(1, (v)))
+static inline long atomic64_inc_return_unchecked(atomic64_unchecked_t *v)
+{
+	return atomic64_add_return_unchecked(1, v);
+}
 #define atomic64_dec_return(v)  (atomic64_sub_return(1, (v)))
 
 static inline long atomic64_cmpxchg(atomic64_t *v, long old, long new)
@@ -372,21 +724,41 @@ static inline long atomic64_cmpxchg(atom
 	return cmpxchg(&v->counter, old, new);
 }
 
+static inline long atomic64_cmpxchg_unchecked(atomic64_unchecked_t *v, long old, long new)
+{
+	return cmpxchg(&v->counter, old, new);
+}
+
 static inline long atomic64_xchg(atomic64_t *v, long new)
 {
 	return xchg(&v->counter, new);
 }
 
+static inline long atomic64_xchg_unchecked(atomic64_unchecked_t *v, long new)
+{
+	return xchg(&v->counter, new);
+}
+
 static inline long atomic_cmpxchg(atomic_t *v, int old, int new)
 {
 	return cmpxchg(&v->counter, old, new);
 }
 
+static inline long atomic_cmpxchg_unchecked(atomic_unchecked_t *v, int old, int new)
+{
+	return cmpxchg(&v->counter, old, new);
+}
+
 static inline long atomic_xchg(atomic_t *v, int new)
 {
 	return xchg(&v->counter, new);
 }
 
+static inline long atomic_xchg_unchecked(atomic_unchecked_t *v, int new)
+{
+	return xchg(&v->counter, new);
+}
+
 /**
  * atomic_add_unless - add unless the number is a given value
  * @v: pointer of type atomic_t
@@ -398,17 +770,30 @@ static inline long atomic_xchg(atomic_t
  */
 static inline int atomic_add_unless(atomic_t *v, int a, int u)
 {
-	int c, old;
+	int c, old, new;
 	c = atomic_read(v);
 	for (;;) {
-		if (unlikely(c == (u)))
+		if (unlikely(c == u))
 			break;
-		old = atomic_cmpxchg((v), c, c + (a));
+
+		asm volatile("addl %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+			     "jno 0f\n"
+			     "subl %2,%0\n"
+			     "int $4\n0:\n"
+			     _ASM_EXTABLE(0b, 0b)
+#endif
+
+			     : "=r" (new)
+			     : "0" (c), "ir" (a));
+
+		old = atomic_cmpxchg(v, c, new);
 		if (likely(old == c))
 			break;
 		c = old;
 	}
-	return c != (u);
+	return c != u;
 }
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
@@ -424,17 +809,30 @@ static inline int atomic_add_unless(atom
  */
 static inline int atomic64_add_unless(atomic64_t *v, long a, long u)
 {
-	long c, old;
+	long c, old, new;
 	c = atomic64_read(v);
 	for (;;) {
-		if (unlikely(c == (u)))
+		if (unlikely(c == u))
 			break;
-		old = atomic64_cmpxchg((v), c, c + (a));
+
+		asm volatile("addq %2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+			     "jno 0f\n"
+			     "subq %2,%0\n"
+			     "int $4\n0:\n"
+			     _ASM_EXTABLE(0b, 0b)
+#endif
+
+			     : "=r" (new)
+			     : "0" (c), "er" (a));
+
+		old = atomic64_cmpxchg(v, c, new);
 		if (likely(old == c))
 			break;
 		c = old;
 	}
-	return c != (u);
+	return c != u;
 }
 
 /**
@@ -466,14 +864,37 @@ static inline void atomic_or_long(unsign
 #define atomic64_inc_not_zero(v) atomic64_add_unless((v), 1, 0)
 
 /* These are x86-specific, used by some header files */
-#define atomic_clear_mask(mask, addr)					\
-	asm volatile(LOCK_PREFIX "andl %0,%1"				\
-		     : : "r" (~(mask)), "m" (*(addr)) : "memory")
-
-#define atomic_set_mask(mask, addr)					\
-	asm volatile(LOCK_PREFIX "orl %0,%1"				\
-		     : : "r" ((unsigned)(mask)), "m" (*(addr))		\
-		     : "memory")
+static inline void atomic_clear_mask(unsigned int mask, atomic_t *v)
+{
+	asm volatile(LOCK_PREFIX "andl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (~(mask))
+		     : "memory");
+}
+
+static inline void atomic_clear_mask_unchecked(unsigned int mask, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "andl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (~(mask))
+		     : "memory");
+}
+
+static inline void atomic_set_mask(unsigned int mask, atomic_t *v)
+{
+	asm volatile(LOCK_PREFIX "orl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (mask)
+		     : "memory");
+}
+
+static inline void atomic_set_mask_unchecked(unsigned int mask, atomic_unchecked_t *v)
+{
+	asm volatile(LOCK_PREFIX "orl %1,%0"
+		     : "+m" (v->counter)
+		     : "r" (mask)
+		     : "memory");
+}
 
 /* Atomic operations are already serializing on x86 */
 #define smp_mb__before_atomic_dec()	barrier()
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/bitops.h linux-2.6.32.60-pax/arch/x86/include/asm/bitops.h
--- linux-2.6.32.60/arch/x86/include/asm/bitops.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/bitops.h	2012-03-13 13:15:34.448098027 +0100
@@ -38,7 +38,7 @@
  * a mask operation on a byte.
  */
 #define IS_IMMEDIATE(nr)		(__builtin_constant_p(nr))
-#define CONST_MASK_ADDR(nr, addr)	BITOP_ADDR((void *)(addr) + ((nr)>>3))
+#define CONST_MASK_ADDR(nr, addr)	BITOP_ADDR((volatile void *)(addr) + ((nr)>>3))
 #define CONST_MASK(nr)			(1 << ((nr) & 7))
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/boot.h linux-2.6.32.60-pax/arch/x86/include/asm/boot.h
--- linux-2.6.32.60/arch/x86/include/asm/boot.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/boot.h	2012-03-13 13:15:34.452098026 +0100
@@ -11,10 +11,15 @@
 #include <asm/pgtable_types.h>
 
 /* Physical address where kernel should be loaded. */
-#define LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
+#define ____LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
 				+ (CONFIG_PHYSICAL_ALIGN - 1)) \
 				& ~(CONFIG_PHYSICAL_ALIGN - 1))
 
+#ifndef __ASSEMBLY__
+extern unsigned char __LOAD_PHYSICAL_ADDR[];
+#define LOAD_PHYSICAL_ADDR ((unsigned long)__LOAD_PHYSICAL_ADDR)
+#endif
+
 /* Minimum kernel alignment, as a power of two */
 #ifdef CONFIG_X86_64
 #define MIN_KERNEL_ALIGN_LG2	PMD_SHIFT
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/cacheflush.h linux-2.6.32.60-pax/arch/x86/include/asm/cacheflush.h
--- linux-2.6.32.60/arch/x86/include/asm/cacheflush.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/cacheflush.h	2012-03-13 13:15:34.452098026 +0100
@@ -60,7 +60,7 @@ PAGEFLAG(WC, WC)
 static inline unsigned long get_page_memtype(struct page *pg)
 {
 	if (!PageUncached(pg) && !PageWC(pg))
-		return -1;
+		return ~0UL;
 	else if (!PageUncached(pg) && PageWC(pg))
 		return _PAGE_CACHE_WC;
 	else if (PageUncached(pg) && !PageWC(pg))
@@ -85,7 +85,7 @@ static inline void set_page_memtype(stru
 		SetPageWC(pg);
 		break;
 	default:
-	case -1:
+	case ~0UL:
 		ClearPageUncached(pg);
 		ClearPageWC(pg);
 		break;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/cache.h linux-2.6.32.60-pax/arch/x86/include/asm/cache.h
--- linux-2.6.32.60/arch/x86/include/asm/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/cache.h	2012-03-13 13:15:34.452098026 +0100
@@ -5,9 +5,10 @@
 
 /* L1 cache line size */
 #define L1_CACHE_SHIFT	(CONFIG_X86_L1_CACHE_SHIFT)
-#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
+#define L1_CACHE_BYTES	(_AC(1,UL) << L1_CACHE_SHIFT)
 
 #define __read_mostly __attribute__((__section__(".data.read_mostly")))
+#define __read_only __attribute__((__section__(".data.read_only")))
 
 #ifdef CONFIG_X86_VSMP
 /* vSMP Internode cacheline shift */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/calling.h linux-2.6.32.60-pax/arch/x86/include/asm/calling.h
--- linux-2.6.32.60/arch/x86/include/asm/calling.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/calling.h	2012-03-13 13:15:34.452098026 +0100
@@ -52,32 +52,32 @@ For 32-bit we have the following convent
  * for assembly code:
  */
 
-#define R15		  0
-#define R14		  8
-#define R13		 16
-#define R12		 24
-#define RBP		 32
-#define RBX		 40
+#define R15		  (0)
+#define R14		  (8)
+#define R13		 (16)
+#define R12		 (24)
+#define RBP		 (32)
+#define RBX		 (40)
 
 /* arguments: interrupts/non tracing syscalls only save up to here: */
-#define R11		 48
-#define R10		 56
-#define R9		 64
-#define R8		 72
-#define RAX		 80
-#define RCX		 88
-#define RDX		 96
-#define RSI		104
-#define RDI		112
-#define ORIG_RAX	120       /* + error_code */
+#define R11		 (48)
+#define R10		 (56)
+#define R9		 (64)
+#define R8		 (72)
+#define RAX		 (80)
+#define RCX		 (88)
+#define RDX		 (96)
+#define RSI		(104)
+#define RDI		(112)
+#define ORIG_RAX	(120)       /* + error_code */
 /* end of arguments */
 
 /* cpu exception frame or undefined in case of fast syscall: */
-#define RIP		128
-#define CS		136
-#define EFLAGS		144
-#define RSP		152
-#define SS		160
+#define RIP		(128)
+#define CS		(136)
+#define EFLAGS		(144)
+#define RSP		(152)
+#define SS		(160)
 
 #define ARGOFFSET	R11
 #define SWFRAME		ORIG_RAX
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/checksum_32.h linux-2.6.32.60-pax/arch/x86/include/asm/checksum_32.h
--- linux-2.6.32.60/arch/x86/include/asm/checksum_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/checksum_32.h	2012-03-13 13:15:34.452098026 +0100
@@ -31,6 +31,14 @@ asmlinkage __wsum csum_partial_copy_gene
 					    int len, __wsum sum,
 					    int *src_err_ptr, int *dst_err_ptr);
 
+asmlinkage __wsum csum_partial_copy_generic_to_user(const void *src, void *dst,
+						  int len, __wsum sum,
+						  int *src_err_ptr, int *dst_err_ptr);
+
+asmlinkage __wsum csum_partial_copy_generic_from_user(const void *src, void *dst,
+						  int len, __wsum sum,
+						  int *src_err_ptr, int *dst_err_ptr);
+
 /*
  *	Note: when you get a NULL pointer exception here this means someone
  *	passed in an incorrect kernel address to one of these functions.
@@ -50,7 +58,7 @@ static inline __wsum csum_partial_copy_f
 						 int *err_ptr)
 {
 	might_sleep();
-	return csum_partial_copy_generic((__force void *)src, dst,
+	return csum_partial_copy_generic_from_user((__force void *)src, dst,
 					 len, sum, err_ptr, NULL);
 }
 
@@ -178,7 +186,7 @@ static inline __wsum csum_and_copy_to_us
 {
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, dst, len))
-		return csum_partial_copy_generic(src, (__force void *)dst,
+		return csum_partial_copy_generic_to_user(src, (__force void *)dst,
 						 len, sum, NULL, err_ptr);
 
 	if (len)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/desc_defs.h linux-2.6.32.60-pax/arch/x86/include/asm/desc_defs.h
--- linux-2.6.32.60/arch/x86/include/asm/desc_defs.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/desc_defs.h	2012-03-13 13:15:34.456098026 +0100
@@ -31,6 +31,12 @@ struct desc_struct {
 			unsigned base1: 8, type: 4, s: 1, dpl: 2, p: 1;
 			unsigned limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
 		};
+		struct {
+			u16 offset_low;
+			u16 seg;
+			unsigned reserved: 8, type: 4, s: 1, dpl: 2, p: 1;
+			unsigned offset_high: 16;
+		} gate;
 	};
 } __attribute__((packed));
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/desc.h linux-2.6.32.60-pax/arch/x86/include/asm/desc.h
--- linux-2.6.32.60/arch/x86/include/asm/desc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/desc.h	2012-03-13 13:15:34.456098026 +0100
@@ -4,6 +4,7 @@
 #include <asm/desc_defs.h>
 #include <asm/ldt.h>
 #include <asm/mmu.h>
+#include <asm/pgtable.h>
 #include <linux/smp.h>
 
 static inline void fill_ldt(struct desc_struct *desc,
@@ -15,6 +16,7 @@ static inline void fill_ldt(struct desc_
 	desc->base1 = (info->base_addr & 0x00ff0000) >> 16;
 	desc->type = (info->read_exec_only ^ 1) << 1;
 	desc->type |= info->contents << 2;
+	desc->type |= info->seg_not_present ^ 1;
 	desc->s = 1;
 	desc->dpl = 0x3;
 	desc->p = info->seg_not_present ^ 1;
@@ -31,16 +33,12 @@ static inline void fill_ldt(struct desc_
 }
 
 extern struct desc_ptr idt_descr;
-extern gate_desc idt_table[];
-
-struct gdt_page {
-	struct desc_struct gdt[GDT_ENTRIES];
-} __attribute__((aligned(PAGE_SIZE)));
-DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);
+extern gate_desc idt_table[256];
 
+extern struct desc_struct cpu_gdt_table[NR_CPUS][PAGE_SIZE / sizeof(struct desc_struct)];
 static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
 {
-	return per_cpu(gdt_page, cpu).gdt;
+	return cpu_gdt_table[cpu];
 }
 
 #ifdef CONFIG_X86_64
@@ -65,9 +63,14 @@ static inline void pack_gate(gate_desc *
 			     unsigned long base, unsigned dpl, unsigned flags,
 			     unsigned short seg)
 {
-	gate->a = (seg << 16) | (base & 0xffff);
-	gate->b = (base & 0xffff0000) |
-		  (((0x80 | type | (dpl << 5)) & 0xff) << 8);
+	gate->gate.offset_low = base;
+	gate->gate.seg = seg;
+	gate->gate.reserved = 0;
+	gate->gate.type = type;
+	gate->gate.s = 0;
+	gate->gate.dpl = dpl;
+	gate->gate.p = 1;
+	gate->gate.offset_high = base >> 16;
 }
 
 #endif
@@ -115,13 +118,17 @@ static inline void paravirt_free_ldt(str
 static inline void native_write_idt_entry(gate_desc *idt, int entry,
 					  const gate_desc *gate)
 {
+	pax_open_kernel();
 	memcpy(&idt[entry], gate, sizeof(*gate));
+	pax_close_kernel();
 }
 
 static inline void native_write_ldt_entry(struct desc_struct *ldt, int entry,
 					  const void *desc)
 {
+	pax_open_kernel();
 	memcpy(&ldt[entry], desc, 8);
+	pax_close_kernel();
 }
 
 static inline void native_write_gdt_entry(struct desc_struct *gdt, int entry,
@@ -139,7 +146,10 @@ static inline void native_write_gdt_entr
 		size = sizeof(struct desc_struct);
 		break;
 	}
+
+	pax_open_kernel();
 	memcpy(&gdt[entry], desc, size);
+	pax_close_kernel();
 }
 
 static inline void pack_descriptor(struct desc_struct *desc, unsigned long base,
@@ -211,7 +221,9 @@ static inline void native_set_ldt(const
 
 static inline void native_load_tr_desc(void)
 {
+	pax_open_kernel();
 	asm volatile("ltr %w0"::"q" (GDT_ENTRY_TSS*8));
+	pax_close_kernel();
 }
 
 static inline void native_load_gdt(const struct desc_ptr *dtr)
@@ -246,8 +258,10 @@ static inline void native_load_tls(struc
 	unsigned int i;
 	struct desc_struct *gdt = get_cpu_gdt_table(cpu);
 
+	pax_open_kernel();
 	for (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++)
 		gdt[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i];
+	pax_close_kernel();
 }
 
 #define _LDT_empty(info)				\
@@ -309,7 +323,7 @@ static inline void set_desc_limit(struct
 	desc->limit = (limit >> 16) & 0xf;
 }
 
-static inline void _set_gate(int gate, unsigned type, void *addr,
+static inline void _set_gate(int gate, unsigned type, const void *addr,
 			     unsigned dpl, unsigned ist, unsigned seg)
 {
 	gate_desc s;
@@ -327,7 +341,7 @@ static inline void _set_gate(int gate, u
  * Pentium F0 0F bugfix can have resulted in the mapped
  * IDT being write-protected.
  */
-static inline void set_intr_gate(unsigned int n, void *addr)
+static inline void set_intr_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
@@ -356,19 +370,19 @@ static inline void alloc_intr_gate(unsig
 /*
  * This routine sets up an interrupt gate at directory privilege level 3.
  */
-static inline void set_system_intr_gate(unsigned int n, void *addr)
+static inline void set_system_intr_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);
 }
 
-static inline void set_system_trap_gate(unsigned int n, void *addr)
+static inline void set_system_trap_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS);
 }
 
-static inline void set_trap_gate(unsigned int n, void *addr)
+static inline void set_trap_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TRAP, addr, 0, 0, __KERNEL_CS);
@@ -377,19 +391,31 @@ static inline void set_trap_gate(unsigne
 static inline void set_task_gate(unsigned int n, unsigned int gdt_entry)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_TASK, (void *)0, 0, 0, (gdt_entry<<3));
+	_set_gate(n, GATE_TASK, (const void *)0, 0, 0, (gdt_entry<<3));
 }
 
-static inline void set_intr_gate_ist(int n, void *addr, unsigned ist)
+static inline void set_intr_gate_ist(int n, const void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
 }
 
-static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
+static inline void set_system_intr_gate_ist(int n, const void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS);
 }
 
+#ifdef CONFIG_X86_32
+static inline void set_user_cs(unsigned long base, unsigned long limit, int cpu)
+{
+	struct desc_struct d;
+
+	if (likely(limit))
+		limit = (limit - 1UL) >> PAGE_SHIFT;
+	pack_descriptor(&d, base, limit, 0xFB, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_DEFAULT_USER_CS, &d, DESCTYPE_S);
+}
+#endif
+
 #endif /* _ASM_X86_DESC_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/device.h linux-2.6.32.60-pax/arch/x86/include/asm/device.h
--- linux-2.6.32.60/arch/x86/include/asm/device.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/device.h	2012-03-13 13:15:34.456098026 +0100
@@ -6,7 +6,7 @@ struct dev_archdata {
 	void	*acpi_handle;
 #endif
 #ifdef CONFIG_X86_64
-struct dma_map_ops *dma_ops;
+	struct dma_map_ops *dma_ops;
 #endif
 #ifdef CONFIG_DMAR
 	void *iommu; /* hook for IOMMU specific extension */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/e820.h linux-2.6.32.60-pax/arch/x86/include/asm/e820.h
--- linux-2.6.32.60/arch/x86/include/asm/e820.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/e820.h	2012-03-13 13:15:34.456098026 +0100
@@ -133,7 +133,7 @@ extern char *default_machine_specific_me
 #define ISA_END_ADDRESS		0x100000
 #define is_ISA_range(s, e) ((s) >= ISA_START_ADDRESS && (e) < ISA_END_ADDRESS)
 
-#define BIOS_BEGIN		0x000a0000
+#define BIOS_BEGIN		0x000c0000
 #define BIOS_END		0x00100000
 
 #ifdef __KERNEL__
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/elf.h linux-2.6.32.60-pax/arch/x86/include/asm/elf.h
--- linux-2.6.32.60/arch/x86/include/asm/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/elf.h	2012-03-13 13:15:34.456098026 +0100
@@ -257,7 +257,25 @@ extern int force_personality32;
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define ELF_ET_DYN_BASE		((current->mm->pax_flags & MF_PAX_SEGMEXEC) ? SEGMEXEC_TASK_SIZE/3*2 : TASK_SIZE/3*2)
+#else
 #define ELF_ET_DYN_BASE		(TASK_SIZE / 3 * 2)
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+#ifdef CONFIG_X86_32
+#define PAX_ELF_ET_DYN_BASE	0x10000000UL
+
+#define PAX_DELTA_MMAP_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#define PAX_DELTA_STACK_LEN	(current->mm->pax_flags & MF_PAX_SEGMEXEC ? 15 : 16)
+#else
+#define PAX_ELF_ET_DYN_BASE	0x400000UL
+
+#define PAX_DELTA_MMAP_LEN	((test_thread_flag(TIF_IA32)) ? 16 : TASK_SIZE_MAX_SHIFT - PAGE_SHIFT - 3)
+#define PAX_DELTA_STACK_LEN	((test_thread_flag(TIF_IA32)) ? 16 : TASK_SIZE_MAX_SHIFT - PAGE_SHIFT - 3)
+#endif
+#endif
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
@@ -310,9 +328,7 @@ do {									\
 
 #define ARCH_DLINFO							\
 do {									\
-	if (vdso_enabled)						\
-		NEW_AUX_ENT(AT_SYSINFO_EHDR,				\
-			    (unsigned long)current->mm->context.vdso);	\
+	NEW_AUX_ENT(AT_SYSINFO_EHDR, current->mm->context.vdso);	\
 } while (0)
 
 #define AT_SYSINFO		32
@@ -323,7 +339,7 @@ do {									\
 
 #endif /* !CONFIG_X86_32 */
 
-#define VDSO_CURRENT_BASE	((unsigned long)current->mm->context.vdso)
+#define VDSO_CURRENT_BASE	(current->mm->context.vdso)
 
 #define VDSO_ENTRY							\
 	((unsigned long)VDSO32_SYMBOL(VDSO_CURRENT_BASE, vsyscall))
@@ -337,7 +353,4 @@ extern int arch_setup_additional_pages(s
 extern int syscall32_setup_pages(struct linux_binprm *, int exstack);
 #define compat_arch_setup_additional_pages	syscall32_setup_pages
 
-extern unsigned long arch_randomize_brk(struct mm_struct *mm);
-#define arch_randomize_brk arch_randomize_brk
-
 #endif /* _ASM_X86_ELF_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/emergency-restart.h linux-2.6.32.60-pax/arch/x86/include/asm/emergency-restart.h
--- linux-2.6.32.60/arch/x86/include/asm/emergency-restart.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/emergency-restart.h	2012-03-13 13:15:34.460098026 +0100
@@ -15,6 +15,6 @@ enum reboot_type {
 
 extern enum reboot_type reboot_type;
 
-extern void machine_emergency_restart(void);
+extern void machine_emergency_restart(void) __noreturn;
 
 #endif /* _ASM_X86_EMERGENCY_RESTART_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/futex.h linux-2.6.32.60-pax/arch/x86/include/asm/futex.h
--- linux-2.6.32.60/arch/x86/include/asm/futex.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/futex.h	2012-12-01 02:39:40.596117528 +0100
@@ -12,20 +12,22 @@
 #include <asm/system.h>
 
 #define __futex_atomic_op1(insn, ret, oldval, uaddr, oparg)	\
+	typecheck(u32 __user *, uaddr);				\
 	asm volatile("1:\t" insn "\n"				\
 		     "2:\t.section .fixup,\"ax\"\n"		\
 		     "3:\tmov\t%3, %1\n"			\
 		     "\tjmp\t2b\n"				\
 		     "\t.previous\n"				\
 		     _ASM_EXTABLE(1b, 3b)			\
-		     : "=r" (oldval), "=r" (ret), "+m" (*uaddr)	\
+		     : "=r" (oldval), "=r" (ret), "+m" (*(u32 __user *)____m(uaddr))\
 		     : "i" (-EFAULT), "0" (oparg), "1" (0))
 
 #define __futex_atomic_op2(insn, ret, oldval, uaddr, oparg)	\
+	typecheck(u32 __user *, uaddr);				\
 	asm volatile("1:\tmovl	%2, %0\n"			\
 		     "\tmovl\t%0, %3\n"				\
 		     "\t" insn "\n"				\
-		     "2:\t" LOCK_PREFIX "cmpxchgl %3, %2\n"	\
+		     "2:\t" LOCK_PREFIX __copyuser_seg"cmpxchgl %3, %2\n"	\
 		     "\tjnz\t1b\n"				\
 		     "3:\t.section .fixup,\"ax\"\n"		\
 		     "4:\tmov\t%5, %1\n"			\
@@ -34,10 +36,10 @@
 		     _ASM_EXTABLE(1b, 4b)			\
 		     _ASM_EXTABLE(2b, 4b)			\
 		     : "=&a" (oldval), "=&r" (ret),		\
-		       "+m" (*uaddr), "=&r" (tem)		\
+		       "+m" (*(u32 __user *)____m(uaddr)), "=&r" (tem)	\
 		     : "r" (oparg), "i" (-EFAULT), "1" (0))
 
-static inline int futex_atomic_op_inuser(int encoded_op, int __user *uaddr)
+static inline int futex_atomic_op_inuser(int encoded_op, u32 __user *uaddr)
 {
 	int op = (encoded_op >> 28) & 7;
 	int cmp = (encoded_op >> 24) & 15;
@@ -61,10 +63,10 @@ static inline int futex_atomic_op_inuser
 
 	switch (op) {
 	case FUTEX_OP_SET:
-		__futex_atomic_op1("xchgl %0, %2", ret, oldval, uaddr, oparg);
+		__futex_atomic_op1(__copyuser_seg"xchgl %0, %2", ret, oldval, uaddr, oparg);
 		break;
 	case FUTEX_OP_ADD:
-		__futex_atomic_op1(LOCK_PREFIX "xaddl %0, %2", ret, oldval,
+		__futex_atomic_op1(LOCK_PREFIX __copyuser_seg"xaddl %0, %2", ret, oldval,
 				   uaddr, oparg);
 		break;
 	case FUTEX_OP_OR:
@@ -109,7 +111,7 @@ static inline int futex_atomic_op_inuser
 	return ret;
 }
 
-static inline int futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval,
+static inline int futex_atomic_cmpxchg_inatomic(u32 __user *uaddr, int oldval,
 						int newval)
 {
 
@@ -119,16 +121,16 @@ static inline int futex_atomic_cmpxchg_i
 		return -ENOSYS;
 #endif
 
-	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))
 		return -EFAULT;
 
-	asm volatile("1:\t" LOCK_PREFIX "cmpxchgl %3, %1\n"
+	asm volatile("1:\t" LOCK_PREFIX __copyuser_seg"cmpxchgl %3, %1\n"
 		     "2:\t.section .fixup, \"ax\"\n"
 		     "3:\tmov     %2, %0\n"
 		     "\tjmp     2b\n"
 		     "\t.previous\n"
 		     _ASM_EXTABLE(1b, 3b)
-		     : "=a" (oldval), "+m" (*uaddr)
+		     : "=a" (oldval), "+m" (*(u32 *)____m(uaddr))
 		     : "i" (-EFAULT), "r" (newval), "0" (oldval)
 		     : "memory"
 	);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/hw_irq.h linux-2.6.32.60-pax/arch/x86/include/asm/hw_irq.h
--- linux-2.6.32.60/arch/x86/include/asm/hw_irq.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/hw_irq.h	2012-03-13 13:15:34.460098026 +0100
@@ -92,8 +92,8 @@ extern void setup_ioapic_dest(void);
 extern void enable_IO_APIC(void);
 
 /* Statistics */
-extern atomic_t irq_err_count;
-extern atomic_t irq_mis_count;
+extern atomic_unchecked_t irq_err_count;
+extern atomic_unchecked_t irq_mis_count;
 
 /* EISA */
 extern void eisa_set_level_irq(unsigned int irq);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/i387.h linux-2.6.32.60-pax/arch/x86/include/asm/i387.h
--- linux-2.6.32.60/arch/x86/include/asm/i387.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/i387.h	2012-12-05 01:02:55.167921666 +0100
@@ -56,10 +56,12 @@ static inline void tolerant_fwait(void)
 		     _ASM_EXTABLE(1b, 2b));
 }
 
-static inline int fxrstor_checking(struct i387_fxsave_struct *fx)
+static inline int fxrstor_checking(struct i387_fxsave_struct __user *fx)
 {
 	int err;
 
+	fx = (struct i387_fxsave_struct __user *)____m(fx);
+
 	asm volatile("1:  rex64/fxrstor (%[fx])\n\t"
 		     "2:\n"
 		     ".section .fixup,\"ax\"\n"
@@ -105,6 +107,8 @@ static inline int fxsave_user(struct i38
 {
 	int err;
 
+	fx = (struct i387_fxsave_struct __user *)____m(fx);
+
 	asm volatile("1:  rex64/fxsave (%[fx])\n\t"
 		     "2:\n"
 		     ".section .fixup,\"ax\"\n"
@@ -179,15 +183,15 @@ static inline void tolerant_fwait(void)
 }
 
 /* perform fxrstor iff the processor has extended states, otherwise frstor */
-static inline int fxrstor_checking(struct i387_fxsave_struct *fx)
+static inline int fxrstor_checking(struct i387_fxsave_struct __user *fx)
 {
 	/*
 	 * The "nop" is needed to make the instructions the same
 	 * length.
 	 */
 	alternative_input(
-		"nop ; frstor %1",
-		"fxrstor %1",
+		__copyuser_seg" frstor %1; nop",
+		__copyuser_seg" fxrstor %1",
 		X86_FEATURE_FXSR,
 		"m" (*fx));
 
@@ -195,13 +199,8 @@ static inline int fxrstor_checking(struc
 }
 
 /* We need a safe address that is cheap to find and that is already
-   in L1 during context switch. The best choices are unfortunately
-   different for UP and SMP */
-#ifdef CONFIG_SMP
-#define safe_address (__per_cpu_offset[0])
-#else
-#define safe_address (kstat_cpu(0).cpustat.user)
-#endif
+   in L1 during context switch. */
+#define safe_address (init_tss[raw_smp_processor_id()].x86_tss.sp0)
 
 /*
  * These must be called with preempt disabled
@@ -258,8 +257,16 @@ static inline int restore_fpu_checking(s
 {
 	if (task_thread_info(tsk)->status & TS_XSAVE)
 		return xrstor_checking(&tsk->thread.xstate->xsave);
-	else
-		return fxrstor_checking(&tsk->thread.xstate->fxsave);
+	else {
+		int ret;
+		mm_segment_t fs;
+
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+		ret = fxrstor_checking(&tsk->thread.xstate->fxsave);
+		set_fs(fs);
+		return ret;
+	}
 }
 
 /*
@@ -291,7 +298,7 @@ static inline void kernel_fpu_begin(void
 	struct thread_info *me = current_thread_info();
 	preempt_disable();
 	if (me->status & TS_USEDFPU)
-		__save_init_fpu(me->task);
+		__save_init_fpu(current);
 	else
 		clts();
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/io_32.h linux-2.6.32.60-pax/arch/x86/include/asm/io_32.h
--- linux-2.6.32.60/arch/x86/include/asm/io_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/io_32.h	2012-03-13 13:15:34.460098026 +0100
@@ -3,6 +3,7 @@
 
 #include <linux/string.h>
 #include <linux/compiler.h>
+#include <asm/processor.h>
 
 /*
  * This file contains the definitions for the x86 IO instructions
@@ -42,6 +43,17 @@
 
 #ifdef __KERNEL__
 
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+static inline int valid_phys_addr_range(unsigned long addr, size_t count)
+{
+	return ((addr + count + PAGE_SIZE - 1) >> PAGE_SHIFT) < (1ULL << (boot_cpu_data.x86_phys_bits - PAGE_SHIFT)) ? 1 : 0;
+}
+
+static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t count)
+{
+	return (pfn + (count >> PAGE_SHIFT)) < (1ULL << (boot_cpu_data.x86_phys_bits - PAGE_SHIFT)) ? 1 : 0;
+}
+
 #include <asm-generic/iomap.h>
 
 #include <linux/vmalloc.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/io_64.h linux-2.6.32.60-pax/arch/x86/include/asm/io_64.h
--- linux-2.6.32.60/arch/x86/include/asm/io_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/io_64.h	2012-03-13 13:15:34.464098026 +0100
@@ -140,6 +140,17 @@ __OUTS(l)
 
 #include <linux/vmalloc.h>
 
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+static inline int valid_phys_addr_range(unsigned long addr, size_t count)
+{
+	return ((addr + count + PAGE_SIZE - 1) >> PAGE_SHIFT) < (1ULL << (boot_cpu_data.x86_phys_bits - PAGE_SHIFT)) ? 1 : 0;
+}
+
+static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t count)
+{
+	return (pfn + (count >> PAGE_SHIFT)) < (1ULL << (boot_cpu_data.x86_phys_bits - PAGE_SHIFT)) ? 1 : 0;
+}
+
 #include <asm-generic/iomap.h>
 
 void __memcpy_fromio(void *, unsigned long, unsigned);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/io.h linux-2.6.32.60-pax/arch/x86/include/asm/io.h
--- linux-2.6.32.60/arch/x86/include/asm/io.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/io.h	2013-01-22 17:38:23.376543636 +0100
@@ -170,7 +170,7 @@ static inline void __iomem *ioremap(reso
 	return ioremap_nocache(offset, size);
 }
 
-extern void iounmap(volatile void __iomem *addr);
+extern void iounmap(const volatile void __iomem *addr);
 
 extern void set_iounmap_nonlazy(void);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/irqflags.h linux-2.6.32.60-pax/arch/x86/include/asm/irqflags.h
--- linux-2.6.32.60/arch/x86/include/asm/irqflags.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/irqflags.h	2012-03-13 13:15:34.464098026 +0100
@@ -142,6 +142,11 @@ static inline unsigned long __raw_local_
 	sti;					\
 	sysexit
 
+#define GET_CR0_INTO_RDI		mov %cr0, %rdi
+#define SET_RDI_INTO_CR0		mov %rdi, %cr0
+#define GET_CR3_INTO_RDI		mov %cr3, %rdi
+#define SET_RDI_INTO_CR3		mov %rdi, %cr3
+
 #else
 #define INTERRUPT_RETURN		iret
 #define ENABLE_INTERRUPTS_SYSEXIT	sti; sysexit
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/kprobes.h linux-2.6.32.60-pax/arch/x86/include/asm/kprobes.h
--- linux-2.6.32.60/arch/x86/include/asm/kprobes.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/kprobes.h	2012-03-13 13:15:34.464098026 +0100
@@ -34,13 +34,8 @@ typedef u8 kprobe_opcode_t;
 #define BREAKPOINT_INSTRUCTION	0xcc
 #define RELATIVEJUMP_INSTRUCTION 0xe9
 #define MAX_INSN_SIZE 16
-#define MAX_STACK_SIZE 64
-#define MIN_STACK_SIZE(ADDR)					       \
-	(((MAX_STACK_SIZE) < (((unsigned long)current_thread_info()) + \
-			      THREAD_SIZE - (unsigned long)(ADDR)))    \
-	 ? (MAX_STACK_SIZE)					       \
-	 : (((unsigned long)current_thread_info()) +		       \
-	    THREAD_SIZE - (unsigned long)(ADDR)))
+#define MAX_STACK_SIZE 64UL
+#define MIN_STACK_SIZE(ADDR)	min(MAX_STACK_SIZE, current->thread.sp0 - (unsigned long)(ADDR))
 
 #define flush_insn_slot(p)	do { } while (0)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/kvm_host.h linux-2.6.32.60-pax/arch/x86/include/asm/kvm_host.h
--- linux-2.6.32.60/arch/x86/include/asm/kvm_host.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/kvm_host.h	2012-05-20 19:21:25.257167271 +0200
@@ -534,7 +534,7 @@ struct kvm_x86_ops {
 	bool (*gb_page_enable)(void);
 
 	const struct trace_print_flags *exit_reasons_str;
-};
+} __do_const;
 
 extern struct kvm_x86_ops *kvm_x86_ops;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/local.h linux-2.6.32.60-pax/arch/x86/include/asm/local.h
--- linux-2.6.32.60/arch/x86/include/asm/local.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/local.h	2012-12-14 20:55:58.501775464 +0100
@@ -11,33 +11,97 @@ typedef struct {
 	atomic_long_t a;
 } local_t;
 
+typedef struct {
+	atomic_long_unchecked_t a;
+} local_unchecked_t;
+
 #define LOCAL_INIT(i)	{ ATOMIC_LONG_INIT(i) }
 
 #define local_read(l)	atomic_long_read(&(l)->a)
+#define local_read_unchecked(l)	atomic_long_read_unchecked(&(l)->a)
 #define local_set(l, i)	atomic_long_set(&(l)->a, (i))
+#define local_set_unchecked(l, i)	atomic_long_set_unchecked(&(l)->a, (i))
 
 static inline void local_inc(local_t *l)
 {
-	asm volatile(_ASM_INC "%0"
+	asm volatile(_ASM_INC "%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_DEC "%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (l->a.counter));
+}
+
+static inline void local_inc_unchecked(local_unchecked_t *l)
+{
+	asm volatile(_ASM_INC "%0\n"
 		     : "+m" (l->a.counter));
 }
 
 static inline void local_dec(local_t *l)
 {
-	asm volatile(_ASM_DEC "%0"
+	asm volatile(_ASM_DEC "%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_INC "%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (l->a.counter));
+}
+
+static inline void local_dec_unchecked(local_unchecked_t *l)
+{
+	asm volatile(_ASM_DEC "%0\n"
 		     : "+m" (l->a.counter));
 }
 
 static inline void local_add(long i, local_t *l)
 {
-	asm volatile(_ASM_ADD "%1,%0"
+	asm volatile(_ASM_ADD "%1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_SUB "%1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (l->a.counter)
+		     : "ir" (i));
+}
+
+static inline void local_add_unchecked(long i, local_unchecked_t *l)
+{
+	asm volatile(_ASM_ADD "%1,%0\n"
 		     : "+m" (l->a.counter)
 		     : "ir" (i));
 }
 
 static inline void local_sub(long i, local_t *l)
 {
-	asm volatile(_ASM_SUB "%1,%0"
+	asm volatile(_ASM_SUB "%1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_ADD "%1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     : "+m" (l->a.counter)
+		     : "ir" (i));
+}
+
+static inline void local_sub_unchecked(long i, local_unchecked_t *l)
+{
+	asm volatile(_ASM_SUB "%1,%0\n"
 		     : "+m" (l->a.counter)
 		     : "ir" (i));
 }
@@ -55,7 +119,16 @@ static inline int local_sub_and_test(lon
 {
 	unsigned char c;
 
-	asm volatile(_ASM_SUB "%2,%0; sete %1"
+	asm volatile(_ASM_SUB "%2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_ADD "%2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "+m" (l->a.counter), "=qm" (c)
 		     : "ir" (i) : "memory");
 	return c;
@@ -73,7 +146,16 @@ static inline int local_dec_and_test(loc
 {
 	unsigned char c;
 
-	asm volatile(_ASM_DEC "%0; sete %1"
+	asm volatile(_ASM_DEC "%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_INC "%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "+m" (l->a.counter), "=qm" (c)
 		     : : "memory");
 	return c != 0;
@@ -91,7 +173,16 @@ static inline int local_inc_and_test(loc
 {
 	unsigned char c;
 
-	asm volatile(_ASM_INC "%0; sete %1"
+	asm volatile(_ASM_INC "%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_DEC "%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sete %1\n"
 		     : "+m" (l->a.counter), "=qm" (c)
 		     : : "memory");
 	return c != 0;
@@ -110,7 +201,16 @@ static inline int local_add_negative(lon
 {
 	unsigned char c;
 
-	asm volatile(_ASM_ADD "%2,%0; sets %1"
+	asm volatile(_ASM_ADD "%2,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_SUB "%2,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     "sets %1\n"
 		     : "+m" (l->a.counter), "=qm" (c)
 		     : "ir" (i) : "memory");
 	return c;
@@ -133,7 +233,15 @@ static inline long local_add_return(long
 #endif
 	/* Modern 486+ processor */
 	__i = i;
-	asm volatile(_ASM_XADD "%0, %1;"
+	asm volatile(_ASM_XADD "%0, %1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     _ASM_MOV "%0,%1\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "+r" (i), "+m" (l->a.counter)
 		     : : "memory");
 	return i + __i;
@@ -148,6 +256,38 @@ no_xadd: /* Legacy 386 processor */
 #endif
 }
 
+/**
+ * local_add_return_unchecked - add and return
+ * @i: integer value to add
+ * @l: pointer to type local_unchecked_t
+ *
+ * Atomically adds @i to @l and returns @i + @l
+ */
+static inline long local_add_return_unchecked(long i, local_unchecked_t *l)
+{
+	long __i;
+#ifdef CONFIG_M386
+	unsigned long flags;
+	if (unlikely(boot_cpu_data.x86 <= 3))
+		goto no_xadd;
+#endif
+	/* Modern 486+ processor */
+	__i = i;
+	asm volatile(_ASM_XADD "%0, %1\n"
+		     : "+r" (i), "+m" (l->a.counter)
+		     : : "memory");
+	return i + __i;
+
+#ifdef CONFIG_M386
+no_xadd: /* Legacy 386 processor */
+	local_irq_save(flags);
+	__i = local_read_unchecked(l);
+	local_set_unchecked(l, i + __i);
+	local_irq_restore(flags);
+	return i + __i;
+#endif
+}
+
 static inline long local_sub_return(long i, local_t *l)
 {
 	return local_add_return(-i, l);
@@ -158,6 +298,8 @@ static inline long local_sub_return(long
 
 #define local_cmpxchg(l, o, n) \
 	(cmpxchg_local(&((l)->a.counter), (o), (n)))
+#define local_cmpxchg_unchecked(l, o, n) \
+	(cmpxchg_local(&((l)->a.counter), (o), (n)))
 /* Always has a lock prefix */
 #define local_xchg(l, n) (xchg(&((l)->a.counter), (n)))
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/mman.h linux-2.6.32.60-pax/arch/x86/include/asm/mman.h
--- linux-2.6.32.60/arch/x86/include/asm/mman.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/mman.h	2012-03-13 13:15:34.468098025 +0100
@@ -5,4 +5,14 @@
 
 #include <asm-generic/mman.h>
 
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+#ifdef CONFIG_X86_32
+#define arch_mmap_check	i386_mmap_check
+int i386_mmap_check(unsigned long addr, unsigned long len,
+		unsigned long flags);
+#endif
+#endif
+#endif
+
 #endif /* _ASM_X86_MMAN_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/mmu_context.h linux-2.6.32.60-pax/arch/x86/include/asm/mmu_context.h
--- linux-2.6.32.60/arch/x86/include/asm/mmu_context.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/mmu_context.h	2012-05-28 00:40:22.987136113 +0200
@@ -24,6 +24,18 @@ void destroy_context(struct mm_struct *m
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 {
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	unsigned int i;
+	pgd_t *pgd;
+
+	pax_open_kernel();
+	pgd = get_cpu_pgd(smp_processor_id());
+	for (i = USER_PGD_PTRS; i < 2 * USER_PGD_PTRS; ++i)
+		set_pgd_batched(pgd+i, native_make_pgd(0));
+	pax_close_kernel();
+#endif
+
 #ifdef CONFIG_SMP
 	if (percpu_read(cpu_tlbstate.state) == TLBSTATE_OK)
 		percpu_write(cpu_tlbstate.state, TLBSTATE_LAZY);
@@ -34,16 +46,30 @@ static inline void switch_mm(struct mm_s
 			     struct task_struct *tsk)
 {
 	unsigned cpu = smp_processor_id();
+#if defined(CONFIG_X86_32) && defined(CONFIG_SMP) && (defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC))
+	int tlbstate = TLBSTATE_OK;
+#endif
 
 	if (likely(prev != next)) {
 #ifdef CONFIG_SMP
+#if defined(CONFIG_X86_32) && (defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC))
+		tlbstate = percpu_read(cpu_tlbstate.state);
+#endif
 		percpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		percpu_write(cpu_tlbstate.active_mm, next);
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
 		/* Re-load page tables */
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		pax_open_kernel();
+		__clone_user_pgds(get_cpu_pgd(cpu), next->pgd);
+		__shadow_user_pgds(get_cpu_pgd(cpu) + USER_PGD_PTRS, next->pgd);
+		pax_close_kernel();
+		load_cr3(get_cpu_pgd(cpu));
+#else
 		load_cr3(next->pgd);
+#endif
 
 		/* stop flush ipis for the previous mm */
 		cpumask_clear_cpu(cpu, mm_cpumask(prev));
@@ -53,9 +79,38 @@ static inline void switch_mm(struct mm_s
 		 */
 		if (unlikely(prev->context.ldt != next->context.ldt))
 			load_LDT_nolock(&next->context);
-	}
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		if (!nx_enabled) {
+			smp_mb__before_clear_bit();
+			cpu_clear(cpu, prev->context.cpu_user_cs_mask);
+			smp_mb__after_clear_bit();
+			cpu_set(cpu, next->context.cpu_user_cs_mask);
+		}
+#endif
+
+#if defined(CONFIG_X86_32) && (defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC))
+		if (unlikely(prev->context.user_cs_base != next->context.user_cs_base ||
+			     prev->context.user_cs_limit != next->context.user_cs_limit))
+			set_user_cs(next->context.user_cs_base, next->context.user_cs_limit, cpu);
 #ifdef CONFIG_SMP
+		else if (unlikely(tlbstate != TLBSTATE_OK))
+			set_user_cs(next->context.user_cs_base, next->context.user_cs_limit, cpu);
+#endif
+#endif
+
+	}
 	else {
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		pax_open_kernel();
+		__clone_user_pgds(get_cpu_pgd(cpu), next->pgd);
+		__shadow_user_pgds(get_cpu_pgd(cpu) + USER_PGD_PTRS, next->pgd);
+		pax_close_kernel();
+		load_cr3(get_cpu_pgd(cpu));
+#endif
+
+#ifdef CONFIG_SMP
 		percpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		BUG_ON(percpu_read(cpu_tlbstate.active_mm) != next);
 
@@ -64,11 +119,28 @@ static inline void switch_mm(struct mm_s
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
 			 */
+
+#ifndef CONFIG_PAX_PER_CPU_PGD
 			load_cr3(next->pgd);
+#endif
+
 			load_LDT_nolock(&next->context);
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+			if (!nx_enabled)
+				cpu_set(cpu, next->context.cpu_user_cs_mask);
+#endif
+
+#if defined(CONFIG_X86_32) && (defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC))
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!((next->pax_flags & MF_PAX_PAGEEXEC) && nx_enabled))
+#endif
+				set_user_cs(next->context.user_cs_base, next->context.user_cs_limit, cpu);
+#endif
+
 		}
-	}
 #endif
+	}
 }
 
 #define activate_mm(prev, next)			\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/mmu.h linux-2.6.32.60-pax/arch/x86/include/asm/mmu.h
--- linux-2.6.32.60/arch/x86/include/asm/mmu.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/mmu.h	2012-03-13 13:15:34.468098025 +0100
@@ -9,10 +9,23 @@
  * we put the segment information here.
  */
 typedef struct {
-	void *ldt;
+	struct desc_struct *ldt;
 	int size;
 	struct mutex lock;
-	void *vdso;
+	unsigned long vdso;
+
+#ifdef CONFIG_X86_32
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	unsigned long user_cs_base;
+	unsigned long user_cs_limit;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+	cpumask_t cpu_user_cs_mask;
+#endif
+
+#endif
+#endif
+
 } mm_context_t;
 
 #ifdef CONFIG_SMP
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/module.h linux-2.6.32.60-pax/arch/x86/include/asm/module.h
--- linux-2.6.32.60/arch/x86/include/asm/module.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/module.h	2012-03-13 13:15:34.468098025 +0100
@@ -5,6 +5,7 @@
 
 #ifdef CONFIG_X86_64
 /* X86_64 does not define MODULE_PROC_FAMILY */
+#define MODULE_PROC_FAMILY ""
 #elif defined CONFIG_M386
 #define MODULE_PROC_FAMILY "386 "
 #elif defined CONFIG_M486
@@ -59,13 +60,26 @@
 #error unknown processor family
 #endif
 
-#ifdef CONFIG_X86_32
-# ifdef CONFIG_4KSTACKS
-#  define MODULE_STACKSIZE "4KSTACKS "
-# else
-#  define MODULE_STACKSIZE ""
-# endif
-# define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_STACKSIZE
+#if defined(CONFIG_X86_32) && defined(CONFIG_4KSTACKS)
+#define MODULE_STACKSIZE "4KSTACKS "
+#else
+#define MODULE_STACKSIZE ""
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_BTS
+#define MODULE_PAX_KERNEXEC "KERNEXEC_BTS "
+#elif defined(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR)
+#define MODULE_PAX_KERNEXEC "KERNEXEC_OR "
+#else
+#define MODULE_PAX_KERNEXEC ""
 #endif
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+#define MODULE_PAX_UDEREF "UDEREF "
+#else
+#define MODULE_PAX_UDEREF ""
+#endif
+
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_STACKSIZE MODULE_PAX_KERNEXEC MODULE_PAX_UDEREF
+
 #endif /* _ASM_X86_MODULE_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/page_64_types.h linux-2.6.32.60-pax/arch/x86/include/asm/page_64_types.h
--- linux-2.6.32.60/arch/x86/include/asm/page_64_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/page_64_types.h	2012-03-13 13:15:34.468098025 +0100
@@ -56,7 +56,7 @@ void copy_page(void *to, void *from);
 
 /* duplicated to the one in bootmem.h */
 extern unsigned long max_pfn;
-extern unsigned long phys_base;
+extern const unsigned long phys_base;
 
 extern unsigned long __phys_addr(unsigned long);
 #define __phys_reloc_hide(x)	(x)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/paravirt.h linux-2.6.32.60-pax/arch/x86/include/asm/paravirt.h
--- linux-2.6.32.60/arch/x86/include/asm/paravirt.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/paravirt.h	2012-03-13 13:15:34.472098025 +0100
@@ -648,6 +648,18 @@ static inline void set_pgd(pgd_t *pgdp,
 			    val);
 }
 
+static inline void set_pgd_batched(pgd_t *pgdp, pgd_t pgd)
+{
+	pgdval_t val = native_pgd_val(pgd);
+
+	if (sizeof(pgdval_t) > sizeof(long))
+		PVOP_VCALL3(pv_mmu_ops.set_pgd_batched, pgdp,
+			    val, (u64)val >> 32);
+	else
+		PVOP_VCALL2(pv_mmu_ops.set_pgd_batched, pgdp,
+			    val);
+}
+
 static inline void pgd_clear(pgd_t *pgdp)
 {
 	set_pgd(pgdp, __pgd(0));
@@ -729,6 +741,21 @@ static inline void __set_fixmap(unsigned
 	pv_mmu_ops.set_fixmap(idx, phys, flags);
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+static inline unsigned long pax_open_kernel(void)
+{
+	return PVOP_CALL0(unsigned long, pv_mmu_ops.pax_open_kernel);
+}
+
+static inline unsigned long pax_close_kernel(void)
+{
+	return PVOP_CALL0(unsigned long, pv_mmu_ops.pax_close_kernel);
+}
+#else
+static inline unsigned long pax_open_kernel(void) { return 0; }
+static inline unsigned long pax_close_kernel(void) { return 0; }
+#endif
+
 #if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)
 
 static inline int __raw_spin_is_locked(struct raw_spinlock *lock)
@@ -945,7 +972,7 @@ extern void default_banner(void);
 
 #define PARA_PATCH(struct, off)        ((PARAVIRT_PATCH_##struct + (off)) / 4)
 #define PARA_SITE(ptype, clobbers, ops) _PVSITE(ptype, clobbers, ops, .long, 4)
-#define PARA_INDIRECT(addr)	*%cs:addr
+#define PARA_INDIRECT(addr)	*%ss:addr
 #endif
 
 #define INTERRUPT_RETURN						\
@@ -1022,6 +1049,21 @@ extern void default_banner(void);
 	PARA_SITE(PARA_PATCH(pv_cpu_ops, PV_CPU_irq_enable_sysexit),	\
 		  CLBR_NONE,						\
 		  jmp PARA_INDIRECT(pv_cpu_ops+PV_CPU_irq_enable_sysexit))
+
+#define GET_CR0_INTO_RDI				\
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_read_cr0);	\
+	mov %rax,%rdi
+
+#define SET_RDI_INTO_CR0				\
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_write_cr0)
+
+#define GET_CR3_INTO_RDI				\
+	call PARA_INDIRECT(pv_mmu_ops+PV_MMU_read_cr3);	\
+	mov %rax,%rdi
+
+#define SET_RDI_INTO_CR3				\
+	call PARA_INDIRECT(pv_mmu_ops+PV_MMU_write_cr3)
+
 #endif	/* CONFIG_X86_32 */
 
 #endif /* __ASSEMBLY__ */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/paravirt_types.h linux-2.6.32.60-pax/arch/x86/include/asm/paravirt_types.h
--- linux-2.6.32.60/arch/x86/include/asm/paravirt_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/paravirt_types.h	2013-02-17 20:17:00.495589090 +0100
@@ -78,7 +78,7 @@ struct pv_init_ops {
 	 */
 	unsigned (*patch)(u8 type, u16 clobber, void *insnbuf,
 			  unsigned long addr, unsigned len);
-};
+} __no_const;
 
 
 struct pv_lazy_ops {
@@ -90,7 +90,7 @@ struct pv_lazy_ops {
 struct pv_time_ops {
 	unsigned long long (*sched_clock)(void);
 	unsigned long (*get_tsc_khz)(void);
-};
+} __no_const;
 
 struct pv_cpu_ops {
 	/* hooks for various privileged instructions */
@@ -186,7 +186,7 @@ struct pv_cpu_ops {
 
 	void (*start_context_switch)(struct task_struct *prev);
 	void (*end_context_switch)(struct task_struct *next);
-};
+} __no_const;
 
 struct pv_irq_ops {
 	/*
@@ -217,7 +217,7 @@ struct pv_apic_ops {
 				 unsigned long start_eip,
 				 unsigned long start_esp);
 #endif
-};
+} __no_const;
 
 struct pv_mmu_ops {
 	unsigned long (*read_cr2)(void);
@@ -301,6 +301,7 @@ struct pv_mmu_ops {
 	struct paravirt_callee_save make_pud;
 
 	void (*set_pgd)(pgd_t *pudp, pgd_t pgdval);
+	void (*set_pgd_batched)(pgd_t *pudp, pgd_t pgdval);
 #endif	/* PAGETABLE_LEVELS == 4 */
 #endif	/* PAGETABLE_LEVELS >= 3 */
 
@@ -316,6 +317,12 @@ struct pv_mmu_ops {
 	   an mfn.  We can tell which is which from the index. */
 	void (*set_fixmap)(unsigned /* enum fixed_addresses */ idx,
 			   phys_addr_t phys, pgprot_t flags);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long (*pax_open_kernel)(void);
+	unsigned long (*pax_close_kernel)(void);
+#endif
+
 };
 
 struct raw_spinlock;
@@ -326,7 +333,7 @@ struct pv_lock_ops {
 	void (*spin_lock_flags)(struct raw_spinlock *lock, unsigned long flags);
 	int (*spin_trylock)(struct raw_spinlock *lock);
 	void (*spin_unlock)(struct raw_spinlock *lock);
-};
+} __no_const;
 
 /* This contains all the paravirt structures: we get a convenient
  * number for each function using the offset which we use to indicate
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/percpu.h linux-2.6.32.60-pax/arch/x86/include/asm/percpu.h
--- linux-2.6.32.60/arch/x86/include/asm/percpu.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/percpu.h	2012-03-13 13:15:34.472098025 +0100
@@ -78,6 +78,7 @@ do {							\
 	if (0) {					\
 		T__ tmp__;				\
 		tmp__ = (val);				\
+		(void)tmp__;				\
 	}						\
 	switch (sizeof(var)) {				\
 	case 1:						\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgalloc.h linux-2.6.32.60-pax/arch/x86/include/asm/pgalloc.h
--- linux-2.6.32.60/arch/x86/include/asm/pgalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgalloc.h	2012-05-07 17:49:11.836114632 +0200
@@ -63,6 +63,13 @@ static inline void pmd_populate_kernel(s
 				       pmd_t *pmd, pte_t *pte)
 {
 	paravirt_alloc_pte(mm, __pa(pte) >> PAGE_SHIFT);
+	set_pmd(pmd, __pmd(__pa(pte) | _KERNPG_TABLE));
+}
+
+static inline void pmd_populate_user(struct mm_struct *mm,
+				       pmd_t *pmd, pte_t *pte)
+{
+	paravirt_alloc_pte(mm, __pa(pte) >> PAGE_SHIFT);
 	set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
 }
 
@@ -99,12 +106,22 @@ static inline void __pmd_free_tlb(struct
 
 #ifdef CONFIG_X86_PAE
 extern void pud_populate(struct mm_struct *mm, pud_t *pudp, pmd_t *pmd);
+static inline void pud_populate_kernel(struct mm_struct *mm, pud_t *pudp, pmd_t *pmd)
+{
+	pud_populate(mm, pudp, pmd);
+}
 #else	/* !CONFIG_X86_PAE */
 static inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
 {
 	paravirt_alloc_pmd(mm, __pa(pmd) >> PAGE_SHIFT);
 	set_pud(pud, __pud(_PAGE_TABLE | __pa(pmd)));
 }
+
+static inline void pud_populate_kernel(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
+{
+	paravirt_alloc_pmd(mm, __pa(pmd) >> PAGE_SHIFT);
+	set_pud(pud, __pud(_KERNPG_TABLE | __pa(pmd)));
+}
 #endif	/* CONFIG_X86_PAE */
 
 #if PAGETABLE_LEVELS > 3
@@ -114,6 +131,12 @@ static inline void pgd_populate(struct m
 	set_pgd(pgd, __pgd(_PAGE_TABLE | __pa(pud)));
 }
 
+static inline void pgd_populate_kernel(struct mm_struct *mm, pgd_t *pgd, pud_t *pud)
+{
+	paravirt_alloc_pud(mm, __pa(pud) >> PAGE_SHIFT);
+	set_pgd(pgd, __pgd(_KERNPG_TABLE | __pa(pud)));
+}
+
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
 	return (pud_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable-2level.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable-2level.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable-2level.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable-2level.h	2012-03-13 13:15:34.476098025 +0100
@@ -18,7 +18,9 @@ static inline void native_set_pte(pte_t
 
 static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
 {
+	pax_open_kernel();
 	*pmdp = pmd;
+	pax_close_kernel();
 }
 
 static inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable_32.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_32.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_32.h	2012-03-13 13:15:34.476098025 +0100
@@ -26,9 +26,6 @@
 struct mm_struct;
 struct vm_area_struct;
 
-extern pgd_t swapper_pg_dir[1024];
-extern pgd_t trampoline_pg_dir[1024];
-
 static inline void pgtable_cache_init(void) { }
 static inline void check_pgt_cache(void) { }
 void paging_init(void);
@@ -49,6 +46,12 @@ extern void set_pmd_pfn(unsigned long, u
 # include <asm/pgtable-2level.h>
 #endif
 
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern pgd_t trampoline_pg_dir[PTRS_PER_PGD];
+#ifdef CONFIG_X86_PAE
+extern pmd_t swapper_pm_dir[PTRS_PER_PGD][PTRS_PER_PMD];
+#endif
+
 #if defined(CONFIG_HIGHPTE)
 #define __KM_PTE			\
 	(in_nmi() ? KM_NMI_PTE : 	\
@@ -73,7 +76,9 @@ extern void set_pmd_pfn(unsigned long, u
 /* Clear a kernel PTE and flush it from the TLB */
 #define kpte_clear_flush(ptep, vaddr)		\
 do {						\
+	pax_open_kernel();			\
 	pte_clear(&init_mm, (vaddr), (ptep));	\
+	pax_close_kernel();			\
 	__flush_tlb_one((vaddr));		\
 } while (0)
 
@@ -85,6 +90,9 @@ do {						\
 
 #endif /* !__ASSEMBLY__ */
 
+#define HAVE_ARCH_UNMAPPED_AREA
+#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN
+
 /*
  * kern_addr_valid() is (1) for FLATMEM and (0) for
  * SPARSEMEM and DISCONTIGMEM
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable_32_types.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_32_types.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable_32_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_32_types.h	2012-03-13 13:15:34.476098025 +0100
@@ -8,7 +8,7 @@
  */
 #ifdef CONFIG_X86_PAE
 # include <asm/pgtable-3level_types.h>
-# define PMD_SIZE	(1UL << PMD_SHIFT)
+# define PMD_SIZE	(_AC(1, UL) << PMD_SHIFT)
 # define PMD_MASK	(~(PMD_SIZE - 1))
 #else
 # include <asm/pgtable-2level_types.h>
@@ -46,6 +46,19 @@ extern bool __vmalloc_start_set; /* set
 # define VMALLOC_END	(FIXADDR_START - 2 * PAGE_SIZE)
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+#ifndef __ASSEMBLY__
+extern unsigned char MODULES_EXEC_VADDR[];
+extern unsigned char MODULES_EXEC_END[];
+#endif
+#include <asm/boot.h>
+#define ktla_ktva(addr)		(addr + LOAD_PHYSICAL_ADDR + PAGE_OFFSET)
+#define ktva_ktla(addr)		(addr - LOAD_PHYSICAL_ADDR - PAGE_OFFSET)
+#else
+#define ktla_ktva(addr)		(addr)
+#define ktva_ktla(addr)		(addr)
+#endif
+
 #define MODULES_VADDR	VMALLOC_START
 #define MODULES_END	VMALLOC_END
 #define MODULES_LEN	(MODULES_VADDR - MODULES_END)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable-3level.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable-3level.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable-3level.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable-3level.h	2012-03-13 13:15:34.476098025 +0100
@@ -38,12 +38,16 @@ static inline void native_set_pte_atomic
 
 static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
 {
+	pax_open_kernel();
 	set_64bit((unsigned long long *)(pmdp), native_pmd_val(pmd));
+	pax_close_kernel();
 }
 
 static inline void native_set_pud(pud_t *pudp, pud_t pud)
 {
+	pax_open_kernel();
 	set_64bit((unsigned long long *)(pudp), native_pud_val(pud));
+	pax_close_kernel();
 }
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable_64.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_64.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_64.h	2012-05-07 17:49:11.840114631 +0200
@@ -16,10 +16,14 @@
 
 extern pud_t level3_kernel_pgt[512];
 extern pud_t level3_ident_pgt[512];
+extern pud_t level3_vmalloc_start_pgt[512];
+extern pud_t level3_vmalloc_end_pgt[512];
+extern pud_t level3_vmemmap_pgt[512];
+extern pud_t level2_vmemmap_pgt[512];
 extern pmd_t level2_kernel_pgt[512];
 extern pmd_t level2_fixmap_pgt[512];
-extern pmd_t level2_ident_pgt[512];
-extern pgd_t init_level4_pgt[];
+extern pmd_t level2_ident_pgt[512*2];
+extern pgd_t init_level4_pgt[512];
 
 #define swapper_pg_dir init_level4_pgt
 
@@ -74,7 +78,9 @@ static inline pte_t native_ptep_get_and_
 
 static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
 {
+	pax_open_kernel();
 	*pmdp = pmd;
+	pax_close_kernel();
 }
 
 static inline void native_pmd_clear(pmd_t *pmd)
@@ -84,7 +90,9 @@ static inline void native_pmd_clear(pmd_
 
 static inline void native_set_pud(pud_t *pudp, pud_t pud)
 {
+	pax_open_kernel();
 	*pudp = pud;
+	pax_close_kernel();
 }
 
 static inline void native_pud_clear(pud_t *pud)
@@ -94,6 +102,13 @@ static inline void native_pud_clear(pud_
 
 static inline void native_set_pgd(pgd_t *pgdp, pgd_t pgd)
 {
+	pax_open_kernel();
+	*pgdp = pgd;
+	pax_close_kernel();
+}
+
+static inline void native_set_pgd_batched(pgd_t *pgdp, pgd_t pgd)
+{
 	*pgdp = pgd;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable_64_types.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_64_types.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable_64_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_64_types.h	2012-03-13 13:15:34.480098025 +0100
@@ -59,5 +59,10 @@ typedef struct { pteval_t pte; } pte_t;
 #define MODULES_VADDR    _AC(0xffffffffa0000000, UL)
 #define MODULES_END      _AC(0xffffffffff000000, UL)
 #define MODULES_LEN   (MODULES_END - MODULES_VADDR)
+#define MODULES_EXEC_VADDR MODULES_VADDR
+#define MODULES_EXEC_END MODULES_END
+
+#define ktla_ktva(addr)		(addr)
+#define ktva_ktla(addr)		(addr)
 
 #endif /* _ASM_X86_PGTABLE_64_DEFS_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable.h	2013-02-17 17:06:17.596200052 +0100
@@ -39,6 +39,7 @@ extern struct list_head pgd_list;
 
 #ifndef __PAGETABLE_PUD_FOLDED
 #define set_pgd(pgdp, pgd)		native_set_pgd(pgdp, pgd)
+#define set_pgd_batched(pgdp, pgd)	native_set_pgd_batched(pgdp, pgd)
 #define pgd_clear(pgd)			native_pgd_clear(pgd)
 #endif
 
@@ -74,12 +75,51 @@ extern struct list_head pgd_list;
 
 #define arch_end_context_switch(prev)	do {} while(0)
 
+#define pax_open_kernel()	native_pax_open_kernel()
+#define pax_close_kernel()	native_pax_close_kernel()
 #endif	/* CONFIG_PARAVIRT */
 
+#define  __HAVE_ARCH_PAX_OPEN_KERNEL
+#define  __HAVE_ARCH_PAX_CLOSE_KERNEL
+
+#ifdef CONFIG_PAX_KERNEXEC
+static inline unsigned long native_pax_open_kernel(void)
+{
+	unsigned long cr0;
+
+	preempt_disable();
+	barrier();
+	cr0 = read_cr0() ^ X86_CR0_WP;
+	BUG_ON(cr0 & X86_CR0_WP);
+	write_cr0(cr0);
+	return cr0 ^ X86_CR0_WP;
+}
+
+static inline unsigned long native_pax_close_kernel(void)
+{
+	unsigned long cr0;
+
+	cr0 = read_cr0() ^ X86_CR0_WP;
+	BUG_ON(!(cr0 & X86_CR0_WP));
+	write_cr0(cr0);
+	barrier();
+	preempt_enable_no_resched();
+	return cr0 ^ X86_CR0_WP;
+}
+#else
+static inline unsigned long native_pax_open_kernel(void) { return 0; }
+static inline unsigned long native_pax_close_kernel(void) { return 0; }
+#endif
+
 /*
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
+static inline int pte_user(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_USER;
+}
+
 static inline int pte_dirty(pte_t pte)
 {
 	return pte_flags(pte) & _PAGE_DIRTY;
@@ -167,9 +207,29 @@ static inline pte_t pte_wrprotect(pte_t
 	return pte_clear_flags(pte, _PAGE_RW);
 }
 
+static inline pte_t pte_mkread(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_USER);
+}
+
 static inline pte_t pte_mkexec(pte_t pte)
 {
-	return pte_clear_flags(pte, _PAGE_NX);
+#ifdef CONFIG_X86_PAE
+	if (__supported_pte_mask & _PAGE_NX)
+		return pte_clear_flags(pte, _PAGE_NX);
+	else
+#endif
+		return pte_set_flags(pte, _PAGE_USER);
+}
+
+static inline pte_t pte_exprotect(pte_t pte)
+{
+#ifdef CONFIG_X86_PAE
+	if (__supported_pte_mask & _PAGE_NX)
+		return pte_set_flags(pte, _PAGE_NX);
+	else
+#endif
+		return pte_clear_flags(pte, _PAGE_USER);
 }
 
 static inline pte_t pte_mkdirty(pte_t pte)
@@ -302,6 +362,15 @@ pte_t *populate_extra_pte(unsigned long
 #endif
 
 #ifndef __ASSEMBLY__
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+extern pgd_t cpu_pgd[NR_CPUS][PTRS_PER_PGD];
+static inline pgd_t *get_cpu_pgd(unsigned int cpu)
+{
+	return cpu_pgd[cpu];
+}
+#endif
+
 #include <linux/mm_types.h>
 
 static inline int pte_none(pte_t pte)
@@ -472,7 +541,7 @@ static inline pud_t *pud_offset(pgd_t *p
 
 static inline int pgd_bad(pgd_t pgd)
 {
-	return (pgd_flags(pgd) & ~_PAGE_USER) != _KERNPG_TABLE;
+	return (pgd_flags(pgd) & ~(_PAGE_USER | _PAGE_NX)) != _KERNPG_TABLE;
 }
 
 static inline int pgd_none(pgd_t pgd)
@@ -495,7 +564,12 @@ static inline int pgd_none(pgd_t pgd)
  * pgd_offset() returns a (pgd_t *)
  * pgd_index() is used get the offset into the pgd page's array of pgd_t's;
  */
-#define pgd_offset(mm, address) ((mm)->pgd + pgd_index((address)))
+#define pgd_offset(mm, address) ((mm)->pgd + pgd_index(address))
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+#define pgd_offset_cpu(cpu, address) (get_cpu_pgd(cpu) + pgd_index(address))
+#endif
+
 /*
  * a shortcut which implies the use of the kernel's pgd, instead
  * of a process's
@@ -506,6 +580,20 @@ static inline int pgd_none(pgd_t pgd)
 #define KERNEL_PGD_BOUNDARY	pgd_index(PAGE_OFFSET)
 #define KERNEL_PGD_PTRS		(PTRS_PER_PGD - KERNEL_PGD_BOUNDARY)
 
+#ifdef CONFIG_X86_32
+#define USER_PGD_PTRS		KERNEL_PGD_BOUNDARY
+#else
+#define TASK_SIZE_MAX_SHIFT CONFIG_TASK_SIZE_MAX_SHIFT
+#define USER_PGD_PTRS		(_AC(1,UL) << (TASK_SIZE_MAX_SHIFT - PGDIR_SHIFT))
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+#define PAX_USER_SHADOW_BASE	(_AC(1,UL) << TASK_SIZE_MAX_SHIFT)
+#else
+#define PAX_USER_SHADOW_BASE	(_AC(0,UL))
+#endif
+
+#endif
+
 #ifndef __ASSEMBLY__
 
 extern int direct_gbpages;
@@ -611,11 +699,23 @@ static inline void ptep_set_wrprotect(st
  * dst and src can be on the same page, but the range must not overlap,
  * and must not cross a page boundary.
  */
-static inline void clone_pgd_range(pgd_t *dst, pgd_t *src, int count)
+static inline void clone_pgd_range(pgd_t *dst, const pgd_t *src, int count)
 {
-       memcpy(dst, src, count * sizeof(pgd_t));
+	pax_open_kernel();
+	while (count--)
+		*dst++ = *src++;
+	pax_close_kernel();
 }
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+extern void __clone_user_pgds(pgd_t *dst, const pgd_t *src);
+#endif
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+extern void __shadow_user_pgds(pgd_t *dst, const pgd_t *src);
+#else
+static inline void __shadow_user_pgds(pgd_t *dst, const pgd_t *src) {}
+#endif
 
 #include <asm-generic/pgtable.h>
 #endif	/* __ASSEMBLY__ */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/pgtable_types.h linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_types.h
--- linux-2.6.32.60/arch/x86/include/asm/pgtable_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/pgtable_types.h	2012-03-13 13:15:34.480098025 +0100
@@ -16,12 +16,11 @@
 #define _PAGE_BIT_PSE		7	/* 4 MB (or 2MB) page */
 #define _PAGE_BIT_PAT		7	/* on 4KB pages */
 #define _PAGE_BIT_GLOBAL	8	/* Global TLB entry PPro+ */
-#define _PAGE_BIT_UNUSED1	9	/* available for programmer */
+#define _PAGE_BIT_SPECIAL	9	/* special mappings, no associated struct page */
 #define _PAGE_BIT_IOMAP		10	/* flag used to indicate IO mapping */
 #define _PAGE_BIT_HIDDEN	11	/* hidden by kmemcheck */
 #define _PAGE_BIT_PAT_LARGE	12	/* On 2MB or 1GB pages */
-#define _PAGE_BIT_SPECIAL	_PAGE_BIT_UNUSED1
-#define _PAGE_BIT_CPA_TEST	_PAGE_BIT_UNUSED1
+#define _PAGE_BIT_CPA_TEST	_PAGE_BIT_SPECIAL
 #define _PAGE_BIT_NX           63       /* No execute: only valid after cpuid check */
 
 /* If _PAGE_BIT_PRESENT is clear, we use these: */
@@ -39,7 +38,6 @@
 #define _PAGE_DIRTY	(_AT(pteval_t, 1) << _PAGE_BIT_DIRTY)
 #define _PAGE_PSE	(_AT(pteval_t, 1) << _PAGE_BIT_PSE)
 #define _PAGE_GLOBAL	(_AT(pteval_t, 1) << _PAGE_BIT_GLOBAL)
-#define _PAGE_UNUSED1	(_AT(pteval_t, 1) << _PAGE_BIT_UNUSED1)
 #define _PAGE_IOMAP	(_AT(pteval_t, 1) << _PAGE_BIT_IOMAP)
 #define _PAGE_PAT	(_AT(pteval_t, 1) << _PAGE_BIT_PAT)
 #define _PAGE_PAT_LARGE (_AT(pteval_t, 1) << _PAGE_BIT_PAT_LARGE)
@@ -55,8 +53,10 @@
 
 #if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
 #define _PAGE_NX	(_AT(pteval_t, 1) << _PAGE_BIT_NX)
-#else
+#elif defined(CONFIG_KMEMCHECK)
 #define _PAGE_NX	(_AT(pteval_t, 0))
+#else
+#define _PAGE_NX	(_AT(pteval_t, 1) << _PAGE_BIT_HIDDEN)
 #endif
 
 #define _PAGE_FILE	(_AT(pteval_t, 1) << _PAGE_BIT_FILE)
@@ -93,6 +93,9 @@
 #define PAGE_READONLY_EXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER |	\
 					 _PAGE_ACCESSED)
 
+#define PAGE_READONLY_NOEXEC PAGE_READONLY
+#define PAGE_SHARED_NOEXEC PAGE_SHARED
+
 #define __PAGE_KERNEL_EXEC						\
 	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_GLOBAL)
 #define __PAGE_KERNEL		(__PAGE_KERNEL_EXEC | _PAGE_NX)
@@ -103,8 +106,8 @@
 #define __PAGE_KERNEL_WC		(__PAGE_KERNEL | _PAGE_CACHE_WC)
 #define __PAGE_KERNEL_NOCACHE		(__PAGE_KERNEL | _PAGE_PCD | _PAGE_PWT)
 #define __PAGE_KERNEL_UC_MINUS		(__PAGE_KERNEL | _PAGE_PCD)
-#define __PAGE_KERNEL_VSYSCALL		(__PAGE_KERNEL_RX | _PAGE_USER)
-#define __PAGE_KERNEL_VSYSCALL_NOCACHE	(__PAGE_KERNEL_VSYSCALL | _PAGE_PCD | _PAGE_PWT)
+#define __PAGE_KERNEL_VSYSCALL		(__PAGE_KERNEL_RO | _PAGE_USER)
+#define __PAGE_KERNEL_VSYSCALL_NOCACHE	(__PAGE_KERNEL_RO | _PAGE_PCD | _PAGE_PWT | _PAGE_USER)
 #define __PAGE_KERNEL_LARGE		(__PAGE_KERNEL | _PAGE_PSE)
 #define __PAGE_KERNEL_LARGE_NOCACHE	(__PAGE_KERNEL | _PAGE_CACHE_UC | _PAGE_PSE)
 #define __PAGE_KERNEL_LARGE_EXEC	(__PAGE_KERNEL_EXEC | _PAGE_PSE)
@@ -163,8 +166,8 @@
  * bits are combined, this will alow user to access the high address mapped
  * VDSO in the presence of CONFIG_COMPAT_VDSO
  */
-#define PTE_IDENT_ATTR	 0x003		/* PRESENT+RW */
-#define PDE_IDENT_ATTR	 0x067		/* PRESENT+RW+USER+DIRTY+ACCESSED */
+#define PTE_IDENT_ATTR	 0x063		/* PRESENT+RW+DIRTY+ACCESSED */
+#define PDE_IDENT_ATTR	 0x063		/* PRESENT+RW+DIRTY+ACCESSED */
 #define PGD_IDENT_ATTR	 0x001		/* PRESENT (no other attributes) */
 #endif
 
@@ -202,7 +205,17 @@ static inline pgdval_t pgd_flags(pgd_t p
 {
 	return native_pgd_val(pgd) & PTE_FLAGS_MASK;
 }
+#endif
 
+#if PAGETABLE_LEVELS == 3
+#include <asm-generic/pgtable-nopud.h>
+#endif
+
+#if PAGETABLE_LEVELS == 2
+#include <asm-generic/pgtable-nopmd.h>
+#endif
+
+#ifndef __ASSEMBLY__
 #if PAGETABLE_LEVELS > 3
 typedef struct { pudval_t pud; } pud_t;
 
@@ -216,8 +229,6 @@ static inline pudval_t native_pud_val(pu
 	return pud.pud;
 }
 #else
-#include <asm-generic/pgtable-nopud.h>
-
 static inline pudval_t native_pud_val(pud_t pud)
 {
 	return native_pgd_val(pud.pgd);
@@ -237,8 +248,6 @@ static inline pmdval_t native_pmd_val(pm
 	return pmd.pmd;
 }
 #else
-#include <asm-generic/pgtable-nopmd.h>
-
 static inline pmdval_t native_pmd_val(pmd_t pmd)
 {
 	return native_pgd_val(pmd.pud.pgd);
@@ -278,7 +287,16 @@ typedef struct page *pgtable_t;
 
 extern pteval_t __supported_pte_mask;
 extern void set_nx(void);
+
+#ifdef CONFIG_X86_32
+#ifdef CONFIG_X86_PAE
 extern int nx_enabled;
+#else
+#define nx_enabled (0)
+#endif
+#else
+#define nx_enabled (1)
+#endif
 
 #define pgprot_writecombine	pgprot_writecombine
 extern pgprot_t pgprot_writecombine(pgprot_t prot);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/processor.h linux-2.6.32.60-pax/arch/x86/include/asm/processor.h
--- linux-2.6.32.60/arch/x86/include/asm/processor.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/processor.h	2012-03-13 13:15:34.480098025 +0100
@@ -272,7 +272,7 @@ struct tss_struct {
 
 } ____cacheline_aligned;
 
-DECLARE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss);
+extern struct tss_struct init_tss[NR_CPUS];
 
 /*
  * Save the original ist values for checking stack pointers during debugging
@@ -911,11 +911,18 @@ static inline void spin_lock_prefetch(co
  */
 #define TASK_SIZE		PAGE_OFFSET
 #define TASK_SIZE_MAX		TASK_SIZE
+
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_SIZE	(TASK_SIZE / 2)
+#define STACK_TOP		((current->mm->pax_flags & MF_PAX_SEGMEXEC)?SEGMEXEC_TASK_SIZE:TASK_SIZE)
+#else
 #define STACK_TOP		TASK_SIZE
-#define STACK_TOP_MAX		STACK_TOP
+#endif
+
+#define STACK_TOP_MAX		TASK_SIZE
 
 #define INIT_THREAD  {							  \
-	.sp0			= sizeof(init_stack) + (long)&init_stack, \
+	.sp0			= sizeof(init_stack) + (long)&init_stack - 8, \
 	.vm86_info		= NULL,					  \
 	.sysenter_cs		= __KERNEL_CS,				  \
 	.io_bitmap_ptr		= NULL,					  \
@@ -929,7 +936,7 @@ static inline void spin_lock_prefetch(co
  */
 #define INIT_TSS  {							  \
 	.x86_tss = {							  \
-		.sp0		= sizeof(init_stack) + (long)&init_stack, \
+		.sp0		= sizeof(init_stack) + (long)&init_stack - 8, \
 		.ss0		= __KERNEL_DS,				  \
 		.ss1		= __KERNEL_CS,				  \
 		.io_bitmap_base	= INVALID_IO_BITMAP_OFFSET,		  \
@@ -940,11 +947,7 @@ static inline void spin_lock_prefetch(co
 extern unsigned long thread_saved_pc(struct task_struct *tsk);
 
 #define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))
-#define KSTK_TOP(info)                                                 \
-({                                                                     \
-       unsigned long *__ptr = (unsigned long *)(info);                 \
-       (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
-})
+#define KSTK_TOP(info)         ((container_of(info, struct task_struct, tinfo))->thread.sp0)
 
 /*
  * The below -8 is to reserve 8 bytes on top of the ring0 stack.
@@ -959,7 +962,7 @@ extern unsigned long thread_saved_pc(str
 #define task_pt_regs(task)                                             \
 ({                                                                     \
        struct pt_regs *__regs__;                                       \
-       __regs__ = (struct pt_regs *)(KSTK_TOP(task_stack_page(task))-8); \
+       __regs__ = (struct pt_regs *)((task)->thread.sp0);              \
        __regs__ - 1;                                                   \
 })
 
@@ -969,13 +972,13 @@ extern unsigned long thread_saved_pc(str
 /*
  * User space process size. 47bits minus one guard page.
  */
-#define TASK_SIZE_MAX	((1UL << 47) - PAGE_SIZE)
+#define TASK_SIZE_MAX	((1UL << TASK_SIZE_MAX_SHIFT) - PAGE_SIZE)
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
 #define IA32_PAGE_OFFSET	((current->personality & ADDR_LIMIT_3GB) ? \
-					0xc0000000 : 0xFFFFe000)
+					0xc0000000 : 0xFFFFf000)
 
 #define TASK_SIZE		(test_thread_flag(TIF_IA32) ? \
 					IA32_PAGE_OFFSET : TASK_SIZE_MAX)
@@ -986,11 +989,11 @@ extern unsigned long thread_saved_pc(str
 #define STACK_TOP_MAX		TASK_SIZE_MAX
 
 #define INIT_THREAD  { \
-	.sp0 = (unsigned long)&init_stack + sizeof(init_stack) \
+	.sp0 = (unsigned long)&init_stack + sizeof(init_stack) - 16 \
 }
 
 #define INIT_TSS  { \
-	.x86_tss.sp0 = (unsigned long)&init_stack + sizeof(init_stack) \
+	.x86_tss.sp0 = (unsigned long)&init_stack + sizeof(init_stack) - 16 \
 }
 
 /*
@@ -1012,6 +1015,10 @@ extern void start_thread(struct pt_regs
  */
 #define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
 
+#ifdef CONFIG_PAX_SEGMEXEC
+#define SEGMEXEC_TASK_UNMAPPED_BASE	(PAGE_ALIGN(SEGMEXEC_TASK_SIZE / 3))
+#endif
+
 #define KSTK_EIP(task)		(task_pt_regs(task)->ip)
 
 /* Get/set a process' ability to use the timestamp counter instruction */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/ptrace.h linux-2.6.32.60-pax/arch/x86/include/asm/ptrace.h
--- linux-2.6.32.60/arch/x86/include/asm/ptrace.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/ptrace.h	2012-03-13 13:15:34.484098025 +0100
@@ -151,28 +151,29 @@ static inline unsigned long regs_return_
 }
 
 /*
- * user_mode_vm(regs) determines whether a register set came from user mode.
+ * user_mode(regs) determines whether a register set came from user mode.
  * This is true if V8086 mode was enabled OR if the register set was from
  * protected mode with RPL-3 CS value.  This tricky test checks that with
  * one comparison.  Many places in the kernel can bypass this full check
- * if they have already ruled out V8086 mode, so user_mode(regs) can be used.
+ * if they have already ruled out V8086 mode, so user_mode_novm(regs) can
+ * be used.
  */
-static inline int user_mode(struct pt_regs *regs)
+static inline int user_mode_novm(struct pt_regs *regs)
 {
 #ifdef CONFIG_X86_32
 	return (regs->cs & SEGMENT_RPL_MASK) == USER_RPL;
 #else
-	return !!(regs->cs & 3);
+	return !!(regs->cs & SEGMENT_RPL_MASK);
 #endif
 }
 
-static inline int user_mode_vm(struct pt_regs *regs)
+static inline int user_mode(struct pt_regs *regs)
 {
 #ifdef CONFIG_X86_32
 	return ((regs->cs & SEGMENT_RPL_MASK) | (regs->flags & X86_VM_MASK)) >=
 		USER_RPL;
 #else
-	return user_mode(regs);
+	return user_mode_novm(regs);
 #endif
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/reboot.h linux-2.6.32.60-pax/arch/x86/include/asm/reboot.h
--- linux-2.6.32.60/arch/x86/include/asm/reboot.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/reboot.h	2013-02-17 17:41:19.476087828 +0100
@@ -6,19 +6,19 @@
 struct pt_regs;
 
 struct machine_ops {
-	void (*restart)(char *cmd);
-	void (*halt)(void);
-	void (*power_off)(void);
+	void (* __noreturn restart)(char *cmd);
+	void (* __noreturn halt)(void);
+	void (* __noreturn power_off)(void);
 	void (*shutdown)(void);
 	void (*crash_shutdown)(struct pt_regs *);
-	void (*emergency_restart)(void);
-};
+	void (* __noreturn emergency_restart)(void);
+} __no_const;
 
 extern struct machine_ops machine_ops;
 
 void native_machine_crash_shutdown(struct pt_regs *regs);
 void native_machine_shutdown(void);
-void machine_real_restart(const unsigned char *code, int length);
+void __noreturn machine_real_restart(const unsigned char *code, unsigned int length);
 
 typedef void (*nmi_shootdown_cb)(int, struct die_args*);
 void nmi_shootdown_cpus(nmi_shootdown_cb callback);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/rwsem.h linux-2.6.32.60-pax/arch/x86/include/asm/rwsem.h
--- linux-2.6.32.60/arch/x86/include/asm/rwsem.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/rwsem.h	2012-03-13 13:15:34.484098025 +0100
@@ -118,6 +118,14 @@ static inline void __down_read(struct rw
 {
 	asm volatile("# beginning down_read\n\t"
 		     LOCK_PREFIX _ASM_INC "(%1)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX _ASM_DEC "(%1)\n\t"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     /* adds 0x00000001, returns the old value */
 		     "  jns        1f\n"
 		     "  call call_rwsem_down_read_failed\n"
@@ -139,6 +147,14 @@ static inline int __down_read_trylock(st
 		     "1:\n\t"
 		     "  mov          %1,%2\n\t"
 		     "  add          %3,%2\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "sub %3,%2\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     "  jle	     2f\n\t"
 		     LOCK_PREFIX "  cmpxchg  %2,%0\n\t"
 		     "  jnz	     1b\n\t"
@@ -160,6 +176,14 @@ static inline void __down_write_nested(s
 	tmp = RWSEM_ACTIVE_WRITE_BIAS;
 	asm volatile("# beginning down_write\n\t"
 		     LOCK_PREFIX "  xadd      %1,(%2)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "mov %1,(%2)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     /* subtract 0x0000ffff, returns the old value */
 		     "  test      %1,%1\n\t"
 		     /* was the count 0 before? */
@@ -198,6 +222,14 @@ static inline void __up_read(struct rw_s
 	rwsem_count_t tmp = -RWSEM_ACTIVE_READ_BIAS;
 	asm volatile("# beginning __up_read\n\t"
 		     LOCK_PREFIX "  xadd      %1,(%2)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "mov %1,(%2)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     /* subtracts 1, returns the old value */
 		     "  jns        1f\n\t"
 		     "  call call_rwsem_wake\n"
@@ -216,6 +248,14 @@ static inline void __up_write(struct rw_
 	rwsem_count_t tmp;
 	asm volatile("# beginning __up_write\n\t"
 		     LOCK_PREFIX "  xadd      %1,(%2)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "mov %1,(%2)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     /* tries to transition
 			0xffff0001 -> 0x00000000 */
 		     "  jz       1f\n"
@@ -234,6 +274,14 @@ static inline void __downgrade_write(str
 {
 	asm volatile("# beginning __downgrade_write\n\t"
 		     LOCK_PREFIX _ASM_ADD "%2,(%1)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX _ASM_SUB "%2,(%1)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     /*
 		      * transitions 0xZZZZ0001 -> 0xYYYY0001 (i386)
 		      *     0xZZZZZZZZ00000001 -> 0xYYYYYYYY00000001 (x86_64)
@@ -253,7 +301,15 @@ static inline void __downgrade_write(str
 static inline void rwsem_atomic_add(rwsem_count_t delta,
 				    struct rw_semaphore *sem)
 {
-	asm volatile(LOCK_PREFIX _ASM_ADD "%1,%0"
+	asm volatile(LOCK_PREFIX _ASM_ADD "%1,%0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX _ASM_SUB "%1,%0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "+m" (sem->count)
 		     : "er" (delta));
 }
@@ -266,7 +322,15 @@ static inline rwsem_count_t rwsem_atomic
 {
 	rwsem_count_t tmp = delta;
 
-	asm volatile(LOCK_PREFIX "xadd %0,%1"
+	asm volatile(LOCK_PREFIX "xadd %0,%1\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     "mov %0,%1\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "+r" (tmp), "+m" (sem->count)
 		     : : "memory");
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/segment.h linux-2.6.32.60-pax/arch/x86/include/asm/segment.h
--- linux-2.6.32.60/arch/x86/include/asm/segment.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/segment.h	2012-03-13 13:15:34.484098025 +0100
@@ -62,10 +62,15 @@
  *  26 - ESPFIX small SS
  *  27 - per-cpu			[ offset to per-cpu data area ]
  *  28 - stack_canary-20		[ for stack protector ]
- *  29 - unused
- *  30 - unused
+ *  29 - PCI BIOS CS
+ *  30 - PCI BIOS DS
  *  31 - TSS for double fault handler
  */
+#define GDT_ENTRY_KERNEXEC_EFI_CS	(1)
+#define GDT_ENTRY_KERNEXEC_EFI_DS	(2)
+#define __KERNEXEC_EFI_CS	(GDT_ENTRY_KERNEXEC_EFI_CS*8)
+#define __KERNEXEC_EFI_DS	(GDT_ENTRY_KERNEXEC_EFI_DS*8)
+
 #define GDT_ENTRY_TLS_MIN	6
 #define GDT_ENTRY_TLS_MAX 	(GDT_ENTRY_TLS_MIN + GDT_ENTRY_TLS_ENTRIES - 1)
 
@@ -77,6 +82,8 @@
 
 #define GDT_ENTRY_KERNEL_CS		(GDT_ENTRY_KERNEL_BASE + 0)
 
+#define GDT_ENTRY_KERNEXEC_KERNEL_CS	(4)
+
 #define GDT_ENTRY_KERNEL_DS		(GDT_ENTRY_KERNEL_BASE + 1)
 
 #define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE + 4)
@@ -88,7 +95,7 @@
 #define GDT_ENTRY_ESPFIX_SS		(GDT_ENTRY_KERNEL_BASE + 14)
 #define __ESPFIX_SS (GDT_ENTRY_ESPFIX_SS * 8)
 
-#define GDT_ENTRY_PERCPU			(GDT_ENTRY_KERNEL_BASE + 15)
+#define GDT_ENTRY_PERCPU		(GDT_ENTRY_KERNEL_BASE + 15)
 #ifdef CONFIG_SMP
 #define __KERNEL_PERCPU (GDT_ENTRY_PERCPU * 8)
 #else
@@ -102,6 +109,12 @@
 #define __KERNEL_STACK_CANARY		0
 #endif
 
+#define GDT_ENTRY_PCIBIOS_CS		(GDT_ENTRY_KERNEL_BASE + 17)
+#define __PCIBIOS_CS (GDT_ENTRY_PCIBIOS_CS * 8)
+
+#define GDT_ENTRY_PCIBIOS_DS		(GDT_ENTRY_KERNEL_BASE + 18)
+#define __PCIBIOS_DS (GDT_ENTRY_PCIBIOS_DS * 8)
+
 #define GDT_ENTRY_DOUBLEFAULT_TSS	31
 
 /*
@@ -139,7 +152,7 @@
  */
 
 /* Matches PNP_CS32 and PNP_CS16 (they must be consecutive) */
-#define SEGMENT_IS_PNP_CODE(x)   (((x) & 0xf4) == GDT_ENTRY_PNPBIOS_BASE * 8)
+#define SEGMENT_IS_PNP_CODE(x)   (((x) & 0xFFFCU) == PNP_CS32 || ((x) & 0xFFFCU) == PNP_CS16)
 
 
 #else
@@ -163,6 +176,8 @@
 #define __USER32_CS   (GDT_ENTRY_DEFAULT_USER32_CS * 8 + 3)
 #define __USER32_DS	__USER_DS
 
+#define GDT_ENTRY_KERNEXEC_KERNEL_CS 7
+
 #define GDT_ENTRY_TSS 8	/* needs two entries */
 #define GDT_ENTRY_LDT 10 /* needs two entries */
 #define GDT_ENTRY_TLS_MIN 12
@@ -183,6 +198,7 @@
 #endif
 
 #define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS * 8)
+#define __KERNEXEC_KERNEL_CS	(GDT_ENTRY_KERNEXEC_KERNEL_CS * 8)
 #define __KERNEL_DS	(GDT_ENTRY_KERNEL_DS * 8)
 #define __USER_DS     (GDT_ENTRY_DEFAULT_USER_DS* 8 + 3)
 #define __USER_CS     (GDT_ENTRY_DEFAULT_USER_CS* 8 + 3)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/smp.h linux-2.6.32.60-pax/arch/x86/include/asm/smp.h
--- linux-2.6.32.60/arch/x86/include/asm/smp.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/smp.h	2013-02-17 17:40:13.824091333 +0100
@@ -24,7 +24,7 @@ extern unsigned int num_processors;
 DECLARE_PER_CPU(cpumask_var_t, cpu_sibling_map);
 DECLARE_PER_CPU(cpumask_var_t, cpu_core_map);
 DECLARE_PER_CPU(u16, cpu_llc_id);
-DECLARE_PER_CPU(int, cpu_number);
+DECLARE_PER_CPU(unsigned int, cpu_number);
 
 static inline struct cpumask *cpu_sibling_mask(int cpu)
 {
@@ -60,7 +60,7 @@ struct smp_ops {
 
 	void (*send_call_func_ipi)(const struct cpumask *mask);
 	void (*send_call_func_single_ipi)(int cpu);
-};
+} __no_const;
 
 /* Globals due to paravirt */
 extern void set_cpu_sibling_map(int cpu);
@@ -175,14 +175,8 @@ extern unsigned disabled_cpus __cpuinitd
 extern int safe_smp_processor_id(void);
 
 #elif defined(CONFIG_X86_64_SMP)
-#define raw_smp_processor_id() (percpu_read(cpu_number))
-
-#define stack_smp_processor_id()					\
-({								\
-	struct thread_info *ti;						\
-	__asm__("andq %%rsp,%0; ":"=r" (ti) : "0" (CURRENT_MASK));	\
-	ti->cpu;							\
-})
+#define raw_smp_processor_id()		(percpu_read(cpu_number))
+#define stack_smp_processor_id()	raw_smp_processor_id()
 #define safe_smp_processor_id()		smp_processor_id()
 
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/spinlock.h linux-2.6.32.60-pax/arch/x86/include/asm/spinlock.h
--- linux-2.6.32.60/arch/x86/include/asm/spinlock.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/spinlock.h	2012-03-13 13:15:34.488098024 +0100
@@ -249,6 +249,14 @@ static inline int __raw_write_can_lock(r
 static inline void __raw_read_lock(raw_rwlock_t *rw)
 {
 	asm volatile(LOCK_PREFIX " subl $1,(%0)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX " addl $1,(%0)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     "jns 1f\n"
 		     "call __read_lock_failed\n\t"
 		     "1:\n"
@@ -258,6 +266,14 @@ static inline void __raw_read_lock(raw_r
 static inline void __raw_write_lock(raw_rwlock_t *rw)
 {
 	asm volatile(LOCK_PREFIX " subl %1,(%0)\n\t"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX " addl %1,(%0)\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     "jz 1f\n"
 		     "call __write_lock_failed\n\t"
 		     "1:\n"
@@ -286,12 +302,29 @@ static inline int __raw_write_trylock(ra
 
 static inline void __raw_read_unlock(raw_rwlock_t *rw)
 {
-	asm volatile(LOCK_PREFIX "incl %0" :"+m" (rw->lock) : : "memory");
+	asm volatile(LOCK_PREFIX "incl %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "decl %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
+		     :"+m" (rw->lock) : : "memory");
 }
 
 static inline void __raw_write_unlock(raw_rwlock_t *rw)
 {
-	asm volatile(LOCK_PREFIX "addl %1, %0"
+	asm volatile(LOCK_PREFIX "addl %1, %0\n"
+
+#ifdef CONFIG_PAX_REFCOUNT
+		     "jno 0f\n"
+		     LOCK_PREFIX "subl %1, %0\n"
+		     "int $4\n0:\n"
+		     _ASM_EXTABLE(0b, 0b)
+#endif
+
 		     : "+m" (rw->lock) : "i" (RW_LOCK_BIAS) : "memory");
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/stackprotector.h linux-2.6.32.60-pax/arch/x86/include/asm/stackprotector.h
--- linux-2.6.32.60/arch/x86/include/asm/stackprotector.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/stackprotector.h	2012-03-13 13:15:34.488098024 +0100
@@ -48,7 +48,7 @@
  * head_32 for boot CPU and setup_per_cpu_areas() for others.
  */
 #define GDT_STACK_CANARY_INIT						\
-	[GDT_ENTRY_STACK_CANARY] = GDT_ENTRY_INIT(0x4090, 0, 0x18),
+	[GDT_ENTRY_STACK_CANARY] = GDT_ENTRY_INIT(0x4090, 0, 0x17),
 
 /*
  * Initialize the stackprotector canary value.
@@ -113,7 +113,7 @@ static inline void setup_stack_canary_se
 
 static inline void load_stack_canary_segment(void)
 {
-#ifdef CONFIG_X86_32
+#if defined(CONFIG_X86_32) && !defined(CONFIG_PAX_MEMORY_UDEREF)
 	asm volatile ("mov %0, %%gs" : : "r" (0));
 #endif
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/system.h linux-2.6.32.60-pax/arch/x86/include/asm/system.h
--- linux-2.6.32.60/arch/x86/include/asm/system.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/system.h	2012-03-13 13:15:34.488098024 +0100
@@ -132,7 +132,7 @@ do {									\
 	     "thread_return:\n\t"					  \
 	     "movq "__percpu_arg([current_task])",%%rsi\n\t"		  \
 	     __switch_canary						  \
-	     "movq %P[thread_info](%%rsi),%%r8\n\t"			  \
+	     "movq "__percpu_arg([thread_info])",%%r8\n\t"		  \
 	     "movq %%rax,%%rdi\n\t" 					  \
 	     "testl  %[_tif_fork],%P[ti_flags](%%r8)\n\t"	  \
 	     "jnz   ret_from_fork\n\t"					  \
@@ -143,7 +143,7 @@ do {									\
 	       [threadrsp] "i" (offsetof(struct task_struct, thread.sp)), \
 	       [ti_flags] "i" (offsetof(struct thread_info, flags)),	  \
 	       [_tif_fork] "i" (_TIF_FORK),			  	  \
-	       [thread_info] "i" (offsetof(struct task_struct, stack)),   \
+	       [thread_info] "m" (per_cpu_var(current_tinfo)),		  \
 	       [current_task] "m" (per_cpu_var(current_task))		  \
 	       __switch_canary_iparam					  \
 	     : "memory", "cc" __EXTRA_CLOBBER)
@@ -200,7 +200,7 @@ static inline unsigned long get_limit(un
 {
 	unsigned long __limit;
 	asm("lsll %1,%0" : "=r" (__limit) : "r" (segment));
-	return __limit + 1;
+	return __limit;
 }
 
 static inline void native_clts(void)
@@ -340,12 +340,12 @@ void enable_hlt(void);
 
 void cpu_idle_wait(void);
 
-extern unsigned long arch_align_stack(unsigned long sp);
+#define arch_align_stack(x) ((x) & ~0xfUL)
 extern void free_init_pages(char *what, unsigned long begin, unsigned long end);
 
 void default_idle(void);
 
-void stop_this_cpu(void *dummy);
+void stop_this_cpu(void *dummy) __noreturn;
 
 /*
  * Force strict CPU ordering.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/thread_info.h linux-2.6.32.60-pax/arch/x86/include/asm/thread_info.h
--- linux-2.6.32.60/arch/x86/include/asm/thread_info.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/thread_info.h	2012-03-13 13:15:34.488098024 +0100
@@ -10,6 +10,7 @@
 #include <linux/compiler.h>
 #include <asm/page.h>
 #include <asm/types.h>
+#include <asm/percpu.h>
 
 /*
  * low level task data that entry.S needs immediate access to
@@ -24,7 +25,6 @@ struct exec_domain;
 #include <asm/atomic.h>
 
 struct thread_info {
-	struct task_struct	*task;		/* main task structure */
 	struct exec_domain	*exec_domain;	/* execution domain */
 	__u32			flags;		/* low level flags */
 	__u32			status;		/* thread synchronous flags */
@@ -34,18 +34,12 @@ struct thread_info {
 	mm_segment_t		addr_limit;
 	struct restart_block    restart_block;
 	void __user		*sysenter_return;
-#ifdef CONFIG_X86_32
-	unsigned long           previous_esp;   /* ESP of the previous stack in
-						   case of nested (IRQ) stacks
-						*/
-	__u8			supervisor_stack[0];
-#endif
+	unsigned long		lowest_stack;
 	int			uaccess_err;
 };
 
-#define INIT_THREAD_INFO(tsk)			\
+#define INIT_THREAD_INFO			\
 {						\
-	.task		= &tsk,			\
 	.exec_domain	= &default_exec_domain,	\
 	.flags		= 0,			\
 	.cpu		= 0,			\
@@ -56,7 +50,7 @@ struct thread_info {
 	},					\
 }
 
-#define init_thread_info	(init_thread_union.thread_info)
+#define init_thread_info	(init_thread_union.stack)
 #define init_stack		(init_thread_union.stack)
 
 #else /* !__ASSEMBLY__ */
@@ -163,6 +157,23 @@ struct thread_info {
 #define alloc_thread_info(tsk)						\
 	((struct thread_info *)__get_free_pages(THREAD_FLAGS, THREAD_ORDER))
 
+#ifdef __ASSEMBLY__
+/* how to get the thread information struct from ASM */
+#define GET_THREAD_INFO(reg)	 \
+	mov PER_CPU_VAR(current_tinfo), reg
+
+/* use this one if reg already contains %esp */
+#define GET_THREAD_INFO_WITH_ESP(reg) GET_THREAD_INFO(reg)
+#else
+/* how to get the thread information struct from C */
+DECLARE_PER_CPU(struct thread_info *, current_tinfo);
+
+static __always_inline struct thread_info *current_thread_info(void)
+{
+	return percpu_read_stable(current_tinfo);
+}
+#endif
+
 #ifdef CONFIG_X86_32
 
 #define STACK_WARN	(THREAD_SIZE/8)
@@ -173,35 +184,13 @@ struct thread_info {
  */
 #ifndef __ASSEMBLY__
 
-
 /* how to get the current stack pointer from C */
 register unsigned long current_stack_pointer asm("esp") __used;
 
-/* how to get the thread information struct from C */
-static inline struct thread_info *current_thread_info(void)
-{
-	return (struct thread_info *)
-		(current_stack_pointer & ~(THREAD_SIZE - 1));
-}
-
-#else /* !__ASSEMBLY__ */
-
-/* how to get the thread information struct from ASM */
-#define GET_THREAD_INFO(reg)	 \
-	movl $-THREAD_SIZE, reg; \
-	andl %esp, reg
-
-/* use this one if reg already contains %esp */
-#define GET_THREAD_INFO_WITH_ESP(reg) \
-	andl $-THREAD_SIZE, reg
-
 #endif
 
 #else /* X86_32 */
 
-#include <asm/percpu.h>
-#define KERNEL_STACK_OFFSET (5*8)
-
 /*
  * macros/functions for gaining access to the thread information structure
  * preempt_count needs to be 1 initially, until the scheduler is functional.
@@ -209,21 +198,8 @@ static inline struct thread_info *curren
 #ifndef __ASSEMBLY__
 DECLARE_PER_CPU(unsigned long, kernel_stack);
 
-static inline struct thread_info *current_thread_info(void)
-{
-	struct thread_info *ti;
-	ti = (void *)(percpu_read_stable(kernel_stack) +
-		      KERNEL_STACK_OFFSET - THREAD_SIZE);
-	return ti;
-}
-
-#else /* !__ASSEMBLY__ */
-
-/* how to get the thread information struct from ASM */
-#define GET_THREAD_INFO(reg) \
-	movq PER_CPU_VAR(kernel_stack),reg ; \
-	subq $(THREAD_SIZE-KERNEL_STACK_OFFSET),reg
-
+/* how to get the current stack pointer from C */
+register unsigned long current_stack_pointer asm("rsp") __used;
 #endif
 
 #endif /* !X86_32 */
@@ -260,5 +236,16 @@ extern void arch_task_cache_init(void);
 extern void free_thread_info(struct thread_info *ti);
 extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
 #define arch_task_cache_init arch_task_cache_init
+
+#define __HAVE_THREAD_FUNCTIONS
+#define task_thread_info(task)	(&(task)->tinfo)
+#define task_stack_page(task)	((task)->stack)
+#define setup_thread_stack(p, org) do {} while (0)
+#define end_of_stack(p) ((unsigned long *)task_stack_page(p) + 1)
+
+#define __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
+extern struct task_struct *alloc_task_struct(void);
+extern void free_task_struct(struct task_struct *);
+
 #endif
 #endif /* _ASM_X86_THREAD_INFO_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/uaccess_32.h linux-2.6.32.60-pax/arch/x86/include/asm/uaccess_32.h
--- linux-2.6.32.60/arch/x86/include/asm/uaccess_32.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/uaccess_32.h	2013-02-17 17:07:14.588197009 +0100
@@ -12,15 +12,15 @@
 #include <asm/page.h>
 
 unsigned long __must_check __copy_to_user_ll
-		(void __user *to, const void *from, unsigned long n);
+		(void __user *to, const void *from, unsigned long n) __size_overflow(3);
 unsigned long __must_check __copy_from_user_ll
-		(void *to, const void __user *from, unsigned long n);
+		(void *to, const void __user *from, unsigned long n) __size_overflow(3);
 unsigned long __must_check __copy_from_user_ll_nozero
-		(void *to, const void __user *from, unsigned long n);
+		(void *to, const void __user *from, unsigned long n) __size_overflow(3);
 unsigned long __must_check __copy_from_user_ll_nocache
-		(void *to, const void __user *from, unsigned long n);
+		(void *to, const void __user *from, unsigned long n) __size_overflow(3);
 unsigned long __must_check __copy_from_user_ll_nocache_nozero
-		(void *to, const void __user *from, unsigned long n);
+		(void *to, const void __user *from, unsigned long n) __size_overflow(3);
 
 /**
  * __copy_to_user_inatomic: - Copy a block of data into user space, with less checking.
@@ -44,6 +44,11 @@ unsigned long __must_check __copy_from_u
 static __always_inline unsigned long __must_check
 __copy_to_user_inatomic(void __user *to, const void *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
+	check_object_size(from, n, true);
+
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -83,12 +88,16 @@ static __always_inline unsigned long __m
 __copy_to_user(void __user *to, const void *from, unsigned long n)
 {
 	might_fault();
+
 	return __copy_to_user_inatomic(to, from, n);
 }
 
 static __always_inline unsigned long
 __copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)
 {
+	if ((long)n < 0)
+		return n;
+
 	/* Avoid zeroing the tail if the copy fails..
 	 * If 'n' is constant and 1, 2, or 4, we do still zero on a failure,
 	 * but as the zeroing behaviour is only significant when n is not
@@ -138,6 +147,12 @@ static __always_inline unsigned long
 __copy_from_user(void *to, const void __user *from, unsigned long n)
 {
 	might_fault();
+
+	if ((long)n < 0)
+		return n;
+
+	check_object_size(to, n, false);
+
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -160,6 +175,10 @@ static __always_inline unsigned long __c
 				const void __user *from, unsigned long n)
 {
 	might_fault();
+
+	if ((long)n < 0)
+		return n;
+
 	if (__builtin_constant_p(n)) {
 		unsigned long ret;
 
@@ -182,14 +201,72 @@ static __always_inline unsigned long
 __copy_from_user_inatomic_nocache(void *to, const void __user *from,
 				  unsigned long n)
 {
-       return __copy_from_user_ll_nocache_nozero(to, from, n);
+	if ((long)n < 0)
+		return n;
+
+	return __copy_from_user_ll_nocache_nozero(to, from, n);
+}
+
+extern void copy_to_user_overflow(void) __compiletime_warning("copy_to_user() buffer size is not provably correct");
+extern void copy_from_user_overflow(void) __compiletime_warning("copy_from_user() buffer size is not provably correct");
+
+/**
+ * copy_to_user: - Copy a block of data into user space.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+static __always_inline unsigned long __must_check
+copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	size_t sz = __compiletime_object_size(from);
+
+	if (unlikely(sz != (size_t)-1 && sz < n))
+		copy_to_user_overflow();
+	else if (access_ok(VERIFY_WRITE, to, n))
+		n = __copy_to_user(to, from, n);
+	return n;
+}
+
+/**
+ * copy_from_user: - Copy a block of data from user space.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ */
+static __always_inline unsigned long __must_check
+copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	size_t sz = __compiletime_object_size(to);
+
+	check_object_size(to, n, false);
+
+	if (unlikely(sz != (size_t)-1 && sz < n))
+		copy_from_user_overflow();
+	else if (access_ok(VERIFY_READ, from, n))
+		n = __copy_from_user(to, from, n);
+	else if ((long)n > 0)
+		memset(to, 0, n);
+	return n;
 }
 
-unsigned long __must_check copy_to_user(void __user *to,
-					const void *from, unsigned long n);
-unsigned long __must_check copy_from_user(void *to,
-					  const void __user *from,
-					  unsigned long n);
 long __must_check strncpy_from_user(char *dst, const char __user *src,
 				    long count);
 long __must_check __strncpy_from_user(char *dst,
@@ -212,7 +289,7 @@ long __must_check __strncpy_from_user(ch
 #define strlen_user(str) strnlen_user(str, LONG_MAX)
 
 long strnlen_user(const char __user *str, long n);
-unsigned long __must_check clear_user(void __user *mem, unsigned long len);
-unsigned long __must_check __clear_user(void __user *mem, unsigned long len);
+unsigned long __must_check clear_user(void __user *mem, unsigned long len) __size_overflow(2);
+unsigned long __must_check __clear_user(void __user *mem, unsigned long len) __size_overflow(2);
 
 #endif /* _ASM_X86_UACCESS_32_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/uaccess_64.h linux-2.6.32.60-pax/arch/x86/include/asm/uaccess_64.h
--- linux-2.6.32.60/arch/x86/include/asm/uaccess_64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/uaccess_64.h	2013-02-17 17:09:41.008189191 +0100
@@ -9,6 +9,9 @@
 #include <linux/prefetch.h>
 #include <linux/lockdep.h>
 #include <asm/page.h>
+#include <asm/pgtable.h>
+
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
 
 /*
  * Copy To/From Userspace
@@ -16,116 +19,183 @@
 
 /* Handles exceptions in both to and from, but doesn't do access_ok */
 __must_check unsigned long
-copy_user_generic(void *to, const void *from, unsigned len);
+copy_user_generic(void *to, const void *from, unsigned long len) __size_overflow(3);
 
 __must_check unsigned long
-copy_to_user(void __user *to, const void *from, unsigned len);
-__must_check unsigned long
-copy_from_user(void *to, const void __user *from, unsigned len);
-__must_check unsigned long
-copy_in_user(void __user *to, const void __user *from, unsigned len);
+copy_in_user(void __user *to, const void __user *from, unsigned long len);
+
+extern void copy_to_user_overflow(void) __compiletime_warning("copy_to_user() buffer size is not provably correct");
+extern void copy_from_user_overflow(void) __compiletime_warning("copy_from_user() buffer size is not provably correct");
 
 static __always_inline __must_check
-int __copy_from_user(void *dst, const void __user *src, unsigned size)
+unsigned long __copy_from_user(void *dst, const void __user *src, unsigned long size)
 {
-	int ret = 0;
+	size_t sz = __compiletime_object_size(dst);
+	unsigned ret = 0;
 
 	might_fault();
-	if (!__builtin_constant_p(size))
-		return copy_user_generic(dst, (__force void *)src, size);
+
+	if (size > INT_MAX)
+		return size;
+
+	check_object_size(dst, size, false);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!__access_ok(VERIFY_READ, src, size))
+		return size;
+#endif
+
+	if (unlikely(sz != (size_t)-1 && sz < size)) {
+		copy_from_user_overflow();
+		return size;
+	}
+
+	if (!__builtin_constant_p(size)) {
+		return copy_user_generic(dst, (__force_kernel const void *)____m(src), size);
+	}
 	switch (size) {
-	case 1:__get_user_asm(*(u8 *)dst, (u8 __user *)src,
+	case 1:__get_user_asm(*(u8 *)dst, (const u8 __user *)src,
 			      ret, "b", "b", "=q", 1);
 		return ret;
-	case 2:__get_user_asm(*(u16 *)dst, (u16 __user *)src,
+	case 2:__get_user_asm(*(u16 *)dst, (const u16 __user *)src,
 			      ret, "w", "w", "=r", 2);
 		return ret;
-	case 4:__get_user_asm(*(u32 *)dst, (u32 __user *)src,
+	case 4:__get_user_asm(*(u32 *)dst, (const u32 __user *)src,
 			      ret, "l", "k", "=r", 4);
 		return ret;
-	case 8:__get_user_asm(*(u64 *)dst, (u64 __user *)src,
+	case 8:__get_user_asm(*(u64 *)dst, (const u64 __user *)src,
 			      ret, "q", "", "=r", 8);
 		return ret;
 	case 10:
-		__get_user_asm(*(u64 *)dst, (u64 __user *)src,
+		__get_user_asm(*(u64 *)dst, (const u64 __user *)src,
 			       ret, "q", "", "=r", 10);
 		if (unlikely(ret))
 			return ret;
 		__get_user_asm(*(u16 *)(8 + (char *)dst),
-			       (u16 __user *)(8 + (char __user *)src),
+			       (const u16 __user *)(8 + (const char __user *)src),
 			       ret, "w", "w", "=r", 2);
 		return ret;
 	case 16:
-		__get_user_asm(*(u64 *)dst, (u64 __user *)src,
+		__get_user_asm(*(u64 *)dst, (const u64 __user *)src,
 			       ret, "q", "", "=r", 16);
 		if (unlikely(ret))
 			return ret;
 		__get_user_asm(*(u64 *)(8 + (char *)dst),
-			       (u64 __user *)(8 + (char __user *)src),
+			       (const u64 __user *)(8 + (const char __user *)src),
 			       ret, "q", "", "=r", 8);
 		return ret;
 	default:
-		return copy_user_generic(dst, (__force void *)src, size);
+		return copy_user_generic(dst, (__force_kernel const void *)____m(src), size);
 	}
 }
 
 static __always_inline __must_check
-int __copy_to_user(void __user *dst, const void *src, unsigned size)
+unsigned long __copy_to_user(void __user *dst, const void *src, unsigned long size)
 {
-	int ret = 0;
+	size_t sz = __compiletime_object_size(dst);
+	unsigned ret = 0;
 
 	might_fault();
+
+	if (size > INT_MAX)
+		return size;
+
+	check_object_size(src, size, true);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!__access_ok(VERIFY_WRITE, dst, size))
+		return size;
+#endif
+
+	if (unlikely(sz != (size_t)-1 && sz < size)) {
+		copy_to_user_overflow();
+		return size;
+	}
+
 	if (!__builtin_constant_p(size))
-		return copy_user_generic((__force void *)dst, src, size);
+		return copy_user_generic((__force_kernel void *)____m(dst), src, size);
 	switch (size) {
-	case 1:__put_user_asm(*(u8 *)src, (u8 __user *)dst,
+	case 1:__put_user_asm(*(const u8 *)src, (u8 __user *)dst,
 			      ret, "b", "b", "iq", 1);
 		return ret;
-	case 2:__put_user_asm(*(u16 *)src, (u16 __user *)dst,
+	case 2:__put_user_asm(*(const u16 *)src, (u16 __user *)dst,
 			      ret, "w", "w", "ir", 2);
 		return ret;
-	case 4:__put_user_asm(*(u32 *)src, (u32 __user *)dst,
+	case 4:__put_user_asm(*(const u32 *)src, (u32 __user *)dst,
 			      ret, "l", "k", "ir", 4);
 		return ret;
-	case 8:__put_user_asm(*(u64 *)src, (u64 __user *)dst,
+	case 8:__put_user_asm(*(const u64 *)src, (u64 __user *)dst,
 			      ret, "q", "", "er", 8);
 		return ret;
 	case 10:
-		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
+		__put_user_asm(*(const u64 *)src, (u64 __user *)dst,
 			       ret, "q", "", "er", 10);
 		if (unlikely(ret))
 			return ret;
 		asm("":::"memory");
-		__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,
+		__put_user_asm(4[(const u16 *)src], 4 + (u16 __user *)dst,
 			       ret, "w", "w", "ir", 2);
 		return ret;
 	case 16:
-		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
+		__put_user_asm(*(const u64 *)src, (u64 __user *)dst,
 			       ret, "q", "", "er", 16);
 		if (unlikely(ret))
 			return ret;
 		asm("":::"memory");
-		__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,
+		__put_user_asm(1[(const u64 *)src], 1 + (u64 __user *)dst,
 			       ret, "q", "", "er", 8);
 		return ret;
 	default:
-		return copy_user_generic((__force void *)dst, src, size);
+		return copy_user_generic((__force_kernel void *)____m(dst), src, size);
 	}
 }
 
 static __always_inline __must_check
-int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
+unsigned long copy_to_user(void __user *to, const void *from, unsigned long len)
 {
-	int ret = 0;
+	if (access_ok(VERIFY_WRITE, to, len))
+		len = __copy_to_user(to, from, len);
+	return len;
+}
 
+static __always_inline __must_check
+unsigned long copy_from_user(void *to, const void __user *from, unsigned long len)
+{
 	might_fault();
+
+	check_object_size(to, len, false);
+
+	if (access_ok(VERIFY_READ, from, len))
+		len = __copy_from_user(to, from, len);
+	else if (len < INT_MAX)
+		memset(to, 0, len);
+	return len;
+}
+
+static __always_inline __must_check
+unsigned long __copy_in_user(void __user *dst, const void __user *src, unsigned long size)
+{
+	unsigned ret = 0;
+
+	might_fault();
+
+	if (size > INT_MAX)
+		return size;
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!__access_ok(VERIFY_READ, src, size))
+		return size;
+	if (!__access_ok(VERIFY_WRITE, dst, size))
+		return size;
+#endif
+
 	if (!__builtin_constant_p(size))
-		return copy_user_generic((__force void *)dst,
-					 (__force void *)src, size);
+		return copy_user_generic((__force_kernel void *)____m(dst),
+					 (__force_kernel const void *)____m(src), size);
 	switch (size) {
 	case 1: {
 		u8 tmp;
-		__get_user_asm(tmp, (u8 __user *)src,
+		__get_user_asm(tmp, (const u8 __user *)src,
 			       ret, "b", "b", "=q", 1);
 		if (likely(!ret))
 			__put_user_asm(tmp, (u8 __user *)dst,
@@ -134,7 +204,7 @@ int __copy_in_user(void __user *dst, con
 	}
 	case 2: {
 		u16 tmp;
-		__get_user_asm(tmp, (u16 __user *)src,
+		__get_user_asm(tmp, (const u16 __user *)src,
 			       ret, "w", "w", "=r", 2);
 		if (likely(!ret))
 			__put_user_asm(tmp, (u16 __user *)dst,
@@ -144,7 +214,7 @@ int __copy_in_user(void __user *dst, con
 
 	case 4: {
 		u32 tmp;
-		__get_user_asm(tmp, (u32 __user *)src,
+		__get_user_asm(tmp, (const u32 __user *)src,
 			       ret, "l", "k", "=r", 4);
 		if (likely(!ret))
 			__put_user_asm(tmp, (u32 __user *)dst,
@@ -153,7 +223,7 @@ int __copy_in_user(void __user *dst, con
 	}
 	case 8: {
 		u64 tmp;
-		__get_user_asm(tmp, (u64 __user *)src,
+		__get_user_asm(tmp, (const u64 __user *)src,
 			       ret, "q", "", "=r", 8);
 		if (likely(!ret))
 			__put_user_asm(tmp, (u64 __user *)dst,
@@ -161,8 +231,8 @@ int __copy_in_user(void __user *dst, con
 		return ret;
 	}
 	default:
-		return copy_user_generic((__force void *)dst,
-					 (__force void *)src, size);
+		return copy_user_generic((__force_kernel void *)____m(dst),
+					 (__force_kernel const void *)____m(src), size);
 	}
 }
 
@@ -173,36 +243,60 @@ __strncpy_from_user(char *dst, const cha
 __must_check long strnlen_user(const char __user *str, long n);
 __must_check long __strnlen_user(const char __user *str, long n);
 __must_check long strlen_user(const char __user *str);
-__must_check unsigned long clear_user(void __user *mem, unsigned long len);
-__must_check unsigned long __clear_user(void __user *mem, unsigned long len);
+__must_check unsigned long clear_user(void __user *mem, unsigned long len) __size_overflow(2);
+__must_check unsigned long __clear_user(void __user *mem, unsigned long len) __size_overflow(2);
 
-__must_check long __copy_from_user_inatomic(void *dst, const void __user *src,
-					    unsigned size);
+static __must_check __always_inline unsigned long
+__copy_from_user_inatomic(void *dst, const void __user *src, unsigned long size)
+{
+	if (size > INT_MAX)
+		return size;
+
+	return copy_user_generic(dst, (__force_kernel const void *)____m(src), size);
+}
 
-static __must_check __always_inline int
-__copy_to_user_inatomic(void __user *dst, const void *src, unsigned size)
+static __must_check __always_inline unsigned long
+__copy_to_user_inatomic(void __user *dst, const void *src, unsigned long size)
 {
-	return copy_user_generic((__force void *)dst, src, size);
+	if (size > INT_MAX)
+		return size;
+
+	return copy_user_generic((__force_kernel void *)____m(dst), src, size);
 }
 
-extern long __copy_user_nocache(void *dst, const void __user *src,
-				unsigned size, int zerorest);
+extern unsigned long __copy_user_nocache(void *dst, const void __user *src,
+				unsigned long size, int zerorest) __size_overflow(3);
 
-static inline int
-__copy_from_user_nocache(void *dst, const void __user *src, unsigned size)
+static inline unsigned long __copy_from_user_nocache(void *dst, const void __user *src, unsigned long size)
 {
 	might_sleep();
+
+	if (size > INT_MAX)
+		return size;
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!__access_ok(VERIFY_READ, src, size))
+		return size;
+#endif
+
 	return __copy_user_nocache(dst, src, size, 1);
 }
 
-static inline int
-__copy_from_user_inatomic_nocache(void *dst, const void __user *src,
-				  unsigned size)
+static inline unsigned long __copy_from_user_inatomic_nocache(void *dst, const void __user *src,
+				  unsigned long size)
 {
+	if (size > INT_MAX)
+		return size;
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!__access_ok(VERIFY_READ, src, size))
+		return size;
+#endif
+
 	return __copy_user_nocache(dst, src, size, 0);
 }
 
-unsigned long
-copy_user_handle_tail(char *to, char *from, unsigned len, unsigned zerorest);
+extern unsigned long
+copy_user_handle_tail(char __user *to, char __user *from, unsigned long len, unsigned zerorest) __size_overflow(3);
 
 #endif /* _ASM_X86_UACCESS_64_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/uaccess.h linux-2.6.32.60-pax/arch/x86/include/asm/uaccess.h
--- linux-2.6.32.60/arch/x86/include/asm/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/uaccess.h	2013-02-17 17:10:04.508187936 +0100
@@ -8,6 +8,7 @@
 #include <linux/thread_info.h>
 #include <linux/prefetch.h>
 #include <linux/string.h>
+#include <linux/sched.h>
 #include <asm/asm.h>
 #include <asm/page.h>
 
@@ -29,7 +30,12 @@
 
 #define get_ds()	(KERNEL_DS)
 #define get_fs()	(current_thread_info()->addr_limit)
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_MEMORY_UDEREF)
+void __set_fs(mm_segment_t x);
+void set_fs(mm_segment_t x);
+#else
 #define set_fs(x)	(current_thread_info()->addr_limit = (x))
+#endif
 
 #define segment_eq(a, b)	((a).seg == (b).seg)
 
@@ -77,7 +83,33 @@
  * checks that the pointer is in the user space range - after calling
  * this function, memory access functions may still return -EFAULT.
  */
-#define access_ok(type, addr, size) (likely(__range_not_ok(addr, size) == 0))
+#define __access_ok(type, addr, size) (likely(__range_not_ok(addr, size) == 0))
+#define access_ok(type, addr, size)					\
+({									\
+	long __size = size;						\
+	unsigned long __addr = (unsigned long)addr;			\
+	unsigned long __addr_ao = __addr & PAGE_MASK;			\
+	unsigned long __end_ao = __addr + __size - 1;			\
+	bool __ret_ao = __range_not_ok(__addr, __size) == 0;		\
+	if (__ret_ao && unlikely((__end_ao ^ __addr_ao) & PAGE_MASK)) {	\
+		while(__addr_ao <= __end_ao) {				\
+			char __c_ao;					\
+			__addr_ao += PAGE_SIZE;				\
+			if (__size > PAGE_SIZE)				\
+				cond_resched();				\
+			if (__get_user(__c_ao, (char __user *)__addr))	\
+				break;					\
+			if (type != VERIFY_WRITE) {			\
+				__addr = __addr_ao;			\
+				continue;				\
+			}						\
+			if (__put_user(__c_ao, (char __user *)__addr))	\
+				break;					\
+			__addr = __addr_ao;				\
+		}							\
+	}								\
+	__ret_ao;							\
+})
 
 /*
  * The exception table consists of pairs of addresses: the first is the
@@ -183,12 +215,20 @@ extern int __get_user_bad(void);
 	asm volatile("call __put_user_" #size : "=a" (__ret_pu)	\
 		     : "0" ((typeof(*(ptr)))(x)), "c" (ptr) : "ebx")
 
-
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define __copyuser_seg "gs;"
+#define __COPYUSER_SET_ES "pushl %%gs; popl %%es\n"
+#define __COPYUSER_RESTORE_ES "pushl %%ss; popl %%es\n"
+#else
+#define __copyuser_seg
+#define __COPYUSER_SET_ES
+#define __COPYUSER_RESTORE_ES
+#endif
 
 #ifdef CONFIG_X86_32
 #define __put_user_asm_u64(x, addr, err, errret)			\
-	asm volatile("1:	movl %%eax,0(%2)\n"			\
-		     "2:	movl %%edx,4(%2)\n"			\
+	asm volatile("1:	"__copyuser_seg"movl %%eax,0(%2)\n"	\
+		     "2:	"__copyuser_seg"movl %%edx,4(%2)\n"	\
 		     "3:\n"						\
 		     ".section .fixup,\"ax\"\n"				\
 		     "4:	movl %3,%0\n"				\
@@ -200,8 +240,8 @@ extern int __get_user_bad(void);
 		     : "A" (x), "r" (addr), "i" (errret), "0" (err))
 
 #define __put_user_asm_ex_u64(x, addr)					\
-	asm volatile("1:	movl %%eax,0(%1)\n"			\
-		     "2:	movl %%edx,4(%1)\n"			\
+	asm volatile("1:	"__copyuser_seg"movl %%eax,0(%1)\n"	\
+		     "2:	"__copyuser_seg"movl %%edx,4(%1)\n"	\
 		     "3:\n"						\
 		     _ASM_EXTABLE(1b, 2b - 1b)				\
 		     _ASM_EXTABLE(2b, 3b - 2b)				\
@@ -253,7 +293,7 @@ extern void __put_user_8(void);
 	__typeof__(*(ptr)) __pu_val;				\
 	__chk_user_ptr(ptr);					\
 	might_fault();						\
-	__pu_val = x;						\
+	__pu_val = (x);						\
 	switch (sizeof(*(ptr))) {				\
 	case 1:							\
 		__put_user_x(1, __pu_val, ptr, __ret_pu);	\
@@ -374,7 +414,7 @@ do {									\
 } while (0)
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
-	asm volatile("1:	mov"itype" %2,%"rtype"1\n"		\
+	asm volatile("1:	"__copyuser_seg"mov"itype" %2,%"rtype"1\n"\
 		     "2:\n"						\
 		     ".section .fixup,\"ax\"\n"				\
 		     "3:	mov %3,%0\n"				\
@@ -382,7 +422,7 @@ do {									\
 		     "	jmp 2b\n"					\
 		     ".previous\n"					\
 		     _ASM_EXTABLE(1b, 3b)				\
-		     : "=r" (err), ltype(x)				\
+		     : "=r" (err), ltype (x)				\
 		     : "m" (__m(addr)), "i" (errret), "0" (err))
 
 #define __get_user_size_ex(x, ptr, size)				\
@@ -407,7 +447,7 @@ do {									\
 } while (0)
 
 #define __get_user_asm_ex(x, addr, itype, rtype, ltype)			\
-	asm volatile("1:	mov"itype" %1,%"rtype"0\n"		\
+	asm volatile("1:	"__copyuser_seg"mov"itype" %1,%"rtype"0\n"\
 		     "2:\n"						\
 		     _ASM_EXTABLE(1b, 2b - 1b)				\
 		     : ltype(x) : "m" (__m(addr)))
@@ -424,13 +464,24 @@ do {									\
 	int __gu_err;							\
 	unsigned long __gu_val;						\
 	__get_user_size(__gu_val, (ptr), (size), __gu_err, -EFAULT);	\
-	(x) = (__force __typeof__(*(ptr)))__gu_val;			\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
 	__gu_err;							\
 })
 
 /* FIXME: this hack is definitely wrong -AK */
 struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct __user *)(x))
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define ____m(x)					\
+({							\
+	unsigned long ____x = (unsigned long)(x);	\
+	if (____x < PAX_USER_SHADOW_BASE)		\
+		____x += PAX_USER_SHADOW_BASE;		\
+	(void __user *)____x;				\
+})
+#else
+#define ____m(x) (x)
+#endif
+#define __m(x) (*(struct __large_struct __user *)____m(x))
 
 /*
  * Tell gcc we read from memory instead of writing: this is because
@@ -438,7 +489,7 @@ struct __large_struct { unsigned long bu
  * aliasing issues.
  */
 #define __put_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
-	asm volatile("1:	mov"itype" %"rtype"1,%2\n"		\
+	asm volatile("1:	"__copyuser_seg"mov"itype" %"rtype"1,%2\n"\
 		     "2:\n"						\
 		     ".section .fixup,\"ax\"\n"				\
 		     "3:	mov %3,%0\n"				\
@@ -446,10 +497,10 @@ struct __large_struct { unsigned long bu
 		     ".previous\n"					\
 		     _ASM_EXTABLE(1b, 3b)				\
 		     : "=r"(err)					\
-		     : ltype(x), "m" (__m(addr)), "i" (errret), "0" (err))
+		     : ltype (x), "m" (__m(addr)), "i" (errret), "0" (err))
 
 #define __put_user_asm_ex(x, addr, itype, rtype, ltype)			\
-	asm volatile("1:	mov"itype" %"rtype"0,%1\n"		\
+	asm volatile("1:	"__copyuser_seg"mov"itype" %"rtype"0,%1\n"\
 		     "2:\n"						\
 		     _ASM_EXTABLE(1b, 2b - 1b)				\
 		     : : ltype(x), "m" (__m(addr)))
@@ -488,8 +539,12 @@ struct __large_struct { unsigned long bu
  * On error, the variable @x is set to zero.
  */
 
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define __get_user(x, ptr)	get_user((x), (ptr))
+#else
 #define __get_user(x, ptr)						\
 	__get_user_nocheck((x), (ptr), sizeof(*(ptr)))
+#endif
 
 /**
  * __put_user: - Write a simple value into user space, with less checking.
@@ -511,8 +566,12 @@ struct __large_struct { unsigned long bu
  * Returns zero on success, or -EFAULT on error.
  */
 
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define __put_user(x, ptr)	put_user((x), (ptr))
+#else
 #define __put_user(x, ptr)						\
 	__put_user_nocheck((__typeof__(*(ptr)))(x), (ptr), sizeof(*(ptr)))
+#endif
 
 #define __get_user_unaligned __get_user
 #define __put_user_unaligned __put_user
@@ -530,7 +589,7 @@ struct __large_struct { unsigned long bu
 #define get_user_ex(x, ptr)	do {					\
 	unsigned long __gue_val;					\
 	__get_user_size_ex((__gue_val), (ptr), (sizeof(*(ptr))));	\
-	(x) = (__force __typeof__(*(ptr)))__gue_val;			\
+	(x) = (__typeof__(*(ptr)))__gue_val;				\
 } while (0)
 
 #ifdef CONFIG_X86_WP_WORKS_OK
@@ -567,6 +626,7 @@ extern struct movsl_mask {
 
 #define ARCH_HAS_NOCACHE_UACCESS 1
 
+#define ARCH_HAS_SORT_EXTABLE
 #ifdef CONFIG_X86_32
 # include "uaccess_32.h"
 #else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/vdso.h linux-2.6.32.60-pax/arch/x86/include/asm/vdso.h
--- linux-2.6.32.60/arch/x86/include/asm/vdso.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/vdso.h	2012-03-13 13:15:34.492098024 +0100
@@ -25,7 +25,7 @@ extern const char VDSO32_PRELINK[];
 #define VDSO32_SYMBOL(base, name)					\
 ({									\
 	extern const char VDSO32_##name[];				\
-	(void *)(VDSO32_##name - VDSO32_PRELINK + (unsigned long)(base)); \
+	(void __user *)(VDSO32_##name - VDSO32_PRELINK + (unsigned long)(base)); \
 })
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/vgtod.h linux-2.6.32.60-pax/arch/x86/include/asm/vgtod.h
--- linux-2.6.32.60/arch/x86/include/asm/vgtod.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/vgtod.h	2012-03-13 13:15:34.492098024 +0100
@@ -14,6 +14,7 @@ struct vsyscall_gtod_data {
 	int		sysctl_enabled;
 	struct timezone sys_tz;
 	struct { /* extract of a clocksource struct */
+		char	name[8];
 		cycle_t (*vread)(void);
 		cycle_t	cycle_last;
 		cycle_t	mask;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/vmi.h linux-2.6.32.60-pax/arch/x86/include/asm/vmi.h
--- linux-2.6.32.60/arch/x86/include/asm/vmi.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/vmi.h	2012-03-13 13:15:34.496098024 +0100
@@ -191,6 +191,7 @@ struct vrom_header {
 	u8      reserved[96];   /* Reserved for headers */
 	char    vmi_init[8];    /* VMI_Init jump point */
 	char    get_reloc[8];   /* VMI_GetRelocationInfo jump point */
+	char    rom_data[8048];	/* rest of the option ROM */
 } __attribute__((packed));
 
 struct pnp_header {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/vmi_time.h linux-2.6.32.60-pax/arch/x86/include/asm/vmi_time.h
--- linux-2.6.32.60/arch/x86/include/asm/vmi_time.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/vmi_time.h	2012-03-13 13:15:34.496098024 +0100
@@ -43,7 +43,7 @@ extern struct vmi_timer_ops {
 	int (*wallclock_updated)(void);
 	void (*set_alarm)(u32 flags, u64 expiry, u64 period);
 	void (*cancel_alarm)(u32 flags);
-} vmi_timer_ops;
+} __no_const vmi_timer_ops;
 
 /* Prototypes */
 extern void __init vmi_time_init(void);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/vsyscall.h linux-2.6.32.60-pax/arch/x86/include/asm/vsyscall.h
--- linux-2.6.32.60/arch/x86/include/asm/vsyscall.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/vsyscall.h	2012-03-13 13:15:34.496098024 +0100
@@ -15,9 +15,10 @@ enum vsyscall_num {
 
 #ifdef __KERNEL__
 #include <linux/seqlock.h>
+#include <linux/getcpu.h>
+#include <linux/time.h>
 
 #define __section_vgetcpu_mode __attribute__ ((unused, __section__ (".vgetcpu_mode"), aligned(16)))
-#define __section_jiffies __attribute__ ((unused, __section__ (".jiffies"), aligned(16)))
 
 /* Definitions for CONFIG_GENERIC_TIME definitions */
 #define __section_vsyscall_gtod_data __attribute__ \
@@ -31,7 +32,6 @@ enum vsyscall_num {
 #define VGETCPU_LSL	2
 
 extern int __vgetcpu_mode;
-extern volatile unsigned long __jiffies;
 
 /* kernel space (writeable) */
 extern int vgetcpu_mode;
@@ -39,6 +39,9 @@ extern struct timezone sys_tz;
 
 extern void map_vsyscall(void);
 
+extern int vgettimeofday(struct timeval * tv, struct timezone * tz);
+extern time_t vtime(time_t *t);
+extern long vgetcpu(unsigned *cpu, unsigned *node, struct getcpu_cache *tcache);
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_X86_VSYSCALL_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/x86_init.h linux-2.6.32.60-pax/arch/x86/include/asm/x86_init.h
--- linux-2.6.32.60/arch/x86/include/asm/x86_init.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/x86_init.h	2013-02-17 17:35:09.276107593 +0100
@@ -88,7 +88,7 @@ struct x86_init_timers {
 	void (*setup_percpu_clockev)(void);
 	void (*tsc_pre_init)(void);
 	void (*timer_init)(void);
-};
+} __no_const;
 
 /**
  * struct x86_init_ops - functions for platform specific setup
@@ -101,7 +101,7 @@ struct x86_init_ops {
 	struct x86_init_oem		oem;
 	struct x86_init_paging		paging;
 	struct x86_init_timers		timers;
-};
+} __no_const;
 
 /**
  * struct x86_cpuinit_ops - platform specific cpu hotplug setups
@@ -109,7 +109,7 @@ struct x86_init_ops {
  */
 struct x86_cpuinit_ops {
 	void (*setup_percpu_clockev)(void);
-};
+} __no_const;
 
 /**
  * struct x86_platform_ops - platform specific runtime functions
@@ -121,7 +121,7 @@ struct x86_platform_ops {
 	unsigned long (*calibrate_tsc)(void);
 	unsigned long (*get_wallclock)(void);
 	int (*set_wallclock)(unsigned long nowtime);
-};
+} __no_const;
 
 extern struct x86_init_ops x86_init;
 extern struct x86_cpuinit_ops x86_cpuinit;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/include/asm/xsave.h linux-2.6.32.60-pax/arch/x86/include/asm/xsave.h
--- linux-2.6.32.60/arch/x86/include/asm/xsave.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/include/asm/xsave.h	2012-12-01 02:44:17.884127096 +0100
@@ -56,7 +56,12 @@ static inline int xrstor_checking(struct
 static inline int xsave_user(struct xsave_struct __user *buf)
 {
 	int err;
-	__asm__ __volatile__("1: .byte " REX_PREFIX "0x0f,0xae,0x27\n"
+
+	buf = (struct xsave_struct __user *)____m(buf);
+
+	__asm__ __volatile__("1:"
+			     __copyuser_seg
+			     ".byte " REX_PREFIX "0x0f,0xae,0x27\n"
 			     "2:\n"
 			     ".section .fixup,\"ax\"\n"
 			     "3:  movl $-1,%[err]\n"
@@ -78,11 +83,13 @@ static inline int xsave_user(struct xsav
 static inline int xrestore_user(struct xsave_struct __user *buf, u64 mask)
 {
 	int err;
-	struct xsave_struct *xstate = ((__force struct xsave_struct *)buf);
+	struct xsave_struct *xstate = ((__force_kernel struct xsave_struct *)____m(buf));
 	u32 lmask = mask;
 	u32 hmask = mask >> 32;
 
-	__asm__ __volatile__("1: .byte " REX_PREFIX "0x0f,0xae,0x2f\n"
+	__asm__ __volatile__("1:"
+			     __copyuser_seg
+			     ".byte " REX_PREFIX "0x0f,0xae,0x2f\n"
 			     "2:\n"
 			     ".section .fixup,\"ax\"\n"
 			     "3:  movl $-1,%[err]\n"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/Kconfig linux-2.6.32.60-pax/arch/x86/Kconfig
--- linux-2.6.32.60/arch/x86/Kconfig	2012-10-09 11:00:35.428882463 +0200
+++ linux-2.6.32.60-pax/arch/x86/Kconfig	2013-02-17 17:10:28.316186665 +0100
@@ -223,7 +223,7 @@ config X86_TRAMPOLINE
 
 config X86_32_LAZY_GS
 	def_bool y
-	depends on X86_32 && !CC_STACKPROTECTOR
+	depends on X86_32 && !CC_STACKPROTECTOR && !PAX_MEMORY_UDEREF
 
 config KTIME_SCALAR
 	def_bool X86_32
@@ -1099,7 +1099,7 @@ config PAGE_OFFSET
 	hex
 	default 0xB0000000 if VMSPLIT_3G_OPT
 	default 0x80000000 if VMSPLIT_2G
-	default 0x78000000 if VMSPLIT_2G_OPT
+	default 0x70000000 if VMSPLIT_2G_OPT
 	default 0x40000000 if VMSPLIT_1G
 	default 0xC0000000
 	depends on X86_32
@@ -1469,6 +1469,7 @@ config SECCOMP
 
 config CC_STACKPROTECTOR
 	bool "Enable -fstack-protector buffer overflow detection (EXPERIMENTAL)"
+	depends on X86_64 || !PAX_MEMORY_UDEREF
 	---help---
 	  This option turns on the -fstack-protector GCC feature. This
 	  feature puts, at the beginning of functions, a canary value on
@@ -1526,6 +1527,7 @@ config KEXEC_JUMP
 config PHYSICAL_START
 	hex "Physical address where the kernel is loaded" if (EMBEDDED || CRASH_DUMP)
 	default "0x1000000"
+	range 0x400000 0x40000000
 	---help---
 	  This gives the physical address where the kernel is loaded.
 
@@ -1590,6 +1592,7 @@ config PHYSICAL_ALIGN
 	hex
 	prompt "Alignment value to which kernel should be aligned" if X86_32
 	default "0x1000000"
+	range 0x400000 0x1000000 if PAX_KERNEXEC
 	range 0x2000 0x1000000
 	---help---
 	  This value puts the alignment restrictions on physical address
@@ -1621,9 +1624,10 @@ config HOTPLUG_CPU
 	  Say N if you want to disable CPU hotplug.
 
 config COMPAT_VDSO
-	def_bool y
+	def_bool n
 	prompt "Compat VDSO support"
 	depends on X86_32 || IA32_EMULATION
+	depends on !PAX_PAGEEXEC && !PAX_SEGMEXEC && !PAX_KERNEXEC && !PAX_MEMORY_UDEREF
 	---help---
 	  Map the 32-bit VDSO to the predictable old-style address too.
 	---help---
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/Kconfig.cpu linux-2.6.32.60-pax/arch/x86/Kconfig.cpu
--- linux-2.6.32.60/arch/x86/Kconfig.cpu	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/Kconfig.cpu	2012-03-13 13:15:34.500098024 +0100
@@ -340,7 +340,7 @@ config X86_PPRO_FENCE
 
 config X86_F00F_BUG
 	def_bool y
-	depends on M586MMX || M586TSC || M586 || M486 || M386
+	depends on (M586MMX || M586TSC || M586 || M486 || M386) && !PAX_KERNEXEC
 
 config X86_WP_WORKS_OK
 	def_bool y
@@ -360,7 +360,7 @@ config X86_POPAD_OK
 
 config X86_ALIGNMENT_16
 	def_bool y
-	depends on MWINCHIP3D || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK6 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
+	depends on MWINCHIP3D || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK8 || MK7 || MK6 || MCORE2 || MPENTIUM4 || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
 
 config X86_INTEL_USERCOPY
 	def_bool y
@@ -406,7 +406,7 @@ config X86_CMPXCHG64
 # generates cmov.
 config X86_CMOV
 	def_bool y
-	depends on (MK8 || MK7 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || MCRUSOE || MEFFICEON || X86_64 || MATOM)
+	depends on (MK8 || MK7 || MCORE2 || MPSC || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || MCRUSOE || MEFFICEON || X86_64 || MATOM)
 
 config X86_MINIMUM_CPU_FAMILY
 	int
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/Kconfig.debug linux-2.6.32.60-pax/arch/x86/Kconfig.debug
--- linux-2.6.32.60/arch/x86/Kconfig.debug	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/Kconfig.debug	2012-03-13 13:15:34.500098024 +0100
@@ -99,7 +99,7 @@ config X86_PTDUMP
 config DEBUG_RODATA
 	bool "Write protect kernel read-only data structures"
 	default y
-	depends on DEBUG_KERNEL
+	depends on DEBUG_KERNEL && BROKEN
 	---help---
 	  Mark the kernel read-only data as write-protected in the pagetables,
 	  in order to catch accidental (and incorrect) writes to such const
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/acpi/realmode/Makefile linux-2.6.32.60-pax/arch/x86/kernel/acpi/realmode/Makefile
--- linux-2.6.32.60/arch/x86/kernel/acpi/realmode/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/acpi/realmode/Makefile	2012-09-26 14:56:12.232343871 +0200
@@ -41,6 +41,9 @@ KBUILD_CFLAGS	:= $(LINUXINCLUDE) -g -Os
 		   $(call cc-option, -fno-stack-protector) \
 		   $(call cc-option, -mpreferred-stack-boundary=2)
 KBUILD_CFLAGS	+= $(call cc-option, -m32)
+ifdef CONSTIFY_PLUGIN
+KBUILD_CFLAGS	+= -fplugin-arg-constify_plugin-no-constify
+endif
 KBUILD_AFLAGS	:= $(KBUILD_CFLAGS) -D__ASSEMBLY__
 GCOV_PROFILE := n
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/acpi/realmode/wakeup.S linux-2.6.32.60-pax/arch/x86/kernel/acpi/realmode/wakeup.S
--- linux-2.6.32.60/arch/x86/kernel/acpi/realmode/wakeup.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/acpi/realmode/wakeup.S	2012-03-13 13:15:34.504098024 +0100
@@ -104,7 +104,7 @@ _start:
 	movl	%eax, %ecx
 	orl	%edx, %ecx
 	jz	1f
-	movl	$0xc0000080, %ecx
+	mov	$MSR_EFER, %ecx
 	wrmsr
 1:
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/acpi/sleep.c linux-2.6.32.60-pax/arch/x86/kernel/acpi/sleep.c
--- linux-2.6.32.60/arch/x86/kernel/acpi/sleep.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/acpi/sleep.c	2012-03-13 13:15:34.504098024 +0100
@@ -11,11 +11,12 @@
 #include <linux/cpumask.h>
 #include <asm/segment.h>
 #include <asm/desc.h>
+#include <asm/e820.h>
 
 #include "realmode/wakeup.h"
 #include "sleep.h"
 
-unsigned long acpi_wakeup_address;
+unsigned long acpi_wakeup_address = 0x2000;
 unsigned long acpi_realmode_flags;
 
 /* address in low memory of the wakeup routine. */
@@ -99,8 +100,12 @@ int acpi_save_state_mem(void)
 	header->trampoline_segment = setup_trampoline() >> 4;
 #ifdef CONFIG_SMP
 	stack_start.sp = temp_stack + sizeof(temp_stack);
+
+	pax_open_kernel();
 	early_gdt_descr.address =
 			(unsigned long)get_cpu_gdt_table(smp_processor_id());
+	pax_close_kernel();
+
 	initial_gs = per_cpu_offset(smp_processor_id());
 #endif
 	initial_code = (unsigned long)wakeup_long64;
@@ -134,14 +139,8 @@ void __init acpi_reserve_bootmem(void)
 		return;
 	}
 
-	acpi_realmode = (unsigned long)alloc_bootmem_low(WAKEUP_SIZE);
-
-	if (!acpi_realmode) {
-		printk(KERN_ERR "ACPI: Cannot allocate lowmem, S3 disabled.\n");
-		return;
-	}
-
-	acpi_wakeup_address = virt_to_phys((void *)acpi_realmode);
+	reserve_early(acpi_wakeup_address, acpi_wakeup_address + WAKEUP_SIZE, "ACPI Wakeup Code");
+	acpi_realmode = (unsigned long)__va(acpi_wakeup_address);;
 }
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/acpi/wakeup_32.S linux-2.6.32.60-pax/arch/x86/kernel/acpi/wakeup_32.S
--- linux-2.6.32.60/arch/x86/kernel/acpi/wakeup_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/acpi/wakeup_32.S	2012-03-13 13:15:34.504098024 +0100
@@ -30,13 +30,11 @@ wakeup_pmode_return:
 	# and restore the stack ... but you need gdt for this to work
 	movl	saved_context_esp, %esp
 
-	movl	%cs:saved_magic, %eax
-	cmpl	$0x12345678, %eax
+	cmpl	$0x12345678, saved_magic
 	jne	bogus_magic
 
 	# jump to place where we left off
-	movl	saved_eip, %eax
-	jmp	*%eax
+	jmp	*(saved_eip)
 
 bogus_magic:
 	jmp	bogus_magic
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/alternative.c linux-2.6.32.60-pax/arch/x86/kernel/alternative.c
--- linux-2.6.32.60/arch/x86/kernel/alternative.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/alternative.c	2012-03-13 13:15:34.504098024 +0100
@@ -407,7 +407,7 @@ void __init_or_module apply_paravirt(str
 
 		BUG_ON(p->len > MAX_PATCH_LEN);
 		/* prep the buffer with the original instructions */
-		memcpy(insnbuf, p->instr, p->len);
+		memcpy(insnbuf, ktla_ktva(p->instr), p->len);
 		used = pv_init_ops.patch(p->instrtype, p->clobbers, insnbuf,
 					 (unsigned long)p->instr, p->len);
 
@@ -475,7 +475,7 @@ void __init alternative_instructions(voi
 	if (smp_alt_once)
 		free_init_pages("SMP alternatives",
 				(unsigned long)__smp_locks,
-				(unsigned long)__smp_locks_end);
+				PAGE_ALIGN((unsigned long)__smp_locks_end));
 
 	restart_nmi();
 }
@@ -492,13 +492,17 @@ void __init alternative_instructions(voi
  * instructions. And on the local CPU you need to be protected again NMI or MCE
  * handlers seeing an inconsistent instruction while you patch.
  */
-static void *__init_or_module text_poke_early(void *addr, const void *opcode,
+static void *__kprobes text_poke_early(void *addr, const void *opcode,
 					      size_t len)
 {
 	unsigned long flags;
 	local_irq_save(flags);
-	memcpy(addr, opcode, len);
+
+	pax_open_kernel();
+	memcpy(ktla_ktva(addr), opcode, len);
 	sync_core();
+	pax_close_kernel();
+
 	local_irq_restore(flags);
 	/* Could also do a CLFLUSH here to speed up CPU recovery; but
 	   that causes hangs on some VIA CPUs. */
@@ -520,35 +524,21 @@ static void *__init_or_module text_poke_
  */
 void *__kprobes text_poke(void *addr, const void *opcode, size_t len)
 {
-	unsigned long flags;
-	char *vaddr;
+	unsigned char *vaddr = ktla_ktva(addr);
 	struct page *pages[2];
-	int i;
+	size_t i;
 
 	if (!core_kernel_text((unsigned long)addr)) {
-		pages[0] = vmalloc_to_page(addr);
-		pages[1] = vmalloc_to_page(addr + PAGE_SIZE);
+		pages[0] = vmalloc_to_page(vaddr);
+		pages[1] = vmalloc_to_page(vaddr + PAGE_SIZE);
 	} else {
-		pages[0] = virt_to_page(addr);
+		pages[0] = virt_to_page(vaddr);
 		WARN_ON(!PageReserved(pages[0]));
-		pages[1] = virt_to_page(addr + PAGE_SIZE);
+		pages[1] = virt_to_page(vaddr + PAGE_SIZE);
 	}
 	BUG_ON(!pages[0]);
-	local_irq_save(flags);
-	set_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[0]));
-	if (pages[1])
-		set_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[1]));
-	vaddr = (char *)fix_to_virt(FIX_TEXT_POKE0);
-	memcpy(&vaddr[(unsigned long)addr & ~PAGE_MASK], opcode, len);
-	clear_fixmap(FIX_TEXT_POKE0);
-	if (pages[1])
-		clear_fixmap(FIX_TEXT_POKE1);
-	local_flush_tlb();
-	sync_core();
-	/* Could also do a CLFLUSH here to speed up CPU recovery; but
-	   that causes hangs on some VIA CPUs. */
+	text_poke_early(addr, opcode, len);
 	for (i = 0; i < len; i++)
-		BUG_ON(((char *)addr)[i] != ((char *)opcode)[i]);
-	local_irq_restore(flags);
+		BUG_ON((vaddr)[i] != ((const unsigned char *)opcode)[i]);
 	return addr;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/apic/apic.c linux-2.6.32.60-pax/arch/x86/kernel/apic/apic.c
--- linux-2.6.32.60/arch/x86/kernel/apic/apic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/apic/apic.c	2012-03-13 13:15:34.508098023 +0100
@@ -170,7 +170,7 @@ int first_system_vector = 0xfe;
 /*
  * Debug level, exported for io_apic.c
  */
-unsigned int apic_verbosity;
+int apic_verbosity;
 
 int pic_mode;
 
@@ -1794,7 +1794,7 @@ void smp_error_interrupt(struct pt_regs
 	apic_write(APIC_ESR, 0);
 	v1 = apic_read(APIC_ESR);
 	ack_APIC_irq();
-	atomic_inc(&irq_err_count);
+	atomic_inc_unchecked(&irq_err_count);
 
 	/*
 	 * Here is what the APIC error bits mean:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/apic/io_apic.c linux-2.6.32.60-pax/arch/x86/kernel/apic/io_apic.c
--- linux-2.6.32.60/arch/x86/kernel/apic/io_apic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/apic/io_apic.c	2012-03-13 13:15:34.508098023 +0100
@@ -716,7 +716,7 @@ struct IO_APIC_route_entry **alloc_ioapi
 	ioapic_entries = kzalloc(sizeof(*ioapic_entries) * nr_ioapics,
 				GFP_ATOMIC);
 	if (!ioapic_entries)
-		return 0;
+		return NULL;
 
 	for (apic = 0; apic < nr_ioapics; apic++) {
 		ioapic_entries[apic] =
@@ -733,7 +733,7 @@ nomem:
 		kfree(ioapic_entries[apic]);
 	kfree(ioapic_entries);
 
-	return 0;
+	return NULL;
 }
 
 /*
@@ -1150,7 +1150,7 @@ int IO_APIC_get_PCI_irq_vector(int bus,
 }
 EXPORT_SYMBOL(IO_APIC_get_PCI_irq_vector);
 
-void lock_vector_lock(void)
+void lock_vector_lock(void) __acquires(vector_lock)
 {
 	/* Used to the online set of cpus does not change
 	 * during assign_irq_vector.
@@ -1158,7 +1158,7 @@ void lock_vector_lock(void)
 	spin_lock(&vector_lock);
 }
 
-void unlock_vector_lock(void)
+void unlock_vector_lock(void) __releases(vector_lock)
 {
 	spin_unlock(&vector_lock);
 }
@@ -2542,7 +2542,7 @@ static void ack_apic_edge(unsigned int i
 	ack_APIC_irq();
 }
 
-atomic_t irq_mis_count;
+atomic_unchecked_t irq_mis_count;
 
 static void ack_apic_level(unsigned int irq)
 {
@@ -2626,7 +2626,7 @@ static void ack_apic_level(unsigned int
 
 	/* Tail end of version 0x11 I/O APIC bug workaround */
 	if (!(v & (1 << (i & 0x1f)))) {
-		atomic_inc(&irq_mis_count);
+		atomic_inc_unchecked(&irq_mis_count);
 		spin_lock(&ioapic_lock);
 		__mask_and_edge_IO_APIC_irq(cfg);
 		__unmask_and_level_IO_APIC_irq(cfg);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/apm_32.c linux-2.6.32.60-pax/arch/x86/kernel/apm_32.c
--- linux-2.6.32.60/arch/x86/kernel/apm_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/apm_32.c	2012-03-13 13:15:34.512098023 +0100
@@ -410,7 +410,7 @@ static DEFINE_SPINLOCK(user_list_lock);
  * This is for buggy BIOS's that refer to (real mode) segment 0x40
  * even though they are called in protected mode.
  */
-static struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4092,
+static const struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4093,
 			(unsigned long)__va(0x400UL), PAGE_SIZE - 0x400 - 1);
 
 static const char driver_version[] = "1.16ac";	/* no spaces */
@@ -588,7 +588,10 @@ static long __apm_bios_call(void *_call)
 	BUG_ON(cpu != 0);
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
+
+	pax_open_kernel();
 	gdt[0x40 / 8] = bad_bios_desc;
+	pax_close_kernel();
 
 	apm_irq_save(flags);
 	APM_DO_SAVE_SEGS;
@@ -597,7 +600,11 @@ static long __apm_bios_call(void *_call)
 			  &call->esi);
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
+
+	pax_open_kernel();
 	gdt[0x40 / 8] = save_desc_40;
+	pax_close_kernel();
+
 	put_cpu();
 
 	return call->eax & 0xff;
@@ -664,7 +671,10 @@ static long __apm_bios_call_simple(void
 	BUG_ON(cpu != 0);
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
+
+	pax_open_kernel();
 	gdt[0x40 / 8] = bad_bios_desc;
+	pax_close_kernel();
 
 	apm_irq_save(flags);
 	APM_DO_SAVE_SEGS;
@@ -672,7 +682,11 @@ static long __apm_bios_call_simple(void
 					 &call->eax);
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
+
+	pax_open_kernel();
 	gdt[0x40 / 8] = save_desc_40;
+	pax_close_kernel();
+
 	put_cpu();
 	return error;
 }
@@ -975,7 +989,7 @@ recalc:
 
 static void apm_power_off(void)
 {
-	unsigned char po_bios_call[] = {
+	const unsigned char po_bios_call[] = {
 		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
 		0x8e, 0xd0,		/* movw  ax,ss       */
 		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
@@ -2357,12 +2371,15 @@ static int __init apm_init(void)
 	 * code to that CPU.
 	 */
 	gdt = get_cpu_gdt_table(0);
+
+	pax_open_kernel();
 	set_desc_base(&gdt[APM_CS >> 3],
 		 (unsigned long)__va((unsigned long)apm_info.bios.cseg << 4));
 	set_desc_base(&gdt[APM_CS_16 >> 3],
 		 (unsigned long)__va((unsigned long)apm_info.bios.cseg_16 << 4));
 	set_desc_base(&gdt[APM_DS >> 3],
 		 (unsigned long)__va((unsigned long)apm_info.bios.dseg << 4));
+	pax_close_kernel();
 
 	proc_create("apm", 0, NULL, &apm_file_ops);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/asm-offsets_32.c linux-2.6.32.60-pax/arch/x86/kernel/asm-offsets_32.c
--- linux-2.6.32.60/arch/x86/kernel/asm-offsets_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/asm-offsets_32.c	2012-03-13 13:15:34.512098023 +0100
@@ -51,7 +51,6 @@ void foo(void)
 	OFFSET(CPUINFO_x86_vendor_id, cpuinfo_x86, x86_vendor_id);
 	BLANK();
 
-	OFFSET(TI_task, thread_info, task);
 	OFFSET(TI_exec_domain, thread_info, exec_domain);
 	OFFSET(TI_flags, thread_info, flags);
 	OFFSET(TI_status, thread_info, status);
@@ -60,6 +59,8 @@ void foo(void)
 	OFFSET(TI_restart_block, thread_info, restart_block);
 	OFFSET(TI_sysenter_return, thread_info, sysenter_return);
 	OFFSET(TI_cpu, thread_info, cpu);
+	OFFSET(TI_lowest_stack, thread_info, lowest_stack);
+	DEFINE(TI_task_thread_sp0, offsetof(struct task_struct, thread.sp0) - offsetof(struct task_struct, tinfo));
 	BLANK();
 
 	OFFSET(GDS_size, desc_ptr, size);
@@ -99,6 +100,7 @@ void foo(void)
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
 	DEFINE(PAGE_SHIFT_asm, PAGE_SHIFT);
+	DEFINE(THREAD_SIZE_asm, THREAD_SIZE);
 	DEFINE(PTRS_PER_PTE, PTRS_PER_PTE);
 	DEFINE(PTRS_PER_PMD, PTRS_PER_PMD);
 	DEFINE(PTRS_PER_PGD, PTRS_PER_PGD);
@@ -115,6 +117,11 @@ void foo(void)
 	OFFSET(PV_CPU_iret, pv_cpu_ops, iret);
 	OFFSET(PV_CPU_irq_enable_sysexit, pv_cpu_ops, irq_enable_sysexit);
 	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	OFFSET(PV_CPU_write_cr0, pv_cpu_ops, write_cr0);
+#endif
+
 #endif
 
 #ifdef CONFIG_XEN
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/asm-offsets_64.c linux-2.6.32.60-pax/arch/x86/kernel/asm-offsets_64.c
--- linux-2.6.32.60/arch/x86/kernel/asm-offsets_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/asm-offsets_64.c	2012-03-13 13:15:34.512098023 +0100
@@ -44,6 +44,8 @@ int main(void)
 	ENTRY(addr_limit);
 	ENTRY(preempt_count);
 	ENTRY(status);
+	ENTRY(lowest_stack);
+	DEFINE(TI_task_thread_sp0, offsetof(struct task_struct, thread.sp0) - offsetof(struct task_struct, tinfo));
 #ifdef CONFIG_IA32_EMULATION
 	ENTRY(sysenter_return);
 #endif
@@ -63,6 +65,18 @@ int main(void)
 	OFFSET(PV_CPU_irq_enable_sysexit, pv_cpu_ops, irq_enable_sysexit);
 	OFFSET(PV_CPU_swapgs, pv_cpu_ops, swapgs);
 	OFFSET(PV_MMU_read_cr2, pv_mmu_ops, read_cr2);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);
+	OFFSET(PV_CPU_write_cr0, pv_cpu_ops, write_cr0);
+#endif
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	OFFSET(PV_MMU_read_cr3, pv_mmu_ops, read_cr3);
+	OFFSET(PV_MMU_write_cr3, pv_mmu_ops, write_cr3);
+	OFFSET(PV_MMU_set_pgd_batched, pv_mmu_ops, set_pgd_batched);
+#endif
+
 #endif
 
 
@@ -115,6 +129,7 @@ int main(void)
 	ENTRY(cr8);
 	BLANK();
 #undef ENTRY
+	DEFINE(TSS_size, sizeof(struct tss_struct));
 	DEFINE(TSS_ist, offsetof(struct tss_struct, x86_tss.ist));
 	BLANK();
 	DEFINE(crypto_tfm_ctx_offset, offsetof(struct crypto_tfm, __crt_ctx));
@@ -130,6 +145,7 @@ int main(void)
 
 	BLANK();
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+	DEFINE(THREAD_SIZE_asm, THREAD_SIZE);
 #ifdef CONFIG_XEN
 	BLANK();
 	OFFSET(XEN_vcpu_info_mask, vcpu_info, evtchn_upcall_mask);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/amd.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/amd.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/amd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/amd.c	2012-03-13 13:15:34.512098023 +0100
@@ -602,7 +602,7 @@ static unsigned int __cpuinit amd_size_c
 							unsigned int size)
 {
 	/* AMD errata T13 (order #21922) */
-	if ((c->x86 == 6)) {
+	if (c->x86 == 6) {
 		/* Duron Rev A0 */
 		if (c->x86_model == 3 && c->x86_mask == 0)
 			size = 64;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/common.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/common.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/common.c	2012-10-09 11:00:35.428882463 +0200
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/common.c	2012-10-09 11:00:39.264883030 +0200
@@ -84,60 +84,6 @@ static const struct cpu_dev __cpuinitcon
 
 static const struct cpu_dev *this_cpu __cpuinitdata = &default_cpu;
 
-DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
-#ifdef CONFIG_X86_64
-	/*
-	 * We need valid kernel segments for data and code in long mode too
-	 * IRET will check the segment types  kkeil 2000/10/28
-	 * Also sysret mandates a special GDT layout
-	 *
-	 * TLS descriptors are currently at a different place compared to i386.
-	 * Hopefully nobody expects them at a fixed place (Wine?)
-	 */
-	[GDT_ENTRY_KERNEL32_CS]		= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
-	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
-	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),
-	[GDT_ENTRY_DEFAULT_USER32_CS]	= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),
-	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),
-	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),
-#else
-	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),
-	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
-	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),
-	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),
-	/*
-	 * Segments used for calling PnP BIOS have byte granularity.
-	 * They code segments and data segments have fixed 64k limits,
-	 * the transfer segment sizes are set at run time.
-	 */
-	/* 32-bit code */
-	[GDT_ENTRY_PNPBIOS_CS32]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
-	/* 16-bit code */
-	[GDT_ENTRY_PNPBIOS_CS16]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_DS]		= GDT_ENTRY_INIT(0x0092, 0, 0xffff),
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_TS1]		= GDT_ENTRY_INIT(0x0092, 0, 0),
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_TS2]		= GDT_ENTRY_INIT(0x0092, 0, 0),
-	/*
-	 * The APM segments have byte granularity and their bases
-	 * are set at run time.  All have 64k limits.
-	 */
-	/* 32-bit code */
-	[GDT_ENTRY_APMBIOS_BASE]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
-	/* 16-bit code */
-	[GDT_ENTRY_APMBIOS_BASE+1]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
-	/* data */
-	[GDT_ENTRY_APMBIOS_BASE+2]	= GDT_ENTRY_INIT(0x4092, 0, 0xffff),
-
-	[GDT_ENTRY_ESPFIX_SS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
-	[GDT_ENTRY_PERCPU]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
-	GDT_STACK_CANARY_INIT
-#endif
-} };
-EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
-
 static int __init x86_xsave_setup(char *s)
 {
 	setup_clear_cpu_cap(X86_FEATURE_XSAVE);
@@ -345,7 +291,7 @@ void switch_to_new_gdt(int cpu)
 {
 	struct desc_ptr gdt_descr;
 
-	gdt_descr.address = (long)get_cpu_gdt_table(cpu);
+	gdt_descr.address = (unsigned long)get_cpu_gdt_table(cpu);
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 	/* Reload the per-cpu base */
@@ -799,6 +745,10 @@ static void __cpuinit identify_cpu(struc
 	/* Filter out anything that depends on CPUID levels we don't have */
 	filter_cpuid_features(c, true);
 
+#if defined(CONFIG_X86_32) && (defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF))
+	setup_clear_cpu_cap(X86_FEATURE_SEP);
+#endif
+
 	/* If the model name is still unset, do table lookup. */
 	if (!c->x86_model_id[0]) {
 		const char *p;
@@ -982,6 +932,9 @@ static __init int setup_disablecpuid(cha
 }
 __setup("clearcpuid=", setup_disablecpuid);
 
+DEFINE_PER_CPU(struct thread_info *, current_tinfo) = &init_task.tinfo;
+EXPORT_PER_CPU_SYMBOL(current_tinfo);
+
 #ifdef CONFIG_X86_64
 struct desc_ptr idt_descr = { NR_VECTORS * 16 - 1, (unsigned long) idt_table };
 
@@ -997,7 +950,7 @@ DEFINE_PER_CPU(struct task_struct *, cur
 EXPORT_PER_CPU_SYMBOL(current_task);
 
 DEFINE_PER_CPU(unsigned long, kernel_stack) =
-	(unsigned long)&init_thread_union - KERNEL_STACK_OFFSET + THREAD_SIZE;
+	(unsigned long)&init_thread_union - 16 + THREAD_SIZE;
 EXPORT_PER_CPU_SYMBOL(kernel_stack);
 
 DEFINE_PER_CPU(char *, irq_stack_ptr) =
@@ -1062,7 +1015,7 @@ struct pt_regs * __cpuinit idle_regs(str
 {
 	memset(regs, 0, sizeof(struct pt_regs));
 	regs->fs = __KERNEL_PERCPU;
-	regs->gs = __KERNEL_STACK_CANARY;
+	savesegment(gs, regs->gs);
 
 	return regs;
 }
@@ -1103,7 +1056,7 @@ void __cpuinit cpu_init(void)
 	int i;
 
 	cpu = stack_smp_processor_id();
-	t = &per_cpu(init_tss, cpu);
+	t = init_tss + cpu;
 	orig_ist = &per_cpu(orig_ist, cpu);
 
 #ifdef CONFIG_NUMA
@@ -1129,7 +1082,7 @@ void __cpuinit cpu_init(void)
 	switch_to_new_gdt(cpu);
 	loadsegment(fs, 0);
 
-	load_idt((const struct desc_ptr *)&idt_descr);
+	load_idt(&idt_descr);
 
 	memset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
 	syscall_init();
@@ -1138,7 +1091,6 @@ void __cpuinit cpu_init(void)
 	wrmsrl(MSR_KERNEL_GS_BASE, 0);
 	barrier();
 
-	check_efer();
 	if (cpu != 0)
 		enable_x2apic();
 
@@ -1201,7 +1153,7 @@ void __cpuinit cpu_init(void)
 {
 	int cpu = smp_processor_id();
 	struct task_struct *curr = current;
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
 	struct thread_struct *thread = &curr->thread;
 
 	if (cpumask_test_and_set_cpu(cpu, cpu_initialized_mask)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/intel.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/intel.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/intel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/intel.c	2012-03-13 13:15:34.516098023 +0100
@@ -162,7 +162,7 @@ static void __cpuinit trap_init_f00f_bug
 	 * Update the IDT descriptor and reload the IDT so that
 	 * it uses the read-only mapped virtual address.
 	 */
-	idt_descr.address = fix_to_virt(FIX_F00F_IDT);
+	idt_descr.address = (struct desc_struct *)fix_to_virt(FIX_F00F_IDT);
 	load_idt(&idt_descr);
 }
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/intel_cacheinfo.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/intel_cacheinfo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/intel_cacheinfo.c	2013-01-22 23:51:23.631348704 +0100
@@ -931,6 +931,11 @@ static struct kobj_type ktype_cache = {
 	.default_attrs	= default_attrs,
 };
 
+static struct kobj_type ktype_l3_cache = {
+	.sysfs_ops	= &sysfs_ops,
+	.default_attrs	= default_l3_attrs,
+};
+
 static struct kobj_type ktype_percpu_entry = {
 	.sysfs_ops	= &sysfs_ops,
 };
@@ -997,6 +1002,8 @@ static int __cpuinit cache_add_dev(struc
 	}
 
 	for (i = 0; i < num_cache_leaves; i++) {
+		struct kobj_type *ktype;
+
 		this_object = INDEX_KOBJECT_PTR(cpu, i);
 		this_object->cpu = cpu;
 		this_object->index = i;
@@ -1004,12 +1011,12 @@ static int __cpuinit cache_add_dev(struc
 		this_leaf = CPUID4_INFO_IDX(cpu, i);
 
 		if (this_leaf->can_disable)
-			ktype_cache.default_attrs = default_l3_attrs;
+			ktype = &ktype_l3_cache;
 		else
-			ktype_cache.default_attrs = default_attrs;
+			ktype = &ktype_cache;
 
 		retval = kobject_init_and_add(&(this_object->kobj),
-					      &ktype_cache,
+					      ktype,
 					      per_cpu(cache_kobject, cpu),
 					      "index%1lu", i);
 		if (unlikely(retval)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/Makefile linux-2.6.32.60-pax/arch/x86/kernel/cpu/Makefile
--- linux-2.6.32.60/arch/x86/kernel/cpu/Makefile	2012-10-09 11:00:35.428882463 +0200
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/Makefile	2012-10-09 11:00:39.228883020 +0200
@@ -7,10 +7,6 @@ ifdef CONFIG_FUNCTION_TRACER
 CFLAGS_REMOVE_common.o = -pg
 endif
 
-# Make sure load_percpu_segment has no stackprotector
-nostackp := $(call cc-option, -fno-stack-protector)
-CFLAGS_common.o		:= $(nostackp)
-
 obj-y			:= intel_cacheinfo.o addon_cpuid_features.o
 obj-y			+= proc.o capflags.o powerflags.o common.o
 obj-y			+= vmware.o hypervisor.o sched.o
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/mce.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/mce.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/mce.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/mce.c	2013-01-22 17:38:23.384543635 +0100
@@ -43,6 +43,7 @@
 #include <asm/ipi.h>
 #include <asm/mce.h>
 #include <asm/msr.h>
+#include <asm/local.h>
 
 #include "mce-internal.h"
 
@@ -187,7 +188,7 @@ static void print_mce(struct mce *m)
 			!(m->mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "",
 				m->cs, m->ip);
 
-		if (m->cs == __KERNEL_CS)
+		if (m->cs == __KERNEL_CS || m->cs == __KERNEXEC_KERNEL_CS)
 			print_symbol("{%s}", m->ip);
 		pr_cont("\n");
 	}
@@ -221,10 +222,10 @@ static void print_mce_tail(void)
 
 #define PANIC_TIMEOUT 5 /* 5 seconds */
 
-static atomic_t mce_paniced;
+static atomic_unchecked_t mce_paniced;
 
 static int fake_panic;
-static atomic_t mce_fake_paniced;
+static atomic_unchecked_t mce_fake_paniced;
 
 /* Panic in progress. Enable interrupts and wait for final IPI */
 static void wait_for_panic(void)
@@ -248,7 +249,7 @@ static void mce_panic(char *msg, struct
 		/*
 		 * Make sure only one CPU runs in machine check panic
 		 */
-		if (atomic_inc_return(&mce_paniced) > 1)
+		if (atomic_inc_return_unchecked(&mce_paniced) > 1)
 			wait_for_panic();
 		barrier();
 
@@ -256,7 +257,7 @@ static void mce_panic(char *msg, struct
 		console_verbose();
 	} else {
 		/* Don't log too much for fake panic */
-		if (atomic_inc_return(&mce_fake_paniced) > 1)
+		if (atomic_inc_return_unchecked(&mce_fake_paniced) > 1)
 			return;
 	}
 	print_mce_head();
@@ -616,7 +617,7 @@ static int mce_timed_out(u64 *t)
 	 * might have been modified by someone else.
 	 */
 	rmb();
-	if (atomic_read(&mce_paniced))
+	if (atomic_read_unchecked(&mce_paniced))
 		wait_for_panic();
 	if (!monarch_timeout)
 		goto out;
@@ -1394,7 +1395,7 @@ static void unexpected_machine_check(str
 }
 
 /* Call the installed machine check handler for this CPU setup. */
-void (*machine_check_vector)(struct pt_regs *, long error_code) =
+void (*machine_check_vector)(struct pt_regs *, long error_code) __read_only =
 						unexpected_machine_check;
 
 /*
@@ -1416,7 +1417,9 @@ void __cpuinit mcheck_init(struct cpuinf
 		return;
 	}
 
+	pax_open_kernel();
 	machine_check_vector = do_machine_check;
+	pax_close_kernel();
 
 	mce_init();
 	mce_cpu_features(c);
@@ -1429,14 +1432,14 @@ void __cpuinit mcheck_init(struct cpuinf
  */
 
 static DEFINE_SPINLOCK(mce_state_lock);
-static int		open_count;		/* #times opened */
+static local_t		open_count;		/* #times opened */
 static int		open_exclu;		/* already open exclusive? */
 
 static int mce_open(struct inode *inode, struct file *file)
 {
 	spin_lock(&mce_state_lock);
 
-	if (open_exclu || (open_count && (file->f_flags & O_EXCL))) {
+	if (open_exclu || (local_read(&open_count) && (file->f_flags & O_EXCL))) {
 		spin_unlock(&mce_state_lock);
 
 		return -EBUSY;
@@ -1444,7 +1447,7 @@ static int mce_open(struct inode *inode,
 
 	if (file->f_flags & O_EXCL)
 		open_exclu = 1;
-	open_count++;
+	local_inc(&open_count);
 
 	spin_unlock(&mce_state_lock);
 
@@ -1455,7 +1458,7 @@ static int mce_release(struct inode *ino
 {
 	spin_lock(&mce_state_lock);
 
-	open_count--;
+	local_dec(&open_count);
 	open_exclu = 0;
 
 	spin_unlock(&mce_state_lock);
@@ -2007,7 +2010,7 @@ mce_cpu_callback(struct notifier_block *
 	return NOTIFY_OK;
 }
 
-static struct notifier_block mce_cpu_notifier __cpuinitdata = {
+static struct notifier_block mce_cpu_notifier __cpuinitconst = {
 	.notifier_call = mce_cpu_callback,
 };
 
@@ -2082,7 +2085,7 @@ struct dentry *mce_get_debugfs_dir(void)
 static void mce_reset(void)
 {
 	cpu_missing = 0;
-	atomic_set(&mce_fake_paniced, 0);
+	atomic_set_unchecked(&mce_fake_paniced, 0);
 	atomic_set(&mce_executing, 0);
 	atomic_set(&mce_callin, 0);
 	atomic_set(&global_nwo, 0);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/mce-inject.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/mce-inject.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/mce-inject.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/mce-inject.c	2012-05-20 19:21:25.285167263 +0200
@@ -211,7 +211,9 @@ static ssize_t mce_write(struct file *fi
 static int inject_init(void)
 {
 	printk(KERN_INFO "Machine check injector initialized\n");
-	mce_chrdev_ops.write = mce_write;
+	pax_open_kernel();
+	*(void **)&mce_chrdev_ops.write = mce_write;
+	pax_close_kernel();
 	register_die_notifier(&mce_raise_nb);
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/p5.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/p5.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/p5.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/p5.c	2012-03-13 13:15:34.520098023 +0100
@@ -12,6 +12,7 @@
 #include <asm/system.h>
 #include <asm/mce.h>
 #include <asm/msr.h>
+#include <asm/pgtable.h>
 
 /* By default disabled */
 int mce_p5_enabled __read_mostly;
@@ -50,7 +51,9 @@ void intel_p5_mcheck_init(struct cpuinfo
 	if (!cpu_has(c, X86_FEATURE_MCE))
 		return;
 
+	pax_open_kernel();
 	machine_check_vector = pentium_machine_check;
+	pax_close_kernel();
 	/* Make sure the vector pointer is visible before we enable MCEs: */
 	wmb();
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/winchip.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/winchip.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/mcheck/winchip.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/mcheck/winchip.c	2012-03-13 13:15:34.520098023 +0100
@@ -11,6 +11,7 @@
 #include <asm/system.h>
 #include <asm/mce.h>
 #include <asm/msr.h>
+#include <asm/pgtable.h>
 
 /* Machine check handler for WinChip C6: */
 static void winchip_machine_check(struct pt_regs *regs, long error_code)
@@ -24,7 +25,9 @@ void winchip_mcheck_init(struct cpuinfo_
 {
 	u32 lo, hi;
 
+	pax_open_kernel();
 	machine_check_vector = winchip_machine_check;
+	pax_close_kernel();
 	/* Make sure the vector pointer is visible before we enable MCEs: */
 	wmb();
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/mtrr/mtrr.h linux-2.6.32.60-pax/arch/x86/kernel/cpu/mtrr/mtrr.h
--- linux-2.6.32.60/arch/x86/kernel/cpu/mtrr/mtrr.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/mtrr/mtrr.h	2012-03-13 13:15:34.520098023 +0100
@@ -25,7 +25,7 @@ struct mtrr_ops {
 	int	(*validate_add_page)(unsigned long base, unsigned long size,
 				     unsigned int type);
 	int	(*have_wrcomb)(void);
-};
+} __do_const;
 
 extern int generic_get_free_region(unsigned long base, unsigned long size,
 				   int replace_reg);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/cpu/perf_event.c linux-2.6.32.60-pax/arch/x86/kernel/cpu/perf_event.c
--- linux-2.6.32.60/arch/x86/kernel/cpu/perf_event.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/cpu/perf_event.c	2013-01-22 23:51:57.767346881 +0100
@@ -723,10 +723,10 @@ x86_perf_event_update(struct perf_event
 	 * count to the generic event atomically:
 	 */
 again:
-	prev_raw_count = atomic64_read(&hwc->prev_count);
+	prev_raw_count = atomic64_read_unchecked(&hwc->prev_count);
 	rdmsrl(hwc->event_base + idx, new_raw_count);
 
-	if (atomic64_cmpxchg(&hwc->prev_count, prev_raw_count,
+	if (atomic64_cmpxchg_unchecked(&hwc->prev_count, prev_raw_count,
 					new_raw_count) != prev_raw_count)
 		goto again;
 
@@ -741,7 +741,7 @@ again:
 	delta = (new_raw_count << shift) - (prev_raw_count << shift);
 	delta >>= shift;
 
-	atomic64_add(delta, &event->count);
+	atomic64_add_unchecked(delta, &event->count);
 	atomic64_sub(delta, &hwc->period_left);
 
 	return new_raw_count;
@@ -1353,7 +1353,7 @@ x86_perf_event_set_period(struct perf_ev
 	 * The hw event starts counting from this event offset,
 	 * mark it to be able to extra future deltas:
 	 */
-	atomic64_set(&hwc->prev_count, (u64)-left);
+	atomic64_set_unchecked(&hwc->prev_count, (u64)-left);
 
 	err = checking_wrmsrl(hwc->event_base + idx,
 			     (u64)(-left) & x86_pmu.event_mask);
@@ -1940,7 +1940,7 @@ perf_event_nmi_handler(struct notifier_b
 	return NOTIFY_STOP;
 }
 
-static __read_mostly struct notifier_block perf_event_nmi_notifier = {
+static struct notifier_block perf_event_nmi_notifier = {
 	.notifier_call		= perf_event_nmi_handler,
 	.next			= NULL,
 	.priority		= 1
@@ -2357,7 +2357,7 @@ perf_callchain_user(struct pt_regs *regs
 			break;
 
 		callchain_store(entry, frame.return_address);
-		fp = frame.next_frame;
+		fp = (__force const void __user *)frame.next_frame;
 	}
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/crash.c linux-2.6.32.60-pax/arch/x86/kernel/crash.c
--- linux-2.6.32.60/arch/x86/kernel/crash.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/crash.c	2012-03-13 13:15:34.524098022 +0100
@@ -41,7 +41,7 @@ static void kdump_nmi_callback(int cpu,
 	regs = args->regs;
 
 #ifdef CONFIG_X86_32
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		crash_fixup_ss_esp(&fixed_regs, regs);
 		regs = &fixed_regs;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/doublefault_32.c linux-2.6.32.60-pax/arch/x86/kernel/doublefault_32.c
--- linux-2.6.32.60/arch/x86/kernel/doublefault_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/doublefault_32.c	2012-03-13 13:15:34.524098022 +0100
@@ -11,7 +11,7 @@
 
 #define DOUBLEFAULT_STACKSIZE (1024)
 static unsigned long doublefault_stack[DOUBLEFAULT_STACKSIZE];
-#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE)
+#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE-2)
 
 #define ptr_ok(x) ((x) > PAGE_OFFSET && (x) < PAGE_OFFSET + MAXMEM)
 
@@ -21,7 +21,7 @@ static void doublefault_fn(void)
 	unsigned long gdt, tss;
 
 	store_gdt(&gdt_desc);
-	gdt = gdt_desc.address;
+	gdt = (unsigned long)gdt_desc.address;
 
 	printk(KERN_EMERG "PANIC: double fault, gdt at %08lx [%d bytes]\n", gdt, gdt_desc.size);
 
@@ -58,10 +58,10 @@ struct tss_struct doublefault_tss __cach
 		/* 0x2 bit is always set */
 		.flags		= X86_EFLAGS_SF | 0x2,
 		.sp		= STACK_START,
-		.es		= __USER_DS,
+		.es		= __KERNEL_DS,
 		.cs		= __KERNEL_CS,
 		.ss		= __KERNEL_DS,
-		.ds		= __USER_DS,
+		.ds		= __KERNEL_DS,
 		.fs		= __KERNEL_PERCPU,
 
 		.__cr3		= __pa_nodebug(swapper_pg_dir),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/dumpstack_32.c linux-2.6.32.60-pax/arch/x86/kernel/dumpstack_32.c
--- linux-2.6.32.60/arch/x86/kernel/dumpstack_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/dumpstack_32.c	2012-12-01 02:41:42.516122740 +0100
@@ -53,16 +53,12 @@ void dump_trace(struct task_struct *task
 #endif
 
 	for (;;) {
-		struct thread_info *context;
+		void *stack_start = (void *)((unsigned long)stack & ~(THREAD_SIZE-1));
+		bp = print_context_stack(task, stack_start, stack, bp, ops, data, NULL, &graph);
 
-		context = (struct thread_info *)
-			((unsigned long)stack & (~(THREAD_SIZE - 1)));
-		bp = print_context_stack(context, stack, bp, ops,
-					 data, NULL, &graph);
-
-		stack = (unsigned long *)context->previous_esp;
-		if (!stack)
+		if (stack_start == task_stack_page(task))
 			break;
+		stack = *(unsigned long **)stack_start;
 		if (ops->stack(data, "IRQ") < 0)
 			break;
 		touch_nmi_watchdog();
@@ -112,11 +108,12 @@ void show_registers(struct pt_regs *regs
 	 * When in-kernel, we also print out the stack and code at the
 	 * time of the fault..
 	 */
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		unsigned int code_prologue = code_bytes * 43 / 64;
 		unsigned int code_len = code_bytes;
 		unsigned char c;
 		u8 *ip;
+		unsigned long cs_base = get_desc_base(&get_cpu_gdt_table(0)[(0xffff & regs->cs) >> 3]);
 
 		printk(KERN_EMERG "Stack:\n");
 		show_stack_log_lvl(NULL, regs, &regs->sp,
@@ -124,10 +121,10 @@ void show_registers(struct pt_regs *regs
 
 		printk(KERN_EMERG "Code: ");
 
-		ip = (u8 *)regs->ip - code_prologue;
+		ip = (u8 *)regs->ip - code_prologue + cs_base;
 		if (ip < (u8 *)PAGE_OFFSET || probe_kernel_address(ip, c)) {
 			/* try starting at IP */
-			ip = (u8 *)regs->ip;
+			ip = (u8 *)regs->ip + cs_base;
 			code_len = code_len - code_prologue + 1;
 		}
 		for (i = 0; i < code_len; i++, ip++) {
@@ -136,7 +133,7 @@ void show_registers(struct pt_regs *regs
 				printk(" Bad EIP value.");
 				break;
 			}
-			if (ip == (u8 *)regs->ip)
+			if (ip == (u8 *)regs->ip + cs_base)
 				printk("<%02x> ", c);
 			else
 				printk("%02x ", c);
@@ -145,10 +142,23 @@ void show_registers(struct pt_regs *regs
 	printk("\n");
 }
 
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+void pax_check_alloca(unsigned long size)
+{
+	unsigned long sp = (unsigned long)&sp, stack_left;
+
+	/* all kernel stacks are of the same size */
+	stack_left = sp & (THREAD_SIZE - 1);
+	BUG_ON(stack_left < 256 || size >= stack_left - 256);
+}
+EXPORT_SYMBOL(pax_check_alloca);
+#endif
+
 int is_valid_bugaddr(unsigned long ip)
 {
 	unsigned short ud2;
 
+	ip = ktla_ktva(ip);
 	if (ip < PAGE_OFFSET)
 		return 0;
 	if (probe_kernel_address((unsigned short *)ip, ud2))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/dumpstack_64.c linux-2.6.32.60-pax/arch/x86/kernel/dumpstack_64.c
--- linux-2.6.32.60/arch/x86/kernel/dumpstack_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/dumpstack_64.c	2012-12-01 02:39:40.684118457 +0100
@@ -116,8 +116,8 @@ void dump_trace(struct task_struct *task
 	unsigned long *irq_stack_end =
 		(unsigned long *)per_cpu(irq_stack_ptr, cpu);
 	unsigned used = 0;
-	struct thread_info *tinfo;
 	int graph = 0;
+	void *stack_start;
 
 	if (!task)
 		task = current;
@@ -146,10 +146,10 @@ void dump_trace(struct task_struct *task
 	 * current stack address. If the stacks consist of nested
 	 * exceptions
 	 */
-	tinfo = task_thread_info(task);
 	for (;;) {
 		char *id;
 		unsigned long *estack_end;
+
 		estack_end = in_exception_stack(cpu, (unsigned long)stack,
 						&used, &id);
 
@@ -157,7 +157,7 @@ void dump_trace(struct task_struct *task
 			if (ops->stack(data, id) < 0)
 				break;
 
-			bp = print_context_stack(tinfo, stack, bp, ops,
+			bp = print_context_stack(task, estack_end - EXCEPTION_STKSZ, stack, bp, ops,
 						 data, estack_end, &graph);
 			ops->stack(data, "<EOE>");
 			/*
@@ -165,6 +165,8 @@ void dump_trace(struct task_struct *task
 			 * second-to-last pointer (index -2 to end) in the
 			 * exception stack:
 			 */
+			if ((u16)estack_end[-1] != __KERNEL_DS)
+				goto out;
 			stack = (unsigned long *) estack_end[-2];
 			continue;
 		}
@@ -176,7 +178,7 @@ void dump_trace(struct task_struct *task
 			if (stack >= irq_stack && stack < irq_stack_end) {
 				if (ops->stack(data, "IRQ") < 0)
 					break;
-				bp = print_context_stack(tinfo, stack, bp,
+				bp = print_context_stack(task, irq_stack, stack, bp,
 					ops, data, irq_stack_end, &graph);
 				/*
 				 * We link to the next stack (which would be
@@ -195,7 +197,9 @@ void dump_trace(struct task_struct *task
 	/*
 	 * This handles the process stack:
 	 */
-	bp = print_context_stack(tinfo, stack, bp, ops, data, NULL, &graph);
+	stack_start = (void *)((unsigned long)stack & ~(THREAD_SIZE-1));
+	bp = print_context_stack(task, stack_start, stack, bp, ops, data, NULL, &graph);
+out:
 	put_cpu();
 }
 EXPORT_SYMBOL(dump_trace);
@@ -248,7 +252,7 @@ void show_registers(struct pt_regs *regs
 {
 	int i;
 	unsigned long sp;
-	const int cpu = smp_processor_id();
+	const int cpu = raw_smp_processor_id();
 	struct task_struct *cur = current;
 
 	sp = regs->sp;
@@ -304,3 +308,50 @@ int is_valid_bugaddr(unsigned long ip)
 	return ud2 == 0x0b0f;
 }
 
+
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+void pax_check_alloca(unsigned long size)
+{
+	unsigned long sp = (unsigned long)&sp, stack_start, stack_end;
+	unsigned cpu, used;
+	char *id;
+
+	/* check the process stack first */
+	stack_start = (unsigned long)task_stack_page(current);
+	stack_end = stack_start + THREAD_SIZE;
+	if (likely(stack_start <= sp && sp < stack_end)) {
+		unsigned long stack_left = sp & (THREAD_SIZE - 1);
+		BUG_ON(stack_left < 256 || size >= stack_left - 256);
+		return;
+	}
+
+	cpu = get_cpu();
+
+	/* check the irq stacks */
+	stack_end = (unsigned long)per_cpu(irq_stack_ptr, cpu);
+	stack_start = stack_end - IRQ_STACK_SIZE;
+	if (stack_start <= sp && sp < stack_end) {
+		unsigned long stack_left = sp & (IRQ_STACK_SIZE - 1);
+		put_cpu();
+		BUG_ON(stack_left < 256 || size >= stack_left - 256);
+		return;
+	}
+
+	/* check the exception stacks */
+	used = 0;
+	stack_end = (unsigned long)in_exception_stack(cpu, sp, &used, &id);
+	stack_start = stack_end - EXCEPTION_STKSZ;
+	if (stack_end && stack_start <= sp && sp < stack_end) {
+		unsigned long stack_left = sp & (EXCEPTION_STKSZ - 1);
+		put_cpu();
+		BUG_ON(stack_left < 256 || size >= stack_left - 256);
+		return;
+	}
+
+	put_cpu();
+
+	/* unknown stack */
+	BUG();
+}
+EXPORT_SYMBOL(pax_check_alloca);
+#endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/dumpstack.c linux-2.6.32.60-pax/arch/x86/kernel/dumpstack.c
--- linux-2.6.32.60/arch/x86/kernel/dumpstack.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/dumpstack.c	2012-03-13 13:15:34.528098022 +0100
@@ -36,9 +36,8 @@ void printk_address(unsigned long addres
 static void
 print_ftrace_graph_addr(unsigned long addr, void *data,
 			const struct stacktrace_ops *ops,
-			struct thread_info *tinfo, int *graph)
+			struct task_struct *task, int *graph)
 {
-	struct task_struct *task = tinfo->task;
 	unsigned long ret_addr;
 	int index = task->curr_ret_stack;
 
@@ -59,7 +58,7 @@ print_ftrace_graph_addr(unsigned long ad
 static inline void
 print_ftrace_graph_addr(unsigned long addr, void *data,
 			const struct stacktrace_ops *ops,
-			struct thread_info *tinfo, int *graph)
+			struct task_struct *task, int *graph)
 { }
 #endif
 
@@ -70,10 +69,8 @@ print_ftrace_graph_addr(unsigned long ad
  * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
  */
 
-static inline int valid_stack_ptr(struct thread_info *tinfo,
-			void *p, unsigned int size, void *end)
+static inline int valid_stack_ptr(void *t, void *p, unsigned int size, void *end)
 {
-	void *t = tinfo;
 	if (end) {
 		if (p < end && p >= (end-THREAD_SIZE))
 			return 1;
@@ -84,14 +81,14 @@ static inline int valid_stack_ptr(struct
 }
 
 unsigned long
-print_context_stack(struct thread_info *tinfo,
+print_context_stack(struct task_struct *task, void *stack_start,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data,
 		unsigned long *end, int *graph)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 
-	while (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {
+	while (valid_stack_ptr(stack_start, stack, sizeof(*stack), end)) {
 		unsigned long addr;
 
 		addr = *stack;
@@ -103,7 +100,7 @@ print_context_stack(struct thread_info *
 			} else {
 				ops->address(data, addr, 0);
 			}
-			print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
+			print_ftrace_graph_addr(addr, data, ops, task, graph);
 		}
 		stack++;
 	}
@@ -180,7 +177,7 @@ void dump_stack(void)
 #endif
 
 	printk("Pid: %d, comm: %.20s %s %s %.*s\n",
-		current->pid, current->comm, print_tainted(),
+		task_pid_nr(current), current->comm, print_tainted(),
 		init_utsname()->release,
 		(int)strcspn(init_utsname()->version, " "),
 		init_utsname()->version);
@@ -241,7 +238,7 @@ void __kprobes oops_end(unsigned long fl
 		panic("Fatal exception in interrupt");
 	if (panic_on_oops)
 		panic("Fatal exception");
-	do_exit(signr);
+	do_group_exit(signr);
 }
 
 int __kprobes __die(const char *str, struct pt_regs *regs, long err)
@@ -295,7 +292,7 @@ void die(const char *str, struct pt_regs
 	unsigned long flags = oops_begin();
 	int sig = SIGSEGV;
 
-	if (!user_mode_vm(regs))
+	if (!user_mode(regs))
 		report_bug(regs->ip, regs);
 
 	if (__die(str, regs, err))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/dumpstack.h linux-2.6.32.60-pax/arch/x86/kernel/dumpstack.h
--- linux-2.6.32.60/arch/x86/kernel/dumpstack.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/dumpstack.h	2012-03-13 13:15:34.528098022 +0100
@@ -15,7 +15,7 @@
 #endif
 
 extern unsigned long
-print_context_stack(struct thread_info *tinfo,
+print_context_stack(struct task_struct *task, void *stack_start,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data,
 		unsigned long *end, int *graph);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/e820.c linux-2.6.32.60-pax/arch/x86/kernel/e820.c
--- linux-2.6.32.60/arch/x86/kernel/e820.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/e820.c	2012-03-13 13:15:34.528098022 +0100
@@ -733,7 +733,7 @@ struct early_res {
 };
 static struct early_res early_res[MAX_EARLY_RES] __initdata = {
 	{ 0, PAGE_SIZE, "BIOS data page" },	/* BIOS data page */
-	{}
+	{ 0, 0, {0}, 0 }
 };
 
 static int __init find_overlapped_early(u64 start, u64 end)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/early_printk.c linux-2.6.32.60-pax/arch/x86/kernel/early_printk.c
--- linux-2.6.32.60/arch/x86/kernel/early_printk.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/early_printk.c	2012-03-13 13:15:34.528098022 +0100
@@ -7,6 +7,7 @@
 #include <linux/pci_regs.h>
 #include <linux/pci_ids.h>
 #include <linux/errno.h>
+#include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/processor.h>
 #include <asm/fcntl.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/efi_32.c linux-2.6.32.60-pax/arch/x86/kernel/efi_32.c
--- linux-2.6.32.60/arch/x86/kernel/efi_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/efi_32.c	2012-03-13 13:15:34.532098022 +0100
@@ -38,70 +38,56 @@
  */
 
 static unsigned long efi_rt_eflags;
-static pgd_t efi_bak_pg_dir_pointer[2];
+static pgd_t __initdata efi_bak_pg_dir_pointer[KERNEL_PGD_PTRS];
 
-void efi_call_phys_prelog(void)
+void __init efi_call_phys_prelog(void)
 {
-	unsigned long cr4;
-	unsigned long temp;
 	struct desc_ptr gdt_descr;
 
-	local_irq_save(efi_rt_eflags);
+#ifdef CONFIG_PAX_KERNEXEC
+	struct desc_struct d;
+#endif
 
-	/*
-	 * If I don't have PAE, I should just duplicate two entries in page
-	 * directory. If I have PAE, I just need to duplicate one entry in
-	 * page directory.
-	 */
-	cr4 = read_cr4_safe();
+	local_irq_save(efi_rt_eflags);
 
-	if (cr4 & X86_CR4_PAE) {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		swapper_pg_dir[0].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-	} else {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		efi_bak_pg_dir_pointer[1].pgd =
-		    swapper_pg_dir[pgd_index(0x400000)].pgd;
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-		temp = PAGE_OFFSET + 0x400000;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    swapper_pg_dir[pgd_index(temp)].pgd;
-	}
+	clone_pgd_range(efi_bak_pg_dir_pointer, swapper_pg_dir, KERNEL_PGD_PTRS);
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			min_t(unsigned long, KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 
 	/*
 	 * After the lock is released, the original page table is restored.
 	 */
 	__flush_tlb_all();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pack_descriptor(&d, 0, 0xFFFFF, 0x9B, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(0), GDT_ENTRY_KERNEXEC_EFI_CS, &d, DESCTYPE_S);
+	pack_descriptor(&d, 0, 0xFFFFF, 0x93, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(0), GDT_ENTRY_KERNEXEC_EFI_DS, &d, DESCTYPE_S);
+#endif
+
 	gdt_descr.address = __pa(get_cpu_gdt_table(0));
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 }
 
-void efi_call_phys_epilog(void)
+void __init efi_call_phys_epilog(void)
 {
-	unsigned long cr4;
 	struct desc_ptr gdt_descr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	struct desc_struct d;
+
+	memset(&d, 0, sizeof d);
+	write_gdt_entry(get_cpu_gdt_table(0), GDT_ENTRY_KERNEXEC_EFI_CS, &d, DESCTYPE_S);
+	write_gdt_entry(get_cpu_gdt_table(0), GDT_ENTRY_KERNEXEC_EFI_DS, &d, DESCTYPE_S);
+#endif
+
 	gdt_descr.address = (unsigned long)get_cpu_gdt_table(0);
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 
-	cr4 = read_cr4_safe();
-
-	if (cr4 & X86_CR4_PAE) {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-	} else {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    efi_bak_pg_dir_pointer[1].pgd;
-	}
+	clone_pgd_range(swapper_pg_dir, efi_bak_pg_dir_pointer, KERNEL_PGD_PTRS);
 
 	/*
 	 * After the lock is released, the original page table is restored.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/efi_stub_32.S linux-2.6.32.60-pax/arch/x86/kernel/efi_stub_32.S
--- linux-2.6.32.60/arch/x86/kernel/efi_stub_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/efi_stub_32.S	2012-08-06 13:25:13.803004527 +0200
@@ -6,7 +6,9 @@
  */
 
 #include <linux/linkage.h>
+#include <linux/init.h>
 #include <asm/page_types.h>
+#include <asm/segment.h>
 
 /*
  * efi_call_phys(void *, ...) is a function with variable parameters.
@@ -20,7 +22,7 @@
  * service functions will comply with gcc calling convention, too.
  */
 
-.text
+__INIT
 ENTRY(efi_call_phys)
 	/*
 	 * 0. The function can only be called in Linux kernel. So CS has been
@@ -36,10 +38,24 @@ ENTRY(efi_call_phys)
 	 * The mapping of lower virtual memory has been created in prelog and
 	 * epilog.
 	 */
-	movl	$1f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	jmp	*%edx
+#ifdef CONFIG_PAX_KERNEXEC
+	movl	$(__KERNEXEC_EFI_DS), %edx
+	mov	%edx, %ds
+	mov	%edx, %es
+	mov	%edx, %ss
+	addl	$2f,(1f)
+	ljmp	*(1f)
+
+__INITDATA
+1:	.long __LOAD_PHYSICAL_ADDR, __KERNEXEC_EFI_CS
+.previous
+
+2:
+	subl	$2b,(1b)
+#else
+	jmp	1f-__PAGE_OFFSET
 1:
+#endif
 
 	/*
 	 * 2. Now on the top of stack is the return
@@ -47,14 +63,8 @@ ENTRY(efi_call_phys)
 	 * parameter 2, ..., param n. To make things easy, we save the return
 	 * address of efi_call_phys in a global variable.
 	 */
-	popl	%edx
-	movl	%edx, saved_return_addr
-	/* get the function pointer into ECX*/
-	popl	%ecx
-	movl	%ecx, efi_rt_function_ptr
-	movl	$2f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	pushl	%edx
+	popl	(saved_return_addr)
+	popl	(efi_rt_function_ptr)
 
 	/*
 	 * 3. Clear PG bit in %CR0.
@@ -73,9 +83,8 @@ ENTRY(efi_call_phys)
 	/*
 	 * 5. Call the physical function.
 	 */
-	jmp	*%ecx
+	call	*(efi_rt_function_ptr-__PAGE_OFFSET)
 
-2:
 	/*
 	 * 6. After EFI runtime service returns, control will return to
 	 * following instruction. We'd better readjust stack pointer first.
@@ -88,35 +97,36 @@ ENTRY(efi_call_phys)
 	movl	%cr0, %edx
 	orl	$0x80000000, %edx
 	movl	%edx, %cr0
-	jmp	1f
-1:
+
 	/*
 	 * 8. Now restore the virtual mode from flat mode by
 	 * adding EIP with PAGE_OFFSET.
 	 */
-	movl	$1f, %edx
-	jmp	*%edx
+#ifdef CONFIG_PAX_KERNEXEC
+	movl	$(__KERNEL_DS), %edx
+	mov	%edx, %ds
+	mov	%edx, %es
+	mov	%edx, %ss
+	ljmp	$(__KERNEL_CS),$1f
+#else
+	jmp	1f+__PAGE_OFFSET
+#endif
 1:
 
 	/*
 	 * 9. Balance the stack. And because EAX contain the return value,
 	 * we'd better not clobber it.
 	 */
-	leal	efi_rt_function_ptr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
+	pushl	(efi_rt_function_ptr)
 
 	/*
-	 * 10. Push the saved return address onto the stack and return.
+	 * 10. Return to the saved return address.
 	 */
-	leal	saved_return_addr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
-	ret
+	jmpl	*(saved_return_addr)
 ENDPROC(efi_call_phys)
 .previous
 
-.data
+__INITDATA
 saved_return_addr:
 	.long 0
 efi_rt_function_ptr:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/efi_stub_64.S linux-2.6.32.60-pax/arch/x86/kernel/efi_stub_64.S
--- linux-2.6.32.60/arch/x86/kernel/efi_stub_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/efi_stub_64.S	2012-03-13 13:15:34.532098022 +0100
@@ -7,6 +7,7 @@
  */
 
 #include <linux/linkage.h>
+#include <asm/alternative-asm.h>
 
 #define SAVE_XMM			\
 	mov %rsp, %rax;			\
@@ -40,6 +41,7 @@ ENTRY(efi_call0)
 	call *%rdi
 	addq $32, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call0)
 
@@ -50,6 +52,7 @@ ENTRY(efi_call1)
 	call *%rdi
 	addq $32, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call1)
 
@@ -60,6 +63,7 @@ ENTRY(efi_call2)
 	call *%rdi
 	addq $32, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call2)
 
@@ -71,6 +75,7 @@ ENTRY(efi_call3)
 	call *%rdi
 	addq $32, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call3)
 
@@ -83,6 +88,7 @@ ENTRY(efi_call4)
 	call *%rdi
 	addq $32, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call4)
 
@@ -96,6 +102,7 @@ ENTRY(efi_call5)
 	call *%rdi
 	addq $48, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call5)
 
@@ -112,5 +119,6 @@ ENTRY(efi_call6)
 	call *%rdi
 	addq $48, %rsp
 	RESTORE_XMM
+	pax_force_retaddr 0, 1
 	ret
 ENDPROC(efi_call6)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/entry_32.S linux-2.6.32.60-pax/arch/x86/kernel/entry_32.S
--- linux-2.6.32.60/arch/x86/kernel/entry_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/entry_32.S	2012-08-25 11:13:51.849925753 +0200
@@ -185,13 +185,153 @@
 	/*CFI_REL_OFFSET gs, PT_GS*/
 .endm
 .macro SET_KERNEL_GS reg
+
+#ifdef CONFIG_CC_STACKPROTECTOR
 	movl $(__KERNEL_STACK_CANARY), \reg
+#elif defined(CONFIG_PAX_MEMORY_UDEREF)
+	movl $(__USER_DS), \reg
+#else
+	xorl \reg, \reg
+#endif
+
 	movl \reg, %gs
 .endm
 
 #endif	/* CONFIG_X86_32_LAZY_GS */
 
-.macro SAVE_ALL
+.macro pax_enter_kernel
+#ifdef CONFIG_PAX_KERNEXEC
+	call pax_enter_kernel
+#endif
+.endm
+
+.macro pax_exit_kernel
+#ifdef CONFIG_PAX_KERNEXEC
+	call pax_exit_kernel
+#endif
+.endm
+
+#ifdef CONFIG_PAX_KERNEXEC
+ENTRY(pax_enter_kernel)
+#ifdef CONFIG_PARAVIRT
+	pushl %eax
+	pushl %ecx
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_read_cr0)
+	mov %eax, %esi
+#else
+	mov %cr0, %esi
+#endif
+	bts $16, %esi
+	jnc 1f
+	mov %cs, %esi
+	cmp $__KERNEL_CS, %esi
+	jz 3f
+	ljmp $__KERNEL_CS, $3f
+1:	ljmp $__KERNEXEC_KERNEL_CS, $2f
+2:
+#ifdef CONFIG_PARAVIRT
+	mov %esi, %eax
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_write_cr0)
+#else
+	mov %esi, %cr0
+#endif
+3:
+#ifdef CONFIG_PARAVIRT
+	popl %ecx
+	popl %eax
+#endif
+	ret
+ENDPROC(pax_enter_kernel)
+
+ENTRY(pax_exit_kernel)
+#ifdef CONFIG_PARAVIRT
+	pushl %eax
+	pushl %ecx
+#endif
+	mov %cs, %esi
+	cmp $__KERNEXEC_KERNEL_CS, %esi
+	jnz 2f
+#ifdef CONFIG_PARAVIRT
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_read_cr0);
+	mov %eax, %esi
+#else
+	mov %cr0, %esi
+#endif
+	btr $16, %esi
+	ljmp $__KERNEL_CS, $1f
+1:
+#ifdef CONFIG_PARAVIRT
+	mov %esi, %eax
+	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_write_cr0);
+#else
+	mov %esi, %cr0
+#endif
+2:
+#ifdef CONFIG_PARAVIRT
+	popl %ecx
+	popl %eax
+#endif
+	ret
+ENDPROC(pax_exit_kernel)
+#endif
+
+.macro pax_erase_kstack
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+	call pax_erase_kstack
+#endif
+.endm
+
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+/*
+ * ebp: thread_info
+ */
+ENTRY(pax_erase_kstack)
+	pushl %edi
+	pushl %ecx
+	pushl %eax
+
+	mov TI_lowest_stack(%ebp), %edi
+	mov $0xB4DD00D5, %eax
+	std
+
+1:	mov %edi, %ecx
+	and $THREAD_SIZE_asm - 1, %ecx
+	shr $2, %ecx
+	repne scasl
+	jecxz 2f
+
+	cmp $2*16, %ecx
+	jc 2f
+
+	mov $2*16, %ecx
+	repe scasl
+	jecxz 2f
+	jne 1b
+
+2:	cld
+	mov %esp, %ecx
+	sub %edi, %ecx
+
+	cmp $THREAD_SIZE_asm, %ecx
+	jb 3f
+	ud2
+3:
+
+	shr $2, %ecx
+	rep stosl
+
+	mov TI_task_thread_sp0(%ebp), %edi
+	sub $128, %edi
+	mov %edi, TI_lowest_stack(%ebp)
+
+	popl %eax
+	popl %ecx
+	popl %edi
+	ret
+ENDPROC(pax_erase_kstack)
+#endif
+
+.macro __SAVE_ALL _DS
 	cld
 	PUSH_GS
 	pushl %fs
@@ -224,7 +364,7 @@
 	pushl %ebx
 	CFI_ADJUST_CFA_OFFSET 4
 	CFI_REL_OFFSET ebx, 0
-	movl $(__USER_DS), %edx
+	movl $\_DS, %edx
 	movl %edx, %ds
 	movl %edx, %es
 	movl $(__KERNEL_PERCPU), %edx
@@ -232,6 +372,15 @@
 	SET_KERNEL_GS %edx
 .endm
 
+.macro SAVE_ALL
+#if defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF)
+	__SAVE_ALL __KERNEL_DS
+	pax_enter_kernel
+#else
+	__SAVE_ALL __USER_DS
+#endif
+.endm
+
 .macro RESTORE_INT_REGS
 	popl %ebx
 	CFI_ADJUST_CFA_OFFSET -4
@@ -331,7 +480,7 @@ ENTRY(ret_from_fork)
 	CFI_ADJUST_CFA_OFFSET -4
 	jmp syscall_exit
 	CFI_ENDPROC
-END(ret_from_fork)
+ENDPROC(ret_from_fork)
 
 /*
  * Return to user mode is not as complex as all this looks,
@@ -352,7 +501,15 @@ check_userspace:
 	movb PT_CS(%esp), %al
 	andl $(X86_EFLAGS_VM | SEGMENT_RPL_MASK), %eax
 	cmpl $USER_RPL, %eax
+
+#ifdef CONFIG_PAX_KERNEXEC
+	jae resume_userspace
+
+	pax_exit_kernel
+	jmp resume_kernel
+#else
 	jb resume_kernel		# not returning to v8086 or userspace
+#endif
 
 ENTRY(resume_userspace)
 	LOCKDEP_SYS_EXIT
@@ -364,8 +521,8 @@ ENTRY(resume_userspace)
 	andl $_TIF_WORK_MASK, %ecx	# is there any work to be done on
 					# int/exception return?
 	jne work_pending
-	jmp restore_all
-END(ret_from_exception)
+	jmp restore_all_pax
+ENDPROC(ret_from_exception)
 
 #ifdef CONFIG_PREEMPT
 ENTRY(resume_kernel)
@@ -380,7 +537,7 @@ need_resched:
 	jz restore_all
 	call preempt_schedule_irq
 	jmp need_resched
-END(resume_kernel)
+ENDPROC(resume_kernel)
 #endif
 	CFI_ENDPROC
 
@@ -414,25 +571,36 @@ sysenter_past_esp:
 	/*CFI_REL_OFFSET cs, 0*/
 	/*
 	 * Push current_thread_info()->sysenter_return to the stack.
-	 * A tiny bit of offset fixup is necessary - 4*4 means the 4 words
-	 * pushed above; +8 corresponds to copy_thread's esp0 setting.
 	 */
-	pushl (TI_sysenter_return-THREAD_SIZE+8+4*4)(%esp)
+	pushl $0
 	CFI_ADJUST_CFA_OFFSET 4
 	CFI_REL_OFFSET eip, 0
 
 	pushl %eax
 	CFI_ADJUST_CFA_OFFSET 4
 	SAVE_ALL
+	GET_THREAD_INFO(%ebp)
+	movl TI_sysenter_return(%ebp),%ebp
+	movl %ebp,PT_EIP(%esp)
 	ENABLE_INTERRUPTS(CLBR_NONE)
 
 /*
  * Load the potential sixth argument from user stack.
  * Careful about security.
  */
+	movl PT_OLDESP(%esp),%ebp
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov PT_OLDSS(%esp),%ds
+1:	movl %ds:(%ebp),%ebp
+	push %ss
+	pop %ds
+#else
 	cmpl $__PAGE_OFFSET-3,%ebp
 	jae syscall_fault
 1:	movl (%ebp),%ebp
+#endif
+
 	movl %ebp,PT_EBP(%esp)
 .section __ex_table,"a"
 	.align 4
@@ -441,6 +609,10 @@ sysenter_past_esp:
 
 	GET_THREAD_INFO(%ebp)
 
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)
 	jnz sysenter_audit
 sysenter_do_call:
@@ -455,12 +627,24 @@ sysenter_do_call:
 	testl $_TIF_ALLWORK_MASK, %ecx
 	jne sysexit_audit
 sysenter_exit:
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushl_cfi %eax
+	movl %esp, %eax
+	call pax_randomize_kstack
+	popl_cfi %eax
+#endif
+
+	pax_erase_kstack
+
 /* if something modifies registers it must also disable sysexit */
 	movl PT_EIP(%esp), %edx
 	movl PT_OLDESP(%esp), %ecx
 	xorl %ebp,%ebp
 	TRACE_IRQS_ON
 1:	mov  PT_FS(%esp), %fs
+2:	mov  PT_DS(%esp), %ds
+3:	mov  PT_ES(%esp), %es
 	PTGS_TO_GS
 	ENABLE_INTERRUPTS_SYSEXIT
 
@@ -477,6 +661,9 @@ sysenter_audit:
 	movl %eax,%edx			/* 2nd arg: syscall number */
 	movl $AUDIT_ARCH_I386,%eax	/* 1st arg: audit arch */
 	call audit_syscall_entry
+
+	pax_erase_kstack
+
 	pushl %ebx
 	CFI_ADJUST_CFA_OFFSET 4
 	movl PT_EAX(%esp),%eax		/* reload syscall number */
@@ -504,11 +691,17 @@ sysexit_audit:
 
 	CFI_ENDPROC
 .pushsection .fixup,"ax"
-2:	movl $0,PT_FS(%esp)
+4:	movl $0,PT_FS(%esp)
+	jmp 1b
+5:	movl $0,PT_DS(%esp)
+	jmp 1b
+6:	movl $0,PT_ES(%esp)
 	jmp 1b
 .section __ex_table,"a"
 	.align 4
-	.long 1b,2b
+	.long 1b,4b
+	.long 2b,5b
+	.long 3b,6b
 .popsection
 	PTGS_TO_GS_EX
 ENDPROC(ia32_sysenter_target)
@@ -520,6 +713,11 @@ ENTRY(system_call)
 	CFI_ADJUST_CFA_OFFSET 4
 	SAVE_ALL
 	GET_THREAD_INFO(%ebp)
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
 					# system call tracing in operation / emulation
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)
 	jnz syscall_trace_entry
@@ -538,6 +736,15 @@ syscall_exit:
 	testl $_TIF_ALLWORK_MASK, %ecx	# current->work
 	jne syscall_exit_work
 
+restore_all_pax:
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	movl %esp, %eax
+	call pax_randomize_kstack
+#endif
+
+	pax_erase_kstack
+
 restore_all:
 	TRACE_IRQS_IRET
 restore_all_notrace:
@@ -602,10 +809,29 @@ ldt_ss:
 	mov PT_OLDESP(%esp), %eax	/* load userspace esp */
 	mov %dx, %ax			/* eax: new kernel esp */
 	sub %eax, %edx			/* offset (low word is 0) */
-	PER_CPU(gdt_page, %ebx)
+#ifdef CONFIG_SMP
+	movl PER_CPU_VAR(cpu_number), %ebx
+	shll $PAGE_SHIFT_asm, %ebx
+	addl $cpu_gdt_table, %ebx
+#else
+	movl $cpu_gdt_table, %ebx
+#endif
 	shr $16, %edx
+
+#ifdef CONFIG_PAX_KERNEXEC
+	mov %cr0, %esi
+	btr $16, %esi
+	mov %esi, %cr0
+#endif
+
 	mov %dl, GDT_ENTRY_ESPFIX_SS * 8 + 4(%ebx) /* bits 16..23 */
 	mov %dh, GDT_ENTRY_ESPFIX_SS * 8 + 7(%ebx) /* bits 24..31 */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	bts $16, %esi
+	mov %esi, %cr0
+#endif
+
 	pushl $__ESPFIX_SS
 	CFI_ADJUST_CFA_OFFSET 4
 	push %eax			/* new kernel esp */
@@ -636,36 +862,30 @@ work_resched:
 	movl TI_flags(%ebp), %ecx
 	andl $_TIF_WORK_MASK, %ecx	# is there any work to be done other
 					# than syscall tracing?
-	jz restore_all
+	jz restore_all_pax
 	testb $_TIF_NEED_RESCHED, %cl
 	jnz work_resched
 
 work_notifysig:				# deal with pending signals and
 					# notify-resume requests
+	movl %esp, %eax
 #ifdef CONFIG_VM86
 	testl $X86_EFLAGS_VM, PT_EFLAGS(%esp)
-	movl %esp, %eax
-	jne work_notifysig_v86		# returning to kernel-space or
+	jz 1f				# returning to kernel-space or
 					# vm86-space
-	xorl %edx, %edx
-	call do_notify_resume
-	jmp resume_userspace_sig
 
-	ALIGN
-work_notifysig_v86:
 	pushl %ecx			# save ti_flags for do_notify_resume
 	CFI_ADJUST_CFA_OFFSET 4
 	call save_v86_state		# %eax contains pt_regs pointer
 	popl %ecx
 	CFI_ADJUST_CFA_OFFSET -4
 	movl %eax, %esp
-#else
-	movl %esp, %eax
+1:
 #endif
 	xorl %edx, %edx
 	call do_notify_resume
 	jmp resume_userspace_sig
-END(work_pending)
+ENDPROC(work_pending)
 
 	# perform syscall exit tracing
 	ALIGN
@@ -673,11 +893,14 @@ syscall_trace_entry:
 	movl $-ENOSYS,PT_EAX(%esp)
 	movl %esp, %eax
 	call syscall_trace_enter
+
+	pax_erase_kstack
+
 	/* What it returned is what we'll actually use.  */
 	cmpl $(nr_syscalls), %eax
 	jnae syscall_call
 	jmp syscall_exit
-END(syscall_trace_entry)
+ENDPROC(syscall_trace_entry)
 
 	# perform syscall exit tracing
 	ALIGN
@@ -690,20 +913,24 @@ syscall_exit_work:
 	movl %esp, %eax
 	call syscall_trace_leave
 	jmp resume_userspace
-END(syscall_exit_work)
+ENDPROC(syscall_exit_work)
 	CFI_ENDPROC
 
 	RING0_INT_FRAME			# can't unwind into user space anyway
 syscall_fault:
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	push %ss
+	pop %ds
+#endif
 	GET_THREAD_INFO(%ebp)
 	movl $-EFAULT,PT_EAX(%esp)
 	jmp resume_userspace
-END(syscall_fault)
+ENDPROC(syscall_fault)
 
 syscall_badsys:
 	movl $-ENOSYS,PT_EAX(%esp)
 	jmp resume_userspace
-END(syscall_badsys)
+ENDPROC(syscall_badsys)
 	CFI_ENDPROC
 
 /*
@@ -726,6 +953,33 @@ PTREGSCALL(rt_sigreturn)
 PTREGSCALL(vm86)
 PTREGSCALL(vm86old)
 
+	ALIGN;
+ENTRY(kernel_execve)
+	push %ebp
+	sub $PT_OLDSS+4,%esp
+	push %edi
+	push %ecx
+	push %eax
+	lea 3*4(%esp),%edi
+	mov $PT_OLDSS/4+1,%ecx
+	xorl %eax,%eax
+	rep stosl
+	pop %eax
+	pop %ecx
+	pop %edi
+	movl $X86_EFLAGS_IF,PT_EFLAGS(%esp)
+	mov %eax,PT_EBX(%esp)
+	mov %edx,PT_ECX(%esp)
+	mov %ecx,PT_EDX(%esp)
+	mov %esp,%eax
+	call sys_execve
+	GET_THREAD_INFO(%ebp)
+	test %eax,%eax
+	jz syscall_exit
+	add $PT_OLDSS+4,%esp
+	pop %ebp
+	ret
+
 .macro FIXUP_ESPFIX_STACK
 /*
  * Switch back for ESPFIX stack to the normal zerobased stack
@@ -735,7 +989,13 @@ PTREGSCALL(vm86old)
  * normal stack and adjusts ESP with the matching offset.
  */
 	/* fixup the stack */
-	PER_CPU(gdt_page, %ebx)
+#ifdef CONFIG_SMP
+	movl PER_CPU_VAR(cpu_number), %ebx
+	shll $PAGE_SHIFT_asm, %ebx
+	addl $cpu_gdt_table, %ebx
+#else
+	movl $cpu_gdt_table, %ebx
+#endif
 	mov GDT_ENTRY_ESPFIX_SS * 8 + 4(%ebx), %al /* bits 16..23 */
 	mov GDT_ENTRY_ESPFIX_SS * 8 + 7(%ebx), %ah /* bits 24..31 */
 	shl $16, %eax
@@ -793,7 +1053,7 @@ vector=vector+1
   .endr
 2:	jmp common_interrupt
 .endr
-END(irq_entries_start)
+ENDPROC(irq_entries_start)
 
 .previous
 END(interrupt)
@@ -840,7 +1100,7 @@ ENTRY(coprocessor_error)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(coprocessor_error)
+ENDPROC(coprocessor_error)
 
 ENTRY(simd_coprocessor_error)
 	RING0_INT_FRAME
@@ -850,7 +1110,7 @@ ENTRY(simd_coprocessor_error)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(simd_coprocessor_error)
+ENDPROC(simd_coprocessor_error)
 
 ENTRY(device_not_available)
 	RING0_INT_FRAME
@@ -860,7 +1120,7 @@ ENTRY(device_not_available)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(device_not_available)
+ENDPROC(device_not_available)
 
 #ifdef CONFIG_PARAVIRT
 ENTRY(native_iret)
@@ -869,12 +1129,12 @@ ENTRY(native_iret)
 	.align 4
 	.long native_iret, iret_exc
 .previous
-END(native_iret)
+ENDPROC(native_iret)
 
 ENTRY(native_irq_enable_sysexit)
 	sti
 	sysexit
-END(native_irq_enable_sysexit)
+ENDPROC(native_irq_enable_sysexit)
 #endif
 
 ENTRY(overflow)
@@ -885,7 +1145,7 @@ ENTRY(overflow)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(overflow)
+ENDPROC(overflow)
 
 ENTRY(bounds)
 	RING0_INT_FRAME
@@ -895,7 +1155,7 @@ ENTRY(bounds)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(bounds)
+ENDPROC(bounds)
 
 ENTRY(invalid_op)
 	RING0_INT_FRAME
@@ -905,7 +1165,7 @@ ENTRY(invalid_op)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(invalid_op)
+ENDPROC(invalid_op)
 
 ENTRY(coprocessor_segment_overrun)
 	RING0_INT_FRAME
@@ -915,7 +1175,7 @@ ENTRY(coprocessor_segment_overrun)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(coprocessor_segment_overrun)
+ENDPROC(coprocessor_segment_overrun)
 
 ENTRY(invalid_TSS)
 	RING0_EC_FRAME
@@ -923,7 +1183,7 @@ ENTRY(invalid_TSS)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(invalid_TSS)
+ENDPROC(invalid_TSS)
 
 ENTRY(segment_not_present)
 	RING0_EC_FRAME
@@ -931,7 +1191,7 @@ ENTRY(segment_not_present)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(segment_not_present)
+ENDPROC(segment_not_present)
 
 ENTRY(stack_segment)
 	RING0_EC_FRAME
@@ -939,7 +1199,7 @@ ENTRY(stack_segment)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(stack_segment)
+ENDPROC(stack_segment)
 
 ENTRY(alignment_check)
 	RING0_EC_FRAME
@@ -947,7 +1207,7 @@ ENTRY(alignment_check)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(alignment_check)
+ENDPROC(alignment_check)
 
 ENTRY(divide_error)
 	RING0_INT_FRAME
@@ -957,7 +1217,7 @@ ENTRY(divide_error)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(divide_error)
+ENDPROC(divide_error)
 
 #ifdef CONFIG_X86_MCE
 ENTRY(machine_check)
@@ -968,7 +1228,7 @@ ENTRY(machine_check)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(machine_check)
+ENDPROC(machine_check)
 #endif
 
 ENTRY(spurious_interrupt_bug)
@@ -979,7 +1239,7 @@ ENTRY(spurious_interrupt_bug)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(spurious_interrupt_bug)
+ENDPROC(spurious_interrupt_bug)
 
 ENTRY(kernel_thread_helper)
 	pushl $0		# fake return address for unwinder
@@ -1095,7 +1355,7 @@ ENDPROC(xen_failsafe_callback)
 
 ENTRY(mcount)
 	ret
-END(mcount)
+ENDPROC(mcount)
 
 ENTRY(ftrace_caller)
 	cmpl $0, function_trace_stop
@@ -1124,7 +1384,7 @@ ftrace_graph_call:
 .globl ftrace_stub
 ftrace_stub:
 	ret
-END(ftrace_caller)
+ENDPROC(ftrace_caller)
 
 #else /* ! CONFIG_DYNAMIC_FTRACE */
 
@@ -1160,7 +1420,7 @@ trace:
 	popl %ecx
 	popl %eax
 	jmp ftrace_stub
-END(mcount)
+ENDPROC(mcount)
 #endif /* CONFIG_DYNAMIC_FTRACE */
 #endif /* CONFIG_FUNCTION_TRACER */
 
@@ -1181,7 +1441,7 @@ ENTRY(ftrace_graph_caller)
 	popl %ecx
 	popl %eax
 	ret
-END(ftrace_graph_caller)
+ENDPROC(ftrace_graph_caller)
 
 .globl return_to_handler
 return_to_handler:
@@ -1198,7 +1458,6 @@ return_to_handler:
 	ret
 #endif
 
-.section .rodata,"a"
 #include "syscall_table_32.S"
 
 syscall_table_size=(.-sys_call_table)
@@ -1255,15 +1514,18 @@ error_code:
 	movl $-1, PT_ORIG_EAX(%esp)	# no syscall to restart
 	REG_TO_PTGS %ecx
 	SET_KERNEL_GS %ecx
-	movl $(__USER_DS), %ecx
+	movl $(__KERNEL_DS), %ecx
 	movl %ecx, %ds
 	movl %ecx, %es
+
+	pax_enter_kernel
+
 	TRACE_IRQS_OFF
 	movl %esp,%eax			# pt_regs pointer
 	call *%edi
 	jmp ret_from_exception
 	CFI_ENDPROC
-END(page_fault)
+ENDPROC(page_fault)
 
 /*
  * Debug traps and NMI can happen at the one SYSENTER instruction
@@ -1309,7 +1571,7 @@ debug_stack_correct:
 	call do_debug
 	jmp ret_from_exception
 	CFI_ENDPROC
-END(debug)
+ENDPROC(debug)
 
 /*
  * NMI is doubly nasty. It can happen _while_ we're handling
@@ -1351,6 +1613,9 @@ nmi_stack_correct:
 	xorl %edx,%edx		# zero error code
 	movl %esp,%eax		# pt_regs pointer
 	call do_nmi
+
+	pax_exit_kernel
+
 	jmp restore_all_notrace
 	CFI_ENDPROC
 
@@ -1391,12 +1656,15 @@ nmi_espfix_stack:
 	FIXUP_ESPFIX_STACK		# %eax == %esp
 	xorl %edx,%edx			# zero error code
 	call do_nmi
+
+	pax_exit_kernel
+
 	RESTORE_REGS
 	lss 12+4(%esp), %esp		# back to espfix stack
 	CFI_ADJUST_CFA_OFFSET -24
 	jmp irq_return
 	CFI_ENDPROC
-END(nmi)
+ENDPROC(nmi)
 
 ENTRY(int3)
 	RING0_INT_FRAME
@@ -1409,7 +1677,7 @@ ENTRY(int3)
 	call do_int3
 	jmp ret_from_exception
 	CFI_ENDPROC
-END(int3)
+ENDPROC(int3)
 
 ENTRY(general_protection)
 	RING0_EC_FRAME
@@ -1417,7 +1685,7 @@ ENTRY(general_protection)
 	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
 	CFI_ENDPROC
-END(general_protection)
+ENDPROC(general_protection)
 
 /*
  * End of kprobes section
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/entry_64.S linux-2.6.32.60-pax/arch/x86/kernel/entry_64.S
--- linux-2.6.32.60/arch/x86/kernel/entry_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/entry_64.S	2012-12-01 02:39:40.684118457 +0100
@@ -53,6 +53,8 @@
 #include <asm/paravirt.h>
 #include <asm/ftrace.h>
 #include <asm/percpu.h>
+#include <asm/pgtable.h>
+#include <asm/alternative-asm.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -64,8 +66,9 @@
 #ifdef CONFIG_FUNCTION_TRACER
 #ifdef CONFIG_DYNAMIC_FTRACE
 ENTRY(mcount)
+	pax_force_retaddr
 	retq
-END(mcount)
+ENDPROC(mcount)
 
 ENTRY(ftrace_caller)
 	cmpl $0, function_trace_stop
@@ -88,8 +91,9 @@ GLOBAL(ftrace_graph_call)
 #endif
 
 GLOBAL(ftrace_stub)
+	pax_force_retaddr
 	retq
-END(ftrace_caller)
+ENDPROC(ftrace_caller)
 
 #else /* ! CONFIG_DYNAMIC_FTRACE */
 ENTRY(mcount)
@@ -108,6 +112,7 @@ ENTRY(mcount)
 #endif
 
 GLOBAL(ftrace_stub)
+	pax_force_retaddr
 	retq
 
 trace:
@@ -117,12 +122,13 @@ trace:
 	movq 8(%rbp), %rsi
 	subq $MCOUNT_INSN_SIZE, %rdi
 
+	pax_force_fptr ftrace_trace_function
 	call   *ftrace_trace_function
 
 	MCOUNT_RESTORE_FRAME
 
 	jmp ftrace_stub
-END(mcount)
+ENDPROC(mcount)
 #endif /* CONFIG_DYNAMIC_FTRACE */
 #endif /* CONFIG_FUNCTION_TRACER */
 
@@ -142,8 +148,9 @@ ENTRY(ftrace_graph_caller)
 
 	MCOUNT_RESTORE_FRAME
 
+	pax_force_retaddr
 	retq
-END(ftrace_graph_caller)
+ENDPROC(ftrace_graph_caller)
 
 GLOBAL(return_to_handler)
 	subq  $24, %rsp
@@ -159,6 +166,7 @@ GLOBAL(return_to_handler)
 	movq 8(%rsp), %rdx
 	movq (%rsp), %rax
 	addq $16, %rsp
+	pax_force_retaddr
 	retq
 #endif
 
@@ -174,6 +182,273 @@ ENTRY(native_usergs_sysret64)
 ENDPROC(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
+	.macro ljmpq sel, off
+#if defined(CONFIG_MPSC) || defined(CONFIG_MCORE2) || defined (CONFIG_MATOM)
+	.byte 0x48; ljmp *1234f(%rip)
+	.pushsection .rodata
+	.align 16
+	1234: .quad \off; .word \sel
+	.popsection
+#else
+	pushq $\sel
+	pushq $\off
+	lretq
+#endif
+	.endm
+
+	.macro pax_enter_kernel
+	pax_set_fptr_mask
+#ifdef CONFIG_PAX_KERNEXEC
+	call pax_enter_kernel
+#endif
+	.endm
+
+	.macro pax_exit_kernel
+#ifdef CONFIG_PAX_KERNEXEC
+	call pax_exit_kernel
+#endif
+	.endm
+
+#ifdef CONFIG_PAX_KERNEXEC
+ENTRY(pax_enter_kernel)
+	pushq %rdi
+
+#ifdef CONFIG_PARAVIRT
+	PV_SAVE_REGS(CLBR_RDI)
+#endif
+
+	GET_CR0_INTO_RDI
+	bts $16,%rdi
+	jnc 3f
+	mov %cs,%edi
+	cmp $__KERNEL_CS,%edi
+	jnz 2f
+1:
+
+#ifdef CONFIG_PARAVIRT
+	PV_RESTORE_REGS(CLBR_RDI)
+#endif
+
+	popq %rdi
+	pax_force_retaddr
+	retq
+
+2:	ljmpq __KERNEL_CS,1f
+3:	ljmpq __KERNEXEC_KERNEL_CS,4f
+4:	SET_RDI_INTO_CR0
+	jmp 1b
+ENDPROC(pax_enter_kernel)
+
+ENTRY(pax_exit_kernel)
+	pushq %rdi
+
+#ifdef CONFIG_PARAVIRT
+	PV_SAVE_REGS(CLBR_RDI)
+#endif
+
+	mov %cs,%rdi
+	cmp $__KERNEXEC_KERNEL_CS,%edi
+	jz 2f
+1:
+
+#ifdef CONFIG_PARAVIRT
+	PV_RESTORE_REGS(CLBR_RDI);
+#endif
+
+	popq %rdi
+	pax_force_retaddr
+	retq
+
+2:	GET_CR0_INTO_RDI
+	btr $16,%rdi
+	ljmpq __KERNEL_CS,3f
+3:	SET_RDI_INTO_CR0
+	jmp 1b
+ENDPROC(pax_exit_kernel)
+#endif
+
+	.macro pax_enter_kernel_user
+	pax_set_fptr_mask
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_enter_kernel_user
+#endif
+	.endm
+
+	.macro pax_exit_kernel_user
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_exit_kernel_user
+#endif
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushq %rax
+	call pax_randomize_kstack
+	popq %rax
+#endif
+	.endm
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+ENTRY(pax_enter_kernel_user)
+	pushq %rdi
+	pushq %rbx
+
+#ifdef CONFIG_PARAVIRT
+	PV_SAVE_REGS(CLBR_RDI)
+#endif
+
+	GET_CR3_INTO_RDI
+	mov %rdi,%rbx
+	add $__START_KERNEL_map,%rbx
+	sub phys_base(%rip),%rbx
+
+#ifdef CONFIG_PARAVIRT
+	pushq %rdi
+	cmpl $0, pv_info+PARAVIRT_enabled
+	jz 1f
+	i = 0
+	.rept USER_PGD_PTRS
+	mov i*8(%rbx),%rsi
+	mov $0,%sil
+	lea i*8(%rbx),%rdi
+	call PARA_INDIRECT(pv_mmu_ops+PV_MMU_set_pgd_batched)
+	i = i + 1
+	.endr
+	jmp 2f
+1:
+#endif
+
+	i = 0
+	.rept USER_PGD_PTRS
+	movb $0,i*8(%rbx)
+	i = i + 1
+	.endr
+
+#ifdef CONFIG_PARAVIRT
+2:	popq %rdi
+#endif
+	SET_RDI_INTO_CR3
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_RDI
+	bts $16,%rdi
+	SET_RDI_INTO_CR0
+#endif
+
+#ifdef CONFIG_PARAVIRT
+	PV_RESTORE_REGS(CLBR_RDI)
+#endif
+
+	popq %rbx
+	popq %rdi
+	pax_force_retaddr
+	retq
+ENDPROC(pax_enter_kernel_user)
+
+ENTRY(pax_exit_kernel_user)
+	push %rdi
+
+#ifdef CONFIG_PARAVIRT
+	pushq %rbx
+	PV_SAVE_REGS(CLBR_RDI)
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_RDI
+	btr $16,%rdi
+	SET_RDI_INTO_CR0
+#endif
+
+	GET_CR3_INTO_RDI
+	add $__START_KERNEL_map,%rdi
+	sub phys_base(%rip),%rdi
+
+#ifdef CONFIG_PARAVIRT
+	cmpl $0, pv_info+PARAVIRT_enabled
+	jz 1f
+	mov %rdi,%rbx
+	i = 0
+	.rept USER_PGD_PTRS
+	mov i*8(%rbx),%rsi
+	mov $0x67,%sil
+	lea i*8(%rbx),%rdi
+	call PARA_INDIRECT(pv_mmu_ops+PV_MMU_set_pgd_batched)
+	i = i + 1
+	.endr
+	jmp 2f
+1:
+#endif
+
+	i = 0
+	.rept USER_PGD_PTRS
+	movb $0x67,i*8(%rdi)
+	i = i + 1
+	.endr
+
+#ifdef CONFIG_PARAVIRT
+2:	PV_RESTORE_REGS(CLBR_RDI)
+	popq %rbx
+#endif
+
+	popq %rdi
+	pax_force_retaddr
+	retq
+ENDPROC(pax_exit_kernel_user)
+#endif
+
+.macro pax_erase_kstack
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+	call pax_erase_kstack
+#endif
+.endm
+
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+ENTRY(pax_erase_kstack)
+	pushq %rdi
+	pushq %rcx
+	pushq %rax
+	pushq %r11
+
+	GET_THREAD_INFO(%r11)
+	mov TI_lowest_stack(%r11), %rdi
+	mov $0xB4DD00D5BADBABE5, %rax
+	std
+
+1:	mov %edi, %ecx
+	and $THREAD_SIZE_asm - 1, %ecx
+	shr $3, %ecx
+	repne scasq
+	jecxz 2f
+
+	cmp $2*8, %ecx
+	jc 2f
+
+	mov $2*8, %ecx
+	repe scasq
+	jecxz 2f
+	jne 1b
+
+2:	cld
+	mov %esp, %ecx
+	sub %edi, %ecx
+
+	cmp $THREAD_SIZE_asm, %rcx
+	jb 3f
+	ud2
+3:
+
+	shr $3, %ecx
+	rep stosq
+
+	mov TI_task_thread_sp0(%r11), %rdi
+	sub $256, %rdi
+	mov %rdi, TI_lowest_stack(%r11)
+
+	popq %r11
+	popq %rax
+	popq %rcx
+	popq %rdi
+	pax_force_retaddr
+	ret
+ENDPROC(pax_erase_kstack)
+#endif
 
 .macro TRACE_IRQS_IRETQ offset=ARGOFFSET
 #ifdef CONFIG_TRACE_IRQFLAGS
@@ -233,8 +508,8 @@ ENDPROC(native_usergs_sysret64)
 	.endm
 
 	.macro UNFAKE_STACK_FRAME
-	addq $8*6, %rsp
-	CFI_ADJUST_CFA_OFFSET	-(6*8)
+	addq $8*6 + ARG_SKIP, %rsp
+	CFI_ADJUST_CFA_OFFSET	-(6*8 + ARG_SKIP)
 	.endm
 
 /*
@@ -317,7 +592,7 @@ ENTRY(save_args)
 	leaq -ARGOFFSET+16(%rsp),%rdi	/* arg1 for handler */
 	movq_cfi rbp, 8		/* push %rbp */
 	leaq 8(%rsp), %rbp		/* mov %rsp, %ebp */
-	testl $3, CS(%rdi)
+	testb $3, CS(%rdi)
 	je 1f
 	SWAPGS
 	/*
@@ -337,9 +612,10 @@ ENTRY(save_args)
 	 * We entered an interrupt context - irqs are off:
 	 */
 2:	TRACE_IRQS_OFF
+	pax_force_retaddr_bts
 	ret
 	CFI_ENDPROC
-END(save_args)
+ENDPROC(save_args)
 
 ENTRY(save_rest)
 	PARTIAL_FRAME 1 REST_SKIP+8
@@ -352,9 +628,10 @@ ENTRY(save_rest)
 	movq_cfi r15, R15+16
 	movq %r11, 8(%rsp)	/* return address */
 	FIXUP_TOP_OF_STACK %r11, 16
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
-END(save_rest)
+ENDPROC(save_rest)
 
 /* save complete stack frame */
 	.pushsection .kprobes.text, "ax"
@@ -383,9 +660,10 @@ ENTRY(save_paranoid)
 	js 1f	/* negative -> in kernel */
 	SWAPGS
 	xorl %ebx,%ebx
-1:	ret
+1:	pax_force_retaddr_bts
+	ret
 	CFI_ENDPROC
-END(save_paranoid)
+ENDPROC(save_paranoid)
 	.popsection
 
 /*
@@ -409,7 +687,7 @@ ENTRY(ret_from_fork)
 
 	RESTORE_REST
 
-	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
+	testb $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
 	je   int_ret_from_sys_call
 
 	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET
@@ -419,7 +697,7 @@ ENTRY(ret_from_fork)
 	jmp ret_from_sys_call			# go to the SYSRET fastpath
 
 	CFI_ENDPROC
-END(ret_from_fork)
+ENDPROC(ret_from_fork)
 
 /*
  * System call entry. Upto 6 arguments in registers are supported.
@@ -455,7 +733,7 @@ END(ret_from_fork)
 ENTRY(system_call)
 	CFI_STARTPROC	simple
 	CFI_SIGNAL_FRAME
-	CFI_DEF_CFA	rsp,KERNEL_STACK_OFFSET
+	CFI_DEF_CFA	rsp,0
 	CFI_REGISTER	rip,rcx
 	/*CFI_REGISTER	rflags,r11*/
 	SWAPGS_UNSAFE_STACK
@@ -468,12 +746,18 @@ ENTRY(system_call_after_swapgs)
 
 	movq	%rsp,PER_CPU_VAR(old_rsp)
 	movq	PER_CPU_VAR(kernel_stack),%rsp
+	SAVE_ARGS 8*6,1
+	pax_enter_kernel_user
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pax_erase_kstack
+#endif
+
 	/*
 	 * No need to follow this irqs off/on section - it's straight
 	 * and short:
 	 */
 	ENABLE_INTERRUPTS(CLBR_NONE)
-	SAVE_ARGS 8,1
 	movq  %rax,ORIG_RAX-ARGOFFSET(%rsp)
 	movq  %rcx,RIP-ARGOFFSET(%rsp)
 	CFI_REL_OFFSET rip,RIP-ARGOFFSET
@@ -483,7 +767,7 @@ ENTRY(system_call_after_swapgs)
 system_call_fastpath:
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
-	movq %r10,%rcx
+	movq R10-ARGOFFSET(%rsp),%rcx
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
 	movq %rax,RAX-ARGOFFSET(%rsp)
 /*
@@ -502,6 +786,8 @@ sysret_check:
 	andl %edi,%edx
 	jnz  sysret_careful
 	CFI_REMEMBER_STATE
+	pax_exit_kernel_user
+	pax_erase_kstack
 	/*
 	 * sysretq will re-enable interrupts:
 	 */
@@ -555,14 +841,18 @@ badsys:
 	 * jump back to the normal fast path.
 	 */
 auditsys:
-	movq %r10,%r9			/* 6th arg: 4th syscall arg */
+	movq R10-ARGOFFSET(%rsp),%r9	/* 6th arg: 4th syscall arg */
 	movq %rdx,%r8			/* 5th arg: 3rd syscall arg */
 	movq %rsi,%rcx			/* 4th arg: 2nd syscall arg */
 	movq %rdi,%rdx			/* 3rd arg: 1st syscall arg */
 	movq %rax,%rsi			/* 2nd arg: syscall number */
 	movl $AUDIT_ARCH_X86_64,%edi	/* 1st arg: audit arch */
 	call audit_syscall_entry
+
+	pax_erase_kstack
+
 	LOAD_ARGS 0		/* reload call-clobbered registers */
+	pax_set_fptr_mask
 	jmp system_call_fastpath
 
 	/*
@@ -592,16 +882,20 @@ tracesys:
 	FIXUP_TOP_OF_STACK %rdi
 	movq %rsp,%rdi
 	call syscall_trace_enter
+
+	pax_erase_kstack
+
 	/*
 	 * Reload arg registers from stack in case ptrace changed them.
 	 * We don't reload %rax because syscall_trace_enter() returned
 	 * the value it wants us to use in the table lookup.
 	 */
 	LOAD_ARGS ARGOFFSET, 1
+	pax_set_fptr_mask
 	RESTORE_REST
 	cmpq $__NR_syscall_max,%rax
 	ja   int_ret_from_sys_call	/* RAX(%rsp) set to -ENOSYS above */
-	movq %r10,%rcx	/* fixup for C */
+	movq R10-ARGOFFSET(%rsp),%rcx	/* fixup for C */
 	call *sys_call_table(,%rax,8)
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	/* Use IRET because user could have changed frame */
@@ -613,7 +907,7 @@ tracesys:
 GLOBAL(int_ret_from_sys_call)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	TRACE_IRQS_OFF
-	testl $3,CS-ARGOFFSET(%rsp)
+	testb $3,CS-ARGOFFSET(%rsp)
 	je retint_restore_args
 	movl $_TIF_ALLWORK_MASK,%edi
 	/* edi:	mask to check */
@@ -624,7 +918,9 @@ GLOBAL(int_with_check)
 	andl %edi,%edx
 	jnz   int_careful
 	andl    $~TS_COMPAT,TI_status(%rcx)
-	jmp   retint_swapgs
+	pax_exit_kernel_user
+	pax_erase_kstack
+	jmp   retint_swapgs_pax
 
 	/* Either reschedule or signal or syscall exit tracking needed. */
 	/* First do a reschedule test. */
@@ -674,7 +970,7 @@ int_restore_rest:
 	TRACE_IRQS_OFF
 	jmp int_with_check
 	CFI_ENDPROC
-END(system_call)
+ENDPROC(system_call)
 
 /*
  * Certain special system calls that need to save a complete full stack frame.
@@ -690,7 +986,7 @@ ENTRY(\label)
 	call \func
 	jmp ptregscall_common
 	CFI_ENDPROC
-END(\label)
+ENDPROC(\label)
 	.endm
 
 	PTREGSCALL stub_clone, sys_clone, %r8
@@ -708,9 +1004,10 @@ ENTRY(ptregscall_common)
 	movq_cfi_restore R12+8, r12
 	movq_cfi_restore RBP+8, rbp
 	movq_cfi_restore RBX+8, rbx
+	pax_force_retaddr
 	ret $REST_SKIP		/* pop extended registers */
 	CFI_ENDPROC
-END(ptregscall_common)
+ENDPROC(ptregscall_common)
 
 ENTRY(stub_execve)
 	CFI_STARTPROC
@@ -726,7 +1023,7 @@ ENTRY(stub_execve)
 	RESTORE_REST
 	jmp int_ret_from_sys_call
 	CFI_ENDPROC
-END(stub_execve)
+ENDPROC(stub_execve)
 
 /*
  * sigreturn is special because it needs to restore all registers on return.
@@ -744,7 +1041,7 @@ ENTRY(stub_rt_sigreturn)
 	RESTORE_REST
 	jmp int_ret_from_sys_call
 	CFI_ENDPROC
-END(stub_rt_sigreturn)
+ENDPROC(stub_rt_sigreturn)
 
 /*
  * Build the entry stubs and pointer table with some assembler magic.
@@ -780,7 +1077,7 @@ vector=vector+1
 2:	jmp common_interrupt
 .endr
 	CFI_ENDPROC
-END(irq_entries_start)
+ENDPROC(irq_entries_start)
 
 .previous
 END(interrupt)
@@ -800,6 +1097,16 @@ END(interrupt)
 	CFI_ADJUST_CFA_OFFSET 10*8
 	call save_args
 	PARTIAL_FRAME 0
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rdi)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	call \func
 	.endm
 
@@ -822,7 +1129,7 @@ ret_from_intr:
 	CFI_ADJUST_CFA_OFFSET	-8
 exit_intr:
 	GET_THREAD_INFO(%rcx)
-	testl $3,CS-ARGOFFSET(%rsp)
+	testb $3,CS-ARGOFFSET(%rsp)
 	je retint_kernel
 
 	/* Interrupt came from user space */
@@ -844,12 +1151,16 @@ retint_swapgs:		/* return to user-space
 	 * The iretq could re-enable interrupts:
 	 */
 	DISABLE_INTERRUPTS(CLBR_ANY)
+	pax_exit_kernel_user
+retint_swapgs_pax:
 	TRACE_IRQS_IRETQ
 	SWAPGS
 	jmp restore_args
 
 retint_restore_args:	/* return to kernel space */
 	DISABLE_INTERRUPTS(CLBR_ANY)
+	pax_exit_kernel
+	pax_force_retaddr (RIP-ARGOFFSET)
 	/*
 	 * The iretq could re-enable interrupts:
 	 */
@@ -940,7 +1251,7 @@ ENTRY(retint_kernel)
 #endif
 
 	CFI_ENDPROC
-END(common_interrupt)
+ENDPROC(common_interrupt)
 
 /*
  * APIC interrupts.
@@ -953,7 +1264,7 @@ ENTRY(\sym)
 	interrupt \do_sym
 	jmp ret_from_intr
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 #ifdef CONFIG_SMP
@@ -1032,12 +1343,22 @@ ENTRY(\sym)
 	CFI_ADJUST_CFA_OFFSET 15*8
 	call error_entry
 	DEFAULT_FRAME 0
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
 	call \do_sym
 	jmp error_exit		/* %ebx: no swapgs flag */
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 .macro paranoidzeroentry sym do_sym
@@ -1049,12 +1370,22 @@ ENTRY(\sym)
 	subq $15*8, %rsp
 	call save_paranoid
 	TRACE_IRQS_OFF
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
 	call \do_sym
 	jmp paranoid_exit	/* %ebx: no swapgs flag */
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 .macro paranoidzeroentry_ist sym do_sym ist
@@ -1066,15 +1397,30 @@ ENTRY(\sym)
 	subq $15*8, %rsp
 	call save_paranoid
 	TRACE_IRQS_OFF
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
-	PER_CPU(init_tss, %rbp)
+#ifdef CONFIG_SMP
+	imul $TSS_size, PER_CPU_VAR(cpu_number), %ebp
+	lea init_tss(%rbp), %rbp
+#else
+	lea init_tss(%rip), %rbp
+#endif
 	subq $EXCEPTION_STKSZ, TSS_ist + (\ist - 1) * 8(%rbp)
 	call \do_sym
 	addq $EXCEPTION_STKSZ, TSS_ist + (\ist - 1) * 8(%rbp)
 	jmp paranoid_exit	/* %ebx: no swapgs flag */
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 .macro errorentry sym do_sym
@@ -1085,13 +1431,23 @@ ENTRY(\sym)
 	CFI_ADJUST_CFA_OFFSET 15*8
 	call error_entry
 	DEFAULT_FRAME 0
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	movq %rsp,%rdi			/* pt_regs pointer */
 	movq ORIG_RAX(%rsp),%rsi	/* get error code */
 	movq $-1,ORIG_RAX(%rsp)		/* no syscall to restart */
 	call \do_sym
 	jmp error_exit			/* %ebx: no swapgs flag */
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 	/* error code is on the stack already */
@@ -1104,13 +1460,23 @@ ENTRY(\sym)
 	call save_paranoid
 	DEFAULT_FRAME 0
 	TRACE_IRQS_OFF
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	movq %rsp,%rdi			/* pt_regs pointer */
 	movq ORIG_RAX(%rsp),%rsi	/* get error code */
 	movq $-1,ORIG_RAX(%rsp)		/* no syscall to restart */
 	call \do_sym
 	jmp paranoid_exit		/* %ebx: no swapgs flag */
 	CFI_ENDPROC
-END(\sym)
+ENDPROC(\sym)
 .endm
 
 zeroentry divide_error do_divide_error
@@ -1141,9 +1507,10 @@ gs_change:
 	SWAPGS
 	popf
 	CFI_ADJUST_CFA_OFFSET -8
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
-END(native_load_gs_index)
+ENDPROC(native_load_gs_index)
 
 	.section __ex_table,"a"
 	.align 8
@@ -1193,11 +1560,12 @@ ENTRY(kernel_thread)
 	 * of hacks for example to fork off the per-CPU idle tasks.
 	 * [Hopefully no generic code relies on the reschedule -AK]
 	 */
-	RESTORE_ALL
+	RESTORE_REST
 	UNFAKE_STACK_FRAME
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
-END(kernel_thread)
+ENDPROC(kernel_thread)
 
 ENTRY(child_rip)
 	pushq $0		# fake return address
@@ -1208,13 +1576,14 @@ ENTRY(child_rip)
 	 */
 	movq %rdi, %rax
 	movq %rsi, %rdi
+	pax_force_fptr %rax
 	call *%rax
 	# exit
 	mov %eax, %edi
 	call do_exit
 	ud2			# padding for call trace
 	CFI_ENDPROC
-END(child_rip)
+ENDPROC(child_rip)
 
 /*
  * execve(). This function needs to use IRET, not SYSRET, to set up all state properly.
@@ -1241,11 +1610,11 @@ ENTRY(kernel_execve)
 	RESTORE_REST
 	testq %rax,%rax
 	je int_ret_from_sys_call
-	RESTORE_ARGS
 	UNFAKE_STACK_FRAME
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
-END(kernel_execve)
+ENDPROC(kernel_execve)
 
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(call_softirq)
@@ -1263,9 +1632,10 @@ ENTRY(call_softirq)
 	CFI_DEF_CFA_REGISTER	rsp
 	CFI_ADJUST_CFA_OFFSET   -8
 	decl PER_CPU_VAR(irq_count)
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
-END(call_softirq)
+ENDPROC(call_softirq)
 
 #ifdef CONFIG_XEN
 zeroentry xen_hypervisor_callback xen_do_hypervisor_callback
@@ -1303,7 +1673,7 @@ ENTRY(xen_do_hypervisor_callback)   # do
 	decl PER_CPU_VAR(irq_count)
 	jmp  error_exit
 	CFI_ENDPROC
-END(xen_do_hypervisor_callback)
+ENDPROC(xen_do_hypervisor_callback)
 
 /*
  * Hypervisor uses this for application faults while it executes.
@@ -1362,7 +1732,7 @@ ENTRY(xen_failsafe_callback)
 	SAVE_ALL
 	jmp error_exit
 	CFI_ENDPROC
-END(xen_failsafe_callback)
+ENDPROC(xen_failsafe_callback)
 
 #endif /* CONFIG_XEN */
 
@@ -1405,16 +1775,31 @@ ENTRY(paranoid_exit)
 	TRACE_IRQS_OFF
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz paranoid_restore
-	testl $3,CS(%rsp)
+	testb $3,CS(%rsp)
 	jnz   paranoid_userspace
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pax_exit_kernel
+	TRACE_IRQS_IRETQ 0
+	SWAPGS_UNSAFE_STACK
+	RESTORE_ALL 8
+	pax_force_retaddr_bts
+	jmp irq_return
+#endif
 paranoid_swapgs:
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pax_exit_kernel_user
+#else
+	pax_exit_kernel
+#endif
 	TRACE_IRQS_IRETQ 0
 	SWAPGS_UNSAFE_STACK
 	RESTORE_ALL 8
 	jmp irq_return
 paranoid_restore:
+	pax_exit_kernel
 	TRACE_IRQS_IRETQ 0
 	RESTORE_ALL 8
+	pax_force_retaddr_bts
 	jmp irq_return
 paranoid_userspace:
 	GET_THREAD_INFO(%rcx)
@@ -1443,7 +1828,7 @@ paranoid_schedule:
 	TRACE_IRQS_OFF
 	jmp paranoid_userspace
 	CFI_ENDPROC
-END(paranoid_exit)
+ENDPROC(paranoid_exit)
 
 /*
  * Exception entry point. This expects an error code/orig_rax on the stack.
@@ -1470,12 +1855,13 @@ ENTRY(error_entry)
 	movq_cfi r14, R14+8
 	movq_cfi r15, R15+8
 	xorl %ebx,%ebx
-	testl $3,CS+8(%rsp)
+	testb $3,CS+8(%rsp)
 	je error_kernelspace
 error_swapgs:
 	SWAPGS
 error_sti:
 	TRACE_IRQS_OFF
+	pax_force_retaddr_bts
 	ret
 	CFI_ENDPROC
 
@@ -1497,7 +1883,7 @@ error_kernelspace:
 	cmpq $gs_change,RIP+8(%rsp)
 	je error_swapgs
 	jmp error_sti
-END(error_entry)
+ENDPROC(error_entry)
 
 
 /* ebx:	no swapgs flag (1: don't need swapgs, 0: need it) */
@@ -1517,7 +1903,7 @@ ENTRY(error_exit)
 	jnz retint_careful
 	jmp retint_swapgs
 	CFI_ENDPROC
-END(error_exit)
+ENDPROC(error_exit)
 
 
 	/* runs on exception stack */
@@ -1529,6 +1915,16 @@ ENTRY(nmi)
 	CFI_ADJUST_CFA_OFFSET 15*8
 	call save_paranoid
 	DEFAULT_FRAME 0
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	testb $3, CS(%rsp)
+	jnz 1f
+	pax_enter_kernel
+	jmp 2f
+1:	pax_enter_kernel_user
+2:
+#else
+	pax_enter_kernel
+#endif
 	/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */
 	movq %rsp,%rdi
 	movq $-1,%rsi
@@ -1539,12 +1935,28 @@ ENTRY(nmi)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz nmi_restore
-	testl $3,CS(%rsp)
+	testb $3,CS(%rsp)
 	jnz nmi_userspace
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pax_exit_kernel
+	SWAPGS_UNSAFE_STACK
+	RESTORE_ALL 8
+	pax_force_retaddr_bts
+	jmp irq_return
+#endif
 nmi_swapgs:
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pax_exit_kernel_user
+#else
+	pax_exit_kernel
+#endif
 	SWAPGS_UNSAFE_STACK
+	RESTORE_ALL 8
+	jmp irq_return
 nmi_restore:
+	pax_exit_kernel
 	RESTORE_ALL 8
+	pax_force_retaddr_bts
 	jmp irq_return
 nmi_userspace:
 	GET_THREAD_INFO(%rcx)
@@ -1573,14 +1985,14 @@ nmi_schedule:
 	jmp paranoid_exit
 	CFI_ENDPROC
 #endif
-END(nmi)
+ENDPROC(nmi)
 
 ENTRY(ignore_sysret)
 	CFI_STARTPROC
 	mov $-ENOSYS,%eax
 	sysret
 	CFI_ENDPROC
-END(ignore_sysret)
+ENDPROC(ignore_sysret)
 
 /*
  * End of kprobes section
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/ftrace.c linux-2.6.32.60-pax/arch/x86/kernel/ftrace.c
--- linux-2.6.32.60/arch/x86/kernel/ftrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/ftrace.c	2012-12-14 21:02:11.353798908 +0100
@@ -103,7 +103,7 @@ static void *mod_code_ip;		/* holds the
 static void *mod_code_newcode;		/* holds the text to write to the IP */
 
 static unsigned nmi_wait_count;
-static atomic_t nmi_update_count = ATOMIC_INIT(0);
+static atomic_unchecked_t nmi_update_count = ATOMIC_INIT(0);
 
 int ftrace_arch_read_dyn_info(char *buf, int size)
 {
@@ -111,7 +111,7 @@ int ftrace_arch_read_dyn_info(char *buf,
 
 	r = snprintf(buf, size, "%u %u",
 		     nmi_wait_count,
-		     atomic_read(&nmi_update_count));
+		     atomic_read_unchecked(&nmi_update_count));
 	return r;
 }
 
@@ -149,8 +149,10 @@ void ftrace_nmi_enter(void)
 {
 	if (atomic_inc_return(&nmi_running) & MOD_CODE_WRITE_FLAG) {
 		smp_rmb();
+		pax_open_kernel();
 		ftrace_mod_code();
-		atomic_inc(&nmi_update_count);
+		pax_close_kernel();
+		atomic_inc_unchecked(&nmi_update_count);
 	}
 	/* Must have previous changes seen before executions */
 	smp_mb();
@@ -215,7 +217,7 @@ do_ftrace_mod_code(unsigned long ip, voi
 
 
 
-static unsigned char ftrace_nop[MCOUNT_INSN_SIZE];
+static unsigned char ftrace_nop[MCOUNT_INSN_SIZE] __read_only;
 
 static unsigned char *ftrace_nop_replace(void)
 {
@@ -228,6 +230,8 @@ ftrace_modify_code(unsigned long ip, uns
 {
 	unsigned char replaced[MCOUNT_INSN_SIZE];
 
+	ip = ktla_ktva(ip);
+
 	/*
 	 * Note: Due to modules and __init, code can
 	 *  disappear and change, we need to protect against faulting
@@ -284,7 +288,7 @@ int ftrace_update_ftrace_func(ftrace_fun
 	unsigned char old[MCOUNT_INSN_SIZE], *new;
 	int ret;
 
-	memcpy(old, &ftrace_call, MCOUNT_INSN_SIZE);
+	memcpy(old, ktla_ktva((void *)ftrace_call), MCOUNT_INSN_SIZE);
 	new = ftrace_call_replace(ip, (unsigned long)func);
 	ret = ftrace_modify_code(ip, old, new);
 
@@ -337,15 +341,15 @@ int __init ftrace_dyn_arch_init(void *da
 	switch (faulted) {
 	case 0:
 		pr_info("ftrace: converting mcount calls to 0f 1f 44 00 00\n");
-		memcpy(ftrace_nop, ftrace_test_p6nop, MCOUNT_INSN_SIZE);
+		memcpy(ftrace_nop, ktla_ktva(ftrace_test_p6nop), MCOUNT_INSN_SIZE);
 		break;
 	case 1:
 		pr_info("ftrace: converting mcount calls to 66 66 66 66 90\n");
-		memcpy(ftrace_nop, ftrace_test_nop5, MCOUNT_INSN_SIZE);
+		memcpy(ftrace_nop, ktla_ktva(ftrace_test_nop5), MCOUNT_INSN_SIZE);
 		break;
 	case 2:
 		pr_info("ftrace: converting mcount calls to jmp . + 5\n");
-		memcpy(ftrace_nop, ftrace_test_jmp, MCOUNT_INSN_SIZE);
+		memcpy(ftrace_nop, ktla_ktva(ftrace_test_jmp), MCOUNT_INSN_SIZE);
 		break;
 	}
 
@@ -366,6 +370,8 @@ static int ftrace_mod_jmp(unsigned long
 {
 	unsigned char code[MCOUNT_INSN_SIZE];
 
+	ip = ktla_ktva(ip);
+
 	if (probe_kernel_read(code, (void *)ip, MCOUNT_INSN_SIZE))
 		return -EFAULT;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/head32.c linux-2.6.32.60-pax/arch/x86/kernel/head32.c
--- linux-2.6.32.60/arch/x86/kernel/head32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/head32.c	2013-02-17 17:29:47.240124788 +0100
@@ -16,6 +16,7 @@
 #include <asm/apic.h>
 #include <asm/io_apic.h>
 #include <asm/bios_ebda.h>
+#include <asm/boot.h>
 
 static void __init i386_default_early_setup(void)
 {
@@ -31,7 +32,7 @@ void __init i386_start_kernel(void)
 {
 	reserve_trampoline_memory();
 
-	reserve_early(__pa_symbol(&_text), __pa_symbol(&__bss_stop), "TEXT DATA BSS");
+	reserve_early(LOAD_PHYSICAL_ADDR, __pa_symbol(&__bss_stop), "TEXT DATA BSS");
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* Reserve INITRD */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/head_32.S linux-2.6.32.60-pax/arch/x86/kernel/head_32.S
--- linux-2.6.32.60/arch/x86/kernel/head_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/head_32.S	2012-10-28 23:24:45.058330794 +0100
@@ -19,10 +19,17 @@
 #include <asm/setup.h>
 #include <asm/processor-flags.h>
 #include <asm/percpu.h>
+#include <asm/msr-index.h>
 
 /* Physical address */
 #define pa(X) ((X) - __PAGE_OFFSET)
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define ta(X) (X)
+#else
+#define ta(X) ((X) - __PAGE_OFFSET)
+#endif
+
 /*
  * References to members of the new_cpu_data structure.
  */
@@ -52,11 +59,7 @@
  * and small than max_low_pfn, otherwise will waste some page table entries
  */
 
-#if PTRS_PER_PMD > 1
-#define PAGE_TABLE_SIZE(pages) (((pages) / PTRS_PER_PMD) + PTRS_PER_PGD)
-#else
-#define PAGE_TABLE_SIZE(pages) ((pages) / PTRS_PER_PGD)
-#endif
+#define PAGE_TABLE_SIZE(pages) ((pages) / PTRS_PER_PTE)
 
 /* Enough space to fit pagetables for the low memory linear map */
 MAPPING_BEYOND_END = \
@@ -73,6 +76,12 @@ INIT_MAP_SIZE = PAGE_TABLE_SIZE(KERNEL_P
 RESERVE_BRK(pagetables, INIT_MAP_SIZE)
 
 /*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
+
+/*
  * 32-bit kernel entrypoint; only used by the boot CPU.  On entry,
  * %esi points to the real-mode code as a 32-bit pointer.
  * CS and DS must be 4 GB flat segments, but we don't depend on
@@ -80,6 +89,13 @@ RESERVE_BRK(pagetables, INIT_MAP_SIZE)
  * can.
  */
 __HEAD
+
+#ifdef CONFIG_PAX_KERNEXEC
+	jmp startup_32
+/* PaX: fill first page in .text with int3 to catch NULL derefs in kernel mode */
+.fill PAGE_SIZE-5,1,0xcc
+#endif
+
 ENTRY(startup_32)
 	/* test KEEP_SEGMENTS flag to see if the bootloader is asking
 		us to not reload segments */
@@ -97,6 +113,59 @@ ENTRY(startup_32)
 	movl %eax,%gs
 2:
 
+#ifdef CONFIG_SMP
+	movl $pa(cpu_gdt_table),%edi
+	movl $__per_cpu_load,%eax
+	movw %ax,GDT_ENTRY_PERCPU * 8 + 2(%edi)
+	rorl $16,%eax
+	movb %al,GDT_ENTRY_PERCPU * 8 + 4(%edi)
+	movb %ah,GDT_ENTRY_PERCPU * 8 + 7(%edi)
+	movl $__per_cpu_end - 1,%eax
+	subl $__per_cpu_start,%eax
+	movw %ax,GDT_ENTRY_PERCPU * 8 + 0(%edi)
+#endif
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	movl $NR_CPUS,%ecx
+	movl $pa(cpu_gdt_table),%edi
+1:
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c09700),GDT_ENTRY_KERNEL_DS * 8 + 4(%edi)
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c0fb00),GDT_ENTRY_DEFAULT_USER_CS * 8 + 4(%edi)
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c0f300),GDT_ENTRY_DEFAULT_USER_DS * 8 + 4(%edi)
+	addl $PAGE_SIZE_asm,%edi
+	loop 1b
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $pa(boot_gdt),%edi
+	movl $__LOAD_PHYSICAL_ADDR,%eax
+	movw %ax,GDT_ENTRY_BOOT_CS * 8 + 2(%edi)
+	rorl $16,%eax
+	movb %al,GDT_ENTRY_BOOT_CS * 8 + 4(%edi)
+	movb %ah,GDT_ENTRY_BOOT_CS * 8 + 7(%edi)
+	rorl $16,%eax
+
+	ljmp $(__BOOT_CS),$1f
+1:
+
+	movl $NR_CPUS,%ecx
+	movl $pa(cpu_gdt_table),%edi
+	addl $__PAGE_OFFSET,%eax
+1:
+	movb $0xc0,GDT_ENTRY_KERNEL_CS * 8 + 6(%edi)
+	movb $0xc0,GDT_ENTRY_KERNEXEC_KERNEL_CS * 8 + 6(%edi)
+	movw %ax,GDT_ENTRY_KERNEL_CS * 8 + 2(%edi)
+	movw %ax,GDT_ENTRY_KERNEXEC_KERNEL_CS * 8 + 2(%edi)
+	rorl $16,%eax
+	movb %al,GDT_ENTRY_KERNEL_CS * 8 + 4(%edi)
+	movb %al,GDT_ENTRY_KERNEXEC_KERNEL_CS * 8 + 4(%edi)
+	movb %ah,GDT_ENTRY_KERNEL_CS * 8 + 7(%edi)
+	movb %ah,GDT_ENTRY_KERNEXEC_KERNEL_CS * 8 + 7(%edi)
+	rorl $16,%eax
+	addl $PAGE_SIZE_asm,%edi
+	loop 1b
+#endif
+
 /*
  * Clear BSS first so that there are no surprises...
  */
@@ -140,9 +209,7 @@ ENTRY(startup_32)
 	cmpl $num_subarch_entries, %eax
 	jae bad_subarch
 
-	movl pa(subarch_entries)(,%eax,4), %eax
-	subl $__PAGE_OFFSET, %eax
-	jmp *%eax
+	jmp *pa(subarch_entries)(,%eax,4)
 
 bad_subarch:
 WEAK(lguest_entry)
@@ -154,10 +221,10 @@ WEAK(xen_entry)
 	__INITDATA
 
 subarch_entries:
-	.long default_entry		/* normal x86/PC */
-	.long lguest_entry		/* lguest hypervisor */
-	.long xen_entry			/* Xen hypervisor */
-	.long default_entry		/* Moorestown MID */
+	.long ta(default_entry)		/* normal x86/PC */
+	.long ta(lguest_entry)		/* lguest hypervisor */
+	.long ta(xen_entry)		/* Xen hypervisor */
+	.long ta(default_entry)		/* Moorestown MID */
 num_subarch_entries = (. - subarch_entries) / 4
 .previous
 #endif /* CONFIG_PARAVIRT */
@@ -218,8 +285,11 @@ default_entry:
 	movl %eax, pa(max_pfn_mapped)
 
 	/* Do early initialization of the fixmap area */
-	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR,%eax
-	movl %eax,pa(swapper_pg_pmd+0x1000*KPMDS-8)
+#ifdef CONFIG_COMPAT_VDSO
+	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR+_PAGE_USER,pa(swapper_pg_pmd+0x1000*KPMDS-8)
+#else
+	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR,pa(swapper_pg_pmd+0x1000*KPMDS-8)
+#endif
 #else	/* Not PAE */
 
 page_pde_offset = (__PAGE_OFFSET >> 20);
@@ -249,8 +319,11 @@ page_pde_offset = (__PAGE_OFFSET >> 20);
 	movl %eax, pa(max_pfn_mapped)
 
 	/* Do early initialization of the fixmap area */
-	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR,%eax
-	movl %eax,pa(swapper_pg_dir+0xffc)
+#ifdef CONFIG_COMPAT_VDSO
+	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR+_PAGE_USER,pa(swapper_pg_dir+0xffc)
+#else
+	movl $pa(swapper_pg_fixmap)+PDE_IDENT_ATTR,pa(swapper_pg_dir+0xffc)
+#endif
 #endif
 	jmp 3f
 /*
@@ -297,6 +370,7 @@ ENTRY(startup_32_smp)
 	orl %edx,%eax
 	movl %eax,%cr4
 
+#ifdef CONFIG_X86_PAE
 	btl $5, %eax		# check if PAE is enabled
 	jnc 6f
 
@@ -312,13 +386,17 @@ ENTRY(startup_32_smp)
 	jnc 6f
 
 	/* Setup EFER (Extended Feature Enable Register) */
-	movl $0xc0000080, %ecx
+	movl $MSR_EFER, %ecx
 	rdmsr
 
 	btsl $11, %eax
 	/* Make changes effective */
 	wrmsr
 
+	btsl $_PAGE_BIT_NX-32,pa(__supported_pte_mask+4)
+	movl $1,pa(nx_enabled)
+#endif
+
 6:
 
 /*
@@ -344,9 +422,7 @@ ENTRY(startup_32_smp)
 
 #ifdef CONFIG_SMP
 	cmpb $0, ready
-	jz  1f				/* Initial CPU cleans BSS */
-	jmp checkCPUtype
-1:
+	jnz checkCPUtype		/* Initial CPU cleans BSS */
 #endif /* CONFIG_SMP */
 
 /*
@@ -424,7 +500,7 @@ is386:	movl $2,%ecx		# set MP
 1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
 	movl %eax,%ss			# after changing gdt.
 
-	movl $(__USER_DS),%eax		# DS/ES contains default USER segment
+#	movl $(__KERNEL_DS),%eax	# DS/ES contains default KERNEL segment
 	movl %eax,%ds
 	movl %eax,%es
 
@@ -438,15 +514,22 @@ is386:	movl $2,%ecx		# set MP
 	 */
 	cmpb $0,ready
 	jne 1f
-	movl $per_cpu__gdt_page,%eax
+	movl $cpu_gdt_table,%eax
 	movl $per_cpu__stack_canary,%ecx
+#ifdef CONFIG_SMP
+	addl $__per_cpu_load,%ecx
+#endif
 	movw %cx, 8 * GDT_ENTRY_STACK_CANARY + 2(%eax)
 	shrl $16, %ecx
 	movb %cl, 8 * GDT_ENTRY_STACK_CANARY + 4(%eax)
 	movb %ch, 8 * GDT_ENTRY_STACK_CANARY + 7(%eax)
 1:
-#endif
 	movl $(__KERNEL_STACK_CANARY),%eax
+#elif defined(CONFIG_PAX_MEMORY_UDEREF)
+	movl $(__USER_DS),%eax
+#else
+	xorl %eax,%eax
+#endif
 	movl %eax,%gs
 
 	xorl %eax,%eax			# Clear LDT
@@ -457,10 +540,6 @@ is386:	movl $2,%ecx		# set MP
 #ifdef CONFIG_SMP
 	movb ready, %cl
 	movb $1, ready
-	cmpb $0,%cl		# the first CPU calls start_kernel
-	je   1f
-	movl (stack_start), %esp
-1:
 #endif /* CONFIG_SMP */
 	jmp *(initial_code)
 
@@ -546,22 +625,22 @@ early_page_fault:
 	jmp early_fault
 
 early_fault:
-	cld
 #ifdef CONFIG_PRINTK
+	cmpl $1,%ss:early_recursion_flag
+	je hlt_loop
+	incl %ss:early_recursion_flag
+	cld
 	pusha
 	movl $(__KERNEL_DS),%eax
 	movl %eax,%ds
 	movl %eax,%es
-	cmpl $2,early_recursion_flag
-	je hlt_loop
-	incl early_recursion_flag
 	movl %cr2,%eax
 	pushl %eax
 	pushl %edx		/* trapno */
 	pushl $fault_msg
 	call printk
+;	call dump_stack
 #endif
-	call dump_stack
 hlt_loop:
 	hlt
 	jmp hlt_loop
@@ -569,8 +648,11 @@ hlt_loop:
 /* This is the default interrupt "handler" :-) */
 	ALIGN
 ignore_int:
-	cld
 #ifdef CONFIG_PRINTK
+	cmpl $2,%ss:early_recursion_flag
+	je hlt_loop
+	incl %ss:early_recursion_flag
+	cld
 	pushl %eax
 	pushl %ecx
 	pushl %edx
@@ -579,9 +661,6 @@ ignore_int:
 	movl $(__KERNEL_DS),%eax
 	movl %eax,%ds
 	movl %eax,%es
-	cmpl $2,early_recursion_flag
-	je hlt_loop
-	incl early_recursion_flag
 	pushl 16(%esp)
 	pushl 24(%esp)
 	pushl 32(%esp)
@@ -610,31 +689,47 @@ ENTRY(initial_page_table)
 /*
  * BSS section
  */
-__PAGE_ALIGNED_BSS
-	.align PAGE_SIZE_asm
 #ifdef CONFIG_X86_PAE
+.section .swapper_pg_pmd,"a",@progbits
 swapper_pg_pmd:
 	.fill 1024*KPMDS,4,0
 #else
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
 	.fill 1024,4,0
 #endif
+.section .swapper_pg_fixmap,"a",@progbits
 swapper_pg_fixmap:
 	.fill 1024,4,0
 #ifdef CONFIG_X86_TRAMPOLINE
+.section .trampoline_pg_dir,"a",@progbits
 ENTRY(trampoline_pg_dir)
+#ifdef CONFIG_X86_PAE
+	.fill 4,8,0
+#else
 	.fill 1024,4,0
 #endif
+#endif
+
+.section .empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
 	.fill 4096,1,0
 
 /*
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
+ */
+.section .idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
+
+/*
  * This starts the data section.
  */
 #ifdef CONFIG_X86_PAE
-__PAGE_ALIGNED_DATA
-	/* Page-aligned for the benefit of paravirt? */
-	.align PAGE_SIZE_asm
+.section .swapper_pg_dir,"a",@progbits
+
 ENTRY(swapper_pg_dir)
 	.long	pa(swapper_pg_pmd+PGD_IDENT_ATTR),0	/* low identity map */
 # if KPMDS == 3
@@ -653,15 +748,24 @@ ENTRY(swapper_pg_dir)
 #  error "Kernel PMDs should be 1, 2 or 3"
 # endif
 	.align PAGE_SIZE_asm		/* needs to be page-sized too */
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+ENTRY(cpu_pgd)
+	.rept NR_CPUS
+	.fill	4,8,0
+	.endr
+#endif
+
 #endif
 
 .data
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-8
 	.long __BOOT_DS
 
 ready:	.byte 0
 
+.section .rodata,"a",@progbits
 early_recursion_flag:
 	.long 0
 
@@ -697,7 +801,7 @@ fault_msg:
 	.word 0				# 32 bit align gdt_desc.address
 boot_gdt_descr:
 	.word __BOOT_DS+7
-	.long boot_gdt - __PAGE_OFFSET
+	.long pa(boot_gdt)
 
 	.word 0				# 32-bit align idt_desc.address
 idt_descr:
@@ -708,7 +812,7 @@ idt_descr:
 	.word 0				# 32 bit align gdt_desc.address
 ENTRY(early_gdt_descr)
 	.word GDT_ENTRIES*8-1
-	.long per_cpu__gdt_page		/* Overwritten for secondary CPUs */
+	.long cpu_gdt_table		/* Overwritten for secondary CPUs */
 
 /*
  * The boot_gdt must mirror the equivalent in setup.S and is
@@ -717,5 +821,65 @@ ENTRY(early_gdt_descr)
 	.align L1_CACHE_BYTES
 ENTRY(boot_gdt)
 	.fill GDT_ENTRY_BOOT_CS,8,0
-	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* kernel 4GB data at 0x00000000 */
+
+	.align PAGE_SIZE_asm
+ENTRY(cpu_gdt_table)
+	.rept NR_CPUS
+	.quad 0x0000000000000000	/* NULL descriptor */
+	.quad 0x0000000000000000	/* 0x0b reserved */
+	.quad 0x0000000000000000	/* 0x13 reserved */
+	.quad 0x0000000000000000	/* 0x1b reserved */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	.quad 0x00cf9b000000ffff	/* 0x20 alternate kernel 4GB code at 0x00000000 */
+#else
+	.quad 0x0000000000000000	/* 0x20 unused */
+#endif
+
+	.quad 0x0000000000000000	/* 0x28 unused */
+	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */
+	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */
+	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */
+	.quad 0x0000000000000000	/* 0x4b reserved */
+	.quad 0x0000000000000000	/* 0x53 reserved */
+	.quad 0x0000000000000000	/* 0x5b reserved */
+
+	.quad 0x00cf9b000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x73 user 4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x7b user 4GB data at 0x00000000 */
+
+	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
+	.quad 0x0000000000000000	/* 0x88 LDT descriptor */
+
+	/*
+	 * Segments used for calling PnP BIOS have byte granularity.
+	 * The code segments and data segments have fixed 64k limits,
+	 * the transfer segment sizes are set at run time.
+	 */
+	.quad 0x00409b000000ffff	/* 0x90 32-bit code */
+	.quad 0x00009b000000ffff	/* 0x98 16-bit code */
+	.quad 0x000093000000ffff	/* 0xa0 16-bit data */
+	.quad 0x0000930000000000	/* 0xa8 16-bit data */
+	.quad 0x0000930000000000	/* 0xb0 16-bit data */
+
+	/*
+	 * The APM segments have byte granularity and their bases
+	 * are set at run time.  All have 64k limits.
+	 */
+	.quad 0x00409b000000ffff	/* 0xb8 APM CS    code */
+	.quad 0x00009b000000ffff	/* 0xc0 APM CS 16 code (16 bit) */
+	.quad 0x004093000000ffff	/* 0xc8 APM DS    data */
+
+	.quad 0x00c0930000000000	/* 0xd0 - ESPFIX SS */
+	.quad 0x0040930000000000	/* 0xd8 - PERCPU */
+	.quad 0x0040910000000017	/* 0xe0 - STACK_CANARY */
+	.quad 0x0000000000000000	/* 0xe8 - PCIBIOS_CS */
+	.quad 0x0000000000000000	/* 0xf0 - PCIBIOS_DS */
+	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
+
+	/* Be sure this is zeroed to avoid false validations in Xen */
+	.fill PAGE_SIZE_asm - GDT_SIZE,1,0
+	.endr
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/head_64.S linux-2.6.32.60-pax/arch/x86/kernel/head_64.S
--- linux-2.6.32.60/arch/x86/kernel/head_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/head_64.S	2012-03-13 13:15:34.540098022 +0100
@@ -19,6 +19,8 @@
 #include <asm/cache.h>
 #include <asm/processor-flags.h>
 #include <asm/percpu.h>
+#include <asm/cpufeature.h>
+#include <asm/alternative-asm.h>
 
 #ifdef CONFIG_PARAVIRT
 #include <asm/asm-offsets.h>
@@ -38,6 +40,12 @@ L4_PAGE_OFFSET = pgd_index(__PAGE_OFFSET
 L3_PAGE_OFFSET = pud_index(__PAGE_OFFSET)
 L4_START_KERNEL = pgd_index(__START_KERNEL_map)
 L3_START_KERNEL = pud_index(__START_KERNEL_map)
+L4_VMALLOC_START = pgd_index(VMALLOC_START)
+L3_VMALLOC_START = pud_index(VMALLOC_START)
+L4_VMALLOC_END = pgd_index(VMALLOC_END)
+L3_VMALLOC_END = pud_index(VMALLOC_END)
+L4_VMEMMAP_START = pgd_index(VMEMMAP_START)
+L3_VMEMMAP_START = pud_index(VMEMMAP_START)
 
 	.text
 	__HEAD
@@ -85,35 +93,23 @@ startup_64:
 	 */
 	addq	%rbp, init_level4_pgt + 0(%rip)
 	addq	%rbp, init_level4_pgt + (L4_PAGE_OFFSET*8)(%rip)
+	addq	%rbp, init_level4_pgt + (L4_VMALLOC_START*8)(%rip)
+	addq	%rbp, init_level4_pgt + (L4_VMALLOC_END*8)(%rip)
+	addq	%rbp, init_level4_pgt + (L4_VMEMMAP_START*8)(%rip)
 	addq	%rbp, init_level4_pgt + (L4_START_KERNEL*8)(%rip)
 
 	addq	%rbp, level3_ident_pgt + 0(%rip)
+#ifndef CONFIG_XEN
+	addq	%rbp, level3_ident_pgt + 8(%rip)
+#endif
 
-	addq	%rbp, level3_kernel_pgt + (510*8)(%rip)
-	addq	%rbp, level3_kernel_pgt + (511*8)(%rip)
+	addq	%rbp, level3_vmemmap_pgt + (L3_VMEMMAP_START*8)(%rip)
 
-	addq	%rbp, level2_fixmap_pgt + (506*8)(%rip)
+	addq	%rbp, level3_kernel_pgt + (L3_START_KERNEL*8)(%rip)
+	addq	%rbp, level3_kernel_pgt + (L3_START_KERNEL*8+8)(%rip)
 
-	/* Add an Identity mapping if I am above 1G */
-	leaq	_text(%rip), %rdi
-	andq	$PMD_PAGE_MASK, %rdi
-
-	movq	%rdi, %rax
-	shrq	$PUD_SHIFT, %rax
-	andq	$(PTRS_PER_PUD - 1), %rax
-	jz	ident_complete
-
-	leaq	(level2_spare_pgt - __START_KERNEL_map + _KERNPG_TABLE)(%rbp), %rdx
-	leaq	level3_ident_pgt(%rip), %rbx
-	movq	%rdx, 0(%rbx, %rax, 8)
-
-	movq	%rdi, %rax
-	shrq	$PMD_SHIFT, %rax
-	andq	$(PTRS_PER_PMD - 1), %rax
-	leaq	__PAGE_KERNEL_IDENT_LARGE_EXEC(%rdi), %rdx
-	leaq	level2_spare_pgt(%rip), %rbx
-	movq	%rdx, 0(%rbx, %rax, 8)
-ident_complete:
+	addq	%rbp, level2_fixmap_pgt + (506*8)(%rip)
+	addq	%rbp, level2_fixmap_pgt + (507*8)(%rip)
 
 	/*
 	 * Fixup the kernel text+data virtual addresses. Note that
@@ -161,8 +157,8 @@ ENTRY(secondary_startup_64)
 	 * after the boot processor executes this code.
 	 */
 
-	/* Enable PAE mode and PGE */
-	movl	$(X86_CR4_PAE | X86_CR4_PGE), %eax
+	/* Enable PAE mode and PSE/PGE */
+	movl	$(X86_CR4_PSE | X86_CR4_PAE | X86_CR4_PGE), %eax
 	movq	%rax, %cr4
 
 	/* Setup early boot stage 4 level pagetables. */
@@ -184,9 +180,16 @@ ENTRY(secondary_startup_64)
 	movl	$MSR_EFER, %ecx
 	rdmsr
 	btsl	$_EFER_SCE, %eax	/* Enable System Call */
-	btl	$20,%edi		/* No Execute supported? */
+	btl	$(X86_FEATURE_NX & 31),%edi	/* No Execute supported? */
 	jnc     1f
 	btsl	$_EFER_NX, %eax
+	leaq	init_level4_pgt(%rip), %rdi
+#ifndef CONFIG_EFI
+	btsq	$_PAGE_BIT_NX, 8*L4_PAGE_OFFSET(%rdi)
+#endif
+	btsq	$_PAGE_BIT_NX, 8*L4_VMALLOC_START(%rdi)
+	btsq	$_PAGE_BIT_NX, 8*L4_VMALLOC_END(%rdi)
+	btsq	$_PAGE_BIT_NX, 8*L4_VMEMMAP_START(%rdi)
 1:	wrmsr				/* Make changes effective */
 
 	/* Setup cr0 */
@@ -249,6 +252,7 @@ ENTRY(secondary_startup_64)
 	 * jump.  In addition we need to ensure %cs is set so we make this
 	 * a far return.
 	 */
+	pax_set_fptr_mask
 	movq	initial_code(%rip),%rax
 	pushq	$0		# fake return address to stop unwinder
 	pushq	$__KERNEL_CS	# set correct cs
@@ -262,16 +266,16 @@ ENTRY(secondary_startup_64)
 	.quad	x86_64_start_kernel
 	ENTRY(initial_gs)
 	.quad	INIT_PER_CPU_VAR(irq_stack_union)
-	__FINITDATA
 
 	ENTRY(stack_start)
 	.quad  init_thread_union+THREAD_SIZE-8
 	.word  0
+	__FINITDATA
 
 bad_address:
 	jmp bad_address
 
-	.section ".init.text","ax"
+	__INIT
 #ifdef CONFIG_EARLY_PRINTK
 	.globl early_idt_handlers
 early_idt_handlers:
@@ -316,18 +320,23 @@ ENTRY(early_idt_handler)
 #endif /* EARLY_PRINTK */
 1:	hlt
 	jmp 1b
+	.previous
 
 #ifdef CONFIG_EARLY_PRINTK
+	__INITDATA
 early_recursion_flag:
 	.long 0
+	.previous
 
+	.section .rodata,"a",@progbits
 early_idt_msg:
 	.asciz "PANIC: early exception %02lx rip %lx:%lx error %lx cr2 %lx\n"
 early_idt_ripmsg:
 	.asciz "RIP %s\n"
-#endif /* CONFIG_EARLY_PRINTK */
 	.previous
+#endif /* CONFIG_EARLY_PRINTK */
 
+	.section .rodata,"a",@progbits
 #define NEXT_PAGE(name) \
 	.balign	PAGE_SIZE; \
 ENTRY(name)
@@ -350,13 +359,41 @@ NEXT_PAGE(init_level4_pgt)
 	.quad	level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
 	.org	init_level4_pgt + L4_PAGE_OFFSET*8, 0
 	.quad	level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
+	.org	init_level4_pgt + L4_VMALLOC_START*8, 0
+	.quad	level3_vmalloc_start_pgt - __START_KERNEL_map + _KERNPG_TABLE
+	.org	init_level4_pgt + L4_VMALLOC_END*8, 0
+	.quad	level3_vmalloc_end_pgt - __START_KERNEL_map + _KERNPG_TABLE
+	.org	init_level4_pgt + L4_VMEMMAP_START*8, 0
+	.quad	level3_vmemmap_pgt - __START_KERNEL_map + _KERNPG_TABLE
 	.org	init_level4_pgt + L4_START_KERNEL*8, 0
 	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
 	.quad	level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+NEXT_PAGE(cpu_pgd)
+	.rept NR_CPUS
+	.fill	512,8,0
+	.endr
+#endif
+
 NEXT_PAGE(level3_ident_pgt)
 	.quad	level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
+#ifdef CONFIG_XEN
 	.fill	511,8,0
+#else
+	.quad	level2_ident_pgt + PAGE_SIZE - __START_KERNEL_map + _KERNPG_TABLE
+	.fill	510,8,0
+#endif
+
+NEXT_PAGE(level3_vmalloc_start_pgt)
+	.fill	512,8,0
+
+NEXT_PAGE(level3_vmalloc_end_pgt)
+	.fill	512,8,0
+
+NEXT_PAGE(level3_vmemmap_pgt)
+	.fill	L3_VMEMMAP_START,8,0
+	.quad	level2_vmemmap_pgt - __START_KERNEL_map + _KERNPG_TABLE
 
 NEXT_PAGE(level3_kernel_pgt)
 	.fill	L3_START_KERNEL,8,0
@@ -364,20 +401,23 @@ NEXT_PAGE(level3_kernel_pgt)
 	.quad	level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE
 	.quad	level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
 
+NEXT_PAGE(level2_vmemmap_pgt)
+	.fill	512,8,0
+
 NEXT_PAGE(level2_fixmap_pgt)
-	.fill	506,8,0
-	.quad	level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
-	/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */
-	.fill	5,8,0
+	.fill	507,8,0
+	.quad	level1_vsyscall_pgt - __START_KERNEL_map + _PAGE_TABLE
+	/* 6MB reserved for vsyscalls + a 2MB hole = 3 + 1 entries */
+	.fill	4,8,0
 
-NEXT_PAGE(level1_fixmap_pgt)
+NEXT_PAGE(level1_vsyscall_pgt)
 	.fill	512,8,0
 
-NEXT_PAGE(level2_ident_pgt)
-	/* Since I easily can, map the first 1G.
+	/* Since I easily can, map the first 2G.
 	 * Don't set NX because code runs from these pages.
 	 */
-	PMDS(0, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)
+NEXT_PAGE(level2_ident_pgt)
+	PMDS(0, __PAGE_KERNEL_IDENT_LARGE_EXEC, 2*PTRS_PER_PMD)
 
 NEXT_PAGE(level2_kernel_pgt)
 	/*
@@ -390,33 +430,55 @@ NEXT_PAGE(level2_kernel_pgt)
 	 *  If you want to increase this then increase MODULES_VADDR
 	 *  too.)
 	 */
-	PMDS(0, __PAGE_KERNEL_LARGE_EXEC,
-		KERNEL_IMAGE_SIZE/PMD_SIZE)
-
-NEXT_PAGE(level2_spare_pgt)
-	.fill   512, 8, 0
+	PMDS(0, __PAGE_KERNEL_LARGE_EXEC, KERNEL_IMAGE_SIZE/PMD_SIZE)
 
 #undef PMDS
 #undef NEXT_PAGE
 
-	.data
+	.align PAGE_SIZE
+ENTRY(cpu_gdt_table)
+	.rept NR_CPUS
+	.quad	0x0000000000000000	/* NULL descriptor */
+	.quad	0x00cf9b000000ffff	/* __KERNEL32_CS */
+	.quad	0x00af9b000000ffff	/* __KERNEL_CS */
+	.quad	0x00cf93000000ffff	/* __KERNEL_DS */
+	.quad	0x00cffb000000ffff	/* __USER32_CS */
+	.quad	0x00cff3000000ffff	/* __USER_DS, __USER32_DS  */
+	.quad	0x00affb000000ffff	/* __USER_CS */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	.quad	0x00af9b000000ffff	/* __KERNEXEC_KERNEL_CS */
+#else
+	.quad	0x0			/* unused */
+#endif
+
+	.quad	0,0			/* TSS */
+	.quad	0,0			/* LDT */
+	.quad	0,0,0			/* three TLS descriptors */
+	.quad	0x0000f40000000000	/* node/CPU stored in limit */
+	/* asm/segment.h:GDT_ENTRIES must match this */
+
+	/* zero the remaining page */
+	.fill PAGE_SIZE / 8 - GDT_ENTRIES,8,0
+	.endr
+
 	.align 16
 	.globl early_gdt_descr
 early_gdt_descr:
 	.word	GDT_ENTRIES*8-1
 early_gdt_descr_base:
-	.quad	INIT_PER_CPU_VAR(gdt_page)
+	.quad	cpu_gdt_table
 
 ENTRY(phys_base)
 	/* This must match the first entry in level2_kernel_pgt */
 	.quad   0x0000000000000000
 
 #include "../../x86/xen/xen-head.S"
-	
-	.section .bss, "aw", @nobits
+
+	.section .rodata,"a",@progbits
 	.align L1_CACHE_BYTES
 ENTRY(idt_table)
-	.skip IDT_ENTRIES * 16
+	.fill 512,8,0
 
 	__PAGE_ALIGNED_BSS
 	.align PAGE_SIZE
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/i386_ksyms_32.c linux-2.6.32.60-pax/arch/x86/kernel/i386_ksyms_32.c
--- linux-2.6.32.60/arch/x86/kernel/i386_ksyms_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/i386_ksyms_32.c	2012-03-13 13:15:34.540098022 +0100
@@ -20,8 +20,12 @@ extern void cmpxchg8b_emu(void);
 EXPORT_SYMBOL(cmpxchg8b_emu);
 #endif
 
+EXPORT_SYMBOL_GPL(cpu_gdt_table);
+
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_generic);
+EXPORT_SYMBOL(csum_partial_copy_generic_to_user);
+EXPORT_SYMBOL(csum_partial_copy_generic_from_user);
 
 EXPORT_SYMBOL(__get_user_1);
 EXPORT_SYMBOL(__get_user_2);
@@ -36,3 +40,7 @@ EXPORT_SYMBOL(strstr);
 
 EXPORT_SYMBOL(csum_partial);
 EXPORT_SYMBOL(empty_zero_page);
+
+#ifdef CONFIG_PAX_KERNEXEC
+EXPORT_SYMBOL(__LOAD_PHYSICAL_ADDR);
+#endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/i8259.c linux-2.6.32.60-pax/arch/x86/kernel/i8259.c
--- linux-2.6.32.60/arch/x86/kernel/i8259.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/i8259.c	2012-03-13 13:15:34.540098022 +0100
@@ -208,7 +208,7 @@ spurious_8259A_irq:
 			       "spurious 8259A interrupt: IRQ%d.\n", irq);
 			spurious_irq_mask |= irqmask;
 		}
-		atomic_inc(&irq_err_count);
+		atomic_inc_unchecked(&irq_err_count);
 		/*
 		 * Theoretically we do not have to handle this IRQ,
 		 * but in Linux this does not cause problems and is
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/init_task.c linux-2.6.32.60-pax/arch/x86/kernel/init_task.c
--- linux-2.6.32.60/arch/x86/kernel/init_task.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/init_task.c	2012-03-13 13:15:34.540098022 +0100
@@ -20,8 +20,7 @@ static struct sighand_struct init_sighan
  * way process stacks are handled. This is done by having a special
  * "init_task" linker map entry..
  */
-union thread_union init_thread_union __init_task_data =
-	{ INIT_THREAD_INFO(init_task) };
+union thread_union init_thread_union __init_task_data;
 
 /*
  * Initial task structure.
@@ -38,5 +37,5 @@ EXPORT_SYMBOL(init_task);
  * section. Since TSS's are completely CPU-local, we want them
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */
-DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss) = INIT_TSS;
-
+struct tss_struct init_tss[NR_CPUS] ____cacheline_internodealigned_in_smp = { [0 ... NR_CPUS-1] = INIT_TSS };
+EXPORT_SYMBOL(init_tss);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/ioport.c linux-2.6.32.60-pax/arch/x86/kernel/ioport.c
--- linux-2.6.32.60/arch/x86/kernel/ioport.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/ioport.c	2012-03-13 13:15:34.544098021 +0100
@@ -67,7 +67,7 @@ asmlinkage long sys_ioperm(unsigned long
 	 * because the ->io_bitmap_max value must match the bitmap
 	 * contents:
 	 */
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 
 	set_bitmap(t->io_bitmap_ptr, from, num, !turn_on);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/irq_32.c linux-2.6.32.60-pax/arch/x86/kernel/irq_32.c
--- linux-2.6.32.60/arch/x86/kernel/irq_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/irq_32.c	2012-03-13 13:15:34.544098021 +0100
@@ -35,7 +35,7 @@ static int check_stack_overflow(void)
 	__asm__ __volatile__("andl %%esp,%0" :
 			     "=r" (sp) : "0" (THREAD_SIZE - 1));
 
-	return sp < (sizeof(struct thread_info) + STACK_WARN);
+	return sp < STACK_WARN;
 }
 
 static void print_stack_overflow(void)
@@ -54,9 +54,9 @@ static inline void print_stack_overflow(
  * per-CPU IRQ handling contexts (thread information and stack)
  */
 union irq_ctx {
-	struct thread_info      tinfo;
-	u32                     stack[THREAD_SIZE/sizeof(u32)];
-} __attribute__((aligned(PAGE_SIZE)));
+	unsigned long		previous_esp;
+	u32			stack[THREAD_SIZE/sizeof(u32)];
+} __attribute__((aligned(THREAD_SIZE)));
 
 static DEFINE_PER_CPU(union irq_ctx *, hardirq_ctx);
 static DEFINE_PER_CPU(union irq_ctx *, softirq_ctx);
@@ -78,10 +78,9 @@ static void call_on_stack(void *func, vo
 static inline int
 execute_on_irq_stack(int overflow, struct irq_desc *desc, int irq)
 {
-	union irq_ctx *curctx, *irqctx;
+	union irq_ctx *irqctx;
 	u32 *isp, arg1, arg2;
 
-	curctx = (union irq_ctx *) current_thread_info();
 	irqctx = __get_cpu_var(hardirq_ctx);
 
 	/*
@@ -90,21 +89,16 @@ execute_on_irq_stack(int overflow, struc
 	 * handler) we can't do that and just have to keep using the
 	 * current stack (which is the irq stack already after all)
 	 */
-	if (unlikely(curctx == irqctx))
+	if (unlikely((void *)current_stack_pointer - (void *)irqctx < THREAD_SIZE))
 		return 0;
 
 	/* build the stack frame on the IRQ stack */
-	isp = (u32 *) ((char *)irqctx + sizeof(*irqctx));
-	irqctx->tinfo.task = curctx->tinfo.task;
-	irqctx->tinfo.previous_esp = current_stack_pointer;
+	isp = (u32 *) ((char *)irqctx + sizeof(*irqctx) - 8);
+	irqctx->previous_esp = current_stack_pointer;
 
-	/*
-	 * Copy the softirq bits in preempt_count so that the
-	 * softirq checks work in the hardirq context.
-	 */
-	irqctx->tinfo.preempt_count =
-		(irqctx->tinfo.preempt_count & ~SOFTIRQ_MASK) |
-		(curctx->tinfo.preempt_count & SOFTIRQ_MASK);
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	__set_fs(MAKE_MM_SEG(0));
+#endif
 
 	if (unlikely(overflow))
 		call_on_stack(print_stack_overflow, isp);
@@ -116,6 +110,11 @@ execute_on_irq_stack(int overflow, struc
 		     :  "0" (irq),   "1" (desc),  "2" (isp),
 			"D" (desc->handle_irq)
 		     : "memory", "cc", "ecx");
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	__set_fs(current_thread_info()->addr_limit);
+#endif
+
 	return 1;
 }
 
@@ -124,28 +123,11 @@ execute_on_irq_stack(int overflow, struc
  */
 void __cpuinit irq_ctx_init(int cpu)
 {
-	union irq_ctx *irqctx;
-
 	if (per_cpu(hardirq_ctx, cpu))
 		return;
 
-	irqctx = &per_cpu(hardirq_stack, cpu);
-	irqctx->tinfo.task		= NULL;
-	irqctx->tinfo.exec_domain	= NULL;
-	irqctx->tinfo.cpu		= cpu;
-	irqctx->tinfo.preempt_count	= HARDIRQ_OFFSET;
-	irqctx->tinfo.addr_limit	= MAKE_MM_SEG(0);
-
-	per_cpu(hardirq_ctx, cpu) = irqctx;
-
-	irqctx = &per_cpu(softirq_stack, cpu);
-	irqctx->tinfo.task		= NULL;
-	irqctx->tinfo.exec_domain	= NULL;
-	irqctx->tinfo.cpu		= cpu;
-	irqctx->tinfo.preempt_count	= 0;
-	irqctx->tinfo.addr_limit	= MAKE_MM_SEG(0);
-
-	per_cpu(softirq_ctx, cpu) = irqctx;
+	per_cpu(hardirq_ctx, cpu) = &per_cpu(hardirq_stack, cpu);
+	per_cpu(softirq_ctx, cpu) = &per_cpu(softirq_stack, cpu);
 
 	printk(KERN_DEBUG "CPU %u irqstacks, hard=%p soft=%p\n",
 	       cpu, per_cpu(hardirq_ctx, cpu),  per_cpu(softirq_ctx, cpu));
@@ -159,7 +141,6 @@ void irq_ctx_exit(int cpu)
 asmlinkage void do_softirq(void)
 {
 	unsigned long flags;
-	struct thread_info *curctx;
 	union irq_ctx *irqctx;
 	u32 *isp;
 
@@ -169,15 +150,22 @@ asmlinkage void do_softirq(void)
 	local_irq_save(flags);
 
 	if (local_softirq_pending()) {
-		curctx = current_thread_info();
 		irqctx = __get_cpu_var(softirq_ctx);
-		irqctx->tinfo.task = curctx->task;
-		irqctx->tinfo.previous_esp = current_stack_pointer;
+		irqctx->previous_esp = current_stack_pointer;
 
 		/* build the stack frame on the softirq stack */
-		isp = (u32 *) ((char *)irqctx + sizeof(*irqctx));
+		isp = (u32 *) ((char *)irqctx + sizeof(*irqctx) - 8);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		__set_fs(MAKE_MM_SEG(0));
+#endif
 
 		call_on_stack(__do_softirq, isp);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		__set_fs(current_thread_info()->addr_limit);
+#endif
+
 		/*
 		 * Shouldnt happen, we returned above if in_interrupt():
 		 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/irq.c linux-2.6.32.60-pax/arch/x86/kernel/irq.c
--- linux-2.6.32.60/arch/x86/kernel/irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/irq.c	2012-03-13 13:15:34.544098021 +0100
@@ -15,7 +15,7 @@
 #include <asm/mce.h>
 #include <asm/hw_irq.h>
 
-atomic_t irq_err_count;
+atomic_unchecked_t irq_err_count;
 
 /* Function pointer for generic interrupt vector handling */
 void (*generic_interrupt_extension)(void) = NULL;
@@ -114,9 +114,9 @@ static int show_other_interrupts(struct
 		seq_printf(p, "%10u ", per_cpu(mce_poll_count, j));
 	seq_printf(p, "  Machine check polls\n");
 #endif
-	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
+	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read_unchecked(&irq_err_count));
 #if defined(CONFIG_X86_IO_APIC)
-	seq_printf(p, "%*s: %10u\n", prec, "MIS", atomic_read(&irq_mis_count));
+	seq_printf(p, "%*s: %10u\n", prec, "MIS", atomic_read_unchecked(&irq_mis_count));
 #endif
 	return 0;
 }
@@ -209,10 +209,10 @@ u64 arch_irq_stat_cpu(unsigned int cpu)
 
 u64 arch_irq_stat(void)
 {
-	u64 sum = atomic_read(&irq_err_count);
+	u64 sum = atomic_read_unchecked(&irq_err_count);
 
 #ifdef CONFIG_X86_IO_APIC
-	sum += atomic_read(&irq_mis_count);
+	sum += atomic_read_unchecked(&irq_mis_count);
 #endif
 	return sum;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/kdebugfs.c linux-2.6.32.60-pax/arch/x86/kernel/kdebugfs.c
--- linux-2.6.32.60/arch/x86/kernel/kdebugfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/kdebugfs.c	2012-08-12 13:33:23.117243412 +0200
@@ -26,7 +26,7 @@ struct setup_data_node {
 	u32 len;
 };
 
-static ssize_t setup_data_read(struct file *file, char __user *user_buf,
+static ssize_t __size_overflow(3) setup_data_read(struct file *file, char __user *user_buf,
 			       size_t count, loff_t *ppos)
 {
 	struct setup_data_node *node = file->private_data;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/kgdb.c linux-2.6.32.60-pax/arch/x86/kernel/kgdb.c
--- linux-2.6.32.60/arch/x86/kernel/kgdb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/kgdb.c	2012-12-14 21:46:13.969852452 +0100
@@ -42,6 +42,7 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/nmi.h>
+#include <linux/uaccess.h>
 
 #include <asm/apicdef.h>
 #include <asm/system.h>
@@ -220,8 +221,12 @@ static void kgdb_correct_hw_break(void)
 			dr7 |= ((breakinfo[breakno].len << 2) |
 				 breakinfo[breakno].type) <<
 			       ((breakno << 2) + 16);
-			if (breakno >= 0 && breakno <= 3)
-				set_debugreg(breakinfo[breakno].addr, breakno);
+			if (breakno >= 0 && breakno <= 3) {
+				if (breakinfo[breakno].type == 0)
+					set_debugreg(ktla_ktva(breakinfo[breakno].addr), breakno);
+				else
+					set_debugreg(breakinfo[breakno].addr, breakno);
+			}
 
 		} else {
 			if ((dr7 & breakbit) && !breakinfo[breakno].enabled) {
@@ -390,13 +395,13 @@ int kgdb_arch_handle_exception(int e_vec
 
 		/* clear the trace bit */
 		linux_regs->flags &= ~X86_EFLAGS_TF;
-		atomic_set(&kgdb_cpu_doing_single_step, -1);
+		atomic_set_unchecked(&kgdb_cpu_doing_single_step, -1);
 
 		/* set the trace bit if we're stepping */
 		if (remcomInBuffer[0] == 's') {
 			linux_regs->flags |= X86_EFLAGS_TF;
 			kgdb_single_step = 1;
-			atomic_set(&kgdb_cpu_doing_single_step,
+			atomic_set_unchecked(&kgdb_cpu_doing_single_step,
 				   raw_smp_processor_id());
 		}
 
@@ -476,7 +481,7 @@ static int __kgdb_notify(struct die_args
 		break;
 
 	case DIE_DEBUG:
-		if (atomic_read(&kgdb_cpu_doing_single_step) ==
+		if (atomic_read_unchecked(&kgdb_cpu_doing_single_step) ==
 		    raw_smp_processor_id()) {
 			if (user_mode(regs))
 				return single_step_cont(regs, args);
@@ -573,6 +578,26 @@ unsigned long kgdb_arch_pc(int exception
 	return instruction_pointer(regs);
 }
 
+int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr)
+{
+	int err;
+
+	addr = ktla_ktva(addr);
+	err = probe_kernel_read(saved_instr, (char *)addr, BREAK_INSTR_SIZE);
+	if (err)
+		return err;
+
+	return probe_kernel_write((char *)addr, arch_kgdb_ops.gdb_bpt_instr,
+				  BREAK_INSTR_SIZE);
+}
+
+int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle)
+{
+	addr = ktla_ktva(addr);
+	return probe_kernel_write((char *)addr,
+				  (char *)bundle, BREAK_INSTR_SIZE);
+}
+
 struct kgdb_arch arch_kgdb_ops = {
 	/* Breakpoint instruction: */
 	.gdb_bpt_instr		= { 0xcc },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/kprobes.c linux-2.6.32.60-pax/arch/x86/kernel/kprobes.c
--- linux-2.6.32.60/arch/x86/kernel/kprobes.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/kprobes.c	2012-12-14 20:55:58.509777358 +0100
@@ -168,9 +168,13 @@ static void __kprobes set_jmp_op(void *f
 		char op;
 		s32 raddr;
 	} __attribute__((packed)) * jop;
-	jop = (struct __arch_jmp_op *)from;
+
+	jop = (struct __arch_jmp_op *)(ktla_ktva(from));
+
+	pax_open_kernel();
 	jop->raddr = (s32)((long)(to) - ((long)(from) + 5));
 	jop->op = RELATIVEJUMP_INSTRUCTION;
+	pax_close_kernel();
 }
 
 /*
@@ -195,7 +199,7 @@ static int __kprobes can_boost(kprobe_op
 	kprobe_opcode_t opcode;
 	kprobe_opcode_t *orig_opcodes = opcodes;
 
-	if (search_exception_tables((unsigned long)opcodes))
+	if (search_exception_tables(ktva_ktla((unsigned long)opcodes)))
 		return 0;	/* Page fault may occur on this address. */
 
 retry:
@@ -339,7 +343,9 @@ static void __kprobes fix_riprel(struct
 			disp = (u8 *) p->addr + *((s32 *) insn) -
 			       (u8 *) p->ainsn.insn;
 			BUG_ON((s64) (s32) disp != disp); /* Sanity check.  */
+			pax_open_kernel();
 			*(s32 *)insn = (s32) disp;
+			pax_close_kernel();
 		}
 	}
 #endif
@@ -347,16 +353,18 @@ static void __kprobes fix_riprel(struct
 
 static void __kprobes arch_copy_kprobe(struct kprobe *p)
 {
-	memcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE * sizeof(kprobe_opcode_t));
+	pax_open_kernel();
+	memcpy(p->ainsn.insn, ktla_ktva(p->addr), MAX_INSN_SIZE * sizeof(kprobe_opcode_t));
+	pax_close_kernel();
 
 	fix_riprel(p);
 
-	if (can_boost(p->addr))
+	if (can_boost(ktla_ktva(p->addr)))
 		p->ainsn.boostable = 0;
 	else
 		p->ainsn.boostable = -1;
 
-	p->opcode = *p->addr;
+	p->opcode = *(ktla_ktva(p->addr));
 }
 
 int __kprobes arch_prepare_kprobe(struct kprobe *p)
@@ -432,9 +440,9 @@ static void __kprobes prepare_singlestep
 	regs->flags &= ~X86_EFLAGS_IF;
 	/* single step inline if the instruction is an int3 */
 	if (p->opcode == BREAKPOINT_INSTRUCTION)
-		regs->ip = (unsigned long)p->addr;
+		regs->ip = ktla_ktva((unsigned long)p->addr);
 	else
-		regs->ip = (unsigned long)p->ainsn.insn;
+		regs->ip = ktva_ktla((unsigned long)p->ainsn.insn);
 }
 
 void __kprobes arch_prepare_kretprobe(struct kretprobe_instance *ri,
@@ -455,7 +463,7 @@ static void __kprobes setup_singlestep(s
 	if (p->ainsn.boostable == 1 && !p->post_handler) {
 		/* Boost up -- we can execute copied instructions directly */
 		reset_current_kprobe();
-		regs->ip = (unsigned long)p->ainsn.insn;
+		regs->ip = ktva_ktla((unsigned long)p->ainsn.insn);
 		preempt_enable_no_resched();
 		return;
 	}
@@ -525,7 +533,7 @@ static int __kprobes kprobe_handler(stru
 	struct kprobe_ctlblk *kcb;
 
 	addr = (kprobe_opcode_t *)(regs->ip - sizeof(kprobe_opcode_t));
-	if (*addr != BREAKPOINT_INSTRUCTION) {
+	if (*(kprobe_opcode_t *)ktla_ktva((unsigned long)addr) != BREAKPOINT_INSTRUCTION) {
 		/*
 		 * The breakpoint instruction was removed right
 		 * after we hit it.  Another cpu has removed
@@ -637,6 +645,9 @@ static void __used __kprobes kretprobe_t
 			/* Skip orig_ax, ip, cs */
 			"	addq $24, %rsp\n"
 			"	popfq\n"
+#ifdef KERNEXEC_PLUGIN
+			"	btsq $63,(%rsp)\n"
+#endif
 #else
 			"	pushf\n"
 			/*
@@ -777,7 +788,7 @@ static void __kprobes resume_execution(s
 		struct pt_regs *regs, struct kprobe_ctlblk *kcb)
 {
 	unsigned long *tos = stack_addr(regs);
-	unsigned long copy_ip = (unsigned long)p->ainsn.insn;
+	unsigned long copy_ip = ktva_ktla((unsigned long)p->ainsn.insn);
 	unsigned long orig_ip = (unsigned long)p->addr;
 	kprobe_opcode_t *insn = p->ainsn.insn;
 
@@ -960,7 +971,7 @@ int __kprobes kprobe_exceptions_notify(s
 	struct die_args *args = data;
 	int ret = NOTIFY_DONE;
 
-	if (args->regs && user_mode_vm(args->regs))
+	if (args->regs && user_mode(args->regs))
 		return ret;
 
 	switch (val) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/kvm.c linux-2.6.32.60-pax/arch/x86/kernel/kvm.c
--- linux-2.6.32.60/arch/x86/kernel/kvm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/kvm.c	2013-02-17 17:37:48.300099103 +0100
@@ -216,6 +216,7 @@ static void __init paravirt_ops_setup(vo
 		pv_mmu_ops.set_pud = kvm_set_pud;
 #if PAGETABLE_LEVELS == 4
 		pv_mmu_ops.set_pgd = kvm_set_pgd;
+		pv_mmu_ops.set_pgd_batched = kvm_set_pgd;
 #endif
 #endif
 		pv_mmu_ops.flush_tlb_user = kvm_flush_tlb;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/ldt.c linux-2.6.32.60-pax/arch/x86/kernel/ldt.c
--- linux-2.6.32.60/arch/x86/kernel/ldt.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/ldt.c	2012-05-20 19:21:25.289167262 +0200
@@ -66,13 +66,13 @@ static int alloc_ldt(mm_context_t *pc, i
 	if (reload) {
 #ifdef CONFIG_SMP
 		preempt_disable();
-		load_LDT(pc);
+		load_LDT_nolock(pc);
 		if (!cpumask_equal(mm_cpumask(current->mm),
 				   cpumask_of(smp_processor_id())))
 			smp_call_function(flush_ldt, current->mm, 1);
 		preempt_enable();
 #else
-		load_LDT(pc);
+		load_LDT_nolock(pc);
 #endif
 	}
 	if (oldsize) {
@@ -94,7 +94,7 @@ static inline int copy_ldt(mm_context_t
 		return err;
 
 	for (i = 0; i < old->size; i++)
-		write_ldt_entry(new->ldt, i, old->ldt + i * LDT_ENTRY_SIZE);
+		write_ldt_entry(new->ldt, i, old->ldt + i);
 	return 0;
 }
 
@@ -115,6 +115,24 @@ int init_new_context(struct task_struct
 		retval = copy_ldt(&mm->context, &old_mm->context);
 		mutex_unlock(&old_mm->context.lock);
 	}
+
+	if (tsk == current) {
+		mm->context.vdso = 0;
+
+#ifdef CONFIG_X86_32
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		mm->context.user_cs_base = 0UL;
+		mm->context.user_cs_limit = ~0UL;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpus_clear(mm->context.cpu_user_cs_mask);
+#endif
+
+#endif
+#endif
+
+	}
+
 	return retval;
 }
 
@@ -229,6 +247,13 @@ static int write_ldt(void __user *ptr, u
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & MODIFY_LDT_CONTENTS_CODE)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	fill_ldt(&ldt, &ldt_info);
 	if (oldmode)
 		ldt.avl = 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/machine_kexec_32.c linux-2.6.32.60-pax/arch/x86/kernel/machine_kexec_32.c
--- linux-2.6.32.60/arch/x86/kernel/machine_kexec_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/machine_kexec_32.c	2012-03-13 13:15:34.548098021 +0100
@@ -26,7 +26,7 @@
 #include <asm/system.h>
 #include <asm/cacheflush.h>
 
-static void set_idt(void *newidt, __u16 limit)
+static void set_idt(struct desc_struct *newidt, __u16 limit)
 {
 	struct desc_ptr curidt;
 
@@ -38,7 +38,7 @@ static void set_idt(void *newidt, __u16
 }
 
 
-static void set_gdt(void *newgdt, __u16 limit)
+static void set_gdt(struct desc_struct *newgdt, __u16 limit)
 {
 	struct desc_ptr curgdt;
 
@@ -217,7 +217,7 @@ void machine_kexec(struct kimage *image)
 	}
 
 	control_page = page_address(image->control_code_page);
-	memcpy(control_page, relocate_kernel, KEXEC_CONTROL_CODE_MAX_SIZE);
+	memcpy(control_page, (void *)ktla_ktva((unsigned long)relocate_kernel), KEXEC_CONTROL_CODE_MAX_SIZE);
 
 	relocate_kernel_ptr = control_page;
 	page_list[PA_CONTROL_PAGE] = __pa(control_page);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/microcode_intel.c linux-2.6.32.60-pax/arch/x86/kernel/microcode_intel.c
--- linux-2.6.32.60/arch/x86/kernel/microcode_intel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/microcode_intel.c	2012-05-20 19:28:06.233188976 +0200
@@ -443,13 +443,13 @@ static enum ucode_state request_microcod
 
 static int get_ucode_user(void *to, const void *from, size_t n)
 {
-	return copy_from_user(to, from, n);
+	return copy_from_user(to, (const void __force_user *)from, n);
 }
 
 static enum ucode_state
 request_microcode_user(int cpu, const void __user *buf, size_t size)
 {
-	return generic_load_microcode(cpu, (void *)buf, size, &get_ucode_user);
+	return generic_load_microcode(cpu, (__force_kernel void *)buf, size, &get_ucode_user);
 }
 
 static void microcode_fini_cpu(int cpu)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/module.c linux-2.6.32.60-pax/arch/x86/kernel/module.c
--- linux-2.6.32.60/arch/x86/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/module.c	2012-03-13 13:15:34.552098021 +0100
@@ -34,7 +34,7 @@
 #define DEBUGP(fmt...)
 #endif
 
-void *module_alloc(unsigned long size)
+static void *__module_alloc(unsigned long size, pgprot_t prot)
 {
 	struct vm_struct *area;
 
@@ -48,8 +48,18 @@ void *module_alloc(unsigned long size)
 	if (!area)
 		return NULL;
 
-	return __vmalloc_area(area, GFP_KERNEL | __GFP_HIGHMEM,
-					PAGE_KERNEL_EXEC);
+	return __vmalloc_area(area, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO, prot);
+}
+
+void *module_alloc(unsigned long size)
+{
+
+#ifdef CONFIG_PAX_KERNEXEC
+	return __module_alloc(size, PAGE_KERNEL);
+#else
+	return __module_alloc(size, PAGE_KERNEL_EXEC);
+#endif
+
 }
 
 /* Free memory returned from module_alloc */
@@ -58,6 +68,40 @@ void module_free(struct module *mod, voi
 	vfree(module_region);
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_X86_32
+void *module_alloc_exec(unsigned long size)
+{
+	struct vm_struct *area;
+
+	if (size == 0)
+		return NULL;
+
+	area = __get_vm_area(size, VM_ALLOC, (unsigned long)&MODULES_EXEC_VADDR, (unsigned long)&MODULES_EXEC_END);
+	return area ? area->addr : NULL;
+}
+EXPORT_SYMBOL(module_alloc_exec);
+
+void module_free_exec(struct module *mod, void *module_region)
+{
+	vunmap(module_region);
+}
+EXPORT_SYMBOL(module_free_exec);
+#else
+void module_free_exec(struct module *mod, void *module_region)
+{
+	module_free(mod, module_region);
+}
+EXPORT_SYMBOL(module_free_exec);
+
+void *module_alloc_exec(unsigned long size)
+{
+	return __module_alloc(size, PAGE_KERNEL_RX);
+}
+EXPORT_SYMBOL(module_alloc_exec);
+#endif
+#endif
+
 /* We don't need anything special. */
 int module_frob_arch_sections(Elf_Ehdr *hdr,
 			      Elf_Shdr *sechdrs,
@@ -77,14 +121,16 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 	unsigned int i;
 	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
 	Elf32_Sym *sym;
-	uint32_t *location;
+	uint32_t *plocation, location;
 
 	DEBUGP("Applying relocate section %u to %u\n", relsec,
 	       sechdrs[relsec].sh_info);
 	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
 		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
+		plocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
+		location = (uint32_t)plocation;
+		if (sechdrs[sechdrs[relsec].sh_info].sh_flags & SHF_EXECINSTR)
+			plocation = ktla_ktva((void *)plocation);
 		/* This is the symbol it is referring to.  Note that all
 		   undefined symbols have been resolved.  */
 		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
@@ -93,11 +139,15 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 		switch (ELF32_R_TYPE(rel[i].r_info)) {
 		case R_386_32:
 			/* We add the value into the location given */
-			*location += sym->st_value;
+			pax_open_kernel();
+			*plocation += sym->st_value;
+			pax_close_kernel();
 			break;
 		case R_386_PC32:
 			/* Add the value, subtract its postition */
-			*location += sym->st_value - (uint32_t)location;
+			pax_open_kernel();
+			*plocation += sym->st_value - location;
+			pax_close_kernel();
 			break;
 		default:
 			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
@@ -153,21 +203,30 @@ int apply_relocate_add(Elf64_Shdr *sechd
 		case R_X86_64_NONE:
 			break;
 		case R_X86_64_64:
+			pax_open_kernel();
 			*(u64 *)loc = val;
+			pax_close_kernel();
 			break;
 		case R_X86_64_32:
+			pax_open_kernel();
 			*(u32 *)loc = val;
+			pax_close_kernel();
 			if (val != *(u32 *)loc)
 				goto overflow;
 			break;
 		case R_X86_64_32S:
+			pax_open_kernel();
 			*(s32 *)loc = val;
+			pax_close_kernel();
 			if ((s64)val != *(s32 *)loc)
 				goto overflow;
 			break;
 		case R_X86_64_PC32:
 			val -= (u64)loc;
+			pax_open_kernel();
 			*(u32 *)loc = val;
+			pax_close_kernel();
+
 #if 0
 			if ((s64)val != *(s32 *)loc)
 				goto overflow;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/paravirt.c linux-2.6.32.60-pax/arch/x86/kernel/paravirt.c
--- linux-2.6.32.60/arch/x86/kernel/paravirt.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/paravirt.c	2013-02-17 19:25:30.183754088 +0100
@@ -53,6 +53,9 @@ u64 _paravirt_ident_64(u64 x)
 {
 	return x;
 }
+#if defined(CONFIG_X86_32) && defined(CONFIG_X86_PAE)
+PV_CALLEE_SAVE_REGS_THUNK(_paravirt_ident_64);
+#endif
 
 void __init default_banner(void)
 {
@@ -145,15 +148,19 @@ unsigned paravirt_patch_default(u8 type,
 	if (opfunc == NULL)
 		/* If there's no function, patch it with a ud2a (BUG) */
 		ret = paravirt_patch_insns(insnbuf, len, ud2a, ud2a+sizeof(ud2a));
-	else if (opfunc == _paravirt_nop)
+	else if (opfunc == (void *)_paravirt_nop)
 		/* If the operation is a nop, then nop the callsite */
 		ret = paravirt_patch_nop();
 
 	/* identity functions just return their single argument */
-	else if (opfunc == _paravirt_ident_32)
+	else if (opfunc == (void *)_paravirt_ident_32)
 		ret = paravirt_patch_ident_32(insnbuf, len);
-	else if (opfunc == _paravirt_ident_64)
+	else if (opfunc == (void *)_paravirt_ident_64)
+		ret = paravirt_patch_ident_64(insnbuf, len);
+#if defined(CONFIG_X86_32) && defined(CONFIG_X86_PAE)
+	else if (opfunc == (void *)__raw_callee_save__paravirt_ident_64)
 		ret = paravirt_patch_ident_64(insnbuf, len);
+#endif
 
 	else if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||
 		 type == PARAVIRT_PATCH(pv_cpu_ops.irq_enable_sysexit) ||
@@ -178,7 +185,7 @@ unsigned paravirt_patch_insns(void *insn
 	if (insn_len > len || start == NULL)
 		insn_len = len;
 	else
-		memcpy(insnbuf, start, insn_len);
+		memcpy(insnbuf, ktla_ktva(start), insn_len);
 
 	return insn_len;
 }
@@ -294,22 +301,22 @@ void arch_flush_lazy_mmu_mode(void)
 	preempt_enable();
 }
 
-struct pv_info pv_info = {
+struct pv_info pv_info __read_only = {
 	.name = "bare hardware",
 	.paravirt_enabled = 0,
 	.kernel_rpl = 0,
 	.shared_kernel_pmd = 1,	/* Only used when CONFIG_X86_PAE is set */
 };
 
-struct pv_init_ops pv_init_ops = {
+struct pv_init_ops pv_init_ops __read_only = {
 	.patch = native_patch,
 };
 
-struct pv_time_ops pv_time_ops = {
+struct pv_time_ops pv_time_ops __read_only = {
 	.sched_clock = native_sched_clock,
 };
 
-struct pv_irq_ops pv_irq_ops = {
+struct pv_irq_ops pv_irq_ops __read_only = {
 	.save_fl = __PV_IS_CALLEE_SAVE(native_save_fl),
 	.restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl),
 	.irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable),
@@ -321,7 +328,7 @@ struct pv_irq_ops pv_irq_ops = {
 #endif
 };
 
-struct pv_cpu_ops pv_cpu_ops = {
+struct pv_cpu_ops pv_cpu_ops __read_only = {
 	.cpuid = native_cpuid,
 	.get_debugreg = native_get_debugreg,
 	.set_debugreg = native_set_debugreg,
@@ -382,21 +389,26 @@ struct pv_cpu_ops pv_cpu_ops = {
 	.end_context_switch = paravirt_nop,
 };
 
-struct pv_apic_ops pv_apic_ops = {
+struct pv_apic_ops pv_apic_ops __read_only = {
 #ifdef CONFIG_X86_LOCAL_APIC
 	.startup_ipi_hook = paravirt_nop,
 #endif
 };
 
-#if defined(CONFIG_X86_32) && !defined(CONFIG_X86_PAE)
+#ifdef CONFIG_X86_32
+#ifdef CONFIG_X86_PAE
+/* 64-bit pagetable entries */
+#define PTE_IDENT	PV_CALLEE_SAVE(_paravirt_ident_64)
+#else
 /* 32-bit pagetable entries */
 #define PTE_IDENT	__PV_IS_CALLEE_SAVE(_paravirt_ident_32)
+#endif
 #else
 /* 64-bit pagetable entries */
 #define PTE_IDENT	__PV_IS_CALLEE_SAVE(_paravirt_ident_64)
 #endif
 
-struct pv_mmu_ops pv_mmu_ops = {
+struct pv_mmu_ops pv_mmu_ops __read_only = {
 
 	.read_cr2 = native_read_cr2,
 	.write_cr2 = native_write_cr2,
@@ -448,6 +460,7 @@ struct pv_mmu_ops pv_mmu_ops = {
 	.make_pud = PTE_IDENT,
 
 	.set_pgd = native_set_pgd,
+	.set_pgd_batched = native_set_pgd_batched,
 #endif
 #endif /* PAGETABLE_LEVELS >= 3 */
 
@@ -467,6 +480,12 @@ struct pv_mmu_ops pv_mmu_ops = {
 	},
 
 	.set_fixmap = native_set_fixmap,
+
+#ifdef CONFIG_PAX_KERNEXEC
+	.pax_open_kernel = native_pax_open_kernel,
+	.pax_close_kernel = native_pax_close_kernel,
+#endif
+
 };
 
 EXPORT_SYMBOL_GPL(pv_time_ops);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/paravirt-spinlocks.c linux-2.6.32.60-pax/arch/x86/kernel/paravirt-spinlocks.c
--- linux-2.6.32.60/arch/x86/kernel/paravirt-spinlocks.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/paravirt-spinlocks.c	2012-03-13 13:15:34.552098021 +0100
@@ -13,7 +13,7 @@ default_spin_lock_flags(raw_spinlock_t *
 	__raw_spin_lock(lock);
 }
 
-struct pv_lock_ops pv_lock_ops = {
+struct pv_lock_ops pv_lock_ops __read_only = {
 #ifdef CONFIG_SMP
 	.spin_is_locked = __ticket_spin_is_locked,
 	.spin_is_contended = __ticket_spin_is_contended,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/process_32.c linux-2.6.32.60-pax/arch/x86/kernel/process_32.c
--- linux-2.6.32.60/arch/x86/kernel/process_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/process_32.c	2012-12-01 02:40:04.644119593 +0100
@@ -67,6 +67,7 @@ asmlinkage void ret_from_fork(void) __as
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
 	return ((unsigned long *)tsk->thread.sp)[3];
+//XXX	return tsk->thread.eip;
 }
 
 #ifndef CONFIG_SMP
@@ -129,15 +130,14 @@ void __show_regs(struct pt_regs *regs, i
 	unsigned short ss, gs;
 	const char *board;
 
-	if (user_mode_vm(regs)) {
+	if (user_mode(regs)) {
 		sp = regs->sp;
 		ss = regs->ss & 0xffff;
-		gs = get_user_gs(regs);
 	} else {
 		sp = (unsigned long) (&regs->sp);
 		savesegment(ss, ss);
-		savesegment(gs, gs);
 	}
+	gs = get_user_gs(regs);
 
 	printk("\n");
 
@@ -152,7 +152,7 @@ void __show_regs(struct pt_regs *regs, i
 
 	printk("EIP: %04x:[<%08lx>] EFLAGS: %08lx CPU: %d\n",
 			(u16)regs->cs, regs->ip, regs->flags,
-			smp_processor_id());
+			raw_smp_processor_id());
 	print_symbol("EIP is at %s\n", regs->ip);
 
 	printk("EAX: %08lx EBX: %08lx ECX: %08lx EDX: %08lx\n",
@@ -210,10 +210,10 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.bx = (unsigned long) fn;
 	regs.dx = (unsigned long) arg;
 
-	regs.ds = __USER_DS;
-	regs.es = __USER_DS;
+	regs.ds = __KERNEL_DS;
+	regs.es = __KERNEL_DS;
 	regs.fs = __KERNEL_PERCPU;
-	regs.gs = __KERNEL_STACK_CANARY;
+	savesegment(gs, regs.gs);
 	regs.orig_ax = -1;
 	regs.ip = (unsigned long) kernel_thread_helper;
 	regs.cs = __KERNEL_CS | get_kernel_rpl();
@@ -247,13 +247,14 @@ int copy_thread(unsigned long clone_flag
 	struct task_struct *tsk;
 	int err;
 
-	childregs = task_pt_regs(p);
+	childregs = task_stack_page(p) + THREAD_SIZE - sizeof(struct pt_regs) - 8;
 	*childregs = *regs;
 	childregs->ax = 0;
 	childregs->sp = sp;
 
 	p->thread.sp = (unsigned long) childregs;
 	p->thread.sp0 = (unsigned long) (childregs+1);
+	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p);
 
 	p->thread.ip = (unsigned long) ret_from_fork;
 
@@ -345,7 +346,7 @@ __switch_to(struct task_struct *prev_p,
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 	bool preload_fpu;
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
@@ -380,6 +381,10 @@ __switch_to(struct task_struct *prev_p,
 	 */
 	lazy_save_gs(prev->gs);
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	__set_fs(task_thread_info(next_p)->addr_limit);
+#endif
+
 	/*
 	 * Load the per-thread Thread-Local Storage descriptor.
 	 */
@@ -415,6 +420,9 @@ __switch_to(struct task_struct *prev_p,
 	 */
 	arch_end_context_switch(next_p);
 
+	percpu_write(current_task, next_p);
+	percpu_write(current_tinfo, &next_p->tinfo);
+
 	if (preload_fpu)
 		__math_state_restore();
 
@@ -424,8 +432,6 @@ __switch_to(struct task_struct *prev_p,
 	if (prev->gs | next->gs)
 		lazy_load_gs(next->gs);
 
-	percpu_write(current_task, next_p);
-
 	return prev_p;
 }
 
@@ -495,4 +501,3 @@ unsigned long get_wchan(struct task_stru
 	} while (count++ < 16);
 	return 0;
 }
-
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/process_64.c linux-2.6.32.60-pax/arch/x86/kernel/process_64.c
--- linux-2.6.32.60/arch/x86/kernel/process_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/process_64.c	2012-03-13 13:15:34.556098021 +0100
@@ -91,7 +91,7 @@ static void __exit_idle(void)
 void exit_idle(void)
 {
 	/* idle loop has pid 0 */
-	if (current->pid)
+	if (task_pid_nr(current))
 		return;
 	__exit_idle();
 }
@@ -170,7 +170,7 @@ void __show_regs(struct pt_regs *regs, i
 	if (!board)
 		board = "";
 	printk(KERN_INFO "Pid: %d, comm: %.20s %s %s %.*s %s\n",
-		current->pid, current->comm, print_tainted(),
+		task_pid_nr(current), current->comm, print_tainted(),
 		init_utsname()->release,
 		(int)strcspn(init_utsname()->version, " "),
 		init_utsname()->version, board);
@@ -280,8 +280,7 @@ int copy_thread(unsigned long clone_flag
 	struct pt_regs *childregs;
 	struct task_struct *me = current;
 
-	childregs = ((struct pt_regs *)
-			(THREAD_SIZE + task_stack_page(p))) - 1;
+	childregs = task_stack_page(p) + THREAD_SIZE - sizeof(struct pt_regs) - 16;
 	*childregs = *regs;
 
 	childregs->ax = 0;
@@ -292,6 +291,7 @@ int copy_thread(unsigned long clone_flag
 	p->thread.sp = (unsigned long) childregs;
 	p->thread.sp0 = (unsigned long) (childregs+1);
 	p->thread.usersp = me->thread.usersp;
+	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p);
 
 	set_tsk_thread_flag(p, TIF_FORK);
 
@@ -379,7 +379,7 @@ __switch_to(struct task_struct *prev_p,
 	struct thread_struct *prev = &prev_p->thread;
 	struct thread_struct *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 	unsigned fsindex, gsindex;
 	bool preload_fpu;
 
@@ -475,10 +475,9 @@ __switch_to(struct task_struct *prev_p,
 	prev->usersp = percpu_read(old_rsp);
 	percpu_write(old_rsp, next->usersp);
 	percpu_write(current_task, next_p);
+	percpu_write(current_tinfo, &next_p->tinfo);
 
-	percpu_write(kernel_stack,
-		  (unsigned long)task_stack_page(next_p) +
-		  THREAD_SIZE - KERNEL_STACK_OFFSET);
+	percpu_write(kernel_stack, next->sp0);
 
 	/*
 	 * Now maybe reload the debug registers and handle I/O bitmaps
@@ -559,12 +558,11 @@ unsigned long get_wchan(struct task_stru
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 	stack = (unsigned long)task_stack_page(p);
-	if (p->thread.sp < stack || p->thread.sp >= stack+THREAD_SIZE)
+	if (p->thread.sp < stack || p->thread.sp > stack+THREAD_SIZE-16-sizeof(u64))
 		return 0;
 	fp = *(u64 *)(p->thread.sp);
 	do {
-		if (fp < (unsigned long)stack ||
-		    fp >= (unsigned long)stack+THREAD_SIZE)
+		if (fp < stack || fp > stack+THREAD_SIZE-16-sizeof(u64))
 			return 0;
 		ip = *(u64 *)(fp+8);
 		if (!in_sched_functions(ip))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/process.c linux-2.6.32.60-pax/arch/x86/kernel/process.c
--- linux-2.6.32.60/arch/x86/kernel/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/process.c	2012-03-13 13:15:34.556098021 +0100
@@ -51,16 +51,33 @@ void free_thread_xstate(struct task_stru
 
 void free_thread_info(struct thread_info *ti)
 {
-	free_thread_xstate(ti->task);
 	free_pages((unsigned long)ti, get_order(THREAD_SIZE));
 }
 
+static struct kmem_cache *task_struct_cachep;
+
 void arch_task_cache_init(void)
 {
-        task_xstate_cachep =
-        	kmem_cache_create("task_xstate", xstate_size,
+	/* create a slab on which task_structs can be allocated */
+	task_struct_cachep =
+		kmem_cache_create("task_struct", sizeof(struct task_struct),
+			ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);
+
+	task_xstate_cachep =
+		kmem_cache_create("task_xstate", xstate_size,
 				  __alignof__(union thread_xstate),
-				  SLAB_PANIC | SLAB_NOTRACK, NULL);
+				  SLAB_PANIC | SLAB_NOTRACK | SLAB_USERCOPY, NULL);
+}
+
+struct task_struct *alloc_task_struct(void)
+{
+	return kmem_cache_alloc(task_struct_cachep, GFP_KERNEL);
+}
+
+void free_task_struct(struct task_struct *task)
+{
+	free_thread_xstate(task);
+	kmem_cache_free(task_struct_cachep, task);
 }
 
 /*
@@ -73,7 +90,7 @@ void exit_thread(void)
 	unsigned long *bp = t->io_bitmap_ptr;
 
 	if (bp) {
-		struct tss_struct *tss = &per_cpu(init_tss, get_cpu());
+		struct tss_struct *tss = init_tss + get_cpu();
 
 		t->io_bitmap_ptr = NULL;
 		clear_thread_flag(TIF_IO_BITMAP);
@@ -93,6 +110,9 @@ void flush_thread(void)
 
 	clear_tsk_thread_flag(tsk, TIF_DEBUG);
 
+#if defined(CONFIG_X86_32) && !defined(CONFIG_CC_STACKPROTECTOR) && !defined(CONFIG_PAX_MEMORY_UDEREF)
+	loadsegment(gs, 0);
+#endif
 	tsk->thread.debugreg0 = 0;
 	tsk->thread.debugreg1 = 0;
 	tsk->thread.debugreg2 = 0;
@@ -307,7 +327,7 @@ void default_idle(void)
 EXPORT_SYMBOL(default_idle);
 #endif
 
-void stop_this_cpu(void *dummy)
+__noreturn void stop_this_cpu(void *dummy)
 {
 	local_irq_disable();
 	/*
@@ -568,16 +588,37 @@ static int __init idle_setup(char *str)
 }
 early_param("idle", idle_setup);
 
-unsigned long arch_align_stack(unsigned long sp)
+#ifdef CONFIG_PAX_RANDKSTACK
+void pax_randomize_kstack(struct pt_regs *regs)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
-}
+	struct thread_struct *thread = &current->thread;
+	unsigned long time;
 
-unsigned long arch_randomize_brk(struct mm_struct *mm)
-{
-	unsigned long range_end = mm->brk + 0x02000000;
-	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
-}
+	if (!randomize_va_space)
+		return;
+
+	if (v8086_mode(regs))
+		return;
 
+	rdtscl(time);
+
+	/* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x3EUL;
+	time <<= 2;
+#elif defined(CONFIG_X86_64)
+	time &= 0xFUL;
+	time <<= 4;
+#else
+	time &= 0x1FUL;
+	time <<= 3;
+#endif
+
+	thread->sp0 ^= time;
+	load_sp0(init_tss + smp_processor_id(), thread);
+
+#ifdef CONFIG_X86_64
+	percpu_write(kernel_stack, thread->sp0);
+#endif
+}
+#endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/ptrace.c linux-2.6.32.60-pax/arch/x86/kernel/ptrace.c
--- linux-2.6.32.60/arch/x86/kernel/ptrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/ptrace.c	2012-05-20 19:21:25.301167284 +0200
@@ -925,7 +925,7 @@ static const struct user_regset_view use
 long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 {
 	int ret;
-	unsigned long __user *datap = (unsigned long __user *)data;
+	unsigned long __user *datap = (__force unsigned long __user *)data;
 
 	switch (request) {
 	/* read the word at location addr in the USER area. */
@@ -1012,14 +1012,14 @@ long arch_ptrace(struct task_struct *chi
 		if (addr < 0)
 			return -EIO;
 		ret = do_get_thread_area(child, addr,
-					 (struct user_desc __user *) data);
+					 (__force struct user_desc __user *) data);
 		break;
 
 	case PTRACE_SET_THREAD_AREA:
 		if (addr < 0)
 			return -EIO;
 		ret = do_set_thread_area(child, addr,
-					 (struct user_desc __user *) data, 0);
+					 (__force struct user_desc __user *) data, 0);
 		break;
 #endif
 
@@ -1038,12 +1038,12 @@ long arch_ptrace(struct task_struct *chi
 #ifdef CONFIG_X86_PTRACE_BTS
 	case PTRACE_BTS_CONFIG:
 		ret = ptrace_bts_config
-			(child, data, (struct ptrace_bts_config __user *)addr);
+			(child, data, (__force struct ptrace_bts_config __user *)addr);
 		break;
 
 	case PTRACE_BTS_STATUS:
 		ret = ptrace_bts_status
-			(child, data, (struct ptrace_bts_config __user *)addr);
+			(child, data, (__force struct ptrace_bts_config __user *)addr);
 		break;
 
 	case PTRACE_BTS_SIZE:
@@ -1052,7 +1052,7 @@ long arch_ptrace(struct task_struct *chi
 
 	case PTRACE_BTS_GET:
 		ret = ptrace_bts_read_record
-			(child, data, (struct bts_struct __user *) addr);
+			(child, data, (__force struct bts_struct __user *) addr);
 		break;
 
 	case PTRACE_BTS_CLEAR:
@@ -1061,7 +1061,7 @@ long arch_ptrace(struct task_struct *chi
 
 	case PTRACE_BTS_DRAIN:
 		ret = ptrace_bts_drain
-			(child, data, (struct bts_struct __user *) addr);
+			(child, data, (__force struct bts_struct __user *) addr);
 		break;
 #endif /* CONFIG_X86_PTRACE_BTS */
 
@@ -1450,7 +1450,7 @@ void send_sigtrap(struct task_struct *ts
 	info.si_code = si_code;
 
 	/* User-mode ip? */
-	info.si_addr = user_mode_vm(regs) ? (void __user *) regs->ip : NULL;
+	info.si_addr = user_mode(regs) ? (__force void __user *) regs->ip : NULL;
 
 	/* Send us the fake SIGTRAP */
 	force_sig_info(SIGTRAP, &info, tsk);
@@ -1469,7 +1469,7 @@ void send_sigtrap(struct task_struct *ts
  * We must return the syscall number to actually look up in the table.
  * This can be -1L to skip running any syscall at all.
  */
-asmregparm long syscall_trace_enter(struct pt_regs *regs)
+long syscall_trace_enter(struct pt_regs *regs)
 {
 	long ret = 0;
 
@@ -1514,7 +1514,7 @@ asmregparm long syscall_trace_enter(stru
 	return ret ?: regs->orig_ax;
 }
 
-asmregparm void syscall_trace_leave(struct pt_regs *regs)
+void syscall_trace_leave(struct pt_regs *regs)
 {
 	if (unlikely(current->audit_context))
 		audit_syscall_exit(AUDITSC_RESULT(regs->ax), regs->ax);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/reboot.c linux-2.6.32.60-pax/arch/x86/kernel/reboot.c
--- linux-2.6.32.60/arch/x86/kernel/reboot.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/reboot.c	2013-02-17 17:41:28.652087338 +0100
@@ -33,7 +33,7 @@ void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
 static const struct desc_ptr no_idt = {};
-static int reboot_mode;
+static unsigned short reboot_mode;
 enum reboot_type reboot_type = BOOT_KBD;
 int reboot_force;
 
@@ -292,12 +292,12 @@ core_initcall(reboot_init);
    controller to pulse the CPU reset line, which is more thorough, but
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
-static const unsigned long long
-real_mode_gdt_entries [3] =
+static struct desc_struct
+real_mode_gdt_entries [3] __read_only =
 {
-	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009b000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000093000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	GDT_ENTRY_INIT(0, 0, 0),		/* Null descriptor */
+	GDT_ENTRY_INIT(0x9b, 0, 0xffff),	/* 16-bit real-mode 64k code at 0x00000000 */
+	GDT_ENTRY_INIT(0x93, 0x100, 0xffff)	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
 static const struct desc_ptr
@@ -346,7 +346,7 @@ static const unsigned char jump_to_bios
  * specified by the code and length parameters.
  * We assume that length will aways be less that 100!
  */
-void machine_real_restart(const unsigned char *code, int length)
+__noreturn void machine_real_restart(const unsigned char *code, unsigned int length)
 {
 	local_irq_disable();
 
@@ -366,8 +366,8 @@ void machine_real_restart(const unsigned
 	/* Remap the kernel at virtual address zero, as well as offset zero
 	   from the kernel segment.  This assumes the kernel segment starts at
 	   virtual address PAGE_OFFSET. */
-	memcpy(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
-		sizeof(swapper_pg_dir [0]) * KERNEL_PGD_PTRS);
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			min_t(unsigned long, KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 
 	/*
 	 * Use `swapper_pg_dir' as our page directory.
@@ -379,16 +379,15 @@ void machine_real_restart(const unsigned
 	   boot)".  This seems like a fairly standard thing that gets set by
 	   REBOOT.COM programs, and the previous reset routine did this
 	   too. */
-	*((unsigned short *)0x472) = reboot_mode;
+	*(unsigned short *)(__va(0x472)) = reboot_mode;
 
 	/* For the switch to real mode, copy some code to low memory.  It has
 	   to be in the first 64k because it is running in 16-bit mode, and it
 	   has to have the same physical and virtual address, because it turns
 	   off paging.  Copy it near the end of the first page, out of the way
 	   of BIOS variables. */
-	memcpy((void *)(0x1000 - sizeof(real_mode_switch) - 100),
-		real_mode_switch, sizeof (real_mode_switch));
-	memcpy((void *)(0x1000 - 100), code, length);
+	memcpy(__va(0x1000 - sizeof (real_mode_switch) - 100), real_mode_switch, sizeof (real_mode_switch));
+	memcpy(__va(0x1000 - 100), code, length);
 
 	/* Set up the IDT for real mode. */
 	load_idt(&real_mode_idt);
@@ -416,6 +415,7 @@ void machine_real_restart(const unsigned
 	__asm__ __volatile__ ("ljmp $0x0008,%0"
 				:
 				: "i" ((void *)(0x1000 - sizeof (real_mode_switch) - 100)));
+	do { } while (1);
 }
 #ifdef CONFIG_APM_MODULE
 EXPORT_SYMBOL(machine_real_restart);
@@ -544,7 +544,7 @@ void __attribute__((weak)) mach_reboot_f
 {
 }
 
-static void native_machine_emergency_restart(void)
+static void __noreturn native_machine_emergency_restart(void)
 {
 	int i;
 
@@ -659,13 +659,13 @@ void native_machine_shutdown(void)
 #endif
 }
 
-static void __machine_emergency_restart(int emergency)
+static __noreturn void __machine_emergency_restart(int emergency)
 {
 	reboot_emergency = emergency;
 	machine_ops.emergency_restart();
 }
 
-static void native_machine_restart(char *__unused)
+static void __noreturn native_machine_restart(char *__unused)
 {
 	printk("machine restart\n");
 
@@ -674,7 +674,7 @@ static void native_machine_restart(char
 	__machine_emergency_restart(0);
 }
 
-static void native_machine_halt(void)
+static void __noreturn native_machine_halt(void)
 {
 	/* stop other cpus and apics */
 	machine_shutdown();
@@ -685,7 +685,7 @@ static void native_machine_halt(void)
 	stop_this_cpu(NULL);
 }
 
-static void native_machine_power_off(void)
+static void __noreturn native_machine_power_off(void)
 {
 	if (pm_power_off) {
 		if (!reboot_force)
@@ -694,9 +694,10 @@ static void native_machine_power_off(voi
 	}
 	/* a fallback in case there is no PM info available */
 	tboot_shutdown(TB_SHUTDOWN_HALT);
+	do { } while (1);
 }
 
-struct machine_ops machine_ops = {
+struct machine_ops machine_ops __read_only = {
 	.power_off = native_machine_power_off,
 	.shutdown = native_machine_shutdown,
 	.emergency_restart = native_machine_emergency_restart,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/relocate_kernel_64.S linux-2.6.32.60-pax/arch/x86/kernel/relocate_kernel_64.S
--- linux-2.6.32.60/arch/x86/kernel/relocate_kernel_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/relocate_kernel_64.S	2012-03-13 13:15:34.560098021 +0100
@@ -11,6 +11,7 @@
 #include <asm/kexec.h>
 #include <asm/processor-flags.h>
 #include <asm/pgtable_types.h>
+#include <asm/alternative-asm.h>
 
 /*
  * Must be relocatable PIC code callable as a C function
@@ -167,6 +168,7 @@ identity_mapped:
 	xorq	%r14, %r14
 	xorq	%r15, %r15
 
+	pax_force_retaddr 0, 1
 	ret
 
 1:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/setup.c linux-2.6.32.60-pax/arch/x86/kernel/setup.c
--- linux-2.6.32.60/arch/x86/kernel/setup.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/setup.c	2012-03-13 13:15:34.564098020 +0100
@@ -783,14 +783,14 @@ void __init setup_arch(char **cmdline_p)
 
 	if (!boot_params.hdr.root_flags)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) _text;
-	init_mm.end_code = (unsigned long) _etext;
+	init_mm.start_code = ktla_ktva((unsigned long) _text);
+	init_mm.end_code = ktla_ktva((unsigned long) _etext);
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = _brk_end;
 
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
+	code_resource.start = virt_to_phys(ktla_ktva(_text));
+	code_resource.end = virt_to_phys(ktla_ktva(_etext))-1;
+	data_resource.start = virt_to_phys(_sdata);
 	data_resource.end = virt_to_phys(_edata)-1;
 	bss_resource.start = virt_to_phys(&__bss_start);
 	bss_resource.end = virt_to_phys(&__bss_stop)-1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/setup_percpu.c linux-2.6.32.60-pax/arch/x86/kernel/setup_percpu.c
--- linux-2.6.32.60/arch/x86/kernel/setup_percpu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/setup_percpu.c	2012-05-20 19:21:25.301167284 +0200
@@ -25,19 +25,17 @@
 # define DBG(x...)
 #endif
 
-DEFINE_PER_CPU(int, cpu_number);
+#ifdef CONFIG_SMP
+DEFINE_PER_CPU(unsigned int, cpu_number);
 EXPORT_PER_CPU_SYMBOL(cpu_number);
+#endif
 
-#ifdef CONFIG_X86_64
 #define BOOT_PERCPU_OFFSET ((unsigned long)__per_cpu_load)
-#else
-#define BOOT_PERCPU_OFFSET 0
-#endif
 
 DEFINE_PER_CPU(unsigned long, this_cpu_off) = BOOT_PERCPU_OFFSET;
 EXPORT_PER_CPU_SYMBOL(this_cpu_off);
 
-unsigned long __per_cpu_offset[NR_CPUS] __read_mostly = {
+unsigned long __per_cpu_offset[NR_CPUS] __read_only = {
 	[0 ... NR_CPUS-1] = BOOT_PERCPU_OFFSET,
 };
 EXPORT_SYMBOL(__per_cpu_offset);
@@ -159,10 +157,10 @@ static inline void setup_percpu_segment(
 {
 #ifdef CONFIG_X86_32
 	struct desc_struct gdt;
+	unsigned long base = per_cpu_offset(cpu);
 
-	pack_descriptor(&gdt, per_cpu_offset(cpu), 0xFFFFF,
-			0x2 | DESCTYPE_S, 0x8);
-	gdt.s = 1;
+	pack_descriptor(&gdt, base, (VMALLOC_END - base - 1) >> PAGE_SHIFT,
+			0x83 | DESCTYPE_S, 0xC);
 	write_gdt_entry(get_cpu_gdt_table(cpu),
 			GDT_ENTRY_PERCPU, &gdt, DESCTYPE_S);
 #endif
@@ -212,6 +210,11 @@ void __init setup_per_cpu_areas(void)
 	/* alrighty, percpu areas up and running */
 	delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;
 	for_each_possible_cpu(cpu) {
+#ifdef CONFIG_CC_STACKPROTECTOR
+#ifdef CONFIG_X86_32
+		unsigned long canary = per_cpu(stack_canary.canary, cpu);
+#endif
+#endif
 		per_cpu_offset(cpu) = delta + pcpu_unit_offsets[cpu];
 		per_cpu(this_cpu_off, cpu) = per_cpu_offset(cpu);
 		per_cpu(cpu_number, cpu) = cpu;
@@ -239,6 +242,12 @@ void __init setup_per_cpu_areas(void)
 			early_per_cpu_map(x86_cpu_to_node_map, cpu);
 #endif
 #endif
+#ifdef CONFIG_CC_STACKPROTECTOR
+#ifdef CONFIG_X86_32
+		if (!cpu)
+			per_cpu(stack_canary.canary, cpu) = canary;
+#endif
+#endif
 		/*
 		 * Up to this point, the boot CPU has been using .data.init
 		 * area.  Reload any changed state for the boot CPU.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/signal.c linux-2.6.32.60-pax/arch/x86/kernel/signal.c
--- linux-2.6.32.60/arch/x86/kernel/signal.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/signal.c	2012-03-13 13:15:34.564098020 +0100
@@ -197,7 +197,7 @@ static unsigned long align_sigframe(unsi
 	 * Align the stack pointer according to the i386 ABI,
 	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
 	 */
-	sp = ((sp + 4) & -16ul) - 4;
+	sp = ((sp - 12) & -16ul) - 4;
 #else /* !CONFIG_X86_32 */
 	sp = round_down(sp, 16) - 8;
 #endif
@@ -248,11 +248,11 @@ get_sigframe(struct k_sigaction *ka, str
 	 * Return an always-bogus address instead so we will die with SIGSEGV.
 	 */
 	if (onsigstack && !likely(on_sig_stack(sp)))
-		return (void __user *)-1L;
+		return (__force void __user *)-1L;
 
 	/* save i387 state */
 	if (used_math() && save_i387_xstate(*fpstate) < 0)
-		return (void __user *)-1L;
+		return (__force void __user *)-1L;
 
 	return (void __user *)sp;
 }
@@ -307,9 +307,9 @@ __setup_frame(int sig, struct k_sigactio
 	}
 
 	if (current->mm->context.vdso)
-		restorer = VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);
+		restorer = (__force void __user *)VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);
 	else
-		restorer = &frame->retcode;
+		restorer = (void __user *)&frame->retcode;
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 
@@ -323,7 +323,7 @@ __setup_frame(int sig, struct k_sigactio
 	 * reasons and because gdb uses it as a signature to notice
 	 * signal handler stack frames.
 	 */
-	err |= __put_user(*((u64 *)&retcode), (u64 *)frame->retcode);
+	err |= __put_user(*((u64 *)&retcode), (u64 __user *)frame->retcode);
 
 	if (err)
 		return -EFAULT;
@@ -377,7 +377,10 @@ static int __setup_rt_frame(int sig, str
 		err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 
 		/* Set up to return from userspace.  */
-		restorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);
+		if (current->mm->context.vdso)
+			restorer = (__force void __user *)VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);
+		else
+			restorer = (void __user *)&frame->retcode;
 		if (ka->sa.sa_flags & SA_RESTORER)
 			restorer = ka->sa.sa_restorer;
 		put_user_ex(restorer, &frame->pretcode);
@@ -389,7 +392,7 @@ static int __setup_rt_frame(int sig, str
 		 * reasons and because gdb uses it as a signature to notice
 		 * signal handler stack frames.
 		 */
-		put_user_ex(*((u64 *)&rt_retcode), (u64 *)frame->retcode);
+		put_user_ex(*((u64 *)&rt_retcode), (u64 __user *)frame->retcode);
 	} put_user_catch(err);
 
 	if (err)
@@ -789,7 +792,7 @@ static void do_signal(struct pt_regs *re
 	 * X86_32: vm86 regs switched out by assembly code before reaching
 	 * here, so testing against kernel CS suffices.
 	 */
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		return;
 
 	if (current_thread_info()->status & TS_RESTORE_SIGMASK)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/smpboot.c linux-2.6.32.60-pax/arch/x86/kernel/smpboot.c
--- linux-2.6.32.60/arch/x86/kernel/smpboot.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/smpboot.c	2012-03-13 13:15:34.564098020 +0100
@@ -94,14 +94,14 @@ static DEFINE_PER_CPU(struct task_struct
  */
 static DEFINE_MUTEX(x86_cpu_hotplug_driver_mutex);
 
-void cpu_hotplug_driver_lock()
+void cpu_hotplug_driver_lock(void)
 {
-        mutex_lock(&x86_cpu_hotplug_driver_mutex);
+	mutex_lock(&x86_cpu_hotplug_driver_mutex);
 }
 
-void cpu_hotplug_driver_unlock()
+void cpu_hotplug_driver_unlock(void)
 {
-        mutex_unlock(&x86_cpu_hotplug_driver_mutex);
+	mutex_unlock(&x86_cpu_hotplug_driver_mutex);
 }
 
 ssize_t arch_cpu_probe(const char *buf, size_t count) { return -1; }
@@ -743,6 +743,7 @@ static int __cpuinit do_boot_cpu(int api
 	set_idle_for_cpu(cpu, c_idle.idle);
 do_rest:
 	per_cpu(current_task, cpu) = c_idle.idle;
+	per_cpu(current_tinfo, cpu) = &c_idle.idle->tinfo;
 #ifdef CONFIG_X86_32
 	/* Stack for startup_32 can be just as for start_secondary onwards */
 	irq_ctx_init(cpu);
@@ -750,11 +751,13 @@ do_rest:
 #else
 	clear_tsk_thread_flag(c_idle.idle, TIF_FORK);
 	initial_gs = per_cpu_offset(cpu);
-	per_cpu(kernel_stack, cpu) =
-		(unsigned long)task_stack_page(c_idle.idle) -
-		KERNEL_STACK_OFFSET + THREAD_SIZE;
+	per_cpu(kernel_stack, cpu) = (unsigned long)task_stack_page(c_idle.idle) - 16 + THREAD_SIZE;
 #endif
+
+	pax_open_kernel();
 	early_gdt_descr.address = (unsigned long)get_cpu_gdt_table(cpu);
+	pax_close_kernel();
+
 	initial_code = (unsigned long)start_secondary;
 	stack_start.sp = (void *) c_idle.idle->thread.sp;
 
@@ -891,6 +894,12 @@ int __cpuinit native_cpu_up(unsigned int
 
 	per_cpu(cpu_state, cpu) = CPU_UP_PREPARE;
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	clone_pgd_range(get_cpu_pgd(cpu) + KERNEL_PGD_BOUNDARY,
+			swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			KERNEL_PGD_PTRS);
+#endif
+
 	err = do_boot_cpu(apicid, cpu);
 
 	if (err) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/smp.c linux-2.6.32.60-pax/arch/x86/kernel/smp.c
--- linux-2.6.32.60/arch/x86/kernel/smp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/smp.c	2013-02-17 17:40:41.152089874 +0100
@@ -224,7 +224,7 @@ void smp_call_function_single_interrupt(
 	irq_exit();
 }
 
-struct smp_ops smp_ops = {
+struct smp_ops smp_ops __read_only = {
 	.smp_prepare_boot_cpu	= native_smp_prepare_boot_cpu,
 	.smp_prepare_cpus	= native_smp_prepare_cpus,
 	.smp_cpus_done		= native_smp_cpus_done,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/step.c linux-2.6.32.60-pax/arch/x86/kernel/step.c
--- linux-2.6.32.60/arch/x86/kernel/step.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/step.c	2012-03-13 13:15:34.568098020 +0100
@@ -27,10 +27,10 @@ unsigned long convert_ip_to_linear(struc
 		struct desc_struct *desc;
 		unsigned long base;
 
-		seg &= ~7UL;
+		seg >>= 3;
 
 		mutex_lock(&child->mm->context.lock);
-		if (unlikely((seg >> 3) >= child->mm->context.size))
+		if (unlikely(seg >= child->mm->context.size))
 			addr = -1L; /* bogus selector, access would fault */
 		else {
 			desc = child->mm->context.ldt + seg;
@@ -42,7 +42,8 @@ unsigned long convert_ip_to_linear(struc
 			addr += base;
 		}
 		mutex_unlock(&child->mm->context.lock);
-	}
+	} else if (seg == __KERNEL_CS || seg == __KERNEXEC_KERNEL_CS)
+		addr = ktla_ktva(addr);
 
 	return addr;
 }
@@ -53,6 +54,9 @@ static int is_setting_trap_flag(struct t
 	unsigned char opcode[15];
 	unsigned long addr = convert_ip_to_linear(child, regs);
 
+	if (addr == -EINVAL)
+		return 0;
+
 	copied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);
 	for (i = 0; i < copied; i++) {
 		switch (opcode[i]) {
@@ -74,7 +78,7 @@ static int is_setting_trap_flag(struct t
 
 #ifdef CONFIG_X86_64
 		case 0x40 ... 0x4f:
-			if (regs->cs != __USER_CS)
+			if ((regs->cs & 0xffff) != __USER_CS)
 				/* 32-bit mode: register increment */
 				return 0;
 			/* 64-bit mode: REX prefix */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/syscall_table_32.S linux-2.6.32.60-pax/arch/x86/kernel/syscall_table_32.S
--- linux-2.6.32.60/arch/x86/kernel/syscall_table_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/syscall_table_32.S	2012-03-13 13:15:34.568098020 +0100
@@ -1,3 +1,4 @@
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long sys_restart_syscall	/* 0 - old "setup()" system call, used for restarting */
 	.long sys_exit
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/sys_i386_32.c linux-2.6.32.60-pax/arch/x86/kernel/sys_i386_32.c
--- linux-2.6.32.60/arch/x86/kernel/sys_i386_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/sys_i386_32.c	2012-03-13 13:15:34.568098020 +0100
@@ -24,6 +24,21 @@
 
 #include <asm/syscalls.h>
 
+int i386_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)
+{
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size || addr > pax_task_size - len)
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/i386 didn't use to be able to handle more than
@@ -58,6 +73,212 @@ out:
 	return err;
 }
 
+unsigned long
+arch_get_unmapped_area(struct file *filp, unsigned long addr,
+		unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long start_addr, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
+
+	if (len > pax_task_size)
+		return -ENOMEM;
+
+	if (flags & MAP_FIXED)
+		return addr;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		if (pax_task_size - len >= addr) {
+			vma = find_vma(mm, addr);
+			if (check_heap_stack_gap(vma, addr, len))
+				return addr;
+		}
+	}
+	if (len > mm->cached_hole_size) {
+		start_addr = addr = mm->free_area_cache;
+	} else {
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
+	}
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!nx_enabled && (mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE) && start_addr >= mm->mmap_base) {
+		start_addr = 0x00110000UL;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			start_addr += mm->delta_mmap & 0x03FFF000UL;
+#endif
+
+		if (mm->start_brk <= start_addr && start_addr < mm->mmap_base)
+			start_addr = addr = mm->mmap_base;
+		else
+			addr = start_addr;
+	}
+#endif
+
+full_search:
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (pax_task_size - len < addr) {
+			/*
+			 * Start a new search - just in case we missed
+			 * some holes.
+			 */
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
+				mm->cached_hole_size = 0;
+				goto full_search;
+			}
+			return -ENOMEM;
+		}
+		if (check_heap_stack_gap(vma, addr, len))
+			break;
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+		addr = vma->vm_end;
+		if (mm->start_brk <= addr && addr < mm->mmap_base) {
+			start_addr = addr = mm->mmap_base;
+			mm->cached_hole_size = 0;
+			goto full_search;
+		}
+	}
+
+	/*
+	 * Remember the place where we stopped the search:
+	 */
+	mm->free_area_cache = addr + len;
+	return addr;
+}
+
+unsigned long
+arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
+			  const unsigned long len, const unsigned long pgoff,
+			  const unsigned long flags)
+{
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	unsigned long base = mm->mmap_base, addr = addr0, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
+
+	/* requested length too big for entire address space */
+	if (len > pax_task_size)
+		return -ENOMEM;
+
+	if (flags & MAP_FIXED)
+		return addr;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!nx_enabled && (mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE))
+		goto bottomup;
+#endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
+	/* requesting a specific address */
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		if (pax_task_size - len >= addr) {
+			vma = find_vma(mm, addr);
+			if (check_heap_stack_gap(vma, addr, len))
+				return addr;
+		}
+	}
+
+	/* check if free_area_cache is useful for us */
+	if (len <= mm->cached_hole_size) {
+		mm->cached_hole_size = 0;
+		mm->free_area_cache = mm->mmap_base;
+	}
+
+	/* either no address requested or can't fit in requested address hole */
+	addr = mm->free_area_cache;
+
+	/* make sure it can fit in the remaining address space */
+	if (addr > len) {
+		vma = find_vma(mm, addr-len);
+		if (check_heap_stack_gap(vma, addr - len, len))
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr-len);
+	}
+
+	if (mm->mmap_base < len)
+		goto bottomup;
+
+	addr = mm->mmap_base-len;
+
+	do {
+		/*
+		 * Lookup failure means no vma is above this address,
+		 * else if new region fits below vma->vm_start,
+		 * return with success:
+		 */
+		vma = find_vma(mm, addr);
+		if (check_heap_stack_gap(vma, addr, len))
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr);
+
+		/* remember the largest hole we saw so far */
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+
+		/* try just below the current vma->vm_start */
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
+
+bottomup:
+	/*
+	 * A failed mmap() very likely causes application failure,
+	 * so fall back to the bottom-up function here. This scenario
+	 * can happen with large stack limits and large mmap()
+	 * allocations.
+	 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		mm->mmap_base = SEGMEXEC_TASK_UNMAPPED_BASE;
+	else
+#endif
+
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
+	mm->cached_hole_size = ~0UL;
+	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
+	/*
+	 * Restore the topdown base:
+	 */
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
+	mm->cached_hole_size = ~0UL;
+
+	return addr;
+}
 
 struct sel_arg_struct {
 	unsigned long n;
@@ -93,7 +314,7 @@ asmlinkage int sys_ipc(uint call, int fi
 		return sys_semtimedop(first, (struct sembuf __user *)ptr, second, NULL);
 	case SEMTIMEDOP:
 		return sys_semtimedop(first, (struct sembuf __user *)ptr, second,
-					(const struct timespec __user *)fifth);
+					(__force const struct timespec __user *)fifth);
 
 	case SEMGET:
 		return sys_semget(first, second, third);
@@ -140,7 +361,7 @@ asmlinkage int sys_ipc(uint call, int fi
 			ret = do_shmat(first, (char __user *) ptr, second, &raddr);
 			if (ret)
 				return ret;
-			return put_user(raddr, (ulong __user *) third);
+			return put_user(raddr, (__force ulong __user *) third);
 		}
 		case 1:	/* iBCS2 emulator entry point */
 			if (!segment_eq(get_fs(), get_ds()))
@@ -207,17 +428,3 @@ asmlinkage int sys_olduname(struct oldol
 
 	return error;
 }
-
-
-/*
- * Do a system call from kernel instead of calling sys_execve so we
- * end up with proper pt_regs.
- */
-int kernel_execve(const char *filename, char *const argv[], char *const envp[])
-{
-	long __res;
-	asm volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx"
-	: "=a" (__res)
-	: "0" (__NR_execve), "ri" (filename), "c" (argv), "d" (envp) : "memory");
-	return __res;
-}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/sys_x86_64.c linux-2.6.32.60-pax/arch/x86/kernel/sys_x86_64.c
--- linux-2.6.32.60/arch/x86/kernel/sys_x86_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/sys_x86_64.c	2012-03-13 13:15:34.568098020 +0100
@@ -32,8 +32,8 @@ out:
 	return error;
 }
 
-static void find_start_end(unsigned long flags, unsigned long *begin,
-			   unsigned long *end)
+static void find_start_end(struct mm_struct *mm, unsigned long flags,
+			   unsigned long *begin, unsigned long *end)
 {
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT)) {
 		unsigned long new_begin;
@@ -52,7 +52,7 @@ static void find_start_end(unsigned long
 				*begin = new_begin;
 		}
 	} else {
-		*begin = TASK_UNMAPPED_BASE;
+		*begin = mm->mmap_base;
 		*end = TASK_SIZE;
 	}
 }
@@ -69,16 +69,19 @@ arch_get_unmapped_area(struct file *filp
 	if (flags & MAP_FIXED)
 		return addr;
 
-	find_start_end(flags, &begin, &end);
+	find_start_end(mm, flags, &begin, &end);
 
 	if (len > end)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
-		if (end - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (end - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 	if (((flags & MAP_32BIT) || test_thread_flag(TIF_IA32))
@@ -106,7 +109,7 @@ full_search:
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -128,7 +131,7 @@ arch_get_unmapped_area_topdown(struct fi
 {
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	unsigned long addr = addr0;
+	unsigned long base = mm->mmap_base, addr = addr0;
 
 	/* requested length too big for entire address space */
 	if (len > TASK_SIZE)
@@ -141,13 +144,18 @@ arch_get_unmapped_area_topdown(struct fi
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT))
 		goto bottomup;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
-		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-				(!vma || addr + len <= vma->vm_start))
-			return addr;
+		if (TASK_SIZE - len >= addr) {
+			vma = find_vma(mm, addr);
+			if (check_heap_stack_gap(vma, addr, len))
+				return addr;
+		}
 	}
 
 	/* check if free_area_cache is useful for us */
@@ -162,7 +170,7 @@ arch_get_unmapped_area_topdown(struct fi
 	/* make sure it can fit in the remaining address space */
 	if (addr > len) {
 		vma = find_vma(mm, addr-len);
-		if (!vma || addr <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr - len, len))
 			/* remember the address as a hint for next time */
 			return mm->free_area_cache = addr-len;
 	}
@@ -179,7 +187,7 @@ arch_get_unmapped_area_topdown(struct fi
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (!vma || addr+len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			/* remember the address as a hint for next time */
 			return mm->free_area_cache = addr;
 
@@ -188,8 +196,8 @@ arch_get_unmapped_area_topdown(struct fi
 			mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = vma->vm_start-len;
-	} while (len < vma->vm_start);
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 bottomup:
 	/*
@@ -198,13 +206,21 @@ bottomup:
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
 	 */
-	mm->free_area_cache = mm->mmap_base;
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
 	return addr;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/tboot.c linux-2.6.32.60-pax/arch/x86/kernel/tboot.c
--- linux-2.6.32.60/arch/x86/kernel/tboot.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/tboot.c	2012-03-13 13:15:34.572098020 +0100
@@ -216,7 +216,7 @@ static int tboot_setup_sleep(void)
 
 void tboot_shutdown(u32 shutdown_type)
 {
-	void (*shutdown)(void);
+	void (* __noreturn shutdown)(void);
 
 	if (!tboot_enabled())
 		return;
@@ -238,7 +238,7 @@ void tboot_shutdown(u32 shutdown_type)
 
 	switch_to_tboot_pt();
 
-	shutdown = (void(*)(void))(unsigned long)tboot->shutdown_entry;
+	shutdown = (void *)tboot->shutdown_entry;
 	shutdown();
 
 	/* should not reach here */
@@ -295,7 +295,7 @@ void tboot_sleep(u8 sleep_state, u32 pm1
 	tboot_shutdown(acpi_shutdown_map[sleep_state]);
 }
 
-static atomic_t ap_wfs_count;
+static atomic_unchecked_t ap_wfs_count;
 
 static int tboot_wait_for_aps(int num_aps)
 {
@@ -319,9 +319,9 @@ static int __cpuinit tboot_cpu_callback(
 {
 	switch (action) {
 	case CPU_DYING:
-		atomic_inc(&ap_wfs_count);
+		atomic_inc_unchecked(&ap_wfs_count);
 		if (num_online_cpus() == 1)
-			if (tboot_wait_for_aps(atomic_read(&ap_wfs_count)))
+			if (tboot_wait_for_aps(atomic_read_unchecked(&ap_wfs_count)))
 				return NOTIFY_BAD;
 		break;
 	}
@@ -340,7 +340,7 @@ static __init int tboot_late_init(void)
 
 	tboot_create_trampoline();
 
-	atomic_set(&ap_wfs_count, 0);
+	atomic_set_unchecked(&ap_wfs_count, 0);
 	register_hotcpu_notifier(&tboot_cpu_notifier);
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/time.c linux-2.6.32.60-pax/arch/x86/kernel/time.c
--- linux-2.6.32.60/arch/x86/kernel/time.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/time.c	2012-03-13 13:15:34.572098020 +0100
@@ -26,17 +26,13 @@
 int timer_ack;
 #endif
 
-#ifdef CONFIG_X86_64
-volatile unsigned long __jiffies __section_jiffies = INITIAL_JIFFIES;
-#endif
-
 unsigned long profile_pc(struct pt_regs *regs)
 {
 	unsigned long pc = instruction_pointer(regs);
 
-	if (!user_mode_vm(regs) && in_lock_functions(pc)) {
+	if (!user_mode(regs) && in_lock_functions(pc)) {
 #ifdef CONFIG_FRAME_POINTER
-		return *(unsigned long *)(regs->bp + sizeof(long));
+		return ktla_ktva(*(unsigned long *)(regs->bp + sizeof(long)));
 #else
 		unsigned long *sp =
 			(unsigned long *)kernel_stack_pointer(regs);
@@ -45,11 +41,17 @@ unsigned long profile_pc(struct pt_regs
 		 * or above a saved flags. Eflags has bits 22-31 zero,
 		 * kernel addresses don't.
 		 */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		return ktla_ktva(sp[0]);
+#else
 		if (sp[0] >> 22)
 			return sp[0];
 		if (sp[1] >> 22)
 			return sp[1];
 #endif
+
+#endif
 	}
 	return pc;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/tls.c linux-2.6.32.60-pax/arch/x86/kernel/tls.c
--- linux-2.6.32.60/arch/x86/kernel/tls.c	2012-10-09 11:00:35.432882464 +0200
+++ linux-2.6.32.60-pax/arch/x86/kernel/tls.c	2012-09-20 00:38:15.738660686 +0200
@@ -85,6 +85,11 @@ int do_set_thread_area(struct task_struc
 	if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 		return -EINVAL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((p->mm->pax_flags & MF_PAX_SEGMEXEC) && (info.contents & MODIFY_LDT_CONTENTS_CODE))
+		return -EINVAL;
+#endif
+
 	set_tls_desc(p, idx, &info, 1);
 
 	return 0;
@@ -205,7 +210,7 @@ int regset_tls_set(struct task_struct *t
 
 	if (kbuf)
 		info = kbuf;
-	else if (__copy_from_user(infobuf, ubuf, count))
+	else if (count > sizeof infobuf || __copy_from_user(infobuf, ubuf, count))
 		return -EFAULT;
 	else
 		info = infobuf;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/trampoline_32.S linux-2.6.32.60-pax/arch/x86/kernel/trampoline_32.S
--- linux-2.6.32.60/arch/x86/kernel/trampoline_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/trampoline_32.S	2012-03-13 13:15:34.572098020 +0100
@@ -32,6 +32,12 @@
 #include <asm/segment.h>
 #include <asm/page_types.h>
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define ta(X) (X)
+#else
+#define ta(X) ((X) - __PAGE_OFFSET)
+#endif
+
 /* We can free up trampoline after bootup if cpu hotplug is not supported. */
 __CPUINITRODATA
 .code16
@@ -60,7 +66,7 @@ r_base = .
 	inc	%ax		# protected mode (PE) bit
 	lmsw	%ax		# into protected mode
 	# flush prefetch and jump to startup_32_smp in arch/i386/kernel/head.S
-	ljmpl	$__BOOT_CS, $(startup_32_smp-__PAGE_OFFSET)
+	ljmpl	$__BOOT_CS, $ta(startup_32_smp)
 
 	# These need to be in the same 64K segment as the above;
 	# hence we don't use the boot_gdt_descr defined in head.S
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/trampoline_64.S linux-2.6.32.60-pax/arch/x86/kernel/trampoline_64.S
--- linux-2.6.32.60/arch/x86/kernel/trampoline_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/trampoline_64.S	2012-03-13 13:15:34.572098020 +0100
@@ -91,7 +91,7 @@ startup_32:
 	movl	$__KERNEL_DS, %eax	# Initialize the %ds segment register
 	movl	%eax, %ds
 
-	movl	$X86_CR4_PAE, %eax
+	movl	$(X86_CR4_PSE | X86_CR4_PAE | X86_CR4_PGE), %eax
 	movl	%eax, %cr4		# Enable PAE mode
 
 					# Setup trampoline 4 level pagetables
@@ -138,7 +138,7 @@ tidt:
 	# so the kernel can live anywhere
 	.balign 4
 tgdt:
-	.short	tgdt_end - tgdt		# gdt limit
+	.short	tgdt_end - tgdt - 1	# gdt limit
 	.long	tgdt - r_base
 	.short 0
 	.quad	0x00cf9b000000ffff	# __KERNEL32_CS
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/traps.c linux-2.6.32.60-pax/arch/x86/kernel/traps.c
--- linux-2.6.32.60/arch/x86/kernel/traps.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/traps.c	2012-03-13 13:15:34.576098020 +0100
@@ -69,12 +69,6 @@ asmlinkage int system_call(void);
 
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq;
-
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.
- */
-gate_desc idt_table[NR_VECTORS] __page_aligned_data = { { { { 0, 0 } } }, };
 #endif
 
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
@@ -112,19 +106,19 @@ static inline void preempt_conditional_c
 static inline void
 die_if_kernel(const char *str, struct pt_regs *regs, long err)
 {
-	if (!user_mode_vm(regs))
+	if (!user_mode(regs))
 		die(str, regs, err);
 }
 #endif
 
 static void __kprobes
-do_trap(int trapnr, int signr, char *str, struct pt_regs *regs,
+do_trap(int trapnr, int signr, const char *str, struct pt_regs *regs,
 	long error_code, siginfo_t *info)
 {
 	struct task_struct *tsk = current;
 
 #ifdef CONFIG_X86_32
-	if (regs->flags & X86_VM_MASK) {
+	if (v8086_mode(regs)) {
 		/*
 		 * traps 0, 1, 3, 4, and 5 should be forwarded to vm86.
 		 * On nmi (interrupt 2), do_trap should not be called.
@@ -135,7 +129,7 @@ do_trap(int trapnr, int signr, char *str
 	}
 #endif
 
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		goto kernel_trap;
 
 #ifdef CONFIG_X86_32
@@ -158,7 +152,7 @@ trap_signal:
 	    printk_ratelimit()) {
 		printk(KERN_INFO
 		       "%s[%d] trap %s ip:%lx sp:%lx error:%lx",
-		       tsk->comm, tsk->pid, str,
+		       tsk->comm, task_pid_nr(tsk), str,
 		       regs->ip, regs->sp, error_code);
 		print_vma_addr(" in ", regs->ip);
 		printk("\n");
@@ -175,8 +169,20 @@ kernel_trap:
 	if (!fixup_exception(regs)) {
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_no = trapnr;
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+		if (trapnr == 12 && ((regs->cs & 0xFFFF) == __KERNEL_CS || (regs->cs & 0xFFFF) == __KERNEXEC_KERNEL_CS))
+			str = "PAX: suspicious stack segment fault";
+#endif
+
 		die(str, regs, error_code);
 	}
+
+#ifdef CONFIG_PAX_REFCOUNT
+	if (trapnr == 4)
+		pax_report_refcount_overflow(regs);
+#endif
+
 	return;
 
 #ifdef CONFIG_X86_32
@@ -265,14 +271,30 @@ do_general_protection(struct pt_regs *re
 	conditional_sti(regs);
 
 #ifdef CONFIG_X86_32
-	if (regs->flags & X86_VM_MASK)
+	if (v8086_mode(regs))
 		goto gp_in_vm86;
 #endif
 
 	tsk = current;
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		goto gp_in_kernel;
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+	if (!nx_enabled && tsk->mm && (tsk->mm->pax_flags & MF_PAX_PAGEEXEC)) {
+		struct mm_struct *mm = tsk->mm;
+		unsigned long limit;
+
+		down_write(&mm->mmap_sem);
+		limit = mm->context.user_cs_limit;
+		if (limit < TASK_SIZE) {
+			track_exec_limit(mm, limit, TASK_SIZE, VM_EXEC);
+			up_write(&mm->mmap_sem);
+			return;
+		}
+		up_write(&mm->mmap_sem);
+	}
+#endif
+
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 13;
 
@@ -305,6 +327,13 @@ gp_in_kernel:
 	if (notify_die(DIE_GPF, "general protection fault", regs,
 				error_code, 13, SIGSEGV) == NOTIFY_STOP)
 		return;
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	if ((regs->cs & 0xFFFF) == __KERNEL_CS || (regs->cs & 0xFFFF) == __KERNEXEC_KERNEL_CS)
+		die("PAX: suspicious general protection fault", regs, error_code);
+	else
+#endif
+
 	die("general protection fault", regs, error_code);
 }
 
@@ -435,6 +464,17 @@ static notrace __kprobes void default_do
 dotraplinkage notrace __kprobes void
 do_nmi(struct pt_regs *regs, long error_code)
 {
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	if (!user_mode(regs)) {
+		unsigned long cs = regs->cs & 0xFFFF;
+		unsigned long ip = ktva_ktla(regs->ip);
+
+		if ((cs == __KERNEL_CS || cs == __KERNEXEC_KERNEL_CS) && ip <= (unsigned long)_etext)
+			regs->ip = ip;
+	}
+#endif
+
 	nmi_enter();
 
 	inc_irq_stat(__nmi_count);
@@ -558,7 +598,7 @@ dotraplinkage void __kprobes do_debug(st
 	}
 
 #ifdef CONFIG_X86_32
-	if (regs->flags & X86_VM_MASK)
+	if (v8086_mode(regs))
 		goto debug_vm86;
 #endif
 
@@ -570,7 +610,7 @@ dotraplinkage void __kprobes do_debug(st
 	 * kernel space (but re-enable TF when returning to user mode).
 	 */
 	if (condition & DR_STEP) {
-		if (!user_mode(regs))
+		if (!user_mode_novm(regs))
 			goto clear_TF_reenable;
 	}
 
@@ -757,7 +797,7 @@ do_simd_coprocessor_error(struct pt_regs
 	 * Handle strange cache flush from user space exception
 	 * in all other cases.  This is undocumented behaviour.
 	 */
-	if (regs->flags & X86_VM_MASK) {
+	if (v8086_mode(regs)) {
 		handle_vm86_fault((struct kernel_vm86_regs *)regs, error_code);
 		return;
 	}
@@ -798,7 +838,7 @@ asmlinkage void __attribute__((weak)) sm
 void __math_state_restore(void)
 {
 	struct thread_info *thread = current_thread_info();
-	struct task_struct *tsk = thread->task;
+	struct task_struct *tsk = current;
 
 	/*
 	 * Paranoid restore. send a SIGSEGV if we fail to restore the state.
@@ -825,8 +865,7 @@ void __math_state_restore(void)
  */
 asmlinkage void math_state_restore(void)
 {
-	struct thread_info *thread = current_thread_info();
-	struct task_struct *tsk = thread->task;
+	struct task_struct *tsk = current;
 
 	if (!tsk_used_math(tsk)) {
 		local_irq_enable();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/vm86_32.c linux-2.6.32.60-pax/arch/x86/kernel/vm86_32.c
--- linux-2.6.32.60/arch/x86/kernel/vm86_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/vm86_32.c	2012-05-20 19:21:25.325167265 +0200
@@ -148,7 +148,7 @@ struct pt_regs *save_v86_state(struct ke
 		do_exit(SIGSEGV);
 	}
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	current->thread.sp0 = current->thread.saved_sp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_sp0(tss, &current->thread);
@@ -324,7 +324,7 @@ static void do_sys_vm86(struct kernel_vm
 	tsk->thread.saved_fs = info->regs32->fs;
 	tsk->thread.saved_gs = get_user_gs(info->regs32);
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	tsk->thread.sp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
@@ -529,7 +529,7 @@ static void do_int(struct kernel_vm86_re
 		goto cannot_handle;
 	if (i == 0x21 && is_revectored(AH(regs), &KVM86->int21_revectored))
 		goto cannot_handle;
-	intr_ptr = (unsigned long __user *) (i << 2);
+	intr_ptr = (__force unsigned long __user *) (i << 2);
 	if (get_user(segoffs, intr_ptr))
 		goto cannot_handle;
 	if ((segoffs >> 16) == BIOSSEG)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/vmi_32.c linux-2.6.32.60-pax/arch/x86/kernel/vmi_32.c
--- linux-2.6.32.60/arch/x86/kernel/vmi_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/vmi_32.c	2013-02-17 17:30:49.468121465 +0100
@@ -44,12 +44,17 @@ typedef u32 __attribute__((regparm(1)))
 typedef u64 __attribute__((regparm(2))) (VROMLONGFUNC)(int);
 
 #define call_vrom_func(rom,func) \
-   (((VROMFUNC *)(rom->func))())
+   (((VROMFUNC *)(ktva_ktla(rom.func)))())
 
 #define call_vrom_long_func(rom,func,arg) \
-   (((VROMLONGFUNC *)(rom->func)) (arg))
+({\
+	u64 __reloc = ((VROMLONGFUNC *)(ktva_ktla(rom.func))) (arg);\
+	struct vmi_relocation_info *const __rel = (struct vmi_relocation_info *)&__reloc;\
+	__rel->eip = (unsigned char *)ktva_ktla((unsigned long)__rel->eip);\
+	__reloc;\
+})
 
-static struct vrom_header *vmi_rom;
+static struct vrom_header vmi_rom __attribute((__section__(".vmi.rom"), __aligned__(PAGE_SIZE)));
 static int disable_pge;
 static int disable_pse;
 static int disable_sep;
@@ -76,10 +81,10 @@ static struct {
 	void (*set_initial_ap_state)(int, int);
 	void (*halt)(void);
   	void (*set_lazy_mode)(int mode);
-} vmi_ops;
+} __no_const vmi_ops __read_only;
 
 /* Cached VMI operations */
-struct vmi_timer_ops vmi_timer_ops;
+struct vmi_timer_ops vmi_timer_ops __read_only;
 
 /*
  * VMI patching routines.
@@ -94,7 +99,7 @@ struct vmi_timer_ops vmi_timer_ops;
 static inline void patch_offset(void *insnbuf,
 				unsigned long ip, unsigned long dest)
 {
-        *(unsigned long *)(insnbuf+1) = dest-ip-5;
+	*(unsigned long *)(insnbuf+1) = dest-ip-5;
 }
 
 static unsigned patch_internal(int call, unsigned len, void *insnbuf,
@@ -102,6 +107,7 @@ static unsigned patch_internal(int call,
 {
 	u64 reloc;
 	struct vmi_relocation_info *const rel = (struct vmi_relocation_info *)&reloc;
+
 	reloc = call_vrom_long_func(vmi_rom, get_reloc,	call);
 	switch(rel->type) {
 		case VMI_RELOCATION_CALL_REL:
@@ -404,13 +410,13 @@ static void vmi_set_pud(pud_t *pudp, pud
 
 static void vmi_pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
-	const pte_t pte = { .pte = 0 };
+	const pte_t pte = __pte(0ULL);
 	vmi_ops.set_pte(pte, ptep, vmi_flags_addr(mm, addr, VMI_PAGE_PT, 0));
 }
 
 static void vmi_pmd_clear(pmd_t *pmd)
 {
-	const pte_t pte = { .pte = 0 };
+	const pte_t pte = __pte(0ULL);
 	vmi_ops.set_pte(pte, (pte_t *)pmd, VMI_PAGE_PD);
 }
 #endif
@@ -438,10 +444,10 @@ vmi_startup_ipi_hook(int phys_apicid, un
 	ap.ss = __KERNEL_DS;
 	ap.esp = (unsigned long) start_esp;
 
-	ap.ds = __USER_DS;
-	ap.es = __USER_DS;
+	ap.ds = __KERNEL_DS;
+	ap.es = __KERNEL_DS;
 	ap.fs = __KERNEL_PERCPU;
-	ap.gs = __KERNEL_STACK_CANARY;
+	savesegment(gs, ap.gs);
 
 	ap.eflags = 0;
 
@@ -486,6 +492,18 @@ static void vmi_leave_lazy_mmu(void)
 	paravirt_leave_lazy_mmu();
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+static unsigned long vmi_pax_open_kernel(void)
+{
+	return 0;
+}
+
+static unsigned long vmi_pax_close_kernel(void)
+{
+	return 0;
+}
+#endif
+
 static inline int __init check_vmi_rom(struct vrom_header *rom)
 {
 	struct pci_header *pci;
@@ -498,6 +516,10 @@ static inline int __init check_vmi_rom(s
 		return 0;
 	if (rom->vrom_signature != VMI_SIGNATURE)
 		return 0;
+	if (rom->rom_length * 512 > sizeof(*rom)) {
+		printk(KERN_WARNING "PAX: VMI: ROM size too big: %x\n", rom->rom_length * 512);
+		return 0;
+	}
 	if (rom->api_version_maj != VMI_API_REV_MAJOR ||
 	    rom->api_version_min+1 < VMI_API_REV_MINOR+1) {
 		printk(KERN_WARNING "VMI: Found mismatched rom version %d.%d\n",
@@ -562,7 +584,7 @@ static inline int __init probe_vmi_rom(v
 		struct vrom_header *romstart;
 		romstart = (struct vrom_header *)isa_bus_to_virt(base);
 		if (check_vmi_rom(romstart)) {
-			vmi_rom = romstart;
+			vmi_rom = *romstart;
 			return 1;
 		}
 	}
@@ -836,6 +858,11 @@ static inline int __init activate_vmi(vo
 
 	para_fill(pv_irq_ops.safe_halt, Halt);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pv_mmu_ops.pax_open_kernel = vmi_pax_open_kernel;
+	pv_mmu_ops.pax_close_kernel = vmi_pax_close_kernel;
+#endif
+
 	/*
 	 * Alternative instruction rewriting doesn't happen soon enough
 	 * to convert VMI_IRET to a call instead of a jump; so we have
@@ -853,16 +880,16 @@ static inline int __init activate_vmi(vo
 
 void __init vmi_init(void)
 {
-	if (!vmi_rom)
+	if (!vmi_rom.rom_signature)
 		probe_vmi_rom();
 	else
-		check_vmi_rom(vmi_rom);
+		check_vmi_rom(&vmi_rom);
 
 	/* In case probing for or validating the ROM failed, basil */
-	if (!vmi_rom)
+	if (!vmi_rom.rom_signature)
 		return;
 
-	reserve_top_address(-vmi_rom->virtual_top);
+	reserve_top_address(-vmi_rom.virtual_top);
 
 #ifdef CONFIG_X86_IO_APIC
 	/* This is virtual hardware; timer routing is wired correctly */
@@ -874,7 +901,7 @@ void __init vmi_activate(void)
 {
 	unsigned long flags;
 
-	if (!vmi_rom)
+	if (!vmi_rom.rom_signature)
 		return;
 
 	local_irq_save(flags);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/vmlinux.lds.S linux-2.6.32.60-pax/arch/x86/kernel/vmlinux.lds.S
--- linux-2.6.32.60/arch/x86/kernel/vmlinux.lds.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/vmlinux.lds.S	2012-07-31 00:31:25.424075303 +0200
@@ -26,6 +26,13 @@
 #include <asm/page_types.h>
 #include <asm/cache.h>
 #include <asm/boot.h>
+#include <asm/segment.h>
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#define __KERNEL_TEXT_OFFSET	(LOAD_OFFSET + ____LOAD_PHYSICAL_ADDR)
+#else
+#define __KERNEL_TEXT_OFFSET	0
+#endif
 
 #undef i386     /* in case the preprocessor is a 32bit one */
 
@@ -34,40 +41,53 @@ OUTPUT_FORMAT(CONFIG_OUTPUT_FORMAT, CONF
 #ifdef CONFIG_X86_32
 OUTPUT_ARCH(i386)
 ENTRY(phys_startup_32)
-jiffies = jiffies_64;
 #else
 OUTPUT_ARCH(i386:x86-64)
 ENTRY(phys_startup_64)
-jiffies_64 = jiffies;
 #endif
 
 PHDRS {
 	text PT_LOAD FLAGS(5);          /* R_E */
-	data PT_LOAD FLAGS(7);          /* RWE */
+#ifdef CONFIG_X86_32
+	module PT_LOAD FLAGS(5);        /* R_E */
+#endif
+#ifdef CONFIG_XEN
+	rodata PT_LOAD FLAGS(5);        /* R_E */
+#else
+	rodata PT_LOAD FLAGS(4);        /* R__ */
+#endif
+	data PT_LOAD FLAGS(6);          /* RW_ */
 #ifdef CONFIG_X86_64
 	user PT_LOAD FLAGS(5);          /* R_E */
+#endif
+	init.begin PT_LOAD FLAGS(6);    /* RW_ */
 #ifdef CONFIG_SMP
 	percpu PT_LOAD FLAGS(6);        /* RW_ */
 #endif
+	text.init PT_LOAD FLAGS(5);     /* R_E */
+	text.exit PT_LOAD FLAGS(5);     /* R_E */
 	init PT_LOAD FLAGS(7);          /* RWE */
-#endif
 	note PT_NOTE FLAGS(0);          /* ___ */
 }
 
 SECTIONS
 {
 #ifdef CONFIG_X86_32
-        . = LOAD_OFFSET + LOAD_PHYSICAL_ADDR;
-        phys_startup_32 = startup_32 - LOAD_OFFSET;
+	. = LOAD_OFFSET + ____LOAD_PHYSICAL_ADDR;
 #else
-        . = __START_KERNEL;
-        phys_startup_64 = startup_64 - LOAD_OFFSET;
+	. = __START_KERNEL;
 #endif
 
 	/* Text and read-only data */
-	.text :  AT(ADDR(.text) - LOAD_OFFSET) {
-		_text = .;
+	.text (. - __KERNEL_TEXT_OFFSET): AT(ADDR(.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
 		/* bootstrapping code */
+#ifdef CONFIG_X86_32
+		phys_startup_32 = startup_32 - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
+#else
+		phys_startup_64 = startup_64 - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
+#endif
+		__LOAD_PHYSICAL_ADDR = . - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
+		_text = .;
 		HEAD_TEXT
 #ifdef CONFIG_X86_32
 		. = ALIGN(PAGE_SIZE);
@@ -82,28 +102,72 @@ SECTIONS
 		IRQENTRY_TEXT
 		*(.fixup)
 		*(.gnu.warning)
-		/* End of text section */
-		_etext = .;
 	} :text = 0x9090
 
-	NOTES :text :note
+	. += __KERNEL_TEXT_OFFSET;
+
+#ifdef CONFIG_X86_32
+	. = ALIGN(PAGE_SIZE);
+	.vmi.rom : AT(ADDR(.vmi.rom) - LOAD_OFFSET) {
+		*(.vmi.rom)
+	} :module
+
+	. = ALIGN(PAGE_SIZE);
+	.module.text : AT(ADDR(.module.text) - LOAD_OFFSET) {
+
+#if defined(CONFIG_PAX_KERNEXEC) && defined(CONFIG_MODULES)
+		MODULES_EXEC_VADDR = .;
+		BYTE(0)
+		. += (CONFIG_PAX_KERNEXEC_MODULE_TEXT * 1024 * 1024);
+		. = ALIGN(HPAGE_SIZE) - 1;
+		MODULES_EXEC_END = .;
+#endif
+
+	} :module
+#endif
 
-	EXCEPTION_TABLE(16) :text = 0x9090
+	.text.end : AT(ADDR(.text.end) - LOAD_OFFSET) {
+		/* End of text section */
+		BYTE(0)
+		_etext = . - __KERNEL_TEXT_OFFSET;
+	}
+
+#ifdef CONFIG_X86_32
+	. = ALIGN(PAGE_SIZE);
+	.rodata.page_aligned : AT(ADDR(.rodata.page_aligned) - LOAD_OFFSET) {
+		*(.idt)
+		. = ALIGN(PAGE_SIZE);
+		*(.empty_zero_page)
+		*(.swapper_pg_fixmap)
+		*(.swapper_pg_pmd)
+		*(.swapper_pg_dir)
+		*(.trampoline_pg_dir)
+	} :rodata
+#endif
+
+	. = ALIGN(PAGE_SIZE);
+	NOTES :rodata :note
+
+	EXCEPTION_TABLE(16) :rodata
 
 	RO_DATA(PAGE_SIZE)
 
 	/* Data */
 	.data : AT(ADDR(.data) - LOAD_OFFSET) {
+
+#ifdef CONFIG_PAX_KERNEXEC
+		. = ALIGN(HPAGE_SIZE);
+#else
+		. = ALIGN(PAGE_SIZE);
+#endif
+
 		/* Start of data section */
 		_sdata = .;
 
 		/* init_task */
 		INIT_TASK_DATA(THREAD_SIZE)
 
-#ifdef CONFIG_X86_32
-		/* 32 bit has nosave before _edata */
 		NOSAVE_DATA
-#endif
 
 		PAGE_ALIGNED_DATA(PAGE_SIZE)
 
@@ -112,6 +176,8 @@ SECTIONS
 		DATA_DATA
 		CONSTRUCTORS
 
+		jiffies = jiffies_64;
+
 		/* rarely changed data like cpu maps */
 		READ_MOSTLY_DATA(CONFIG_X86_INTERNODE_CACHE_BYTES)
 
@@ -166,12 +232,6 @@ SECTIONS
 	}
 	vgetcpu_mode = VVIRT(.vgetcpu_mode);
 
-	. = ALIGN(CONFIG_X86_L1_CACHE_BYTES);
-	.jiffies : AT(VLOAD(.jiffies)) {
-		*(.jiffies)
-	}
-	jiffies = VVIRT(.jiffies);
-
 	.vsyscall_3 ADDR(.vsyscall_0) + 3072: AT(VLOAD(.vsyscall_3)) {
 		*(.vsyscall_3)
 	}
@@ -187,12 +247,19 @@ SECTIONS
 #endif /* CONFIG_X86_64 */
 
 	/* Init code and data - will be freed after init */
-	. = ALIGN(PAGE_SIZE);
 	.init.begin : AT(ADDR(.init.begin) - LOAD_OFFSET) {
+		BYTE(0)
+
+#ifdef CONFIG_PAX_KERNEXEC
+		. = ALIGN(HPAGE_SIZE);
+#else
+		. = ALIGN(PAGE_SIZE);
+#endif
+
 		__init_begin = .; /* paired with __init_end */
-	}
+	} :init.begin
 
-#if defined(CONFIG_X86_64) && defined(CONFIG_SMP)
+#ifdef CONFIG_SMP
 	/*
 	 * percpu offsets are zero-based on SMP.  PERCPU_VADDR() changes the
 	 * output PHDR, so the next output section - .init.text - should
@@ -201,12 +268,27 @@ SECTIONS
 	PERCPU_VADDR(0, :percpu)
 #endif
 
-	INIT_TEXT_SECTION(PAGE_SIZE)
-#ifdef CONFIG_X86_64
-	:init
-#endif
+	. = ALIGN(PAGE_SIZE);
+	init_begin = .;
+	.init.text (. - __KERNEL_TEXT_OFFSET): AT(init_begin - LOAD_OFFSET) {
+		VMLINUX_SYMBOL(_sinittext) = .;
+		INIT_TEXT
+		VMLINUX_SYMBOL(_einittext) = .;
+		. = ALIGN(PAGE_SIZE);
+	} :text.init
 
-	INIT_DATA_SECTION(16)
+	/*
+	 * .exit.text is discard at runtime, not link time, to deal with
+	 *  references from .altinstructions and .eh_frame
+	 */
+	.exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+		EXIT_TEXT
+		. = ALIGN(16);
+	} :text.exit
+	. = init_begin + SIZEOF(.init.text) + SIZEOF(.exit.text);
+
+	. = ALIGN(PAGE_SIZE);
+	INIT_DATA_SECTION(16) :init
 
 	.x86_cpu_dev.init : AT(ADDR(.x86_cpu_dev.init) - LOAD_OFFSET) {
 		__x86_cpu_dev_start = .;
@@ -232,19 +314,11 @@ SECTIONS
 		*(.altinstr_replacement)
 	}
 
-	/*
-	 * .exit.text is discard at runtime, not link time, to deal with
-	 *  references from .altinstructions and .eh_frame
-	 */
-	.exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET) {
-		EXIT_TEXT
-	}
-
 	.exit.data : AT(ADDR(.exit.data) - LOAD_OFFSET) {
 		EXIT_DATA
 	}
 
-#if !defined(CONFIG_X86_64) || !defined(CONFIG_SMP)
+#ifndef CONFIG_SMP
 	PERCPU(PAGE_SIZE)
 #endif
 
@@ -267,12 +341,6 @@ SECTIONS
 		. = ALIGN(PAGE_SIZE);
 	}
 
-#ifdef CONFIG_X86_64
-	.data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
-		NOSAVE_DATA
-	}
-#endif
-
 	/* BSS */
 	. = ALIGN(PAGE_SIZE);
 	.bss : AT(ADDR(.bss) - LOAD_OFFSET) {
@@ -288,6 +356,7 @@ SECTIONS
 		__brk_base = .;
 		. += 64 * 1024;		/* 64k alignment slop space */
 		*(.brk_reservation)	/* areas brk users have reserved */
+		. = ALIGN(HPAGE_SIZE);
 		__brk_limit = .;
 	}
 
@@ -316,13 +385,12 @@ SECTIONS
  * for the boot processor.
  */
 #define INIT_PER_CPU(x) init_per_cpu__##x = per_cpu__##x + __per_cpu_load
-INIT_PER_CPU(gdt_page);
 INIT_PER_CPU(irq_stack_union);
 
 /*
  * Build-time check on the image size:
  */
-. = ASSERT((_end - _text <= KERNEL_IMAGE_SIZE),
+. = ASSERT((_end - _text - __KERNEL_TEXT_OFFSET <= KERNEL_IMAGE_SIZE),
 	   "kernel image bigger than KERNEL_IMAGE_SIZE");
 
 #ifdef CONFIG_SMP
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/vsyscall_64.c linux-2.6.32.60-pax/arch/x86/kernel/vsyscall_64.c
--- linux-2.6.32.60/arch/x86/kernel/vsyscall_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/vsyscall_64.c	2012-03-13 13:15:34.580098020 +0100
@@ -80,6 +80,7 @@ void update_vsyscall(struct timespec *wa
 
 	write_seqlock_irqsave(&vsyscall_gtod_data.lock, flags);
 	/* copy vsyscall data */
+	strlcpy(vsyscall_gtod_data.clock.name, clock->name, sizeof vsyscall_gtod_data.clock.name);
 	vsyscall_gtod_data.clock.vread = clock->vread;
 	vsyscall_gtod_data.clock.cycle_last = clock->cycle_last;
 	vsyscall_gtod_data.clock.mask = clock->mask;
@@ -203,7 +204,7 @@ vgetcpu(unsigned *cpu, unsigned *node, s
 	   We do this here because otherwise user space would do it on
 	   its own in a likely inferior way (no access to jiffies).
 	   If you don't like it pass NULL. */
-	if (tcache && tcache->blob[0] == (j = __jiffies)) {
+	if (tcache && tcache->blob[0] == (j = jiffies)) {
 		p = tcache->blob[1];
 	} else if (__vgetcpu_mode == VGETCPU_RDTSCP) {
 		/* Load per CPU data from RDTSCP */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/x8664_ksyms_64.c linux-2.6.32.60-pax/arch/x86/kernel/x8664_ksyms_64.c
--- linux-2.6.32.60/arch/x86/kernel/x8664_ksyms_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/x8664_ksyms_64.c	2012-03-13 13:15:34.580098020 +0100
@@ -30,8 +30,6 @@ EXPORT_SYMBOL(__put_user_8);
 
 EXPORT_SYMBOL(copy_user_generic);
 EXPORT_SYMBOL(__copy_user_nocache);
-EXPORT_SYMBOL(copy_from_user);
-EXPORT_SYMBOL(copy_to_user);
 EXPORT_SYMBOL(__copy_from_user_inatomic);
 
 EXPORT_SYMBOL(copy_page);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kernel/xsave.c linux-2.6.32.60-pax/arch/x86/kernel/xsave.c
--- linux-2.6.32.60/arch/x86/kernel/xsave.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kernel/xsave.c	2012-12-01 02:41:05.520121458 +0100
@@ -54,7 +54,7 @@ int check_for_xstate(struct i387_fxsave_
 	    fx_sw_user->xstate_size > fx_sw_user->extended_size)
 		return -1;
 
-	err = __get_user(magic2, (__u32 *) (((void *)fpstate) +
+	err = __get_user(magic2, (__u32 __user *) (((void __user *)fpstate) +
 					    fx_sw_user->extended_size -
 					    FP_XSTATE_MAGIC2_SIZE));
 	/*
@@ -196,7 +196,7 @@ fx_only:
 	 * the other extended state.
 	 */
 	xrstor_state(init_xstate_buf, pcntxt_mask & ~XSTATE_FPSSE);
-	return fxrstor_checking((__force struct i387_fxsave_struct *)buf);
+	return fxrstor_checking((struct i387_fxsave_struct __user *)buf);
 }
 
 /*
@@ -228,8 +228,7 @@ int restore_i387_xstate(void __user *buf
 	if (task_thread_info(tsk)->status & TS_XSAVE)
 		err = restore_user_xstate(buf);
 	else
-		err = fxrstor_checking((__force struct i387_fxsave_struct *)
-				       buf);
+		err = fxrstor_checking((struct i387_fxsave_struct __user *)buf);
 	if (unlikely(err)) {
 		/*
 		 * Encountered an error while doing the restore from the
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/emulate.c linux-2.6.32.60-pax/arch/x86/kvm/emulate.c
--- linux-2.6.32.60/arch/x86/kvm/emulate.c	2012-10-09 11:00:35.432882464 +0200
+++ linux-2.6.32.60-pax/arch/x86/kvm/emulate.c	2012-10-09 11:00:39.268883031 +0200
@@ -81,8 +81,8 @@
 #define Src2CL      (1<<29)
 #define Src2ImmByte (2<<29)
 #define Src2One     (3<<29)
-#define Src2Imm16   (4<<29)
-#define Src2Mask    (7<<29)
+#define Src2Imm16   (4U<<29)
+#define Src2Mask    (7U<<29)
 
 enum {
 	Group1_80, Group1_81, Group1_82, Group1_83,
@@ -411,6 +411,7 @@ static u32 group2_table[] = {
 
 #define ____emulate_2op(_op, _src, _dst, _eflags, _x, _y, _suffix)	\
 	do {								\
+		unsigned long _tmp;					\
 		__asm__ __volatile__ (					\
 			_PRE_EFLAGS("0", "4", "2")			\
 			_op _suffix " %"_x"3,%1; "			\
@@ -424,8 +425,6 @@ static u32 group2_table[] = {
 /* Raw emulation: instruction has two explicit operands. */
 #define __emulate_2op_nobyte(_op,_src,_dst,_eflags,_wx,_wy,_lx,_ly,_qx,_qy) \
 	do {								\
-		unsigned long _tmp;					\
-									\
 		switch ((_dst).bytes) {					\
 		case 2:							\
 			____emulate_2op(_op,_src,_dst,_eflags,_wx,_wy,"w"); \
@@ -441,7 +440,6 @@ static u32 group2_table[] = {
 
 #define __emulate_2op(_op,_src,_dst,_eflags,_bx,_by,_wx,_wy,_lx,_ly,_qx,_qy) \
 	do {								     \
-		unsigned long _tmp;					     \
 		switch ((_dst).bytes) {				             \
 		case 1:							     \
 			____emulate_2op(_op,_src,_dst,_eflags,_bx,_by,"b");  \
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/lapic.c linux-2.6.32.60-pax/arch/x86/kvm/lapic.c
--- linux-2.6.32.60/arch/x86/kvm/lapic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kvm/lapic.c	2012-03-13 13:15:34.584098019 +0100
@@ -52,7 +52,7 @@
 #define APIC_BUS_CYCLE_NS 1
 
 /* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */
-#define apic_debug(fmt, arg...)
+#define apic_debug(fmt, arg...) do {} while (0)
 
 #define APIC_LVT_NUM			6
 /* 14 is the version for Xeon and Pentium 8.4.8*/
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/paging_tmpl.h linux-2.6.32.60-pax/arch/x86/kvm/paging_tmpl.h
--- linux-2.6.32.60/arch/x86/kvm/paging_tmpl.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kvm/paging_tmpl.h	2012-03-13 13:15:34.584098019 +0100
@@ -461,6 +461,7 @@ static int FNAME(page_fault)(struct kvm_
 	kvm_mmu_free_some_pages(vcpu);
 	sptep = FNAME(fetch)(vcpu, addr, &walker, user_fault, write_fault,
 			     level, &write_pt, pfn);
+	(void)sptep;
 	pgprintk("%s: shadow pte %p %llx ptwrite %d\n", __func__,
 		 sptep, *sptep, write_pt);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/svm.c linux-2.6.32.60-pax/arch/x86/kvm/svm.c
--- linux-2.6.32.60/arch/x86/kvm/svm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kvm/svm.c	2012-04-16 12:38:10.890343014 +0200
@@ -2486,7 +2486,11 @@ static void reload_tss(struct kvm_vcpu *
 	int cpu = raw_smp_processor_id();
 
 	struct svm_cpu_data *svm_data = per_cpu(svm_data, cpu);
+
+	pax_open_kernel();
 	svm_data->tss_desc->type = 9; /* available 32/64-bit TSS */
+	pax_close_kernel();
+
 	load_TR_desc();
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/vmx.c linux-2.6.32.60-pax/arch/x86/kvm/vmx.c
--- linux-2.6.32.60/arch/x86/kvm/vmx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/kvm/vmx.c	2012-09-17 23:35:31.133743609 +0200
@@ -570,7 +570,11 @@ static void reload_tss(void)
 
 	kvm_get_gdt(&gdt);
 	descs = (void *)gdt.base;
+
+	pax_open_kernel();
 	descs[GDT_ENTRY_TSS].type = 9; /* available TSS */
+	pax_close_kernel();
+
 	load_TR_desc();
 }
 
@@ -746,6 +750,10 @@ static void vmx_vcpu_load(struct kvm_vcp
 		kvm_get_gdt(&dt);
 		vmcs_writel(HOST_GDTR_BASE, dt.base);   /* 22.2.4 */
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
+#endif
+
 		rdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);
 		vmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */
 
@@ -1410,8 +1418,11 @@ static __init int hardware_setup(void)
 	if (!cpu_has_vmx_flexpriority())
 		flexpriority_enabled = 0;
 
-	if (!cpu_has_vmx_tpr_shadow())
-		kvm_x86_ops->update_cr8_intercept = NULL;
+	if (!cpu_has_vmx_tpr_shadow()) {
+		pax_open_kernel();
+		*(void **)&kvm_x86_ops->update_cr8_intercept = NULL;
+		pax_close_kernel();
+	}
 
 	if (enable_ept && !cpu_has_vmx_ept_2m_page())
 		kvm_disable_largepages();
@@ -2338,7 +2349,10 @@ static int vmx_vcpu_setup(struct vcpu_vm
 
 	vmcs_writel(HOST_CR0, read_cr0());  /* 22.2.3 */
 	vmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */
+
+#ifndef CONFIG_PAX_PER_CPU_PGD
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
+#endif
 
 	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
 	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
@@ -2362,7 +2376,7 @@ static int vmx_vcpu_setup(struct vcpu_vm
 	vmcs_writel(HOST_IDTR_BASE, dt.base);   /* 22.2.4 */
 
 	asm("mov $.Lkvm_vmx_return, %0" : "=r"(kvm_vmx_return));
-	vmcs_writel(HOST_RIP, kvm_vmx_return); /* 22.2.5 */
+	vmcs_writel(HOST_RIP, ktla_ktva(kvm_vmx_return)); /* 22.2.5 */
 	vmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);
 	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);
 	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);
@@ -3718,6 +3732,12 @@ static void vmx_vcpu_run(struct kvm_vcpu
 		"jmp .Lkvm_vmx_return \n\t"
 		".Llaunched: " __ex(ASM_VMX_VMRESUME) "\n\t"
 		".Lkvm_vmx_return: "
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+		"ljmp %[cs],$.Lkvm_vmx_return2\n\t"
+		".Lkvm_vmx_return2: "
+#endif
+
 		/* Save guest registers, load host registers, keep flags */
 		"xchg %0,     (%%"R"sp) \n\t"
 		"mov %%"R"ax, %c[rax](%0) \n\t"
@@ -3764,8 +3784,13 @@ static void vmx_vcpu_run(struct kvm_vcpu
 		[r15]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),
 #endif
 		[cr2]"i"(offsetof(struct vcpu_vmx, vcpu.arch.cr2))
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+		,[cs]"i"(__KERNEL_CS)
+#endif
+
 	      : "cc", "memory"
-		, R"bx", R"di", R"si"
+		, R"ax", R"bx", R"di", R"si"
 #ifdef CONFIG_X86_64
 		, "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
 #endif
@@ -3782,7 +3807,16 @@ static void vmx_vcpu_run(struct kvm_vcpu
 	if (vmx->rmode.irq.pending)
 		fixup_rmode_irq(vmx);
 
-	asm("mov %0, %%ds; mov %0, %%es" : : "r"(__USER_DS));
+	asm("mov %0, %%ds; mov %0, %%es; mov %0, %%ss" : : "r"(__KERNEL_DS));
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	loadsegment(fs, __KERNEL_PERCPU);
+#endif
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	__set_fs(current_thread_info()->addr_limit);
+#endif
+
 	vmx->launched = 1;
 
 	vmx_complete_interrupts(vmx);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/kvm/x86.c linux-2.6.32.60-pax/arch/x86/kvm/x86.c
--- linux-2.6.32.60/arch/x86/kvm/x86.c	2012-10-09 11:00:35.432882464 +0200
+++ linux-2.6.32.60-pax/arch/x86/kvm/x86.c	2012-10-09 11:00:39.268883031 +0200
@@ -1430,15 +1430,20 @@ static int kvm_vcpu_ioctl_set_cpuid2(str
 				     struct kvm_cpuid2 *cpuid,
 				     struct kvm_cpuid_entry2 __user *entries)
 {
-	int r;
+	int r, i;
 
 	r = -E2BIG;
 	if (cpuid->nent > KVM_MAX_CPUID_ENTRIES)
 		goto out;
 	r = -EFAULT;
-	if (copy_from_user(&vcpu->arch.cpuid_entries, entries,
-			   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))
+	if (!access_ok(VERIFY_READ, entries, cpuid->nent * sizeof(struct kvm_cpuid_entry2)))
 		goto out;
+	for (i = 0; i < cpuid->nent; ++i) {
+		struct kvm_cpuid_entry2 cpuid_entry;
+		if (__copy_from_user(&cpuid_entry, entries + i, sizeof(cpuid_entry)))
+			goto out;
+		vcpu->arch.cpuid_entries[i] = cpuid_entry;
+	}
 	vcpu->arch.cpuid_nent = cpuid->nent;
 	kvm_apic_set_version(vcpu);
 	return 0;
@@ -1451,16 +1456,20 @@ static int kvm_vcpu_ioctl_get_cpuid2(str
 				     struct kvm_cpuid2 *cpuid,
 				     struct kvm_cpuid_entry2 __user *entries)
 {
-	int r;
+	int r, i;
 
 	vcpu_load(vcpu);
 	r = -E2BIG;
 	if (cpuid->nent < vcpu->arch.cpuid_nent)
 		goto out;
 	r = -EFAULT;
-	if (copy_to_user(entries, &vcpu->arch.cpuid_entries,
-			 vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))
+	if (!access_ok(VERIFY_WRITE, entries, vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))
 		goto out;
+	for (i = 0; i < vcpu->arch.cpuid_nent; ++i) {
+		struct kvm_cpuid_entry2 cpuid_entry = vcpu->arch.cpuid_entries[i];
+		if (__copy_to_user(entries + i, &cpuid_entry, sizeof(cpuid_entry)))
+			goto out;
+	}
 	return 0;
 
 out:
@@ -1678,7 +1687,7 @@ static int kvm_vcpu_ioctl_set_lapic(stru
 static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
 				    struct kvm_interrupt *irq)
 {
-	if (irq->irq < 0 || irq->irq >= 256)
+	if (irq->irq >= 256)
 		return -EINVAL;
 	if (irqchip_in_kernel(vcpu->kvm))
 		return -ENXIO;
@@ -3300,7 +3309,7 @@ static struct notifier_block kvmclock_cp
         .notifier_call  = kvmclock_cpufreq_notifier
 };
 
-int kvm_arch_init(void *opaque)
+int kvm_arch_init(const void *opaque)
 {
 	int r, cpu;
 	struct kvm_x86_ops *ops = (struct kvm_x86_ops *)opaque;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lguest/boot.c linux-2.6.32.60-pax/arch/x86/lguest/boot.c
--- linux-2.6.32.60/arch/x86/lguest/boot.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lguest/boot.c	2013-02-17 17:31:20.864119789 +0100
@@ -1172,9 +1172,10 @@ static __init int early_put_chars(u32 vt
  * Rebooting also tells the Host we're finished, but the RESTART flag tells the
  * Launcher to reboot us.
  */
-static void lguest_restart(char *reason)
+static __noreturn void lguest_restart(char *reason)
 {
 	kvm_hypercall2(LHCALL_SHUTDOWN, __pa(reason), LGUEST_SHUTDOWN_RESTART);
+	BUG();
 }
 
 /*G:050
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/atomic64_32.c linux-2.6.32.60-pax/arch/x86/lib/atomic64_32.c
--- linux-2.6.32.60/arch/x86/lib/atomic64_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/atomic64_32.c	2012-03-13 13:15:34.596098019 +0100
@@ -25,6 +25,12 @@ u64 atomic64_cmpxchg(atomic64_t *ptr, u6
 }
 EXPORT_SYMBOL(atomic64_cmpxchg);
 
+u64 atomic64_cmpxchg_unchecked(atomic64_unchecked_t *ptr, u64 old_val, u64 new_val)
+{
+	return cmpxchg8b(&ptr->counter, old_val, new_val);
+}
+EXPORT_SYMBOL(atomic64_cmpxchg_unchecked);
+
 /**
  * atomic64_xchg - xchg atomic64 variable
  * @ptr:      pointer to type atomic64_t
@@ -56,6 +62,36 @@ u64 atomic64_xchg(atomic64_t *ptr, u64 n
 EXPORT_SYMBOL(atomic64_xchg);
 
 /**
+ * atomic64_xchg_unchecked - xchg atomic64 variable
+ * @ptr:      pointer to type atomic64_unchecked_t
+ * @new_val:  value to assign
+ *
+ * Atomically xchgs the value of @ptr to @new_val and returns
+ * the old value.
+ */
+u64 atomic64_xchg_unchecked(atomic64_unchecked_t *ptr, u64 new_val)
+{
+	/*
+	 * Try first with a (possibly incorrect) assumption about
+	 * what we have there. We'll do two loops most likely,
+	 * but we'll get an ownership MESI transaction straight away
+	 * instead of a read transaction followed by a
+	 * flush-for-ownership transaction:
+	 */
+	u64 old_val, real_val = 0;
+
+	do {
+		old_val = real_val;
+
+		real_val = atomic64_cmpxchg_unchecked(ptr, old_val, new_val);
+
+	} while (real_val != old_val);
+
+	return old_val;
+}
+EXPORT_SYMBOL(atomic64_xchg_unchecked);
+
+/**
  * atomic64_set - set atomic64 variable
  * @ptr:      pointer to type atomic64_t
  * @new_val:  value to assign
@@ -69,7 +105,19 @@ void atomic64_set(atomic64_t *ptr, u64 n
 EXPORT_SYMBOL(atomic64_set);
 
 /**
-EXPORT_SYMBOL(atomic64_read);
+ * atomic64_unchecked_set - set atomic64 variable
+ * @ptr:      pointer to type atomic64_unchecked_t
+ * @new_val:  value to assign
+ *
+ * Atomically sets the value of @ptr to @new_val.
+ */
+void atomic64_set_unchecked(atomic64_unchecked_t *ptr, u64 new_val)
+{
+	atomic64_xchg_unchecked(ptr, new_val);
+}
+EXPORT_SYMBOL(atomic64_set_unchecked);
+
+/**
  * atomic64_add_return - add and return
  * @delta: integer value to add
  * @ptr:   pointer to type atomic64_t
@@ -99,24 +147,72 @@ noinline u64 atomic64_add_return(u64 del
 }
 EXPORT_SYMBOL(atomic64_add_return);
 
+/**
+ * atomic64_add_return_unchecked - add and return
+ * @delta: integer value to add
+ * @ptr:   pointer to type atomic64_unchecked_t
+ *
+ * Atomically adds @delta to @ptr and returns @delta + *@ptr
+ */
+noinline u64 atomic64_add_return_unchecked(u64 delta, atomic64_unchecked_t *ptr)
+{
+	/*
+	 * Try first with a (possibly incorrect) assumption about
+	 * what we have there. We'll do two loops most likely,
+	 * but we'll get an ownership MESI transaction straight away
+	 * instead of a read transaction followed by a
+	 * flush-for-ownership transaction:
+	 */
+	u64 old_val, new_val, real_val = 0;
+
+	do {
+		old_val = real_val;
+		new_val = old_val + delta;
+
+		real_val = atomic64_cmpxchg_unchecked(ptr, old_val, new_val);
+
+	} while (real_val != old_val);
+
+	return new_val;
+}
+EXPORT_SYMBOL(atomic64_add_return_unchecked);
+
 u64 atomic64_sub_return(u64 delta, atomic64_t *ptr)
 {
 	return atomic64_add_return(-delta, ptr);
 }
 EXPORT_SYMBOL(atomic64_sub_return);
 
+u64 atomic64_sub_return_unchecked(u64 delta, atomic64_unchecked_t *ptr)
+{
+	return atomic64_add_return_unchecked(-delta, ptr);
+}
+EXPORT_SYMBOL(atomic64_sub_return_unchecked);
+
 u64 atomic64_inc_return(atomic64_t *ptr)
 {
 	return atomic64_add_return(1, ptr);
 }
 EXPORT_SYMBOL(atomic64_inc_return);
 
+u64 atomic64_inc_return_unchecked(atomic64_unchecked_t *ptr)
+{
+	return atomic64_add_return_unchecked(1, ptr);
+}
+EXPORT_SYMBOL(atomic64_inc_return_unchecked);
+
 u64 atomic64_dec_return(atomic64_t *ptr)
 {
 	return atomic64_sub_return(1, ptr);
 }
 EXPORT_SYMBOL(atomic64_dec_return);
 
+u64 atomic64_dec_return_unchecked(atomic64_unchecked_t *ptr)
+{
+	return atomic64_sub_return_unchecked(1, ptr);
+}
+EXPORT_SYMBOL(atomic64_dec_return_unchecked);
+
 /**
  * atomic64_add - add integer to atomic64 variable
  * @delta: integer value to add
@@ -131,6 +227,19 @@ void atomic64_add(u64 delta, atomic64_t
 EXPORT_SYMBOL(atomic64_add);
 
 /**
+ * atomic64_add_unchecked - add integer to atomic64 variable
+ * @delta: integer value to add
+ * @ptr:   pointer to type atomic64_unchecked_t
+ *
+ * Atomically adds @delta to @ptr.
+ */
+void atomic64_add_unchecked(u64 delta, atomic64_unchecked_t *ptr)
+{
+	atomic64_add_return_unchecked(delta, ptr);
+}
+EXPORT_SYMBOL(atomic64_add_unchecked);
+
+/**
  * atomic64_sub - subtract the atomic64 variable
  * @delta: integer value to subtract
  * @ptr:   pointer to type atomic64_t
@@ -144,6 +253,19 @@ void atomic64_sub(u64 delta, atomic64_t
 EXPORT_SYMBOL(atomic64_sub);
 
 /**
+ * atomic64_sub_unchecked - subtract the atomic64 variable
+ * @delta: integer value to subtract
+ * @ptr:   pointer to type atomic64_unchecked_t
+ *
+ * Atomically subtracts @delta from @ptr.
+ */
+void atomic64_sub_unchecked(u64 delta, atomic64_unchecked_t *ptr)
+{
+	atomic64_add_unchecked(-delta, ptr);
+}
+EXPORT_SYMBOL(atomic64_sub_unchecked);
+
+/**
  * atomic64_sub_and_test - subtract value from variable and test result
  * @delta: integer value to subtract
  * @ptr:   pointer to type atomic64_t
@@ -173,6 +295,18 @@ void atomic64_inc(atomic64_t *ptr)
 EXPORT_SYMBOL(atomic64_inc);
 
 /**
+ * atomic64_inc_unchecked - increment atomic64 variable
+ * @ptr: pointer to type atomic64_unchecked_t
+ *
+ * Atomically increments @ptr by 1.
+ */
+void atomic64_inc_unchecked(atomic64_unchecked_t *ptr)
+{
+	atomic64_add_unchecked(1, ptr);
+}
+EXPORT_SYMBOL(atomic64_inc_unchecked);
+
+/**
  * atomic64_dec - decrement atomic64 variable
  * @ptr: pointer to type atomic64_t
  *
@@ -185,6 +319,18 @@ void atomic64_dec(atomic64_t *ptr)
 EXPORT_SYMBOL(atomic64_dec);
 
 /**
+ * atomic64_dec_unchecked - decrement atomic64 variable
+ * @ptr: pointer to type atomic64_unchecked_t
+ *
+ * Atomically decrements @ptr by 1.
+ */
+void atomic64_dec_unchecked(atomic64_unchecked_t *ptr)
+{
+	atomic64_sub_unchecked(1, ptr);
+}
+EXPORT_SYMBOL(atomic64_dec_unchecked);
+
+/**
  * atomic64_dec_and_test - decrement and test
  * @ptr: pointer to type atomic64_t
  *
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/checksum_32.S linux-2.6.32.60-pax/arch/x86/lib/checksum_32.S
--- linux-2.6.32.60/arch/x86/lib/checksum_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/checksum_32.S	2012-03-13 13:15:34.596098019 +0100
@@ -28,7 +28,8 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
 #include <asm/errno.h>
-				
+#include <asm/segment.h>
+
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
  */
@@ -304,9 +305,28 @@ unsigned int csum_partial_copy_generic (
 
 #define ARGBASE 16		
 #define FP		12
-		
-ENTRY(csum_partial_copy_generic)
+
+ENTRY(csum_partial_copy_generic_to_user)
 	CFI_STARTPROC
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl %gs
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
+	jmp csum_partial_copy_generic
+#endif
+
+ENTRY(csum_partial_copy_generic_from_user)
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl %gs
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+#endif
+
+ENTRY(csum_partial_copy_generic)
 	subl  $4,%esp	
 	CFI_ADJUST_CFA_OFFSET 4
 	pushl %edi
@@ -331,7 +351,7 @@ ENTRY(csum_partial_copy_generic)
 	jmp 4f
 SRC(1:	movw (%esi), %bx	)
 	addl $2, %esi
-DST(	movw %bx, (%edi)	)
+DST(	movw %bx, %es:(%edi)	)
 	addl $2, %edi
 	addw %bx, %ax	
 	adcl $0, %eax
@@ -343,30 +363,30 @@ DST(	movw %bx, (%edi)	)
 SRC(1:	movl (%esi), %ebx	)
 SRC(	movl 4(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 4(%edi)	)
+DST(	movl %edx, %es:4(%edi)	)
 
 SRC(	movl 8(%esi), %ebx	)
 SRC(	movl 12(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 8(%edi)	)
+DST(	movl %ebx, %es:8(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 12(%edi)	)
+DST(	movl %edx, %es:12(%edi)	)
 
 SRC(	movl 16(%esi), %ebx 	)
 SRC(	movl 20(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 16(%edi)	)
+DST(	movl %ebx, %es:16(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 20(%edi)	)
+DST(	movl %edx, %es:20(%edi)	)
 
 SRC(	movl 24(%esi), %ebx	)
 SRC(	movl 28(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 24(%edi)	)
+DST(	movl %ebx, %es:24(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 28(%edi)	)
+DST(	movl %edx, %es:28(%edi)	)
 
 	lea 32(%esi), %esi
 	lea 32(%edi), %edi
@@ -380,7 +400,7 @@ DST(	movl %edx, 28(%edi)	)
 	shrl $2, %edx			# This clears CF
 SRC(3:	movl (%esi), %ebx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	lea 4(%esi), %esi
 	lea 4(%edi), %edi
 	dec %edx
@@ -392,12 +412,12 @@ DST(	movl %ebx, (%edi)	)
 	jb 5f
 SRC(	movw (%esi), %cx	)
 	leal 2(%esi), %esi
-DST(	movw %cx, (%edi)	)
+DST(	movw %cx, %es:(%edi)	)
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%ecx
 SRC(5:	movb (%esi), %cl	)
-DST(	movb %cl, (%edi)	)
+DST(	movb %cl, %es:(%edi)	)
 6:	addl %ecx, %eax
 	adcl $0, %eax
 7:
@@ -408,7 +428,7 @@ DST(	movb %cl, (%edi)	)
 
 6001:
 	movl ARGBASE+20(%esp), %ebx	# src_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 
 	# zero the complete destination - computing the rest
 	# is too much work 
@@ -421,11 +441,19 @@ DST(	movb %cl, (%edi)	)
 
 6002:
 	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT,(%ebx)
+	movl $-EFAULT,%ss:(%ebx)
 	jmp 5000b
 
 .previous
 
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
 	popl %ebx
 	CFI_ADJUST_CFA_OFFSET -4
 	CFI_RESTORE ebx
@@ -439,26 +467,47 @@ DST(	movb %cl, (%edi)	)
 	CFI_ADJUST_CFA_OFFSET -4
 	ret	
 	CFI_ENDPROC
-ENDPROC(csum_partial_copy_generic)
+ENDPROC(csum_partial_copy_generic_to_user)
 
 #else
 
 /* Version for PentiumII/PPro */
 
 #define ROUND1(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	addl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	; 
+	DST(movl %ebx, %es:x(%edi))	;
 
 #define ROUND(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	adcl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	;
+	DST(movl %ebx, %es:x(%edi))	;
 
 #define ARGBASE 12
-		
-ENTRY(csum_partial_copy_generic)
+
+ENTRY(csum_partial_copy_generic_to_user)
 	CFI_STARTPROC
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl %gs
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
+	jmp csum_partial_copy_generic
+#endif
+
+ENTRY(csum_partial_copy_generic_from_user)
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl %gs
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+#endif
+
+ENTRY(csum_partial_copy_generic)
 	pushl %ebx
 	CFI_ADJUST_CFA_OFFSET 4
 	CFI_REL_OFFSET ebx, 0
@@ -482,7 +531,7 @@ ENTRY(csum_partial_copy_generic)
 	subl %ebx, %edi  
 	lea  -1(%esi),%edx
 	andl $-32,%edx
-	lea 3f(%ebx,%ebx), %ebx
+	lea 3f(%ebx,%ebx,2), %ebx
 	testl %esi, %esi 
 	jmp *%ebx
 1:	addl $64,%esi
@@ -503,19 +552,19 @@ ENTRY(csum_partial_copy_generic)
 	jb 5f
 SRC(	movw (%esi), %dx         )
 	leal 2(%esi), %esi
-DST(	movw %dx, (%edi)         )
+DST(	movw %dx, %es:(%edi)     )
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%edx
 5:
 SRC(	movb (%esi), %dl         )
-DST(	movb %dl, (%edi)         )
+DST(	movb %dl, %es:(%edi)     )
 6:	addl %edx, %eax
 	adcl $0, %eax
 7:
 .section .fixup, "ax"
 6001:	movl	ARGBASE+20(%esp), %ebx	# src_err_ptr	
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	# zero the complete destination (computing the rest is too much work)
 	movl ARGBASE+8(%esp),%edi	# dst
 	movl ARGBASE+12(%esp),%ecx	# len
@@ -523,10 +572,21 @@ DST(	movb %dl, (%edi)         )
 	rep; stosb
 	jmp 7b
 6002:	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	jmp  7b			
 .previous				
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
+#endif
+
 	popl %esi
 	CFI_ADJUST_CFA_OFFSET -4
 	CFI_RESTORE esi
@@ -538,7 +598,7 @@ DST(	movb %dl, (%edi)         )
 	CFI_RESTORE ebx
 	ret
 	CFI_ENDPROC
-ENDPROC(csum_partial_copy_generic)
+ENDPROC(csum_partial_copy_generic_to_user)
 				
 #undef ROUND
 #undef ROUND1		
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/clear_page_64.S linux-2.6.32.60-pax/arch/x86/lib/clear_page_64.S
--- linux-2.6.32.60/arch/x86/lib/clear_page_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/clear_page_64.S	2012-03-13 13:15:34.596098019 +0100
@@ -1,5 +1,6 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 /*
  * Zero a page. 	
@@ -10,6 +11,7 @@ ENTRY(clear_page_c)
 	movl $4096/8,%ecx
 	xorl %eax,%eax
 	rep stosq
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(clear_page_c)
@@ -33,6 +35,7 @@ ENTRY(clear_page)
 	leaq	64(%rdi),%rdi
 	jnz	.Lloop
 	nop
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 .Lclear_page_end:
@@ -43,7 +46,7 @@ ENDPROC(clear_page)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb					/* jmp <disp8> */
 	.byte (clear_page_c - clear_page) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/copy_page_64.S linux-2.6.32.60-pax/arch/x86/lib/copy_page_64.S
--- linux-2.6.32.60/arch/x86/lib/copy_page_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/copy_page_64.S	2012-03-13 13:15:34.596098019 +0100
@@ -2,12 +2,14 @@
 
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 	ALIGN
 copy_page_c:
 	CFI_STARTPROC
 	movl $4096/8,%ecx
 	rep movsq
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(copy_page_c)
@@ -38,7 +40,7 @@ ENTRY(copy_page)
 	movq     16 (%rsi), %rdx
 	movq     24 (%rsi), %r8
 	movq     32 (%rsi), %r9
-	movq     40 (%rsi), %r10
+	movq     40 (%rsi), %r13
 	movq     48 (%rsi), %r11
 	movq     56 (%rsi), %r12
 
@@ -49,7 +51,7 @@ ENTRY(copy_page)
 	movq     %rdx, 16 (%rdi)
 	movq     %r8,  24 (%rdi)
 	movq     %r9,  32 (%rdi)
-	movq     %r10, 40 (%rdi)
+	movq     %r13, 40 (%rdi)
 	movq     %r11, 48 (%rdi)
 	movq     %r12, 56 (%rdi)
 
@@ -68,7 +70,7 @@ ENTRY(copy_page)
 	movq     16 (%rsi), %rdx
 	movq     24 (%rsi), %r8
 	movq     32 (%rsi), %r9
-	movq     40 (%rsi), %r10
+	movq     40 (%rsi), %r13
 	movq     48 (%rsi), %r11
 	movq     56 (%rsi), %r12
 
@@ -77,7 +79,7 @@ ENTRY(copy_page)
 	movq     %rdx, 16 (%rdi)
 	movq     %r8,  24 (%rdi)
 	movq     %r9,  32 (%rdi)
-	movq     %r10, 40 (%rdi)
+	movq     %r13, 40 (%rdi)
 	movq     %r11, 48 (%rdi)
 	movq     %r12, 56 (%rdi)
 
@@ -94,6 +96,7 @@ ENTRY(copy_page)
 	CFI_RESTORE r13
 	addq	$3*8,%rsp
 	CFI_ADJUST_CFA_OFFSET -3*8
+	pax_force_retaddr
 	ret
 .Lcopy_page_end:
 	CFI_ENDPROC
@@ -104,7 +107,7 @@ ENDPROC(copy_page)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb					/* jmp <disp8> */
 	.byte (copy_page_c - copy_page) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/copy_user_64.S linux-2.6.32.60-pax/arch/x86/lib/copy_user_64.S
--- linux-2.6.32.60/arch/x86/lib/copy_user_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/copy_user_64.S	2012-03-13 13:15:34.596098019 +0100
@@ -8,6 +8,7 @@
 
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 #define FIX_ALIGNMENT 1
 
@@ -15,13 +16,14 @@
 #include <asm/asm-offsets.h>
 #include <asm/thread_info.h>
 #include <asm/cpufeature.h>
+#include <asm/pgtable.h>
 
 	.macro ALTERNATIVE_JUMP feature,orig,alt
 0:
 	.byte 0xe9	/* 32bit jump */
 	.long \orig-1f	/* by default jump to orig */
 1:
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 2:	.byte 0xe9			/* near jump with 32bit immediate */
 	.long \alt-1b /* offset */   /* or alternatively to alt */
 	.previous
@@ -64,55 +66,26 @@
 #endif
 	.endm
 
-/* Standard copy_to_user with segment limit checking */
-ENTRY(copy_to_user)
-	CFI_STARTPROC
-	GET_THREAD_INFO(%rax)
-	movq %rdi,%rcx
-	addq %rdx,%rcx
-	jc bad_to_user
-	cmpq TI_addr_limit(%rax),%rcx
-	ja bad_to_user
-	ALTERNATIVE_JUMP X86_FEATURE_REP_GOOD,copy_user_generic_unrolled,copy_user_generic_string
-	CFI_ENDPROC
-ENDPROC(copy_to_user)
-
-/* Standard copy_from_user with segment limit checking */
-ENTRY(copy_from_user)
-	CFI_STARTPROC
-	GET_THREAD_INFO(%rax)
-	movq %rsi,%rcx
-	addq %rdx,%rcx
-	jc bad_from_user
-	cmpq TI_addr_limit(%rax),%rcx
-	ja bad_from_user
-	ALTERNATIVE_JUMP X86_FEATURE_REP_GOOD,copy_user_generic_unrolled,copy_user_generic_string
-	CFI_ENDPROC
-ENDPROC(copy_from_user)
-
 ENTRY(copy_user_generic)
 	CFI_STARTPROC
 	ALTERNATIVE_JUMP X86_FEATURE_REP_GOOD,copy_user_generic_unrolled,copy_user_generic_string
 	CFI_ENDPROC
 ENDPROC(copy_user_generic)
 
-ENTRY(__copy_from_user_inatomic)
-	CFI_STARTPROC
-	ALTERNATIVE_JUMP X86_FEATURE_REP_GOOD,copy_user_generic_unrolled,copy_user_generic_string
-	CFI_ENDPROC
-ENDPROC(__copy_from_user_inatomic)
-
 	.section .fixup,"ax"
 	/* must zero dest */
 ENTRY(bad_from_user)
 bad_from_user:
 	CFI_STARTPROC
+	testl %edx,%edx
+	js bad_to_user
 	movl %edx,%ecx
 	xorl %eax,%eax
 	rep
 	stosb
 bad_to_user:
 	movl %edx,%eax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(bad_from_user)
@@ -142,19 +115,19 @@ ENTRY(copy_user_generic_unrolled)
 	jz 17f
 1:	movq (%rsi),%r8
 2:	movq 1*8(%rsi),%r9
-3:	movq 2*8(%rsi),%r10
+3:	movq 2*8(%rsi),%rax
 4:	movq 3*8(%rsi),%r11
 5:	movq %r8,(%rdi)
 6:	movq %r9,1*8(%rdi)
-7:	movq %r10,2*8(%rdi)
+7:	movq %rax,2*8(%rdi)
 8:	movq %r11,3*8(%rdi)
 9:	movq 4*8(%rsi),%r8
 10:	movq 5*8(%rsi),%r9
-11:	movq 6*8(%rsi),%r10
+11:	movq 6*8(%rsi),%rax
 12:	movq 7*8(%rsi),%r11
 13:	movq %r8,4*8(%rdi)
 14:	movq %r9,5*8(%rdi)
-15:	movq %r10,6*8(%rdi)
+15:	movq %rax,6*8(%rdi)
 16:	movq %r11,7*8(%rdi)
 	leaq 64(%rsi),%rsi
 	leaq 64(%rdi),%rdi
@@ -180,6 +153,7 @@ ENTRY(copy_user_generic_unrolled)
 	decl %ecx
 	jnz 21b
 23:	xor %eax,%eax
+	pax_force_retaddr
 	ret
 
 	.section .fixup,"ax"
@@ -252,6 +226,7 @@ ENTRY(copy_user_generic_string)
 3:	rep
 	movsb
 4:	xorl %eax,%eax
+	pax_force_retaddr
 	ret
 
 	.section .fixup,"ax"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/copy_user_nocache_64.S linux-2.6.32.60-pax/arch/x86/lib/copy_user_nocache_64.S
--- linux-2.6.32.60/arch/x86/lib/copy_user_nocache_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/copy_user_nocache_64.S	2012-03-13 13:15:34.596098019 +0100
@@ -8,12 +8,14 @@
 
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 #define FIX_ALIGNMENT 1
 
 #include <asm/current.h>
 #include <asm/asm-offsets.h>
 #include <asm/thread_info.h>
+#include <asm/pgtable.h>
 
 	.macro ALIGN_DESTINATION
 #ifdef FIX_ALIGNMENT
@@ -50,6 +52,15 @@
  */
 ENTRY(__copy_user_nocache)
 	CFI_STARTPROC
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov $PAX_USER_SHADOW_BASE,%rcx
+	cmp %rcx,%rsi
+	jae 1f
+	add %rcx,%rsi
+1:
+#endif
+
 	cmpl $8,%edx
 	jb 20f		/* less then 8 bytes, go to byte copy loop */
 	ALIGN_DESTINATION
@@ -59,19 +70,19 @@ ENTRY(__copy_user_nocache)
 	jz 17f
 1:	movq (%rsi),%r8
 2:	movq 1*8(%rsi),%r9
-3:	movq 2*8(%rsi),%r10
+3:	movq 2*8(%rsi),%rax
 4:	movq 3*8(%rsi),%r11
 5:	movnti %r8,(%rdi)
 6:	movnti %r9,1*8(%rdi)
-7:	movnti %r10,2*8(%rdi)
+7:	movnti %rax,2*8(%rdi)
 8:	movnti %r11,3*8(%rdi)
 9:	movq 4*8(%rsi),%r8
 10:	movq 5*8(%rsi),%r9
-11:	movq 6*8(%rsi),%r10
+11:	movq 6*8(%rsi),%rax
 12:	movq 7*8(%rsi),%r11
 13:	movnti %r8,4*8(%rdi)
 14:	movnti %r9,5*8(%rdi)
-15:	movnti %r10,6*8(%rdi)
+15:	movnti %rax,6*8(%rdi)
 16:	movnti %r11,7*8(%rdi)
 	leaq 64(%rsi),%rsi
 	leaq 64(%rdi),%rdi
@@ -98,6 +109,7 @@ ENTRY(__copy_user_nocache)
 	jnz 21b
 23:	xorl %eax,%eax
 	sfence
+	pax_force_retaddr
 	ret
 
 	.section .fixup,"ax"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/csum-copy_64.S linux-2.6.32.60-pax/arch/x86/lib/csum-copy_64.S
--- linux-2.6.32.60/arch/x86/lib/csum-copy_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/csum-copy_64.S	2012-03-13 13:15:34.600098018 +0100
@@ -8,6 +8,7 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
 #include <asm/errno.h>
+#include <asm/alternative-asm.h>
 
 /*
  * Checksum copy with exception handling.
@@ -228,6 +229,7 @@ ENTRY(csum_partial_copy_generic)
 	CFI_RESTORE rbp
 	addq $7*8,%rsp
 	CFI_ADJUST_CFA_OFFSET -7*8
+	pax_force_retaddr 0, 1
 	ret
 	CFI_RESTORE_STATE
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/csum-wrappers_64.c linux-2.6.32.60-pax/arch/x86/lib/csum-wrappers_64.c
--- linux-2.6.32.60/arch/x86/lib/csum-wrappers_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/csum-wrappers_64.c	2012-12-01 02:39:40.692118438 +0100
@@ -52,7 +52,7 @@ csum_partial_copy_from_user(const void _
 			len -= 2;
 		}
 	}
-	isum = csum_partial_copy_generic((__force const void *)src,
+	isum = csum_partial_copy_generic((const void __force_kernel *)____m(src),
 				dst, len, isum, errp, NULL);
 	if (unlikely(*errp))
 		goto out_err;
@@ -105,7 +105,7 @@ csum_partial_copy_to_user(const void *sr
 	}
 
 	*errp = 0;
-	return csum_partial_copy_generic(src, (void __force *)dst,
+	return csum_partial_copy_generic(src, (void __force_kernel *)____m(dst),
 					 len, isum, NULL, errp);
 }
 EXPORT_SYMBOL(csum_partial_copy_to_user);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/getuser.S linux-2.6.32.60-pax/arch/x86/lib/getuser.S
--- linux-2.6.32.60/arch/x86/lib/getuser.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/getuser.S	2012-03-13 13:15:34.600098018 +0100
@@ -33,15 +33,38 @@
 #include <asm/asm-offsets.h>
 #include <asm/thread_info.h>
 #include <asm/asm.h>
+#include <asm/segment.h>
+#include <asm/pgtable.h>
+#include <asm/alternative-asm.h>
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define __copyuser_seg gs;
+#else
+#define __copyuser_seg
+#endif
 
 	.text
 ENTRY(__get_user_1)
 	CFI_STARTPROC
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
 	GET_THREAD_INFO(%_ASM_DX)
 	cmp TI_addr_limit(%_ASM_DX),%_ASM_AX
 	jae bad_get_user
-1:	movzb (%_ASM_AX),%edx
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_DX
+	cmp %_ASM_DX,%_ASM_AX
+	jae 1234f
+	add %_ASM_DX,%_ASM_AX
+1234:
+#endif
+
+#endif
+
+1:	__copyuser_seg movzb (%_ASM_AX),%edx
 	xor %eax,%eax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(__get_user_1)
@@ -49,12 +72,26 @@ ENDPROC(__get_user_1)
 ENTRY(__get_user_2)
 	CFI_STARTPROC
 	add $1,%_ASM_AX
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
 	jc bad_get_user
 	GET_THREAD_INFO(%_ASM_DX)
 	cmp TI_addr_limit(%_ASM_DX),%_ASM_AX
 	jae bad_get_user
-2:	movzwl -1(%_ASM_AX),%edx
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_DX
+	cmp %_ASM_DX,%_ASM_AX
+	jae 1234f
+	add %_ASM_DX,%_ASM_AX
+1234:
+#endif
+
+#endif
+
+2:	__copyuser_seg movzwl -1(%_ASM_AX),%edx
 	xor %eax,%eax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(__get_user_2)
@@ -62,12 +99,26 @@ ENDPROC(__get_user_2)
 ENTRY(__get_user_4)
 	CFI_STARTPROC
 	add $3,%_ASM_AX
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
 	jc bad_get_user
 	GET_THREAD_INFO(%_ASM_DX)
 	cmp TI_addr_limit(%_ASM_DX),%_ASM_AX
 	jae bad_get_user
-3:	mov -3(%_ASM_AX),%edx
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_DX
+	cmp %_ASM_DX,%_ASM_AX
+	jae 1234f
+	add %_ASM_DX,%_ASM_AX
+1234:
+#endif
+
+#endif
+
+3:	__copyuser_seg mov -3(%_ASM_AX),%edx
 	xor %eax,%eax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(__get_user_4)
@@ -80,8 +131,18 @@ ENTRY(__get_user_8)
 	GET_THREAD_INFO(%_ASM_DX)
 	cmp TI_addr_limit(%_ASM_DX),%_ASM_AX
 	jae	bad_get_user
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov $PAX_USER_SHADOW_BASE,%_ASM_DX
+	cmp %_ASM_DX,%_ASM_AX
+	jae 1234f
+	add %_ASM_DX,%_ASM_AX
+1234:
+#endif
+
 4:	movq -7(%_ASM_AX),%_ASM_DX
 	xor %eax,%eax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(__get_user_8)
@@ -91,6 +152,7 @@ bad_get_user:
 	CFI_STARTPROC
 	xor %edx,%edx
 	mov $(-EFAULT),%_ASM_AX
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 END(bad_get_user)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/iomap_copy_64.S linux-2.6.32.60-pax/arch/x86/lib/iomap_copy_64.S
--- linux-2.6.32.60/arch/x86/lib/iomap_copy_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/iomap_copy_64.S	2012-03-13 13:15:34.600098018 +0100
@@ -17,6 +17,7 @@
 
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 /*
  * override generic version in lib/iomap_copy.c
@@ -25,6 +26,7 @@ ENTRY(__iowrite32_copy)
 	CFI_STARTPROC
 	movl %edx,%ecx
 	rep movsd
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(__iowrite32_copy)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/memcpy_64.S linux-2.6.32.60-pax/arch/x86/lib/memcpy_64.S
--- linux-2.6.32.60/arch/x86/lib/memcpy_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/memcpy_64.S	2012-03-13 13:15:34.600098018 +0100
@@ -4,6 +4,7 @@
 
 #include <asm/cpufeature.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 /*
  * memcpy - Copy a memory block.
@@ -34,6 +35,7 @@ memcpy_c:
 	rep movsq
 	movl %edx, %ecx
 	rep movsb
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(memcpy_c)
@@ -118,6 +120,7 @@ ENTRY(memcpy)
 	jnz .Lloop_1
 
 .Lend:
+	pax_force_retaddr 0, 1
 	ret
 	CFI_ENDPROC
 ENDPROC(memcpy)
@@ -128,7 +131,7 @@ ENDPROC(__memcpy)
 	 * It is also a lot simpler. Use this when possible:
 	 */
 
-	.section .altinstr_replacement, "ax"
+	.section .altinstr_replacement, "a"
 1:	.byte 0xeb				/* jmp <disp8> */
 	.byte (memcpy_c - memcpy) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/memset_64.S linux-2.6.32.60-pax/arch/x86/lib/memset_64.S
--- linux-2.6.32.60/arch/x86/lib/memset_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/memset_64.S	2012-03-13 13:15:34.604098018 +0100
@@ -2,6 +2,7 @@
 
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
+#include <asm/alternative-asm.h>
 
 /*
  * ISO C memset - set a memory block to a byte value.
@@ -28,6 +29,7 @@ memset_c:
 	movl %r8d,%ecx
 	rep stosb
 	movq %r9,%rax
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 ENDPROC(memset_c)
@@ -35,13 +37,13 @@ ENDPROC(memset_c)
 ENTRY(memset)
 ENTRY(__memset)
 	CFI_STARTPROC
-	movq %rdi,%r10
 	movq %rdx,%r11
 
 	/* expand byte value  */
 	movzbl %sil,%ecx
 	movabs $0x0101010101010101,%rax
 	mul    %rcx		/* with rax, clobbers rdx */
+	movq  %rdi,%rdx
 
 	/* align dst */
 	movl  %edi,%r9d
@@ -95,7 +97,8 @@ ENTRY(__memset)
 	jnz     .Lloop_1
 
 .Lende:
-	movq	%r10,%rax
+	movq	%rdx,%rax
+	pax_force_retaddr
 	ret
 
 	CFI_RESTORE_STATE
@@ -118,7 +121,7 @@ ENDPROC(__memset)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb				/* jmp <disp8> */
 	.byte (memset_c - memset) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/mmx_32.c linux-2.6.32.60-pax/arch/x86/lib/mmx_32.c
--- linux-2.6.32.60/arch/x86/lib/mmx_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/mmx_32.c	2012-03-13 13:15:34.604098018 +0100
@@ -29,6 +29,7 @@ void *_mmx_memcpy(void *to, const void *
 {
 	void *p;
 	int i;
+	unsigned long cr0;
 
 	if (unlikely(in_interrupt()))
 		return __memcpy(to, from, len);
@@ -39,44 +40,72 @@ void *_mmx_memcpy(void *to, const void *
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"		/* This set is 28 bytes */
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"		/* This set is 28 bytes */
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from));
+			: "=&r" (cr0) : "r" (from) : "ax");
 
 	for ( ; i > 5; i--) {
 		__asm__ __volatile__ (
-		"1:  prefetch 320(%0)\n"
-		"2:  movq (%0), %%mm0\n"
-		"  movq 8(%0), %%mm1\n"
-		"  movq 16(%0), %%mm2\n"
-		"  movq 24(%0), %%mm3\n"
-		"  movq %%mm0, (%1)\n"
-		"  movq %%mm1, 8(%1)\n"
-		"  movq %%mm2, 16(%1)\n"
-		"  movq %%mm3, 24(%1)\n"
-		"  movq 32(%0), %%mm0\n"
-		"  movq 40(%0), %%mm1\n"
-		"  movq 48(%0), %%mm2\n"
-		"  movq 56(%0), %%mm3\n"
-		"  movq %%mm0, 32(%1)\n"
-		"  movq %%mm1, 40(%1)\n"
-		"  movq %%mm2, 48(%1)\n"
-		"  movq %%mm3, 56(%1)\n"
+		"1:  prefetch 320(%1)\n"
+		"2:  movq (%1), %%mm0\n"
+		"  movq 8(%1), %%mm1\n"
+		"  movq 16(%1), %%mm2\n"
+		"  movq 24(%1), %%mm3\n"
+		"  movq %%mm0, (%2)\n"
+		"  movq %%mm1, 8(%2)\n"
+		"  movq %%mm2, 16(%2)\n"
+		"  movq %%mm3, 24(%2)\n"
+		"  movq 32(%1), %%mm0\n"
+		"  movq 40(%1), %%mm1\n"
+		"  movq 48(%1), %%mm2\n"
+		"  movq 56(%1), %%mm3\n"
+		"  movq %%mm0, 32(%2)\n"
+		"  movq %%mm1, 40(%2)\n"
+		"  movq %%mm2, 48(%2)\n"
+		"  movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from), "r" (to) : "memory");
+			: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
@@ -158,6 +187,7 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
@@ -166,42 +196,70 @@ static void fast_copy_page(void *to, voi
 	 * but that is for later. -AV
 	 */
 	__asm__ __volatile__(
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-			_ASM_EXTABLE(1b, 3b) : : "r" (from));
+			_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from) : "ax");
 
 	for (i = 0; i < (4096-320)/64; i++) {
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movntq %%mm0, (%1)\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movntq %%mm1, 8(%1)\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movntq %%mm2, 16(%1)\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movntq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm4\n"
-		"   movntq %%mm4, 32(%1)\n"
-		"   movq 40(%0), %%mm5\n"
-		"   movntq %%mm5, 40(%1)\n"
-		"   movq 48(%0), %%mm6\n"
-		"   movntq %%mm6, 48(%1)\n"
-		"   movq 56(%0), %%mm7\n"
-		"   movntq %%mm7, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movntq %%mm0, (%2)\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movntq %%mm1, 8(%2)\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movntq %%mm2, 16(%2)\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movntq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm4\n"
+		"   movntq %%mm4, 32(%2)\n"
+		"   movq 40(%1), %%mm5\n"
+		"   movntq %%mm5, 40(%2)\n"
+		"   movq 48(%1), %%mm6\n"
+		"   movntq %%mm6, 48(%2)\n"
+		"   movq 56(%1), %%mm7\n"
+		"   movntq %%mm7, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-		_ASM_EXTABLE(1b, 3b) : : "r" (from), "r" (to) : "memory");
+		_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
@@ -280,47 +338,76 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-			_ASM_EXTABLE(1b, 3b) : : "r" (from));
+			_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from) : "ax");
 
 	for (i = 0; i < 4096/64; i++) {
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movq %%mm0, (%1)\n"
-		"   movq %%mm1, 8(%1)\n"
-		"   movq %%mm2, 16(%1)\n"
-		"   movq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm0\n"
-		"   movq 40(%0), %%mm1\n"
-		"   movq 48(%0), %%mm2\n"
-		"   movq 56(%0), %%mm3\n"
-		"   movq %%mm0, 32(%1)\n"
-		"   movq %%mm1, 40(%1)\n"
-		"   movq %%mm2, 48(%1)\n"
-		"   movq %%mm3, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movq %%mm0, (%2)\n"
+		"   movq %%mm1, 8(%2)\n"
+		"   movq %%mm2, 16(%2)\n"
+		"   movq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm0\n"
+		"   movq 40(%1), %%mm1\n"
+		"   movq 48(%1), %%mm2\n"
+		"   movq 56(%1), %%mm3\n"
+		"   movq %%mm0, 32(%2)\n"
+		"   movq %%mm1, 40(%2)\n"
+		"   movq %%mm2, 48(%2)\n"
+		"   movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from), "r" (to) : "memory");
+			: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/msr-reg.S linux-2.6.32.60-pax/arch/x86/lib/msr-reg.S
--- linux-2.6.32.60/arch/x86/lib/msr-reg.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/msr-reg.S	2012-03-13 13:15:34.604098018 +0100
@@ -3,6 +3,7 @@
 #include <asm/dwarf2.h>
 #include <asm/asm.h>
 #include <asm/msr.h>
+#include <asm/alternative-asm.h>
 
 #ifdef CONFIG_X86_64
 /*
@@ -16,7 +17,7 @@ ENTRY(native_\op\()_safe_regs)
 	CFI_STARTPROC
 	pushq_cfi %rbx
 	pushq_cfi %rbp
-	movq	%rdi, %r10	/* Save pointer */
+	movq	%rdi, %r9	/* Save pointer */
 	xorl	%r11d, %r11d	/* Return value */
 	movl    (%rdi), %eax
 	movl    4(%rdi), %ecx
@@ -27,16 +28,17 @@ ENTRY(native_\op\()_safe_regs)
 	movl    28(%rdi), %edi
 	CFI_REMEMBER_STATE
 1:	\op
-2:	movl    %eax, (%r10)
+2:	movl    %eax, (%r9)
 	movl	%r11d, %eax	/* Return value */
-	movl    %ecx, 4(%r10)
-	movl    %edx, 8(%r10)
-	movl    %ebx, 12(%r10)
-	movl    %ebp, 20(%r10)
-	movl    %esi, 24(%r10)
-	movl    %edi, 28(%r10)
+	movl    %ecx, 4(%r9)
+	movl    %edx, 8(%r9)
+	movl    %ebx, 12(%r9)
+	movl    %ebp, 20(%r9)
+	movl    %esi, 24(%r9)
+	movl    %edi, 28(%r9)
 	popq_cfi %rbp
 	popq_cfi %rbx
+	pax_force_retaddr
 	ret
 3:
 	CFI_RESTORE_STATE
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/putuser.S linux-2.6.32.60-pax/arch/x86/lib/putuser.S
--- linux-2.6.32.60/arch/x86/lib/putuser.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/putuser.S	2012-03-13 13:15:34.604098018 +0100
@@ -15,7 +15,9 @@
 #include <asm/thread_info.h>
 #include <asm/errno.h>
 #include <asm/asm.h>
-
+#include <asm/segment.h>
+#include <asm/pgtable.h>
+#include <asm/alternative-asm.h>
 
 /*
  * __put_user_X
@@ -29,52 +31,119 @@
  * as they get called from within inline assembly.
  */
 
-#define ENTER	CFI_STARTPROC ; \
-		GET_THREAD_INFO(%_ASM_BX)
-#define EXIT	ret ; \
+#define ENTER	CFI_STARTPROC
+#define EXIT	pax_force_retaddr; ret ; \
 		CFI_ENDPROC
 
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define _DEST %_ASM_CX,%_ASM_BX
+#else
+#define _DEST %_ASM_CX
+#endif
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#define __copyuser_seg gs;
+#else
+#define __copyuser_seg
+#endif
+
 .text
 ENTRY(__put_user_1)
 	ENTER
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
+	GET_THREAD_INFO(%_ASM_BX)
 	cmp TI_addr_limit(%_ASM_BX),%_ASM_CX
 	jae bad_put_user
-1:	movb %al,(%_ASM_CX)
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_BX
+	cmp %_ASM_BX,%_ASM_CX
+	jb 1234f
+	xor %ebx,%ebx
+1234:
+#endif
+
+#endif
+
+1:	__copyuser_seg movb %al,(_DEST)
 	xor %eax,%eax
 	EXIT
 ENDPROC(__put_user_1)
 
 ENTRY(__put_user_2)
 	ENTER
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
+	GET_THREAD_INFO(%_ASM_BX)
 	mov TI_addr_limit(%_ASM_BX),%_ASM_BX
 	sub $1,%_ASM_BX
 	cmp %_ASM_BX,%_ASM_CX
 	jae bad_put_user
-2:	movw %ax,(%_ASM_CX)
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_BX
+	cmp %_ASM_BX,%_ASM_CX
+	jb 1234f
+	xor %ebx,%ebx
+1234:
+#endif
+
+#endif
+
+2:	__copyuser_seg movw %ax,(_DEST)
 	xor %eax,%eax
 	EXIT
 ENDPROC(__put_user_2)
 
 ENTRY(__put_user_4)
 	ENTER
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
+	GET_THREAD_INFO(%_ASM_BX)
 	mov TI_addr_limit(%_ASM_BX),%_ASM_BX
 	sub $3,%_ASM_BX
 	cmp %_ASM_BX,%_ASM_CX
 	jae bad_put_user
-3:	movl %eax,(%_ASM_CX)
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_BX
+	cmp %_ASM_BX,%_ASM_CX
+	jb 1234f
+	xor %ebx,%ebx
+1234:
+#endif
+
+#endif
+
+3:	__copyuser_seg movl %eax,(_DEST)
 	xor %eax,%eax
 	EXIT
 ENDPROC(__put_user_4)
 
 ENTRY(__put_user_8)
 	ENTER
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_MEMORY_UDEREF)
+	GET_THREAD_INFO(%_ASM_BX)
 	mov TI_addr_limit(%_ASM_BX),%_ASM_BX
 	sub $7,%_ASM_BX
 	cmp %_ASM_BX,%_ASM_CX
 	jae bad_put_user
-4:	mov %_ASM_AX,(%_ASM_CX)
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	mov $PAX_USER_SHADOW_BASE,%_ASM_BX
+	cmp %_ASM_BX,%_ASM_CX
+	jb 1234f
+	xor %ebx,%ebx
+1234:
+#endif
+
+#endif
+
+4:	__copyuser_seg mov %_ASM_AX,(_DEST)
 #ifdef CONFIG_X86_32
-5:	movl %edx,4(%_ASM_CX)
+5:	__copyuser_seg movl %edx,4(_DEST)
 #endif
 	xor %eax,%eax
 	EXIT
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/rwlock_64.S linux-2.6.32.60-pax/arch/x86/lib/rwlock_64.S
--- linux-2.6.32.60/arch/x86/lib/rwlock_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/rwlock_64.S	2012-03-13 13:15:34.604098018 +0100
@@ -2,6 +2,7 @@
 
 #include <linux/linkage.h>
 #include <asm/rwlock.h>
+#include <asm/asm.h>
 #include <asm/alternative-asm.h>
 #include <asm/dwarf2.h>
 
@@ -10,13 +11,34 @@ ENTRY(__write_lock_failed)
 	CFI_STARTPROC
 	LOCK_PREFIX
 	addl $RW_LOCK_BIAS,(%rdi)
+
+#ifdef CONFIG_PAX_REFCOUNT
+	jno 1234f
+	LOCK_PREFIX
+	subl $RW_LOCK_BIAS,(%rdi)
+	int $4
+1234:
+	_ASM_EXTABLE(1234b, 1234b)
+#endif
+
 1:	rep
 	nop
 	cmpl $RW_LOCK_BIAS,(%rdi)
 	jne 1b
 	LOCK_PREFIX
 	subl $RW_LOCK_BIAS,(%rdi)
+
+#ifdef CONFIG_PAX_REFCOUNT
+	jno 1234f
+	LOCK_PREFIX
+	addl $RW_LOCK_BIAS,(%rdi)
+	int $4
+1234:
+	_ASM_EXTABLE(1234b, 1234b)
+#endif
+
 	jnz  __write_lock_failed
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 END(__write_lock_failed)
@@ -26,13 +48,34 @@ ENTRY(__read_lock_failed)
 	CFI_STARTPROC
 	LOCK_PREFIX
 	incl (%rdi)
+
+#ifdef CONFIG_PAX_REFCOUNT
+	jno 1234f
+	LOCK_PREFIX
+	decl (%rdi)
+	int $4
+1234:
+	_ASM_EXTABLE(1234b, 1234b)
+#endif
+
 1:	rep
 	nop
 	cmpl $1,(%rdi)
 	js 1b
 	LOCK_PREFIX
 	decl (%rdi)
+
+#ifdef CONFIG_PAX_REFCOUNT
+	jno 1234f
+	LOCK_PREFIX
+	incl (%rdi)
+	int $4
+1234:
+	_ASM_EXTABLE(1234b, 1234b)
+#endif
+
 	js __read_lock_failed
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
 END(__read_lock_failed)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/rwsem_64.S linux-2.6.32.60-pax/arch/x86/lib/rwsem_64.S
--- linux-2.6.32.60/arch/x86/lib/rwsem_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/rwsem_64.S	2012-03-13 13:15:34.608098018 +0100
@@ -48,6 +48,7 @@ ENTRY(call_rwsem_down_read_failed)
 	call rwsem_down_read_failed
 	popq %rdx
 	restore_common_regs
+	pax_force_retaddr
 	ret
 	ENDPROC(call_rwsem_down_read_failed)
 
@@ -56,6 +57,7 @@ ENTRY(call_rwsem_down_write_failed)
 	movq %rax,%rdi
 	call rwsem_down_write_failed
 	restore_common_regs
+	pax_force_retaddr
 	ret
 	ENDPROC(call_rwsem_down_write_failed)
 
@@ -66,7 +68,8 @@ ENTRY(call_rwsem_wake)
 	movq %rax,%rdi
 	call rwsem_wake
 	restore_common_regs
-1:	ret
+1:	pax_force_retaddr
+	ret
 	ENDPROC(call_rwsem_wake)
 
 /* Fix up special calling conventions */
@@ -77,5 +80,6 @@ ENTRY(call_rwsem_downgrade_wake)
 	call rwsem_downgrade_wake
 	popq %rdx
 	restore_common_regs
+	pax_force_retaddr
 	ret
 	ENDPROC(call_rwsem_downgrade_wake)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/thunk_64.S linux-2.6.32.60-pax/arch/x86/lib/thunk_64.S
--- linux-2.6.32.60/arch/x86/lib/thunk_64.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/thunk_64.S	2012-03-13 13:15:34.608098018 +0100
@@ -10,7 +10,8 @@
 	#include <asm/dwarf2.h>
 	#include <asm/calling.h>			
 	#include <asm/rwlock.h>
-		
+	#include <asm/alternative-asm.h>
+
 	/* rdi:	arg1 ... normal C conventions. rax is saved/restored. */ 	
 	.macro thunk name,func
 	.globl \name
@@ -70,6 +71,7 @@
 	SAVE_ARGS
 restore:
 	RESTORE_ARGS
+	pax_force_retaddr
 	ret	
 	CFI_ENDPROC
 	
@@ -77,5 +79,6 @@ restore:
 	SAVE_ARGS
 restore_norax:	
 	RESTORE_ARGS 1
+	pax_force_retaddr
 	ret
 	CFI_ENDPROC
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/usercopy_32.c linux-2.6.32.60-pax/arch/x86/lib/usercopy_32.c
--- linux-2.6.32.60/arch/x86/lib/usercopy_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/usercopy_32.c	2012-08-12 13:34:04.529244144 +0200
@@ -43,7 +43,7 @@ do {									   \
 	__asm__ __volatile__(						   \
 		"	testl %1,%1\n"					   \
 		"	jz 2f\n"					   \
-		"0:	lodsb\n"					   \
+		"0:	"__copyuser_seg"lodsb\n"			   \
 		"	stosb\n"					   \
 		"	testb %%al,%%al\n"				   \
 		"	jz 1f\n"					   \
@@ -128,10 +128,12 @@ do {									\
 	int __d0;							\
 	might_fault();							\
 	__asm__ __volatile__(						\
+		__COPYUSER_SET_ES					\
 		"0:	rep; stosl\n"					\
 		"	movl %2,%0\n"					\
 		"1:	rep; stosb\n"					\
 		"2:\n"							\
+		__COPYUSER_RESTORE_ES					\
 		".section .fixup,\"ax\"\n"				\
 		"3:	lea 0(%2,%0,4),%0\n"				\
 		"	jmp 2b\n"					\
@@ -200,6 +202,7 @@ long strnlen_user(const char __user *s,
 	might_fault();
 
 	__asm__ __volatile__(
+		__COPYUSER_SET_ES
 		"	testl %0, %0\n"
 		"	jz 3f\n"
 		"	andl %0,%%ecx\n"
@@ -208,6 +211,7 @@ long strnlen_user(const char __user *s,
 		"	subl %%ecx,%0\n"
 		"	addl %0,%%eax\n"
 		"1:\n"
+		__COPYUSER_RESTORE_ES
 		".section .fixup,\"ax\"\n"
 		"2:	xorl %%eax,%%eax\n"
 		"	jmp 1b\n"
@@ -227,7 +231,7 @@ EXPORT_SYMBOL(strnlen_user);
 
 #ifdef CONFIG_X86_INTEL_USERCOPY
 static unsigned long
-__copy_user_intel(void __user *to, const void *from, unsigned long size)
+__generic_copy_to_user_intel(void __user *to, const void *from, unsigned long size)
 {
 	int d0, d1;
 	__asm__ __volatile__(
@@ -239,36 +243,36 @@ __copy_user_intel(void __user *to, const
 		       "       .align 2,0x90\n"
 		       "3:     movl 0(%4), %%eax\n"
 		       "4:     movl 4(%4), %%edx\n"
-		       "5:     movl %%eax, 0(%3)\n"
-		       "6:     movl %%edx, 4(%3)\n"
+		       "5:     "__copyuser_seg" movl %%eax, 0(%3)\n"
+		       "6:     "__copyuser_seg" movl %%edx, 4(%3)\n"
 		       "7:     movl 8(%4), %%eax\n"
 		       "8:     movl 12(%4),%%edx\n"
-		       "9:     movl %%eax, 8(%3)\n"
-		       "10:    movl %%edx, 12(%3)\n"
+		       "9:     "__copyuser_seg" movl %%eax, 8(%3)\n"
+		       "10:    "__copyuser_seg" movl %%edx, 12(%3)\n"
 		       "11:    movl 16(%4), %%eax\n"
 		       "12:    movl 20(%4), %%edx\n"
-		       "13:    movl %%eax, 16(%3)\n"
-		       "14:    movl %%edx, 20(%3)\n"
+		       "13:    "__copyuser_seg" movl %%eax, 16(%3)\n"
+		       "14:    "__copyuser_seg" movl %%edx, 20(%3)\n"
 		       "15:    movl 24(%4), %%eax\n"
 		       "16:    movl 28(%4), %%edx\n"
-		       "17:    movl %%eax, 24(%3)\n"
-		       "18:    movl %%edx, 28(%3)\n"
+		       "17:    "__copyuser_seg" movl %%eax, 24(%3)\n"
+		       "18:    "__copyuser_seg" movl %%edx, 28(%3)\n"
 		       "19:    movl 32(%4), %%eax\n"
 		       "20:    movl 36(%4), %%edx\n"
-		       "21:    movl %%eax, 32(%3)\n"
-		       "22:    movl %%edx, 36(%3)\n"
+		       "21:    "__copyuser_seg" movl %%eax, 32(%3)\n"
+		       "22:    "__copyuser_seg" movl %%edx, 36(%3)\n"
 		       "23:    movl 40(%4), %%eax\n"
 		       "24:    movl 44(%4), %%edx\n"
-		       "25:    movl %%eax, 40(%3)\n"
-		       "26:    movl %%edx, 44(%3)\n"
+		       "25:    "__copyuser_seg" movl %%eax, 40(%3)\n"
+		       "26:    "__copyuser_seg" movl %%edx, 44(%3)\n"
 		       "27:    movl 48(%4), %%eax\n"
 		       "28:    movl 52(%4), %%edx\n"
-		       "29:    movl %%eax, 48(%3)\n"
-		       "30:    movl %%edx, 52(%3)\n"
+		       "29:    "__copyuser_seg" movl %%eax, 48(%3)\n"
+		       "30:    "__copyuser_seg" movl %%edx, 52(%3)\n"
 		       "31:    movl 56(%4), %%eax\n"
 		       "32:    movl 60(%4), %%edx\n"
-		       "33:    movl %%eax, 56(%3)\n"
-		       "34:    movl %%edx, 60(%3)\n"
+		       "33:    "__copyuser_seg" movl %%eax, 56(%3)\n"
+		       "34:    "__copyuser_seg" movl %%edx, 60(%3)\n"
 		       "       addl $-64, %0\n"
 		       "       addl $64, %4\n"
 		       "       addl $64, %3\n"
@@ -278,10 +282,12 @@ __copy_user_intel(void __user *to, const
 		       "       shrl  $2, %0\n"
 		       "       andl  $3, %%eax\n"
 		       "       cld\n"
+		       __COPYUSER_SET_ES
 		       "99:    rep; movsl\n"
 		       "36:    movl %%eax, %0\n"
 		       "37:    rep; movsb\n"
 		       "100:\n"
+		       __COPYUSER_RESTORE_ES
 		       ".section .fixup,\"ax\"\n"
 		       "101:   lea 0(%%eax,%0,4),%0\n"
 		       "       jmp 100b\n"
@@ -334,46 +340,153 @@ __copy_user_intel(void __user *to, const
 }
 
 static unsigned long
+__generic_copy_from_user_intel(void *to, const void __user *from, unsigned long size)
+{
+	int d0, d1;
+	__asm__ __volatile__(
+		       "       .align 2,0x90\n"
+		       "1:     "__copyuser_seg" movl 32(%4), %%eax\n"
+		       "       cmpl $67, %0\n"
+		       "       jbe 3f\n"
+		       "2:     "__copyuser_seg" movl 64(%4), %%eax\n"
+		       "       .align 2,0x90\n"
+		       "3:     "__copyuser_seg" movl 0(%4), %%eax\n"
+		       "4:     "__copyuser_seg" movl 4(%4), %%edx\n"
+		       "5:     movl %%eax, 0(%3)\n"
+		       "6:     movl %%edx, 4(%3)\n"
+		       "7:     "__copyuser_seg" movl 8(%4), %%eax\n"
+		       "8:     "__copyuser_seg" movl 12(%4),%%edx\n"
+		       "9:     movl %%eax, 8(%3)\n"
+		       "10:    movl %%edx, 12(%3)\n"
+		       "11:    "__copyuser_seg" movl 16(%4), %%eax\n"
+		       "12:    "__copyuser_seg" movl 20(%4), %%edx\n"
+		       "13:    movl %%eax, 16(%3)\n"
+		       "14:    movl %%edx, 20(%3)\n"
+		       "15:    "__copyuser_seg" movl 24(%4), %%eax\n"
+		       "16:    "__copyuser_seg" movl 28(%4), %%edx\n"
+		       "17:    movl %%eax, 24(%3)\n"
+		       "18:    movl %%edx, 28(%3)\n"
+		       "19:    "__copyuser_seg" movl 32(%4), %%eax\n"
+		       "20:    "__copyuser_seg" movl 36(%4), %%edx\n"
+		       "21:    movl %%eax, 32(%3)\n"
+		       "22:    movl %%edx, 36(%3)\n"
+		       "23:    "__copyuser_seg" movl 40(%4), %%eax\n"
+		       "24:    "__copyuser_seg" movl 44(%4), %%edx\n"
+		       "25:    movl %%eax, 40(%3)\n"
+		       "26:    movl %%edx, 44(%3)\n"
+		       "27:    "__copyuser_seg" movl 48(%4), %%eax\n"
+		       "28:    "__copyuser_seg" movl 52(%4), %%edx\n"
+		       "29:    movl %%eax, 48(%3)\n"
+		       "30:    movl %%edx, 52(%3)\n"
+		       "31:    "__copyuser_seg" movl 56(%4), %%eax\n"
+		       "32:    "__copyuser_seg" movl 60(%4), %%edx\n"
+		       "33:    movl %%eax, 56(%3)\n"
+		       "34:    movl %%edx, 60(%3)\n"
+		       "       addl $-64, %0\n"
+		       "       addl $64, %4\n"
+		       "       addl $64, %3\n"
+		       "       cmpl $63, %0\n"
+		       "       ja  1b\n"
+		       "35:    movl  %0, %%eax\n"
+		       "       shrl  $2, %0\n"
+		       "       andl  $3, %%eax\n"
+		       "       cld\n"
+		       "99:    rep; "__copyuser_seg" movsl\n"
+		       "36:    movl %%eax, %0\n"
+		       "37:    rep; "__copyuser_seg" movsb\n"
+		       "100:\n"
+		       ".section .fixup,\"ax\"\n"
+		       "101:   lea 0(%%eax,%0,4),%0\n"
+		       "       jmp 100b\n"
+		       ".previous\n"
+		       ".section __ex_table,\"a\"\n"
+		       "       .align 4\n"
+		       "       .long 1b,100b\n"
+		       "       .long 2b,100b\n"
+		       "       .long 3b,100b\n"
+		       "       .long 4b,100b\n"
+		       "       .long 5b,100b\n"
+		       "       .long 6b,100b\n"
+		       "       .long 7b,100b\n"
+		       "       .long 8b,100b\n"
+		       "       .long 9b,100b\n"
+		       "       .long 10b,100b\n"
+		       "       .long 11b,100b\n"
+		       "       .long 12b,100b\n"
+		       "       .long 13b,100b\n"
+		       "       .long 14b,100b\n"
+		       "       .long 15b,100b\n"
+		       "       .long 16b,100b\n"
+		       "       .long 17b,100b\n"
+		       "       .long 18b,100b\n"
+		       "       .long 19b,100b\n"
+		       "       .long 20b,100b\n"
+		       "       .long 21b,100b\n"
+		       "       .long 22b,100b\n"
+		       "       .long 23b,100b\n"
+		       "       .long 24b,100b\n"
+		       "       .long 25b,100b\n"
+		       "       .long 26b,100b\n"
+		       "       .long 27b,100b\n"
+		       "       .long 28b,100b\n"
+		       "       .long 29b,100b\n"
+		       "       .long 30b,100b\n"
+		       "       .long 31b,100b\n"
+		       "       .long 32b,100b\n"
+		       "       .long 33b,100b\n"
+		       "       .long 34b,100b\n"
+		       "       .long 35b,100b\n"
+		       "       .long 36b,100b\n"
+		       "       .long 37b,100b\n"
+		       "       .long 99b,101b\n"
+		       ".previous"
+		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
+		       :  "1"(to), "2"(from), "0"(size)
+		       : "eax", "edx", "memory");
+	return size;
+}
+
+static unsigned long __size_overflow(3)
 __copy_user_zeroing_intel(void *to, const void __user *from, unsigned long size)
 {
 	int d0, d1;
 	__asm__ __volatile__(
 		       "        .align 2,0x90\n"
-		       "0:      movl 32(%4), %%eax\n"
+		       "0:      "__copyuser_seg" movl 32(%4), %%eax\n"
 		       "        cmpl $67, %0\n"
 		       "        jbe 2f\n"
-		       "1:      movl 64(%4), %%eax\n"
+		       "1:      "__copyuser_seg" movl 64(%4), %%eax\n"
 		       "        .align 2,0x90\n"
-		       "2:      movl 0(%4), %%eax\n"
-		       "21:     movl 4(%4), %%edx\n"
+		       "2:      "__copyuser_seg" movl 0(%4), %%eax\n"
+		       "21:     "__copyuser_seg" movl 4(%4), %%edx\n"
 		       "        movl %%eax, 0(%3)\n"
 		       "        movl %%edx, 4(%3)\n"
-		       "3:      movl 8(%4), %%eax\n"
-		       "31:     movl 12(%4),%%edx\n"
+		       "3:      "__copyuser_seg" movl 8(%4), %%eax\n"
+		       "31:     "__copyuser_seg" movl 12(%4),%%edx\n"
 		       "        movl %%eax, 8(%3)\n"
 		       "        movl %%edx, 12(%3)\n"
-		       "4:      movl 16(%4), %%eax\n"
-		       "41:     movl 20(%4), %%edx\n"
+		       "4:      "__copyuser_seg" movl 16(%4), %%eax\n"
+		       "41:     "__copyuser_seg" movl 20(%4), %%edx\n"
 		       "        movl %%eax, 16(%3)\n"
 		       "        movl %%edx, 20(%3)\n"
-		       "10:     movl 24(%4), %%eax\n"
-		       "51:     movl 28(%4), %%edx\n"
+		       "10:     "__copyuser_seg" movl 24(%4), %%eax\n"
+		       "51:     "__copyuser_seg" movl 28(%4), %%edx\n"
 		       "        movl %%eax, 24(%3)\n"
 		       "        movl %%edx, 28(%3)\n"
-		       "11:     movl 32(%4), %%eax\n"
-		       "61:     movl 36(%4), %%edx\n"
+		       "11:     "__copyuser_seg" movl 32(%4), %%eax\n"
+		       "61:     "__copyuser_seg" movl 36(%4), %%edx\n"
 		       "        movl %%eax, 32(%3)\n"
 		       "        movl %%edx, 36(%3)\n"
-		       "12:     movl 40(%4), %%eax\n"
-		       "71:     movl 44(%4), %%edx\n"
+		       "12:     "__copyuser_seg" movl 40(%4), %%eax\n"
+		       "71:     "__copyuser_seg" movl 44(%4), %%edx\n"
 		       "        movl %%eax, 40(%3)\n"
 		       "        movl %%edx, 44(%3)\n"
-		       "13:     movl 48(%4), %%eax\n"
-		       "81:     movl 52(%4), %%edx\n"
+		       "13:     "__copyuser_seg" movl 48(%4), %%eax\n"
+		       "81:     "__copyuser_seg" movl 52(%4), %%edx\n"
 		       "        movl %%eax, 48(%3)\n"
 		       "        movl %%edx, 52(%3)\n"
-		       "14:     movl 56(%4), %%eax\n"
-		       "91:     movl 60(%4), %%edx\n"
+		       "14:     "__copyuser_seg" movl 56(%4), %%eax\n"
+		       "91:     "__copyuser_seg" movl 60(%4), %%edx\n"
 		       "        movl %%eax, 56(%3)\n"
 		       "        movl %%edx, 60(%3)\n"
 		       "        addl $-64, %0\n"
@@ -385,9 +498,9 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        shrl  $2, %0\n"
 		       "        andl $3, %%eax\n"
 		       "        cld\n"
-		       "6:      rep; movsl\n"
+		       "6:      rep; "__copyuser_seg" movsl\n"
 		       "        movl %%eax,%0\n"
-		       "7:      rep; movsb\n"
+		       "7:      rep; "__copyuser_seg" movsb\n"
 		       "8:\n"
 		       ".section .fixup,\"ax\"\n"
 		       "9:      lea 0(%%eax,%0,4),%0\n"
@@ -433,48 +546,48 @@ __copy_user_zeroing_intel(void *to, cons
  * hyoshiok@miraclelinux.com
  */
 
-static unsigned long __copy_user_zeroing_intel_nocache(void *to,
+static unsigned long __size_overflow(3) __copy_user_zeroing_intel_nocache(void *to,
 				const void __user *from, unsigned long size)
 {
 	int d0, d1;
 
 	__asm__ __volatile__(
 	       "        .align 2,0x90\n"
-	       "0:      movl 32(%4), %%eax\n"
+	       "0:      "__copyuser_seg" movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
 	       "        jbe 2f\n"
-	       "1:      movl 64(%4), %%eax\n"
+	       "1:      "__copyuser_seg" movl 64(%4), %%eax\n"
 	       "        .align 2,0x90\n"
-	       "2:      movl 0(%4), %%eax\n"
-	       "21:     movl 4(%4), %%edx\n"
+	       "2:      "__copyuser_seg" movl 0(%4), %%eax\n"
+	       "21:     "__copyuser_seg" movl 4(%4), %%edx\n"
 	       "        movnti %%eax, 0(%3)\n"
 	       "        movnti %%edx, 4(%3)\n"
-	       "3:      movl 8(%4), %%eax\n"
-	       "31:     movl 12(%4),%%edx\n"
+	       "3:      "__copyuser_seg" movl 8(%4), %%eax\n"
+	       "31:     "__copyuser_seg" movl 12(%4),%%edx\n"
 	       "        movnti %%eax, 8(%3)\n"
 	       "        movnti %%edx, 12(%3)\n"
-	       "4:      movl 16(%4), %%eax\n"
-	       "41:     movl 20(%4), %%edx\n"
+	       "4:      "__copyuser_seg" movl 16(%4), %%eax\n"
+	       "41:     "__copyuser_seg" movl 20(%4), %%edx\n"
 	       "        movnti %%eax, 16(%3)\n"
 	       "        movnti %%edx, 20(%3)\n"
-	       "10:     movl 24(%4), %%eax\n"
-	       "51:     movl 28(%4), %%edx\n"
+	       "10:     "__copyuser_seg" movl 24(%4), %%eax\n"
+	       "51:     "__copyuser_seg" movl 28(%4), %%edx\n"
 	       "        movnti %%eax, 24(%3)\n"
 	       "        movnti %%edx, 28(%3)\n"
-	       "11:     movl 32(%4), %%eax\n"
-	       "61:     movl 36(%4), %%edx\n"
+	       "11:     "__copyuser_seg" movl 32(%4), %%eax\n"
+	       "61:     "__copyuser_seg" movl 36(%4), %%edx\n"
 	       "        movnti %%eax, 32(%3)\n"
 	       "        movnti %%edx, 36(%3)\n"
-	       "12:     movl 40(%4), %%eax\n"
-	       "71:     movl 44(%4), %%edx\n"
+	       "12:     "__copyuser_seg" movl 40(%4), %%eax\n"
+	       "71:     "__copyuser_seg" movl 44(%4), %%edx\n"
 	       "        movnti %%eax, 40(%3)\n"
 	       "        movnti %%edx, 44(%3)\n"
-	       "13:     movl 48(%4), %%eax\n"
-	       "81:     movl 52(%4), %%edx\n"
+	       "13:     "__copyuser_seg" movl 48(%4), %%eax\n"
+	       "81:     "__copyuser_seg" movl 52(%4), %%edx\n"
 	       "        movnti %%eax, 48(%3)\n"
 	       "        movnti %%edx, 52(%3)\n"
-	       "14:     movl 56(%4), %%eax\n"
-	       "91:     movl 60(%4), %%edx\n"
+	       "14:     "__copyuser_seg" movl 56(%4), %%eax\n"
+	       "91:     "__copyuser_seg" movl 60(%4), %%edx\n"
 	       "        movnti %%eax, 56(%3)\n"
 	       "        movnti %%edx, 60(%3)\n"
 	       "        addl $-64, %0\n"
@@ -487,9 +600,9 @@ static unsigned long __copy_user_zeroing
 	       "        shrl  $2, %0\n"
 	       "        andl $3, %%eax\n"
 	       "        cld\n"
-	       "6:      rep; movsl\n"
+	       "6:      rep; "__copyuser_seg" movsl\n"
 	       "        movl %%eax,%0\n"
-	       "7:      rep; movsb\n"
+	       "7:      rep; "__copyuser_seg" movsb\n"
 	       "8:\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
@@ -530,48 +643,48 @@ static unsigned long __copy_user_zeroing
 	return size;
 }
 
-static unsigned long __copy_user_intel_nocache(void *to,
+static unsigned long __size_overflow(3) __copy_user_intel_nocache(void *to,
 				const void __user *from, unsigned long size)
 {
 	int d0, d1;
 
 	__asm__ __volatile__(
 	       "        .align 2,0x90\n"
-	       "0:      movl 32(%4), %%eax\n"
+	       "0:      "__copyuser_seg" movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
 	       "        jbe 2f\n"
-	       "1:      movl 64(%4), %%eax\n"
+	       "1:      "__copyuser_seg" movl 64(%4), %%eax\n"
 	       "        .align 2,0x90\n"
-	       "2:      movl 0(%4), %%eax\n"
-	       "21:     movl 4(%4), %%edx\n"
+	       "2:      "__copyuser_seg" movl 0(%4), %%eax\n"
+	       "21:     "__copyuser_seg" movl 4(%4), %%edx\n"
 	       "        movnti %%eax, 0(%3)\n"
 	       "        movnti %%edx, 4(%3)\n"
-	       "3:      movl 8(%4), %%eax\n"
-	       "31:     movl 12(%4),%%edx\n"
+	       "3:      "__copyuser_seg" movl 8(%4), %%eax\n"
+	       "31:     "__copyuser_seg" movl 12(%4),%%edx\n"
 	       "        movnti %%eax, 8(%3)\n"
 	       "        movnti %%edx, 12(%3)\n"
-	       "4:      movl 16(%4), %%eax\n"
-	       "41:     movl 20(%4), %%edx\n"
+	       "4:      "__copyuser_seg" movl 16(%4), %%eax\n"
+	       "41:     "__copyuser_seg" movl 20(%4), %%edx\n"
 	       "        movnti %%eax, 16(%3)\n"
 	       "        movnti %%edx, 20(%3)\n"
-	       "10:     movl 24(%4), %%eax\n"
-	       "51:     movl 28(%4), %%edx\n"
+	       "10:     "__copyuser_seg" movl 24(%4), %%eax\n"
+	       "51:     "__copyuser_seg" movl 28(%4), %%edx\n"
 	       "        movnti %%eax, 24(%3)\n"
 	       "        movnti %%edx, 28(%3)\n"
-	       "11:     movl 32(%4), %%eax\n"
-	       "61:     movl 36(%4), %%edx\n"
+	       "11:     "__copyuser_seg" movl 32(%4), %%eax\n"
+	       "61:     "__copyuser_seg" movl 36(%4), %%edx\n"
 	       "        movnti %%eax, 32(%3)\n"
 	       "        movnti %%edx, 36(%3)\n"
-	       "12:     movl 40(%4), %%eax\n"
-	       "71:     movl 44(%4), %%edx\n"
+	       "12:     "__copyuser_seg" movl 40(%4), %%eax\n"
+	       "71:     "__copyuser_seg" movl 44(%4), %%edx\n"
 	       "        movnti %%eax, 40(%3)\n"
 	       "        movnti %%edx, 44(%3)\n"
-	       "13:     movl 48(%4), %%eax\n"
-	       "81:     movl 52(%4), %%edx\n"
+	       "13:     "__copyuser_seg" movl 48(%4), %%eax\n"
+	       "81:     "__copyuser_seg" movl 52(%4), %%edx\n"
 	       "        movnti %%eax, 48(%3)\n"
 	       "        movnti %%edx, 52(%3)\n"
-	       "14:     movl 56(%4), %%eax\n"
-	       "91:     movl 60(%4), %%edx\n"
+	       "14:     "__copyuser_seg" movl 56(%4), %%eax\n"
+	       "91:     "__copyuser_seg" movl 60(%4), %%edx\n"
 	       "        movnti %%eax, 56(%3)\n"
 	       "        movnti %%edx, 60(%3)\n"
 	       "        addl $-64, %0\n"
@@ -584,9 +697,9 @@ static unsigned long __copy_user_intel_n
 	       "        shrl  $2, %0\n"
 	       "        andl $3, %%eax\n"
 	       "        cld\n"
-	       "6:      rep; movsl\n"
+	       "6:      rep; "__copyuser_seg" movsl\n"
 	       "        movl %%eax,%0\n"
-	       "7:      rep; movsb\n"
+	       "7:      rep; "__copyuser_seg" movsb\n"
 	       "8:\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
@@ -629,32 +742,36 @@ static unsigned long __copy_user_intel_n
  */
 unsigned long __copy_user_zeroing_intel(void *to, const void __user *from,
 					unsigned long size);
-unsigned long __copy_user_intel(void __user *to, const void *from,
+unsigned long __generic_copy_to_user_intel(void __user *to, const void *from,
+					unsigned long size);
+unsigned long __generic_copy_from_user_intel(void *to, const void __user *from,
 					unsigned long size);
 unsigned long __copy_user_zeroing_intel_nocache(void *to,
 				const void __user *from, unsigned long size);
 #endif /* CONFIG_X86_INTEL_USERCOPY */
 
 /* Generic arbitrary sized copy.  */
-#define __copy_user(to, from, size)					\
+#define __copy_user(to, from, size, prefix, set, restore)		\
 do {									\
 	int __d0, __d1, __d2;						\
 	__asm__ __volatile__(						\
+		set							\
 		"	cmp  $7,%0\n"					\
 		"	jbe  1f\n"					\
 		"	movl %1,%0\n"					\
 		"	negl %0\n"					\
 		"	andl $7,%0\n"					\
 		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
+		"4:	rep; "prefix"movsb\n"				\
 		"	movl %3,%0\n"					\
 		"	shrl $2,%0\n"					\
 		"	andl $3,%3\n"					\
 		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
+		"0:	rep; "prefix"movsl\n"				\
 		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
+		"1:	rep; "prefix"movsb\n"				\
 		"2:\n"							\
+		restore							\
 		".section .fixup,\"ax\"\n"				\
 		"5:	addl %3,%0\n"					\
 		"	jmp 2b\n"					\
@@ -682,14 +799,14 @@ do {									\
 		"	negl %0\n"					\
 		"	andl $7,%0\n"					\
 		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
+		"4:	rep; "__copyuser_seg"movsb\n"			\
 		"	movl %3,%0\n"					\
 		"	shrl $2,%0\n"					\
 		"	andl $3,%3\n"					\
 		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
+		"0:	rep; "__copyuser_seg"movsl\n"			\
 		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
+		"1:	rep; "__copyuser_seg"movsb\n"			\
 		"2:\n"							\
 		".section .fixup,\"ax\"\n"				\
 		"5:	addl %3,%0\n"					\
@@ -775,9 +892,9 @@ survive:
 	}
 #endif
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		__copy_user(to, from, n, "", __COPYUSER_SET_ES, __COPYUSER_RESTORE_ES);
 	else
-		n = __copy_user_intel(to, from, n);
+		n = __generic_copy_to_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_to_user_ll);
@@ -797,10 +914,9 @@ unsigned long __copy_from_user_ll_nozero
 					 unsigned long n)
 {
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		__copy_user(to, from, n, __copyuser_seg, "", "");
 	else
-		n = __copy_user_intel((void __user *)to,
-				      (const void *)from, n);
+		n = __generic_copy_from_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_from_user_ll_nozero);
@@ -827,59 +943,50 @@ unsigned long __copy_from_user_ll_nocach
 	if (n > 64 && cpu_has_xmm2)
 		n = __copy_user_intel_nocache(to, from, n);
 	else
-		__copy_user(to, from, n);
+		__copy_user(to, from, n, __copyuser_seg, "", "");
 #else
-	__copy_user(to, from, n);
+	__copy_user(to, from, n, __copyuser_seg, "", "");
 #endif
 	return n;
 }
 EXPORT_SYMBOL(__copy_from_user_ll_nocache_nozero);
 
-/**
- * copy_to_user: - Copy a block of data into user space.
- * @to:   Destination address, in user space.
- * @from: Source address, in kernel space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from kernel space to user space.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- */
-unsigned long
-copy_to_user(void __user *to, const void *from, unsigned long n)
+void copy_from_user_overflow(void)
 {
-	if (access_ok(VERIFY_WRITE, to, n))
-		n = __copy_to_user(to, from, n);
-	return n;
+	WARN(1, "Buffer overflow detected!\n");
 }
-EXPORT_SYMBOL(copy_to_user);
+EXPORT_SYMBOL(copy_from_user_overflow);
 
-/**
- * copy_from_user: - Copy a block of data from user space.
- * @to:   Destination address, in kernel space.
- * @from: Source address, in user space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from user space to kernel space.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- *
- * If some data could not be copied, this function will pad the copied
- * data to the requested size using zero bytes.
- */
-unsigned long
-copy_from_user(void *to, const void __user *from, unsigned long n)
+void copy_to_user_overflow(void)
 {
-	if (access_ok(VERIFY_READ, from, n))
-		n = __copy_from_user(to, from, n);
-	else
-		memset(to, 0, n);
-	return n;
+	WARN(1, "Buffer overflow detected!\n");
 }
-EXPORT_SYMBOL(copy_from_user);
+EXPORT_SYMBOL(copy_to_user_overflow);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+void __set_fs(mm_segment_t x)
+{
+	switch (x.seg) {
+	case 0:
+		loadsegment(gs, 0);
+		break;
+	case TASK_SIZE_MAX:
+		loadsegment(gs, __USER_DS);
+		break;
+	case -1UL:
+		loadsegment(gs, __KERNEL_DS);
+		break;
+	default:
+		BUG();
+	}
+	return;
+}
+EXPORT_SYMBOL(__set_fs);
+
+void set_fs(mm_segment_t x)
+{
+	current_thread_info()->addr_limit = x;
+	__set_fs(x);
+}
+EXPORT_SYMBOL(set_fs);
+#endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/lib/usercopy_64.c linux-2.6.32.60-pax/arch/x86/lib/usercopy_64.c
--- linux-2.6.32.60/arch/x86/lib/usercopy_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/lib/usercopy_64.c	2012-12-01 02:39:40.692118438 +0100
@@ -42,6 +42,12 @@ long
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res;
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if ((unsigned long)src < PAX_USER_SHADOW_BASE)
+		src += PAX_USER_SHADOW_BASE;
+#endif
+
 	__do_strncpy_from_user(dst, src, count, res);
 	return res;
 }
@@ -87,7 +93,7 @@ unsigned long __clear_user(void __user *
 		_ASM_EXTABLE(0b,3b)
 		_ASM_EXTABLE(1b,2b)
 		: [size8] "=&c"(size), [dst] "=&D" (__d0)
-		: [size1] "r"(size & 7), "[size8]" (size / 8), "[dst]"(addr),
+		: [size1] "r"(size & 7), "[size8]" (size / 8), "[dst]"(____m(addr)),
 		  [zero] "r" (0UL), [eight] "r" (8UL));
 	return size;
 }
@@ -149,12 +155,11 @@ long strlen_user(const char __user *s)
 }
 EXPORT_SYMBOL(strlen_user);
 
-unsigned long copy_in_user(void __user *to, const void __user *from, unsigned len)
+unsigned long copy_in_user(void __user *to, const void __user *from, unsigned long len)
 {
-	if (access_ok(VERIFY_WRITE, to, len) && access_ok(VERIFY_READ, from, len)) { 
-		return copy_user_generic((__force void *)to, (__force void *)from, len);
-	} 
-	return len;		
+	if (access_ok(VERIFY_WRITE, to, len) && access_ok(VERIFY_READ, from, len))
+		return copy_user_generic((void __force_kernel *)____m(to), (void __force_kernel *)____m(from), len);
+	return len;
 }
 EXPORT_SYMBOL(copy_in_user);
 
@@ -164,7 +169,7 @@ EXPORT_SYMBOL(copy_in_user);
  * it is not necessary to optimize tail handling.
  */
 unsigned long
-copy_user_handle_tail(char *to, char *from, unsigned len, unsigned zerorest)
+copy_user_handle_tail(char __user *to, char __user *from, unsigned long len, unsigned zerorest)
 {
 	char c;
 	unsigned zero_len;
@@ -181,3 +186,15 @@ copy_user_handle_tail(char *to, char *fr
 			break;
 	return len;
 }
+
+void copy_from_user_overflow(void)
+{
+	WARN(1, "Buffer overflow detected!\n");
+}
+EXPORT_SYMBOL(copy_from_user_overflow);
+
+void copy_to_user_overflow(void)
+{
+	WARN(1, "Buffer overflow detected!\n");
+}
+EXPORT_SYMBOL(copy_to_user_overflow);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/Makefile linux-2.6.32.60-pax/arch/x86/Makefile
--- linux-2.6.32.60/arch/x86/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/Makefile	2012-03-13 13:15:34.612098018 +0100
@@ -46,6 +46,7 @@ else
         UTS_MACHINE := x86_64
         CHECKFLAGS += -D__x86_64__ -m64
 
+        biarch := $(call cc-option,-m64)
         KBUILD_AFLAGS += -m64
         KBUILD_CFLAGS += -m64
 
@@ -189,3 +190,12 @@ define archhelp
   echo  '                  FDARGS="..."  arguments for the booted kernel'
   echo  '                  FDINITRD=file initrd for the booted kernel'
 endef
+
+define OLD_LD
+
+*** ${VERSION}.${PATCHLEVEL} PaX kernels no longer build correctly with old versions of binutils.
+*** Please upgrade your binutils to 2.18 or newer
+endef
+
+archprepare:
+	$(if $(LDFLAGS_BUILD_ID),,$(error $(OLD_LD)))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/extable.c linux-2.6.32.60-pax/arch/x86/mm/extable.c
--- linux-2.6.32.60/arch/x86/mm/extable.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/extable.c	2012-03-13 13:15:34.612098018 +0100
@@ -1,14 +1,71 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/sort.h>
 #include <asm/uaccess.h>
+#include <asm/pgtable.h>
 
+/*
+ * The exception table needs to be sorted so that the binary
+ * search that we use to find entries in it works properly.
+ * This is used both for the kernel exception table and for
+ * the exception tables of modules that get loaded.
+ */
+static int cmp_ex(const void *a, const void *b)
+{
+	const struct exception_table_entry *x = a, *y = b;
+
+	/* avoid overflow */
+	if (x->insn > y->insn)
+		return 1;
+	if (x->insn < y->insn)
+		return -1;
+	return 0;
+}
+
+static void swap_ex(void *a, void *b, int size)
+{
+	struct exception_table_entry t, *x = a, *y = b;
+
+	t = *x;
+
+	pax_open_kernel();
+	*x = *y;
+	*y = t;
+	pax_close_kernel();
+}
+
+void sort_extable(struct exception_table_entry *start,
+		  struct exception_table_entry *finish)
+{
+	sort(start, finish - start, sizeof(struct exception_table_entry),
+	     cmp_ex, swap_ex);
+}
+
+#ifdef CONFIG_MODULES
+/*
+ * If the exception table is sorted, any referring to the module init
+ * will be at the beginning or the end.
+ */
+void trim_init_extable(struct module *m)
+{
+	/*trim the beginning*/
+	while (m->num_exentries && within_module_init(m->extable[0].insn, m)) {
+		m->extable++;
+		m->num_exentries--;
+	}
+	/*trim the end*/
+	while (m->num_exentries &&
+		within_module_init(m->extable[m->num_exentries-1].insn, m))
+		m->num_exentries--;
+}
+#endif /* CONFIG_MODULES */
 
 int fixup_exception(struct pt_regs *regs)
 {
 	const struct exception_table_entry *fixup;
 
 #ifdef CONFIG_PNPBIOS
-	if (unlikely(SEGMENT_IS_PNP_CODE(regs->cs))) {
+	if (unlikely(!v8086_mode(regs) && SEGMENT_IS_PNP_CODE(regs->cs))) {
 		extern u32 pnp_bios_fault_eip, pnp_bios_fault_esp;
 		extern u32 pnp_bios_is_utter_crap;
 		pnp_bios_is_utter_crap = 1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/fault.c linux-2.6.32.60-pax/arch/x86/mm/fault.c
--- linux-2.6.32.60/arch/x86/mm/fault.c	2012-10-09 11:00:35.432882464 +0200
+++ linux-2.6.32.60-pax/arch/x86/mm/fault.c	2013-02-17 17:11:44.616182591 +0100
@@ -11,10 +11,19 @@
 #include <linux/kprobes.h>		/* __kprobes, ...		*/
 #include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
 #include <linux/perf_event.h>		/* perf_sw_event		*/
+#include <linux/unistd.h>
+#include <linux/compiler.h>
 
 #include <asm/traps.h>			/* dotraplinkage, ...		*/
 #include <asm/pgalloc.h>		/* pgd_*(), ...			*/
 #include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/
+#include <asm/vsyscall.h>
+#include <asm/tlbflush.h>
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+#include <asm/stacktrace.h>
+#include "../kernel/dumpstack.h"
+#endif
 
 /*
  * Page fault error code bits:
@@ -51,7 +60,7 @@ static inline int notify_page_fault(stru
 	int ret = 0;
 
 	/* kprobe_running() needs smp_processor_id() */
-	if (kprobes_built_in() && !user_mode_vm(regs)) {
+	if (kprobes_built_in() && !user_mode(regs)) {
 		preempt_disable();
 		if (kprobe_running() && kprobe_fault_handler(regs, 14))
 			ret = 1;
@@ -112,7 +121,10 @@ check_prefetch_opcode(struct pt_regs *re
 		return !instr_lo || (instr_lo>>1) == 1;
 	case 0x00:
 		/* Prefetch instruction is 0x0F0D or 0x0F18 */
-		if (probe_kernel_address(instr, opcode))
+		if (user_mode(regs)) {
+			if (__copy_from_user_inatomic(&opcode, (unsigned char __force_user *)(instr), 1))
+				return 0;
+		} else if (probe_kernel_address(instr, opcode))
 			return 0;
 
 		*prefetch = (instr_lo == 0xF) &&
@@ -146,7 +158,10 @@ is_prefetch(struct pt_regs *regs, unsign
 	while (instr < max_instr) {
 		unsigned char opcode;
 
-		if (probe_kernel_address(instr, opcode))
+		if (user_mode(regs)) {
+			if (__copy_from_user_inatomic(&opcode, (unsigned char __force_user *)(instr), 1))
+				break;
+		} else if (probe_kernel_address(instr, opcode))
 			break;
 
 		instr++;
@@ -172,6 +187,34 @@ force_sig_info_fault(int si_signo, int s
 	force_sig_info(si_signo, &info, tsk);
 }
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+static bool pax_is_fetch_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+static inline pmd_t * pax_get_pmd(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd_present(*pgd))
+		return NULL;
+	pud = pud_offset(pgd, address);
+	if (!pud_present(*pud))
+		return NULL;
+	pmd = pmd_offset(pud, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	return pmd;
+}
+#endif
+
 DEFINE_SPINLOCK(pgd_lock);
 LIST_HEAD(pgd_list);
 
@@ -223,11 +266,23 @@ void vmalloc_sync_all(void)
 	     address >= TASK_SIZE && address < FIXADDR_TOP;
 	     address += PMD_SIZE) {
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		unsigned long cpu;
+#else
 		struct page *page;
+#endif
 
 		spin_lock(&pgd_lock);
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		for (cpu = 0; cpu < nr_cpu_ids; ++cpu) {
+			pgd_t *pgd = get_cpu_pgd(cpu);
+#else
 		list_for_each_entry(page, &pgd_list, lru) {
-			if (!vmalloc_sync_one(page_address(page), address))
+			pgd_t *pgd = page_address(page);
+#endif
+
+			if (!vmalloc_sync_one(pgd, address))
 				break;
 		}
 		spin_unlock(&pgd_lock);
@@ -257,6 +312,11 @@ static noinline int vmalloc_fault(unsign
 	 * an interrupt in the middle of a task switch..
 	 */
 	pgd_paddr = read_cr3();
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	BUG_ON(__pa(get_cpu_pgd(smp_processor_id())) != (pgd_paddr & PHYSICAL_PAGE_MASK));
+#endif
+
 	pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);
 	if (!pmd_k)
 		return -1;
@@ -330,15 +390,27 @@ void vmalloc_sync_all(void)
 	     address += PGDIR_SIZE) {
 
 		const pgd_t *pgd_ref = pgd_offset_k(address);
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		unsigned long cpu;
+#else
 		struct page *page;
+#endif
 
 		if (pgd_none(*pgd_ref))
 			continue;
 
 		spin_lock(&pgd_lock);
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		for (cpu = 0; cpu < nr_cpu_ids; ++cpu) {
+			pgd_t *pgd = pgd_offset_cpu(cpu, address);
+#else
 		list_for_each_entry(page, &pgd_list, lru) {
 			pgd_t *pgd;
 			pgd = (pgd_t *)page_address(page) + pgd_index(address);
+#endif
+
 			if (pgd_none(*pgd))
 				set_pgd(pgd, *pgd_ref);
 			else
@@ -371,7 +443,14 @@ static noinline int vmalloc_fault(unsign
 	 * happen within a race in page table update. In the later
 	 * case just flush:
 	 */
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	BUG_ON(__pa(get_cpu_pgd(smp_processor_id())) != (read_cr3() & PHYSICAL_PAGE_MASK));
+	pgd = pgd_offset_cpu(smp_processor_id(), address);
+#else
 	pgd = pgd_offset(current->active_mm, address);
+#endif
+
 	pgd_ref = pgd_offset_k(address);
 	if (pgd_none(*pgd_ref))
 		return -1;
@@ -533,7 +612,7 @@ static int is_errata93(struct pt_regs *r
 static int is_errata100(struct pt_regs *regs, unsigned long address)
 {
 #ifdef CONFIG_X86_64
-	if ((regs->cs == __USER32_CS || (regs->cs & (1<<2))) && (address >> 32))
+	if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT)) && (address >> 32))
 		return 1;
 #endif
 	return 0;
@@ -560,7 +639,7 @@ static int is_f00f_bug(struct pt_regs *r
 }
 
 static const char nx_warning[] = KERN_CRIT
-"kernel tried to execute NX-protected page - exploit attempt? (uid: %d)\n";
+"kernel tried to execute NX-protected page - exploit attempt? (uid: %d, task: %s, pid: %d)\n";
 
 static void
 show_fault_oops(struct pt_regs *regs, unsigned long error_code,
@@ -569,15 +648,21 @@ show_fault_oops(struct pt_regs *regs, un
 	if (!oops_may_print())
 		return;
 
-	if (error_code & PF_INSTR) {
+	if (nx_enabled && (error_code & PF_INSTR)) {
 		unsigned int level;
 
 		pte_t *pte = lookup_address(address, &level);
 
 		if (pte && pte_present(*pte) && !pte_exec(*pte))
-			printk(nx_warning, current_uid());
+			printk(nx_warning, current_uid(), current->comm, task_pid_nr(current));
 	}
 
+#ifdef CONFIG_PAX_KERNEXEC
+	if (init_mm.start_code <= address && address < init_mm.end_code)
+		printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code\n",
+				 current->comm, task_pid_nr(current), current_uid(), current_euid());
+#endif
+
 	printk(KERN_ALERT "BUG: unable to handle kernel ");
 	if (address < PAGE_SIZE)
 		printk(KERN_CONT "NULL pointer dereference");
@@ -703,6 +788,23 @@ __bad_area_nosemaphore(struct pt_regs *r
 {
 	struct task_struct *tsk = current;
 
+#ifdef CONFIG_X86_64
+	struct mm_struct *mm = tsk->mm;
+
+	if (mm && (error_code & PF_INSTR) && mm->context.vdso) {
+		if (regs->ip == (unsigned long)vgettimeofday) {
+			regs->ip = (unsigned long)VDSO64_SYMBOL(mm->context.vdso, fallback_gettimeofday);
+			return;
+		} else if (regs->ip == (unsigned long)vtime) {
+			regs->ip = (unsigned long)VDSO64_SYMBOL(mm->context.vdso, fallback_time);
+			return;
+		} else if (regs->ip == (unsigned long)vgetcpu) {
+			regs->ip = (unsigned long)VDSO64_SYMBOL(mm->context.vdso, getcpu);
+			return;
+		}
+	}
+#endif
+
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & PF_USER) {
 		/*
@@ -720,12 +822,29 @@ __bad_area_nosemaphore(struct pt_regs *r
 		if (is_errata100(regs, address))
 			return;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		if (pax_is_fetch_fault(regs, error_code, address)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 2:
+				return;
+			}
+#endif
+
+			pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
+		/* Kernel addresses are always protection faults: */
+		error_code |= address >= TASK_SIZE;
+
 		if (unlikely(show_unhandled_signals))
 			show_signal_msg(regs, error_code, address, tsk);
 
-		/* Kernel addresses are always protection faults: */
 		tsk->thread.cr2		= address;
-		tsk->thread.error_code	= error_code | (address >= TASK_SIZE);
+		tsk->thread.error_code	= error_code;
 		tsk->thread.trap_no	= 14;
 
 		force_sig_info_fault(SIGSEGV, si_code, address, tsk);
@@ -816,7 +935,7 @@ do_sigbus(struct pt_regs *regs, unsigned
 	if (fault & VM_FAULT_HWPOISON) {
 		printk(KERN_ERR
 	"MCE: Killing %s:%d due to hardware memory corruption fault at %lx\n",
-			tsk->comm, tsk->pid, address);
+			tsk->comm, task_pid_nr(tsk), address);
 		code = BUS_MCEERR_AR;
 	}
 #endif
@@ -855,6 +974,99 @@ static int spurious_fault_check(unsigned
 	return 1;
 }
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+static int pax_handle_pageexec_fault(struct pt_regs *regs, struct mm_struct *mm, unsigned long address, unsigned long error_code)
+{
+	pte_t *pte;
+	pmd_t *pmd;
+	spinlock_t *ptl;
+	unsigned char pte_mask;
+
+	if (nx_enabled || (error_code & (PF_PROT|PF_USER)) != (PF_PROT|PF_USER) || v8086_mode(regs) ||
+	    !(mm->pax_flags & MF_PAX_PAGEEXEC))
+		return 0;
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & PF_WRITE) && (regs->ip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+		up_read(&mm->mmap_sem);
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		switch (pax_handle_fetch_fault(regs)) {
+		case 2:
+			return 1;
+		}
+#endif
+
+		pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+		do_group_exit(SIGKILL);
+	}
+
+	pmd = pax_get_pmd(mm, address);
+	if (unlikely(!pmd))
+		return 0;
+
+	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
+	if (unlikely(!(pte_val(*pte) & _PAGE_PRESENT) || pte_user(*pte))) {
+		pte_unmap_unlock(pte, ptl);
+		return 0;
+	}
+
+	if (unlikely((error_code & PF_WRITE) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		pte_unmap_unlock(pte, ptl);
+		return 0;
+	}
+
+#ifdef CONFIG_SMP
+	if (likely(address > get_limit(regs->cs) && cpu_isset(smp_processor_id(), mm->context.cpu_user_cs_mask)))
+#else
+	if (likely(address > get_limit(regs->cs)))
+#endif
+	{
+		set_pte(pte, pte_mkread(*pte));
+		__flush_tlb_one(address);
+		pte_unmap_unlock(pte, ptl);
+		up_read(&mm->mmap_sem);
+		return 1;
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & PF_WRITE) << (_PAGE_BIT_DIRTY-1));
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+		"orb %2,(%1)\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg (%0)\n"
+#endif
+		__copyuser_seg"testb $0,(%0)\n"
+		"xorb %3,(%1)\n"
+		:
+		: "r" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER)
+		: "memory", "cc");
+	pte_unmap_unlock(pte, ptl);
+	up_read(&mm->mmap_sem);
+	return 1;
+}
+#endif
+
 /*
  * Handle a spurious fault caused by a stale TLB entry.
  *
@@ -921,6 +1133,9 @@ int show_unhandled_signals = 1;
 static inline int
 access_error(unsigned long error_code, int write, struct vm_area_struct *vma)
 {
+	if (nx_enabled && (error_code & PF_INSTR) && !(vma->vm_flags & VM_EXEC))
+		return 1;
+
 	if (write) {
 		/* write, present and write, not present: */
 		if (unlikely(!(vma->vm_flags & VM_WRITE)))
@@ -954,17 +1169,31 @@ do_page_fault(struct pt_regs *regs, unsi
 {
 	struct vm_area_struct *vma;
 	struct task_struct *tsk;
-	unsigned long address;
 	struct mm_struct *mm;
 	int write;
 	int fault;
 
+	/* Get the faulting address: */
+	unsigned long address = read_cr2();
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+	if (!user_mode(regs) && address < 2 * PAX_USER_SHADOW_BASE) {
+		if (!search_exception_tables(regs->ip)) {
+			bad_area_nosemaphore(regs, error_code, address);
+			return;
+		}
+		if (address < PAX_USER_SHADOW_BASE) {
+			printk(KERN_ERR "PAX: please report this to pageexec@freemail.hu\n");
+			printk(KERN_ERR "PAX: faulting IP: %pS\n", (void *)regs->ip);
+			show_trace_log_lvl(NULL, NULL, (void *)regs->sp, regs->bp, KERN_ERR);
+		} else
+			address -= PAX_USER_SHADOW_BASE;
+	}
+#endif
+
 	tsk = current;
 	mm = tsk->mm;
 
-	/* Get the faulting address: */
-	address = read_cr2();
-
 	/*
 	 * Detect and handle instructions that would cause a page fault for
 	 * both a tracked kernel page and a userspace page.
@@ -1024,7 +1253,7 @@ do_page_fault(struct pt_regs *regs, unsi
 	 * User-mode registers count as a user access even for any
 	 * potential system fault or CPU buglet:
 	 */
-	if (user_mode_vm(regs)) {
+	if (user_mode(regs)) {
 		local_irq_enable();
 		error_code |= PF_USER;
 	} else {
@@ -1078,6 +1307,11 @@ do_page_fault(struct pt_regs *regs, unsi
 		might_sleep();
 	}
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+	if (pax_handle_pageexec_fault(regs, mm, address, error_code))
+		return;
+#endif
+
 	vma = find_vma(mm, address);
 	if (unlikely(!vma)) {
 		bad_area(regs, error_code, address);
@@ -1089,18 +1323,24 @@ do_page_fault(struct pt_regs *regs, unsi
 		bad_area(regs, error_code, address);
 		return;
 	}
-	if (error_code & PF_USER) {
-		/*
-		 * Accessing the stack below %sp is always a bug.
-		 * The large cushion allows instructions like enter
-		 * and pusha to work. ("enter $65535, $31" pushes
-		 * 32 pointers and then decrements %sp by 65535.)
-		 */
-		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
-			bad_area(regs, error_code, address);
-			return;
-		}
+	/*
+	 * Accessing the stack below %sp is always a bug.
+	 * The large cushion allows instructions like enter
+	 * and pusha to work. ("enter $65535, $31" pushes
+	 * 32 pointers and then decrements %sp by 65535.)
+	 */
+	if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < task_pt_regs(tsk)->sp)) {
+		bad_area(regs, error_code, address);
+		return;
+	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (unlikely((mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < address - SEGMEXEC_TASK_SIZE - 1)) {
+		bad_area(regs, error_code, address);
+		return;
 	}
+#endif
+
 	if (unlikely(expand_stack(vma, address))) {
 		bad_area(regs, error_code, address);
 		return;
@@ -1144,3 +1384,292 @@ good_area:
 
 	up_read(&mm->mmap_sem);
 }
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+static bool pax_is_fetch_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long ip = regs->ip;
+
+	if (v8086_mode(regs))
+		ip = ((regs->cs & 0xffff) << 4) + (ip & 0xffff);
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+		if ((__supported_pte_mask & _PAGE_NX) && (error_code & PF_INSTR))
+			return true;
+		if (!(error_code & (PF_PROT | PF_WRITE)) && ip == address)
+			return true;
+		return false;
+	}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (!(error_code & (PF_PROT | PF_WRITE)) && (ip + SEGMEXEC_TASK_SIZE == address))
+			return true;
+		return false;
+	}
+#endif
+
+	return false;
+}
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault_32(struct pt_regs *regs)
+{
+	int err;
+
+	do { /* PaX: libffi trampoline emulation */
+		unsigned char mov, jmp;
+		unsigned int addr1, addr2;
+
+#ifdef CONFIG_X86_64
+		if ((regs->ip + 9) >> 32)
+			break;
+#endif
+
+		err = get_user(mov, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+
+		if (err)
+			break;
+
+		if (mov == 0xB8 && jmp == 0xE9) {
+			regs->ax = addr1;
+			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned int addr1, addr2;
+
+#ifdef CONFIG_X86_64
+		if ((regs->ip + 11) >> 32)
+			break;
+#endif
+
+		err = get_user(mov1, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(mov2, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+		err |= get_user(jmp, (unsigned short __user *)(regs->ip + 10));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xB9 && mov2 == 0xB8 && jmp == 0xE0FF) {
+			regs->cx = addr1;
+			regs->ax = addr2;
+			regs->ip = addr2;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned int addr1, addr2;
+
+#ifdef CONFIG_X86_64
+		if ((regs->ip + 9) >> 32)
+			break;
+#endif
+
+		err = get_user(mov, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+
+		if (err)
+			break;
+
+		if (mov == 0xB9 && jmp == 0xE9) {
+			regs->cx = addr1;
+			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+			return 2;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+
+#ifdef CONFIG_X86_64
+static int pax_handle_fetch_fault_64(struct pt_regs *regs)
+{
+	int err;
+
+	do { /* PaX: libffi trampoline emulation */
+		unsigned short mov1, mov2, jmp1;
+		unsigned char stcclc, jmp2;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+		err |= get_user(stcclc, (unsigned char __user *)(regs->ip + 20));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 21));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 23));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB49 && mov2 == 0xBA49 && (stcclc == 0xF8 || stcclc == 0xF9) && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			if (stcclc == 0xF8)
+				regs->flags &= ~X86_EFLAGS_CF;
+			else
+				regs->flags |= X86_EFLAGS_CF;
+			regs->ip = addr1;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned int addr1;
+		unsigned long addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 6));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 8));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 16));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 18));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB41 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 20));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 22));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB49 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return 2;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->ip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	if (v8086_mode(regs))
+		return 1;
+
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+
+#ifdef CONFIG_X86_32
+	return pax_handle_fetch_fault_32(regs);
+#else
+	if (regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))
+		return pax_handle_fetch_fault_32(regs);
+	else
+		return pax_handle_fetch_fault_64(regs);
+#endif
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char __force_user *)pc+i))
+			printk(KERN_CONT "?? ");
+		else
+			printk(KERN_CONT "%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-%lu: ", (unsigned long)sizeof(long));
+	for (i = -1; i < 80 / (long)sizeof(long); i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long __force_user *)sp+i)) {
+#ifdef CONFIG_X86_32
+			printk(KERN_CONT "???????? ");
+#else
+			if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT)))
+				printk(KERN_CONT "???????? ???????? ");
+			else
+				printk(KERN_CONT "???????????????? ");
+#endif
+		} else {
+#ifdef CONFIG_X86_64
+			if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))) {
+				printk(KERN_CONT "%08x ", (unsigned int)c);
+				printk(KERN_CONT "%08x ", (unsigned int)(c >> 32));
+			} else
+#endif
+				printk(KERN_CONT "%0*lx ", 2 * (int)sizeof(long), c);
+		}
+	}
+	printk("\n");
+}
+#endif
+
+/**
+ * probe_kernel_write(): safely attempt to write to a location
+ * @dst: address to write to
+ * @src: pointer to the data that shall be written
+ * @size: size of the data chunk
+ *
+ * Safely write to address @dst from the buffer at @src.  If a kernel fault
+ * happens, handle that and return -EFAULT.
+ */
+long notrace probe_kernel_write(void *dst, const void *src, size_t size)
+{
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	set_fs(KERNEL_DS);
+	pagefault_disable();
+	pax_open_kernel();
+	ret = __copy_to_user_inatomic((void __force_user *)dst, src, size);
+	pax_close_kernel();
+	pagefault_enable();
+	set_fs(old_fs);
+
+	return ret ? -EFAULT : 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/gup.c linux-2.6.32.60-pax/arch/x86/mm/gup.c
--- linux-2.6.32.60/arch/x86/mm/gup.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/gup.c	2012-03-13 13:15:34.612098018 +0100
@@ -237,7 +237,7 @@ int __get_user_pages_fast(unsigned long
 	addr = start;
 	len = (unsigned long) nr_pages << PAGE_SHIFT;
 	end = start + len;
-	if (unlikely(!access_ok(write ? VERIFY_WRITE : VERIFY_READ,
+	if (unlikely(!__access_ok(write ? VERIFY_WRITE : VERIFY_READ,
 					(void __user *)start, len)))
 		return 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/highmem_32.c linux-2.6.32.60-pax/arch/x86/mm/highmem_32.c
--- linux-2.6.32.60/arch/x86/mm/highmem_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/highmem_32.c	2012-03-13 13:15:34.616098018 +0100
@@ -43,7 +43,10 @@ void *kmap_atomic_prot(struct page *page
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
 	BUG_ON(!pte_none(*(kmap_pte-idx)));
+
+	pax_open_kernel();
 	set_pte(kmap_pte-idx, mk_pte(page, prot));
+	pax_close_kernel();
 
 	return (void *)vaddr;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/hugetlbpage.c linux-2.6.32.60-pax/arch/x86/mm/hugetlbpage.c
--- linux-2.6.32.60/arch/x86/mm/hugetlbpage.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/hugetlbpage.c	2013-02-17 17:12:19.936180706 +0100
@@ -267,13 +267,20 @@ static unsigned long hugetlb_get_unmappe
 	struct hstate *h = hstate_file(file);
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
-	unsigned long start_addr;
+	unsigned long start_addr, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
 
 	if (len > mm->cached_hole_size) {
-	        start_addr = mm->free_area_cache;
+		start_addr = mm->free_area_cache;
 	} else {
-	        start_addr = TASK_UNMAPPED_BASE;
-	        mm->cached_hole_size = 0;
+		start_addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
 	}
 
 full_search:
@@ -281,26 +288,27 @@ full_search:
 
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr) {
+		if (pax_task_size - len < addr) {
 			/*
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
-			mm->free_area_cache = addr + len;
-			return addr;
-		}
+		if (check_heap_stack_gap(vma, addr, len))
+			break;
 		if (addr + mm->cached_hole_size < vma->vm_start)
 		        mm->cached_hole_size = vma->vm_start - addr;
 		addr = ALIGN(vma->vm_end, huge_page_size(h));
 	}
+
+	mm->free_area_cache = addr + len;
+	return addr;
 }
 
 static unsigned long hugetlb_get_unmapped_area_topdown(struct file *file,
@@ -309,10 +317,9 @@ static unsigned long hugetlb_get_unmappe
 {
 	struct hstate *h = hstate_file(file);
 	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma, *prev_vma;
-	unsigned long base = mm->mmap_base, addr = addr0;
+	struct vm_area_struct *vma;
+	unsigned long base = mm->mmap_base, addr;
 	unsigned long largest_hole = mm->cached_hole_size;
-	int first_time = 1;
 
 	/* don't allow allocations above current base */
 	if (mm->free_area_cache > base)
@@ -322,64 +329,68 @@ static unsigned long hugetlb_get_unmappe
 	        largest_hole = 0;
 		mm->free_area_cache  = base;
 	}
-try_again:
+
 	/* make sure it can fit in the remaining address space */
 	if (mm->free_area_cache < len)
 		goto fail;
 
 	/* either no address requested or cant fit in requested address hole */
-	addr = (mm->free_area_cache - len) & huge_page_mask(h);
+	addr = (mm->free_area_cache - len);
 	do {
+		addr &= huge_page_mask(h);
 		/*
 		 * Lookup failure means no vma is above this address,
 		 * i.e. return with success:
 		 */
-		if (!(vma = find_vma_prev(mm, addr, &prev_vma)))
+		vma = find_vma(mm, addr);
+		if (!vma)
 			return addr;
 
 		/*
 		 * new region fits between prev_vma->vm_end and
 		 * vma->vm_start, use it:
 		 */
-		if (addr + len <= vma->vm_start &&
-		            (!prev_vma || (addr >= prev_vma->vm_end))) {
+		if (check_heap_stack_gap(vma, addr, len)) {
 			/* remember the address as a hint for next time */
-		        mm->cached_hole_size = largest_hole;
-		        return (mm->free_area_cache = addr);
-		} else {
-			/* pull free_area_cache down to the first hole */
-		        if (mm->free_area_cache == vma->vm_end) {
-				mm->free_area_cache = vma->vm_start;
-				mm->cached_hole_size = largest_hole;
-			}
+			mm->cached_hole_size = largest_hole;
+			return (mm->free_area_cache = addr);
+		}
+		/* pull free_area_cache down to the first hole */
+		if (mm->free_area_cache == vma->vm_end) {
+			mm->free_area_cache = vma->vm_start;
+			mm->cached_hole_size = largest_hole;
 		}
 
 		/* remember the largest hole we saw so far */
 		if (addr + largest_hole < vma->vm_start)
-		        largest_hole = vma->vm_start - addr;
+			largest_hole = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = (vma->vm_start - len) & huge_page_mask(h);
-	} while (len <= vma->vm_start);
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 fail:
 	/*
-	 * if hint left us with no space for the requested
-	 * mapping then try again:
-	 */
-	if (first_time) {
-		mm->free_area_cache = base;
-		largest_hole = 0;
-		first_time = 0;
-		goto try_again;
-	}
-	/*
 	 * A failed mmap() very likely causes application failure,
 	 * so fall back to the bottom-up function here. This scenario
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		mm->mmap_base = SEGMEXEC_TASK_UNMAPPED_BASE;
+	else
+#endif
+
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
 	addr = hugetlb_get_unmapped_area_bottomup(file, addr0,
 			len, pgoff, flags);
@@ -387,6 +398,7 @@ fail:
 	/*
 	 * Restore the topdown base:
 	 */
+	mm->mmap_base = base;
 	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
@@ -400,10 +412,19 @@ hugetlb_get_unmapped_area(struct file *f
 	struct hstate *h = hstate_file(file);
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
+	unsigned long pax_task_size = TASK_SIZE;
 
 	if (len & ~huge_page_mask(h))
 		return -EINVAL;
-	if (len > TASK_SIZE)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
+
+	if (len > pax_task_size)
 		return -ENOMEM;
 
 	if (flags & MAP_FIXED) {
@@ -412,11 +433,14 @@ hugetlb_get_unmapped_area(struct file *f
 		return addr;
 	}
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
+		if (pax_task_size - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 	if (mm->get_unmapped_area == arch_get_unmapped_area)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/init_32.c linux-2.6.32.60-pax/arch/x86/mm/init_32.c
--- linux-2.6.32.60/arch/x86/mm/init_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/init_32.c	2012-03-13 13:15:34.616098018 +0100
@@ -72,36 +72,6 @@ static __init void *alloc_low_page(void)
 }
 
 /*
- * Creates a middle page table and puts a pointer to it in the
- * given global directory entry. This only returns the gd entry
- * in non-PAE compilation mode, since the middle layer is folded.
- */
-static pmd_t * __init one_md_table_init(pgd_t *pgd)
-{
-	pud_t *pud;
-	pmd_t *pmd_table;
-
-#ifdef CONFIG_X86_PAE
-	if (!(pgd_val(*pgd) & _PAGE_PRESENT)) {
-		if (after_bootmem)
-			pmd_table = (pmd_t *)alloc_bootmem_pages(PAGE_SIZE);
-		else
-			pmd_table = (pmd_t *)alloc_low_page();
-		paravirt_alloc_pmd(&init_mm, __pa(pmd_table) >> PAGE_SHIFT);
-		set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));
-		pud = pud_offset(pgd, 0);
-		BUG_ON(pmd_table != pmd_offset(pud, 0));
-
-		return pmd_table;
-	}
-#endif
-	pud = pud_offset(pgd, 0);
-	pmd_table = pmd_offset(pud, 0);
-
-	return pmd_table;
-}
-
-/*
  * Create a page table and place a pointer to it in a middle page
  * directory entry:
  */
@@ -121,13 +91,28 @@ static pte_t * __init one_page_table_ini
 			page_table = (pte_t *)alloc_low_page();
 
 		paravirt_alloc_pte(&init_mm, __pa(page_table) >> PAGE_SHIFT);
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		set_pmd(pmd, __pmd(__pa(page_table) | _KERNPG_TABLE));
+#else
 		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+#endif
 		BUG_ON(page_table != pte_offset_kernel(pmd, 0));
 	}
 
 	return pte_offset_kernel(pmd, 0);
 }
 
+static pmd_t * __init one_md_table_init(pgd_t *pgd)
+{
+	pud_t *pud;
+	pmd_t *pmd_table;
+
+	pud = pud_offset(pgd, 0);
+	pmd_table = pmd_offset(pud, 0);
+
+	return pmd_table;
+}
+
 pmd_t * __init populate_extra_pmd(unsigned long vaddr)
 {
 	int pgd_idx = pgd_index(vaddr);
@@ -201,6 +186,7 @@ page_table_range_init(unsigned long star
 	int pgd_idx, pmd_idx;
 	unsigned long vaddr;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte = NULL;
 
@@ -210,8 +196,13 @@ page_table_range_init(unsigned long star
 	pgd = pgd_base + pgd_idx;
 
 	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
-		pmd = pmd + pmd_index(vaddr);
+		pud = pud_offset(pgd, vaddr);
+		pmd = pmd_offset(pud, vaddr);
+
+#ifdef CONFIG_X86_PAE
+		paravirt_alloc_pmd(&init_mm, __pa(pmd) >> PAGE_SHIFT);
+#endif
+
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end);
 							pmd++, pmd_idx++) {
 			pte = page_table_kmap_check(one_page_table_init(pmd),
@@ -223,11 +214,20 @@ page_table_range_init(unsigned long star
 	}
 }
 
-static inline int is_kernel_text(unsigned long addr)
+static inline int is_kernel_text(unsigned long start, unsigned long end)
 {
-	if (addr >= PAGE_OFFSET && addr <= (unsigned long)__init_end)
-		return 1;
-	return 0;
+	if ((start > ktla_ktva((unsigned long)_etext) ||
+	     end <= ktla_ktva((unsigned long)_stext)) &&
+	    (start > ktla_ktva((unsigned long)_einittext) ||
+	     end <= ktla_ktva((unsigned long)_sinittext)) &&
+
+#ifdef CONFIG_ACPI_SLEEP
+	    (start > (unsigned long)__va(acpi_wakeup_address) + 0x4000 || end <= (unsigned long)__va(acpi_wakeup_address)) &&
+#endif
+
+	    (start > (unsigned long)__va(0xfffff) || end <= (unsigned long)__va(0xc0000)))
+		return 0;
+	return 1;
 }
 
 /*
@@ -243,9 +243,10 @@ kernel_physical_mapping_init(unsigned lo
 	int use_pse = page_size_mask == (1<<PG_LEVEL_2M);
 	unsigned long start_pfn, end_pfn;
 	pgd_t *pgd_base = swapper_pg_dir;
-	int pgd_idx, pmd_idx, pte_ofs;
+	unsigned int pgd_idx, pmd_idx, pte_ofs;
 	unsigned long pfn;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	unsigned pages_2m, pages_4k;
@@ -278,8 +279,13 @@ repeat:
 	pfn = start_pfn;
 	pgd_idx = pgd_index((pfn<<PAGE_SHIFT) + PAGE_OFFSET);
 	pgd = pgd_base + pgd_idx;
-	for (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
+	for (; pgd_idx < PTRS_PER_PGD && pfn < max_low_pfn; pgd++, pgd_idx++) {
+		pud = pud_offset(pgd, 0);
+		pmd = pmd_offset(pud, 0);
+
+#ifdef CONFIG_X86_PAE
+		paravirt_alloc_pmd(&init_mm, __pa(pmd) >> PAGE_SHIFT);
+#endif
 
 		if (pfn >= end_pfn)
 			continue;
@@ -291,14 +297,13 @@ repeat:
 #endif
 		for (; pmd_idx < PTRS_PER_PMD && pfn < end_pfn;
 		     pmd++, pmd_idx++) {
-			unsigned int addr = pfn * PAGE_SIZE + PAGE_OFFSET;
+			unsigned long address = pfn * PAGE_SIZE + PAGE_OFFSET;
 
 			/*
 			 * Map with big pages if possible, otherwise
 			 * create normal page tables:
 			 */
 			if (use_pse) {
-				unsigned int addr2;
 				pgprot_t prot = PAGE_KERNEL_LARGE;
 				/*
 				 * first pass will use the same initial
@@ -308,11 +313,7 @@ repeat:
 					__pgprot(PTE_IDENT_ATTR |
 						 _PAGE_PSE);
 
-				addr2 = (pfn + PTRS_PER_PTE-1) * PAGE_SIZE +
-					PAGE_OFFSET + PAGE_SIZE-1;
-
-				if (is_kernel_text(addr) ||
-				    is_kernel_text(addr2))
+				if (is_kernel_text(address, address + PMD_SIZE))
 					prot = PAGE_KERNEL_LARGE_EXEC;
 
 				pages_2m++;
@@ -329,7 +330,7 @@ repeat:
 			pte_ofs = pte_index((pfn<<PAGE_SHIFT) + PAGE_OFFSET);
 			pte += pte_ofs;
 			for (; pte_ofs < PTRS_PER_PTE && pfn < end_pfn;
-			     pte++, pfn++, pte_ofs++, addr += PAGE_SIZE) {
+			     pte++, pfn++, pte_ofs++, address += PAGE_SIZE) {
 				pgprot_t prot = PAGE_KERNEL;
 				/*
 				 * first pass will use the same initial
@@ -337,7 +338,7 @@ repeat:
 				 */
 				pgprot_t init_prot = __pgprot(PTE_IDENT_ATTR);
 
-				if (is_kernel_text(addr))
+				if (is_kernel_text(address, address + PAGE_SIZE))
 					prot = PAGE_KERNEL_EXEC;
 
 				pages_4k++;
@@ -489,7 +490,7 @@ void __init native_pagetable_setup_start
 
 		pud = pud_offset(pgd, va);
 		pmd = pmd_offset(pud, va);
-		if (!pmd_present(*pmd))
+		if (!pmd_present(*pmd) || pmd_huge(*pmd))
 			break;
 
 		pte = pte_offset_kernel(pmd, va);
@@ -541,9 +542,7 @@ void __init early_ioremap_page_table_ran
 
 static void __init pagetable_init(void)
 {
-	pgd_t *pgd_base = swapper_pg_dir;
-
-	permanent_kmaps_init(pgd_base);
+	permanent_kmaps_init(swapper_pg_dir);
 }
 
 #ifdef CONFIG_ACPI_SLEEP
@@ -551,12 +550,12 @@ static void __init pagetable_init(void)
  * ACPI suspend needs this for resume, because things like the intel-agp
  * driver might have split up a kernel 4MB mapping.
  */
-char swsusp_pg_dir[PAGE_SIZE]
+pgd_t swsusp_pg_dir[PTRS_PER_PGD]
 	__attribute__ ((aligned(PAGE_SIZE)));
 
 static inline void save_pg_dir(void)
 {
-	memcpy(swsusp_pg_dir, swapper_pg_dir, PAGE_SIZE);
+	clone_pgd_range(swsusp_pg_dir, swapper_pg_dir, PTRS_PER_PGD);
 }
 #else /* !CONFIG_ACPI_SLEEP */
 static inline void save_pg_dir(void)
@@ -588,7 +587,7 @@ void zap_low_mappings(bool early)
 		flush_tlb_all();
 }
 
-pteval_t __supported_pte_mask __read_mostly = ~(_PAGE_NX | _PAGE_GLOBAL | _PAGE_IOMAP);
+pteval_t __supported_pte_mask __read_only = ~(_PAGE_NX | _PAGE_GLOBAL | _PAGE_IOMAP);
 EXPORT_SYMBOL_GPL(__supported_pte_mask);
 
 /* user-defined highmem size */
@@ -777,7 +776,7 @@ void __init setup_bootmem_allocator(void
 	 * Initialize the boot-time allocator (with low memory only):
 	 */
 	bootmap_size = bootmem_bootmap_pages(max_low_pfn)<<PAGE_SHIFT;
-	bootmap = find_e820_area(0, max_pfn_mapped<<PAGE_SHIFT, bootmap_size,
+	bootmap = find_e820_area(0x100000, max_pfn_mapped<<PAGE_SHIFT, bootmap_size,
 				 PAGE_SIZE);
 	if (bootmap == -1L)
 		panic("Cannot find bootmem map of size %ld\n", bootmap_size);
@@ -864,6 +863,12 @@ void __init mem_init(void)
 
 	pci_iommu_alloc();
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	clone_pgd_range(get_cpu_pgd(0) + KERNEL_PGD_BOUNDARY,
+			swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			KERNEL_PGD_PTRS);
+#endif
+
 #ifdef CONFIG_FLATMEM
 	BUG_ON(!mem_map);
 #endif
@@ -881,7 +886,7 @@ void __init mem_init(void)
 	set_highmem_pages_init();
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_sdata;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	printk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, "
@@ -923,10 +928,10 @@ void __init mem_init(void)
 		((unsigned long)&__init_end -
 		 (unsigned long)&__init_begin) >> 10,
 
-		(unsigned long)&_etext, (unsigned long)&_edata,
-		((unsigned long)&_edata - (unsigned long)&_etext) >> 10,
+		(unsigned long)&_sdata, (unsigned long)&_edata,
+		((unsigned long)&_edata - (unsigned long)&_sdata) >> 10,
 
-		(unsigned long)&_text, (unsigned long)&_etext,
+		ktla_ktva((unsigned long)&_text), ktla_ktva((unsigned long)&_etext),
 		((unsigned long)&_etext - (unsigned long)&_text) >> 10);
 
 	/*
@@ -1007,6 +1012,7 @@ void set_kernel_text_rw(void)
 	if (!kernel_set_to_readonly)
 		return;
 
+	start = ktla_ktva(start);
 	pr_debug("Set kernel text: %lx - %lx for read write\n",
 		 start, start+size);
 
@@ -1021,6 +1027,7 @@ void set_kernel_text_ro(void)
 	if (!kernel_set_to_readonly)
 		return;
 
+	start = ktla_ktva(start);
 	pr_debug("Set kernel text: %lx - %lx for read only\n",
 		 start, start+size);
 
@@ -1032,6 +1039,7 @@ void mark_rodata_ro(void)
 	unsigned long start = PFN_ALIGN(_text);
 	unsigned long size = PFN_ALIGN(_etext) - start;
 
+	start = ktla_ktva(start);
 	set_pages_ro(virt_to_page(start), size >> PAGE_SHIFT);
 	printk(KERN_INFO "Write protecting the kernel text: %luk\n",
 		size >> 10);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/init_64.c linux-2.6.32.60-pax/arch/x86/mm/init_64.c
--- linux-2.6.32.60/arch/x86/mm/init_64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/init_64.c	2012-05-08 23:38:04.267923473 +0200
@@ -123,7 +123,7 @@ static pud_t *fill_pud(pgd_t *pgd, unsig
 {
 	if (pgd_none(*pgd)) {
 		pud_t *pud = (pud_t *)spp_getpage();
-		pgd_populate(&init_mm, pgd, pud);
+		pgd_populate_kernel(&init_mm, pgd, pud);
 		if (pud != pud_offset(pgd, 0))
 			printk(KERN_ERR "PAGETABLE BUG #00! %p <-> %p\n",
 			       pud, pud_offset(pgd, 0));
@@ -135,7 +135,7 @@ static pmd_t *fill_pmd(pud_t *pud, unsig
 {
 	if (pud_none(*pud)) {
 		pmd_t *pmd = (pmd_t *) spp_getpage();
-		pud_populate(&init_mm, pud, pmd);
+		pud_populate_kernel(&init_mm, pud, pmd);
 		if (pmd != pmd_offset(pud, 0))
 			printk(KERN_ERR "PAGETABLE BUG #01! %p <-> %p\n",
 			       pmd, pmd_offset(pud, 0));
@@ -164,7 +164,9 @@ void set_pte_vaddr_pud(pud_t *pud_page,
 	pmd = fill_pmd(pud, vaddr);
 	pte = fill_pte(pmd, vaddr);
 
+	pax_open_kernel();
 	set_pte(pte, new_pte);
+	pax_close_kernel();
 
 	/*
 	 * It's enough to flush this one mapping.
@@ -223,14 +225,12 @@ static void __init __init_extra_mapping(
 		pgd = pgd_offset_k((unsigned long)__va(phys));
 		if (pgd_none(*pgd)) {
 			pud = (pud_t *) spp_getpage();
-			set_pgd(pgd, __pgd(__pa(pud) | _KERNPG_TABLE |
-						_PAGE_USER));
+			set_pgd(pgd, __pgd(__pa(pud) | _PAGE_TABLE));
 		}
 		pud = pud_offset(pgd, (unsigned long)__va(phys));
 		if (pud_none(*pud)) {
 			pmd = (pmd_t *) spp_getpage();
-			set_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE |
-						_PAGE_USER));
+			set_pud(pud, __pud(__pa(pmd) | _PAGE_TABLE));
 		}
 		pmd = pmd_offset(pud, phys);
 		BUG_ON(!pmd_none(*pmd));
@@ -507,7 +507,7 @@ phys_pud_init(pud_t *pud_page, unsigned
 		unmap_low_page(pmd);
 
 		spin_lock(&init_mm.page_table_lock);
-		pud_populate(&init_mm, pud, __va(pmd_phys));
+		pud_populate_kernel(&init_mm, pud, __va(pmd_phys));
 		spin_unlock(&init_mm.page_table_lock);
 	}
 	__flush_tlb_all();
@@ -560,7 +560,7 @@ kernel_physical_mapping_init(unsigned lo
 		unmap_low_page(pud);
 
 		spin_lock(&init_mm.page_table_lock);
-		pgd_populate(&init_mm, pgd, __va(pud_phys));
+		pgd_populate_kernel(&init_mm, pgd, __va(pud_phys));
 		spin_unlock(&init_mm.page_table_lock);
 	}
 	__flush_tlb_all();
@@ -675,6 +675,12 @@ void __init mem_init(void)
 
 	pci_iommu_alloc();
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	clone_pgd_range(get_cpu_pgd(0) + KERNEL_PGD_BOUNDARY,
+			swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			KERNEL_PGD_PTRS);
+#endif
+
 	/* clear_bss() already clear the empty_zero_page */
 
 	reservedpages = 0;
@@ -861,8 +867,8 @@ int kern_addr_valid(unsigned long addr)
 static struct vm_area_struct gate_vma = {
 	.vm_start	= VSYSCALL_START,
 	.vm_end		= VSYSCALL_START + (VSYSCALL_MAPPED_PAGES * PAGE_SIZE),
-	.vm_page_prot	= PAGE_READONLY_EXEC,
-	.vm_flags	= VM_READ | VM_EXEC
+	.vm_page_prot	= PAGE_READONLY,
+	.vm_flags	= VM_READ
 };
 
 struct vm_area_struct *get_gate_vma(struct task_struct *tsk)
@@ -896,7 +902,7 @@ int in_gate_area_no_task(unsigned long a
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
+	if (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso)
 		return "[vdso]";
 	if (vma == &gate_vma)
 		return "[vsyscall]";
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/init.c linux-2.6.32.60-pax/arch/x86/mm/init.c
--- linux-2.6.32.60/arch/x86/mm/init.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/init.c	2012-10-28 23:24:45.130327560 +0100
@@ -69,11 +69,7 @@ static void __init find_early_table_spac
 	 * cause a hotspot and fill up ZONE_DMA. The page tables
 	 * need roughly 0.5KB per GB.
 	 */
-#ifdef CONFIG_X86_32
-	start = 0x7000;
-#else
-	start = 0x8000;
-#endif
+	start = 0x100000;
 	e820_table_start = find_e820_area(start, max_pfn_mapped<<PAGE_SHIFT,
 					tables, PAGE_SIZE);
 	if (e820_table_start == -1UL)
@@ -147,7 +143,7 @@ unsigned long __init_refok init_memory_m
 #endif
 
 	set_nx();
-	if (nx_enabled)
+	if (nx_enabled && cpu_has_nx)
 		printk(KERN_INFO "NX (Execute Disable) protection: active\n");
 
 	/* Enable PSE if available */
@@ -331,7 +327,13 @@ unsigned long __init_refok init_memory_m
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
-	if (pagenr <= 256)
+	if (!pagenr)
+		return 1;
+#ifdef CONFIG_VM86
+	if (pagenr < (ISA_START_ADDRESS >> PAGE_SHIFT))
+		return 1;
+#endif
+	if ((ISA_START_ADDRESS >> PAGE_SHIFT) <= pagenr && pagenr < (ISA_END_ADDRESS >> PAGE_SHIFT))
 		return 1;
 	if (iomem_is_exclusive(pagenr << PAGE_SHIFT))
 		return 0;
@@ -379,6 +381,87 @@ void free_init_pages(char *what, unsigne
 
 void free_initmem(void)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_X86_32
+	/* PaX: limit KERNEL_CS to actual size */
+	unsigned long addr, limit;
+	struct desc_struct d;
+	int cpu;
+
+	limit = paravirt_enabled() ? ktva_ktla(0xffffffff) : (unsigned long)&_etext;
+	limit = (limit - 1UL) >> PAGE_SHIFT;
+
+	memset(__LOAD_PHYSICAL_ADDR + PAGE_OFFSET, POISON_FREE_INITMEM, PAGE_SIZE);
+	for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
+		pack_descriptor(&d, get_desc_base(&get_cpu_gdt_table(cpu)[GDT_ENTRY_KERNEL_CS]), limit, 0x9B, 0xC);
+		write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_KERNEL_CS, &d, DESCTYPE_S);
+		write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_KERNEXEC_KERNEL_CS, &d, DESCTYPE_S);
+	}
+
+	/* PaX: make KERNEL_CS read-only */
+	addr = PFN_ALIGN(ktla_ktva((unsigned long)&_text));
+	if (!paravirt_enabled())
+		set_memory_ro(addr, (PFN_ALIGN(_sdata) - addr) >> PAGE_SHIFT);
+/*
+		for (addr = ktla_ktva((unsigned long)&_text); addr < (unsigned long)&_sdata; addr += PMD_SIZE) {
+			pgd = pgd_offset_k(addr);
+			pud = pud_offset(pgd, addr);
+			pmd = pmd_offset(pud, addr);
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+		}
+*/
+#ifdef CONFIG_X86_PAE
+	set_memory_nx(PFN_ALIGN(__init_begin), (PFN_ALIGN(__init_end) - PFN_ALIGN(__init_begin)) >> PAGE_SHIFT);
+/*
+	for (addr = (unsigned long)&__init_begin; addr < (unsigned long)&__init_end; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
+	}
+*/
+#endif
+
+#ifdef CONFIG_MODULES
+	set_memory_4k((unsigned long)MODULES_EXEC_VADDR, (MODULES_EXEC_END - MODULES_EXEC_VADDR) >> PAGE_SHIFT);
+#endif
+
+#else
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	unsigned long addr, end;
+
+	/* PaX: make kernel code/rodata read-only, rest non-executable */
+	for (addr = __START_KERNEL_map; addr < __START_KERNEL_map + KERNEL_IMAGE_SIZE; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		if (!pmd_present(*pmd))
+			continue;
+		if ((unsigned long)_text <= addr && addr < (unsigned long)_sdata)
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+		else
+			set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
+	}
+
+	addr = (unsigned long)__va(__pa(__START_KERNEL_map));
+	end = addr + KERNEL_IMAGE_SIZE;
+	for (; addr < end; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		if (!pmd_present(*pmd))
+			continue;
+		if ((unsigned long)__va(__pa(_text)) <= addr && addr < (unsigned long)__va(__pa(_sdata)))
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+	}
+#endif
+
+	flush_tlb_all();
+#endif
+
 	free_init_pages("unused kernel memory",
 			(unsigned long)(&__init_begin),
 			(unsigned long)(&__init_end));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/iomap_32.c linux-2.6.32.60-pax/arch/x86/mm/iomap_32.c
--- linux-2.6.32.60/arch/x86/mm/iomap_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/iomap_32.c	2012-03-13 13:15:34.620098017 +0100
@@ -65,7 +65,11 @@ void *kmap_atomic_prot_pfn(unsigned long
 	debug_kmap_atomic(type);
 	idx = type + KM_TYPE_NR * smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+
+	pax_open_kernel();
 	set_pte(kmap_pte - idx, pfn_pte(pfn, prot));
+	pax_close_kernel();
+
 	arch_flush_lazy_mmu_mode();
 
 	return (void *)vaddr;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/ioremap.c linux-2.6.32.60-pax/arch/x86/mm/ioremap.c
--- linux-2.6.32.60/arch/x86/mm/ioremap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/ioremap.c	2013-01-22 17:38:23.384543635 +0100
@@ -41,8 +41,8 @@ int page_is_ram(unsigned long pagenr)
 	 * Second special case: Some BIOSen report the PC BIOS
 	 * area (640->1Mb) as ram even though it is not.
 	 */
-	if (pagenr >= (BIOS_BEGIN >> PAGE_SHIFT) &&
-		    pagenr < (BIOS_END >> PAGE_SHIFT))
+	if (pagenr >= (ISA_START_ADDRESS >> PAGE_SHIFT) &&
+		    pagenr < (ISA_END_ADDRESS >> PAGE_SHIFT))
 		return 0;
 
 	for (i = 0; i < e820.nr_map; i++) {
@@ -137,13 +137,10 @@ static void __iomem *__ioremap_caller(re
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
 	 */
-	for (pfn = phys_addr >> PAGE_SHIFT;
-				(pfn << PAGE_SHIFT) < (last_addr & PAGE_MASK);
-				pfn++) {
-
+	for (pfn = phys_addr >> PAGE_SHIFT; ((resource_size_t)pfn << PAGE_SHIFT) < (last_addr & PAGE_MASK); pfn++) {
 		int is_ram = page_is_ram(pfn);
 
-		if (is_ram && pfn_valid(pfn) && !PageReserved(pfn_to_page(pfn)))
+		if (is_ram && pfn_valid(pfn) && (pfn >= 0x100 || !PageReserved(pfn_to_page(pfn))))
 			return NULL;
 		WARN_ON_ONCE(is_ram);
 	}
@@ -319,7 +316,7 @@ EXPORT_SYMBOL(ioremap_prot);
  *
  * Caller must ensure there is only one unmapping for the same pointer.
  */
-void iounmap(volatile void __iomem *addr)
+void iounmap(const volatile void __iomem *addr)
 {
 	struct vm_struct *p, *o;
 
@@ -378,6 +375,9 @@ void *xlate_dev_mem_ptr(unsigned long ph
 
 	/* If page is RAM, we can use __va. Otherwise ioremap and unmap. */
 	if (page_is_ram(start >> PAGE_SHIFT))
+#ifdef CONFIG_HIGHMEM
+	if ((start >> PAGE_SHIFT) < max_low_pfn)
+#endif
 		return __va(phys);
 
 	addr = (void __force *)ioremap_default(start, PAGE_SIZE);
@@ -407,7 +407,7 @@ static int __init early_ioremap_debug_se
 early_param("early_ioremap_debug", early_ioremap_debug_setup);
 
 static __initdata int after_paging_init;
-static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __page_aligned_bss;
+static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __read_only __aligned(PAGE_SIZE);
 
 static inline pmd_t * __init early_ioremap_pmd(unsigned long addr)
 {
@@ -439,8 +439,7 @@ void __init early_ioremap_init(void)
 		slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
 
 	pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
-	memset(bm_pte, 0, sizeof(bm_pte));
-	pmd_populate_kernel(&init_mm, pmd, bm_pte);
+	pmd_populate_user(&init_mm, pmd, bm_pte);
 
 	/*
 	 * The boot-ioremap range spans multiple pmds, for which
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/kmemcheck/kmemcheck.c linux-2.6.32.60-pax/arch/x86/mm/kmemcheck/kmemcheck.c
--- linux-2.6.32.60/arch/x86/mm/kmemcheck/kmemcheck.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/kmemcheck/kmemcheck.c	2012-03-13 13:15:34.620098017 +0100
@@ -622,9 +622,9 @@ bool kmemcheck_fault(struct pt_regs *reg
 	 * memory (e.g. tracked pages)? For now, we need this to avoid
 	 * invoking kmemcheck for PnP BIOS calls.
 	 */
-	if (regs->flags & X86_VM_MASK)
+	if (v8086_mode(regs))
 		return false;
-	if (regs->cs != __KERNEL_CS)
+	if (regs->cs != __KERNEL_CS && regs->cs != __KERNEXEC_KERNEL_CS)
 		return false;
 
 	pte = kmemcheck_pte_lookup(address);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/mmap.c linux-2.6.32.60-pax/arch/x86/mm/mmap.c
--- linux-2.6.32.60/arch/x86/mm/mmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/mmap.c	2012-03-13 13:15:34.624098017 +0100
@@ -49,7 +49,7 @@ static unsigned int stack_maxrandom_size
  * Leave an at least ~128 MB hole with possible stack randomization.
  */
 #define MIN_GAP (128*1024*1024UL + stack_maxrandom_size())
-#define MAX_GAP (TASK_SIZE/6*5)
+#define MAX_GAP (pax_task_size/6*5)
 
 /*
  * True on X86_32 or when emulating IA32 on X86_64
@@ -94,27 +94,40 @@ static unsigned long mmap_rnd(void)
 	return rnd << PAGE_SHIFT;
 }
 
-static unsigned long mmap_base(void)
+static unsigned long mmap_base(struct mm_struct *mm)
 {
 	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (gap < MIN_GAP)
 		gap = MIN_GAP;
 	else if (gap > MAX_GAP)
 		gap = MAX_GAP;
 
-	return PAGE_ALIGN(TASK_SIZE - gap - mmap_rnd());
+	return PAGE_ALIGN(pax_task_size - gap - mmap_rnd());
 }
 
 /*
  * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64
  * does, but not when emulating X86_32
  */
-static unsigned long mmap_legacy_base(void)
+static unsigned long mmap_legacy_base(struct mm_struct *mm)
 {
-	if (mmap_is_ia32())
+	if (mmap_is_ia32()) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mm->pax_flags & MF_PAX_SEGMEXEC)
+			return SEGMEXEC_TASK_UNMAPPED_BASE;
+		else
+#endif
+
 		return TASK_UNMAPPED_BASE;
-	else
+	} else
 		return TASK_UNMAPPED_BASE + mmap_rnd();
 }
 
@@ -125,11 +138,23 @@ static unsigned long mmap_legacy_base(vo
 void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	if (mmap_is_legacy()) {
-		mm->mmap_base = mmap_legacy_base();
+		mm->mmap_base = mmap_legacy_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
-		mm->mmap_base = mmap_base();
+		mm->mmap_base = mmap_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/mmio-mod.c linux-2.6.32.60-pax/arch/x86/mm/mmio-mod.c
--- linux-2.6.32.60/arch/x86/mm/mmio-mod.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/mmio-mod.c	2013-01-22 17:38:23.384543635 +0100
@@ -193,7 +193,7 @@ static void pre(struct kmmio_probe *p, s
 		break;
 	default:
 		{
-			unsigned char *ip = (unsigned char *)instptr;
+			unsigned char *ip = (unsigned char *)ktla_ktva(instptr);
 			my_trace->opcode = MMIO_UNKNOWN_OP;
 			my_trace->width = 0;
 			my_trace->value = (*ip) << 16 | *(ip + 1) << 8 |
@@ -233,7 +233,7 @@ static void post(struct kmmio_probe *p,
 static void ioremap_trace_core(resource_size_t offset, unsigned long size,
 							void __iomem *addr)
 {
-	static atomic_t next_id;
+	static atomic_unchecked_t next_id;
 	struct remap_trace *trace = kmalloc(sizeof(*trace), GFP_KERNEL);
 	/* These are page-unaligned. */
 	struct mmiotrace_map map = {
@@ -257,7 +257,7 @@ static void ioremap_trace_core(resource_
 			.private = trace
 		},
 		.phys = offset,
-		.id = atomic_inc_return(&next_id)
+		.id = atomic_inc_return_unchecked(&next_id)
 	};
 	map.map_id = trace->id;
 
@@ -289,7 +289,7 @@ void mmiotrace_ioremap(resource_size_t o
 	ioremap_trace_core(offset, size, addr);
 }
 
-static void iounmap_trace_core(volatile void __iomem *addr)
+static void iounmap_trace_core(const volatile void __iomem *addr)
 {
 	struct mmiotrace_map map = {
 		.phys = 0,
@@ -327,7 +327,7 @@ not_enabled:
 	}
 }
 
-void mmiotrace_iounmap(volatile void __iomem *addr)
+void mmiotrace_iounmap(const volatile void __iomem *addr)
 {
 	might_sleep();
 	if (is_enabled()) /* recheck and proper locking in *_core() */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/numa_32.c linux-2.6.32.60-pax/arch/x86/mm/numa_32.c
--- linux-2.6.32.60/arch/x86/mm/numa_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/numa_32.c	2012-03-13 13:15:34.624098017 +0100
@@ -98,7 +98,6 @@ unsigned long node_memmap_size_bytes(int
 }
 #endif
 
-extern unsigned long find_max_low_pfn(void);
 extern unsigned long highend_pfn, highstart_pfn;
 
 #define LARGE_PAGE_BYTES (PTRS_PER_PTE * PAGE_SIZE)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pageattr.c linux-2.6.32.60-pax/arch/x86/mm/pageattr.c
--- linux-2.6.32.60/arch/x86/mm/pageattr.c	2012-10-09 11:00:35.436882465 +0200
+++ linux-2.6.32.60-pax/arch/x86/mm/pageattr.c	2012-12-14 20:55:58.513778305 +0100
@@ -259,16 +259,17 @@ static inline pgprot_t static_protection
 	 * PCI BIOS based config access (CONFIG_PCI_GOBIOS) support.
 	 */
 	if (within(pfn, BIOS_BEGIN >> PAGE_SHIFT, BIOS_END >> PAGE_SHIFT))
-		pgprot_val(forbidden) |= _PAGE_NX;
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
 
 	/*
 	 * The kernel text needs to be executable for obvious reasons
 	 * Does not cover __inittext since that is gone later on. On
 	 * 64bit we do not enforce !NX on the low mapping
 	 */
-	if (within(address, (unsigned long)_text, (unsigned long)_etext))
-		pgprot_val(forbidden) |= _PAGE_NX;
+	if (within(address, ktla_ktva((unsigned long)_text), ktla_ktva((unsigned long)_etext)))
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
 
+#ifdef CONFIG_DEBUG_RODATA
 	/*
 	 * The .rodata section needs to be read-only. Using the pfn
 	 * catches all aliases.
@@ -276,6 +277,14 @@ static inline pgprot_t static_protection
 	if (within(pfn, __pa((unsigned long)__start_rodata) >> PAGE_SHIFT,
 		   __pa((unsigned long)__end_rodata) >> PAGE_SHIFT))
 		pgprot_val(forbidden) |= _PAGE_RW;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	if (within(pfn, __pa(ktla_ktva((unsigned long)&_text)), __pa((unsigned long)&_sdata))) {
+		pgprot_val(forbidden) |= _PAGE_RW;
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
+	}
+#endif
 
 	prot = __pgprot(pgprot_val(prot) & ~pgprot_val(forbidden));
 
@@ -329,23 +338,37 @@ EXPORT_SYMBOL_GPL(lookup_address);
 static void __set_pmd_pte(pte_t *kpte, unsigned long address, pte_t pte)
 {
 	/* change init_mm */
+	pax_open_kernel();
 	set_pte_atomic(kpte, pte);
+
 #ifdef CONFIG_X86_32
 	if (!SHARED_KERNEL_PMD) {
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		unsigned long cpu;
+#else
 		struct page *page;
+#endif
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		for (cpu = 0; cpu < nr_cpu_ids; ++cpu) {
+			pgd_t *pgd = get_cpu_pgd(cpu);
+#else
 		list_for_each_entry(page, &pgd_list, lru) {
-			pgd_t *pgd;
+			pgd_t *pgd = (pgd_t *)page_address(page);
+#endif
+
 			pud_t *pud;
 			pmd_t *pmd;
 
-			pgd = (pgd_t *)page_address(page) + pgd_index(address);
+			pgd += pgd_index(address);
 			pud = pud_offset(pgd, address);
 			pmd = pmd_offset(pud, address);
 			set_pte_atomic((pte_t *)pmd, pte);
 		}
 	}
 #endif
+	pax_close_kernel();
 }
 
 static int
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pageattr-test.c linux-2.6.32.60-pax/arch/x86/mm/pageattr-test.c
--- linux-2.6.32.60/arch/x86/mm/pageattr-test.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/pageattr-test.c	2012-03-13 13:15:34.848098005 +0100
@@ -36,7 +36,7 @@ enum {
 
 static int pte_testbit(pte_t pte)
 {
-	return pte_flags(pte) & _PAGE_UNUSED1;
+	return pte_flags(pte) & _PAGE_CPA_TEST;
 }
 
 struct split_state {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pat.c linux-2.6.32.60-pax/arch/x86/mm/pat.c
--- linux-2.6.32.60/arch/x86/mm/pat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/pat.c	2012-03-13 13:15:34.848098005 +0100
@@ -258,7 +258,7 @@ chk_conflict(struct memtype *new, struct
 
  conflict:
 	printk(KERN_INFO "%s:%d conflicting memory types "
-	       "%Lx-%Lx %s<->%s\n", current->comm, current->pid, new->start,
+	       "%Lx-%Lx %s<->%s\n", current->comm, task_pid_nr(current), new->start,
 	       new->end, cattr_name(new->type), cattr_name(entry->type));
 	return -EBUSY;
 }
@@ -559,7 +559,7 @@ unlock_ret:
 
 	if (err) {
 		printk(KERN_INFO "%s:%d freeing invalid memtype %Lx-%Lx\n",
-			current->comm, current->pid, start, end);
+			current->comm, task_pid_nr(current), start, end);
 	}
 
 	dprintk("free_memtype request 0x%Lx-0x%Lx\n", start, end);
@@ -689,8 +689,8 @@ static inline int range_is_allowed(unsig
 	while (cursor < to) {
 		if (!devmem_is_allowed(pfn)) {
 			printk(KERN_INFO
-		"Program %s tried to access /dev/mem between %Lx->%Lx.\n",
-				current->comm, from, to);
+		"Program %s tried to access /dev/mem between %Lx->%Lx (%Lx).\n",
+				current->comm, from, to, cursor);
 			return 0;
 		}
 		cursor += PAGE_SIZE;
@@ -755,7 +755,7 @@ int kernel_map_sync_memtype(u64 base, un
 		printk(KERN_INFO
 			"%s:%d ioremap_change_attr failed %s "
 			"for %Lx-%Lx\n",
-			current->comm, current->pid,
+			current->comm, task_pid_nr(current),
 			cattr_name(flags),
 			base, (unsigned long long)(base + size));
 		return -EINVAL;
@@ -813,7 +813,7 @@ static int reserve_pfn_range(u64 paddr,
 			free_memtype(paddr, paddr + size);
 			printk(KERN_ERR "%s:%d map pfn expected mapping type %s"
 				" for %Lx-%Lx, got %s\n",
-				current->comm, current->pid,
+				current->comm, task_pid_nr(current),
 				cattr_name(want_flags),
 				(unsigned long long)paddr,
 				(unsigned long long)(paddr + size),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pf_in.c linux-2.6.32.60-pax/arch/x86/mm/pf_in.c
--- linux-2.6.32.60/arch/x86/mm/pf_in.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/pf_in.c	2012-03-13 13:15:34.848098005 +0100
@@ -148,7 +148,7 @@ enum reason_type get_ins_type(unsigned l
 	int i;
 	enum reason_type rv = OTHERS;
 
-	p = (unsigned char *)ins_addr;
+	p = (unsigned char *)ktla_ktva(ins_addr);
 	p += skip_prefix(p, &prf);
 	p += get_opcode(p, &opcode);
 
@@ -168,7 +168,7 @@ static unsigned int get_ins_reg_width(un
 	struct prefix_bits prf;
 	int i;
 
-	p = (unsigned char *)ins_addr;
+	p = (unsigned char *)ktla_ktva(ins_addr);
 	p += skip_prefix(p, &prf);
 	p += get_opcode(p, &opcode);
 
@@ -191,7 +191,7 @@ unsigned int get_ins_mem_width(unsigned
 	struct prefix_bits prf;
 	int i;
 
-	p = (unsigned char *)ins_addr;
+	p = (unsigned char *)ktla_ktva(ins_addr);
 	p += skip_prefix(p, &prf);
 	p += get_opcode(p, &opcode);
 
@@ -417,7 +417,7 @@ unsigned long get_ins_reg_val(unsigned l
 	int i;
 	unsigned long rv;
 
-	p = (unsigned char *)ins_addr;
+	p = (unsigned char *)ktla_ktva(ins_addr);
 	p += skip_prefix(p, &prf);
 	p += get_opcode(p, &opcode);
 	for (i = 0; i < ARRAY_SIZE(reg_rop); i++)
@@ -472,7 +472,7 @@ unsigned long get_ins_imm_val(unsigned l
 	int i;
 	unsigned long rv;
 
-	p = (unsigned char *)ins_addr;
+	p = (unsigned char *)ktla_ktva(ins_addr);
 	p += skip_prefix(p, &prf);
 	p += get_opcode(p, &opcode);
 	for (i = 0; i < ARRAY_SIZE(imm_wop); i++)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pgtable_32.c linux-2.6.32.60-pax/arch/x86/mm/pgtable_32.c
--- linux-2.6.32.60/arch/x86/mm/pgtable_32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/pgtable_32.c	2012-03-13 13:15:34.852098005 +0100
@@ -49,10 +49,13 @@ void set_pte_vaddr(unsigned long vaddr,
 		return;
 	}
 	pte = pte_offset_kernel(pmd, vaddr);
+
+	pax_open_kernel();
 	if (pte_val(pteval))
 		set_pte_at(&init_mm, vaddr, pte, pteval);
 	else
 		pte_clear(&init_mm, vaddr, pte);
+	pax_close_kernel();
 
 	/*
 	 * It's enough to flush this one mapping.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/pgtable.c linux-2.6.32.60-pax/arch/x86/mm/pgtable.c
--- linux-2.6.32.60/arch/x86/mm/pgtable.c	2012-10-09 11:00:35.436882465 +0200
+++ linux-2.6.32.60-pax/arch/x86/mm/pgtable.c	2012-10-09 11:07:58.836942943 +0200
@@ -83,9 +83,64 @@ static inline void pgd_list_del(pgd_t *p
 	list_del(&page->lru);
 }
 
-#define UNSHARED_PTRS_PER_PGD				\
-	(SHARED_KERNEL_PMD ? KERNEL_PGD_BOUNDARY : PTRS_PER_PGD)
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+pgdval_t clone_pgd_mask __read_only = ~_PAGE_PRESENT;
 
+void __shadow_user_pgds(pgd_t *dst, const pgd_t *src)
+{
+	unsigned int count = USER_PGD_PTRS;
+
+	while (count--)
+		*dst++ = __pgd((pgd_val(*src++) | (_PAGE_NX & __supported_pte_mask)) & ~_PAGE_USER);
+}
+#endif
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+void __clone_user_pgds(pgd_t *dst, const pgd_t *src)
+{
+	unsigned int count = USER_PGD_PTRS;
+
+	while (count--) {
+		pgd_t pgd;
+
+#ifdef CONFIG_X86_64
+		pgd = __pgd(pgd_val(*src++) | _PAGE_USER);
+#else
+		pgd = *src++;
+#endif
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+		pgd = __pgd(pgd_val(pgd) & clone_pgd_mask);
+#endif
+
+		*dst++ = pgd;
+	}
+
+}
+#endif
+
+#ifdef CONFIG_X86_64
+#define pxd_t				pud_t
+#define pyd_t				pgd_t
+#define paravirt_release_pxd(pfn)	paravirt_release_pud(pfn)
+#define pxd_free(mm, pud)		pud_free((mm), (pud))
+#define pyd_populate(mm, pgd, pud)	pgd_populate((mm), (pgd), (pud))
+#define pyd_offset(mm, address)		pgd_offset((mm), (address))
+#define PYD_SIZE			PGDIR_SIZE
+#else
+#define pxd_t				pmd_t
+#define pyd_t				pud_t
+#define paravirt_release_pxd(pfn)	paravirt_release_pmd(pfn)
+#define pxd_free(mm, pud)		pmd_free((mm), (pud))
+#define pyd_populate(mm, pgd, pud)	pud_populate((mm), (pgd), (pud))
+#define pyd_offset(mm, address)		pud_offset((mm), (address))
+#define PYD_SIZE			PUD_SIZE
+#endif
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+static inline void pgd_ctor(pgd_t *pgd) {}
+static inline void pgd_dtor(pgd_t *pgd) {}
+#else
 static void pgd_ctor(pgd_t *pgd)
 {
 	/* If the pgd points to a shared pagetable level (either the
@@ -117,6 +172,7 @@ static void pgd_dtor(pgd_t *pgd)
 	pgd_list_del(pgd);
 	spin_unlock(&pgd_lock);
 }
+#endif
 
 /*
  * List of all pgd's needed for non-PAE so it can invalidate entries
@@ -129,7 +185,7 @@ static void pgd_dtor(pgd_t *pgd)
  * -- wli
  */
 
-#ifdef CONFIG_X86_PAE
+#if defined(CONFIG_X86_32) && defined(CONFIG_X86_PAE)
 /*
  * In PAE mode, we need to do a cr3 reload (=tlb flush) when
  * updating the top-level pagetable entries to guarantee the
@@ -141,7 +197,7 @@ static void pgd_dtor(pgd_t *pgd)
  * not shared between pagetables (!SHARED_KERNEL_PMDS), we allocate
  * and initialize the kernel pmds here.
  */
-#define PREALLOCATED_PMDS	UNSHARED_PTRS_PER_PGD
+#define PREALLOCATED_PXDS	(SHARED_KERNEL_PMD ? KERNEL_PGD_BOUNDARY : PTRS_PER_PGD)
 
 void pud_populate(struct mm_struct *mm, pud_t *pudp, pmd_t *pmd)
 {
@@ -159,36 +215,38 @@ void pud_populate(struct mm_struct *mm,
 	 */
 	flush_tlb_mm(mm);
 }
+#elif defined(CONFIG_X86_64) && defined(CONFIG_PAX_PER_CPU_PGD)
+#define PREALLOCATED_PXDS	USER_PGD_PTRS
 #else  /* !CONFIG_X86_PAE */
 
 /* No need to prepopulate any pagetable entries in non-PAE modes. */
-#define PREALLOCATED_PMDS	0
+#define PREALLOCATED_PXDS	0
 
 #endif	/* CONFIG_X86_PAE */
 
-static void free_pmds(pmd_t *pmds[])
+static void free_pxds(pxd_t *pxds[])
 {
 	int i;
 
-	for(i = 0; i < PREALLOCATED_PMDS; i++)
-		if (pmds[i])
-			free_page((unsigned long)pmds[i]);
+	for(i = 0; i < PREALLOCATED_PXDS; i++)
+		if (pxds[i])
+			free_page((unsigned long)pxds[i]);
 }
 
-static int preallocate_pmds(pmd_t *pmds[])
+static int preallocate_pxds(pxd_t *pxds[])
 {
 	int i;
 	bool failed = false;
 
-	for(i = 0; i < PREALLOCATED_PMDS; i++) {
-		pmd_t *pmd = (pmd_t *)__get_free_page(PGALLOC_GFP);
-		if (pmd == NULL)
+	for(i = 0; i < PREALLOCATED_PXDS; i++) {
+		pxd_t *pxd = (pxd_t *)__get_free_page(PGALLOC_GFP);
+		if (pxd == NULL)
 			failed = true;
-		pmds[i] = pmd;
+		pxds[i] = pxd;
 	}
 
 	if (failed) {
-		free_pmds(pmds);
+		free_pxds(pxds);
 		return -ENOMEM;
 	}
 
@@ -201,51 +259,55 @@ static int preallocate_pmds(pmd_t *pmds[
  * preallocate which never got a corresponding vma will need to be
  * freed manually.
  */
-static void pgd_mop_up_pmds(struct mm_struct *mm, pgd_t *pgdp)
+static void pgd_mop_up_pxds(struct mm_struct *mm, pgd_t *pgdp)
 {
 	int i;
 
-	for(i = 0; i < PREALLOCATED_PMDS; i++) {
+	for(i = 0; i < PREALLOCATED_PXDS; i++) {
 		pgd_t pgd = pgdp[i];
 
 		if (pgd_val(pgd) != 0) {
-			pmd_t *pmd = (pmd_t *)pgd_page_vaddr(pgd);
+			pxd_t *pxd = (pxd_t *)pgd_page_vaddr(pgd);
 
-			pgdp[i] = native_make_pgd(0);
+			set_pgd(pgdp + i, native_make_pgd(0));
 
-			paravirt_release_pmd(pgd_val(pgd) >> PAGE_SHIFT);
-			pmd_free(mm, pmd);
+			paravirt_release_pxd(pgd_val(pgd) >> PAGE_SHIFT);
+			pxd_free(mm, pxd);
 		}
 	}
 }
 
-static void pgd_prepopulate_pmd(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmds[])
+static void pgd_prepopulate_pxd(struct mm_struct *mm, pgd_t *pgd, pxd_t *pxds[])
 {
-	pud_t *pud;
+	pyd_t *pyd;
 	unsigned long addr;
 	int i;
 
-	if (PREALLOCATED_PMDS == 0) /* Work around gcc-3.4.x bug */
+	if (PREALLOCATED_PXDS == 0) /* Work around gcc-3.4.x bug */
 		return;
 
-	pud = pud_offset(pgd, 0);
-
- 	for (addr = i = 0; i < PREALLOCATED_PMDS;
-	     i++, pud++, addr += PUD_SIZE) {
-		pmd_t *pmd = pmds[i];
+#ifdef CONFIG_X86_64
+	pyd = pyd_offset(mm, 0L);
+#else
+	pyd = pyd_offset(pgd, 0L);
+#endif
+
+ 	for (addr = i = 0; i < PREALLOCATED_PXDS;
+	     i++, pyd++, addr += PYD_SIZE) {
+		pxd_t *pxd = pxds[i];
 
 		if (i >= KERNEL_PGD_BOUNDARY)
-			memcpy(pmd, (pmd_t *)pgd_page_vaddr(swapper_pg_dir[i]),
-			       sizeof(pmd_t) * PTRS_PER_PMD);
+			memcpy(pxd, (pxd_t *)pgd_page_vaddr(swapper_pg_dir[i]),
+			       sizeof(pxd_t) * PTRS_PER_PMD);
 
-		pud_populate(mm, pud, pmd);
+		pyd_populate(mm, pyd, pxd);
 	}
 }
 
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	pgd_t *pgd;
-	pmd_t *pmds[PREALLOCATED_PMDS];
+	pxd_t *pxds[PREALLOCATED_PXDS];
 
 	pgd = (pgd_t *)__get_free_page(PGALLOC_GFP);
 
@@ -254,11 +316,11 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 
 	mm->pgd = pgd;
 
-	if (preallocate_pmds(pmds) != 0)
+	if (preallocate_pxds(pxds) != 0)
 		goto out_free_pgd;
 
 	if (paravirt_pgd_alloc(mm) != 0)
-		goto out_free_pmds;
+		goto out_free_pxds;
 
 	/*
 	 * Make sure that pre-populating the pmds is atomic with
@@ -268,14 +330,14 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 	spin_lock(&pgd_lock);
 
 	pgd_ctor(pgd);
-	pgd_prepopulate_pmd(mm, pgd, pmds);
+	pgd_prepopulate_pxd(mm, pgd, pxds);
 
 	spin_unlock(&pgd_lock);
 
 	return pgd;
 
-out_free_pmds:
-	free_pmds(pmds);
+out_free_pxds:
+	free_pxds(pxds);
 out_free_pgd:
 	free_page((unsigned long)pgd);
 out:
@@ -284,7 +346,7 @@ out:
 
 void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
-	pgd_mop_up_pmds(mm, pgd);
+	pgd_mop_up_pxds(mm, pgd);
 	pgd_dtor(pgd);
 	paravirt_pgd_free(mm, pgd);
 	free_page((unsigned long)pgd);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/setup_nx.c linux-2.6.32.60-pax/arch/x86/mm/setup_nx.c
--- linux-2.6.32.60/arch/x86/mm/setup_nx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/setup_nx.c	2012-03-13 13:15:34.852098005 +0100
@@ -4,11 +4,10 @@
 
 #include <asm/pgtable.h>
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_X86_PAE)
 int nx_enabled;
 
-#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
-static int disable_nx __cpuinitdata;
-
+#ifndef CONFIG_PAX_PAGEEXEC
 /*
  * noexec = on|off
  *
@@ -22,32 +21,26 @@ static int __init noexec_setup(char *str
 	if (!str)
 		return -EINVAL;
 	if (!strncmp(str, "on", 2)) {
-		__supported_pte_mask |= _PAGE_NX;
-		disable_nx = 0;
+		nx_enabled = 1;
 	} else if (!strncmp(str, "off", 3)) {
-		disable_nx = 1;
-		__supported_pte_mask &= ~_PAGE_NX;
+		nx_enabled = 0;
 	}
 	return 0;
 }
 early_param("noexec", noexec_setup);
 #endif
+#endif
 
 #ifdef CONFIG_X86_PAE
 void __init set_nx(void)
 {
-	unsigned int v[4], l, h;
+	if (!nx_enabled && cpu_has_nx) {
+		unsigned l, h;
 
-	if (cpu_has_pae && (cpuid_eax(0x80000000) > 0x80000001)) {
-		cpuid(0x80000001, &v[0], &v[1], &v[2], &v[3]);
-
-		if ((v[3] & (1 << 20)) && !disable_nx) {
-			rdmsr(MSR_EFER, l, h);
-			l |= EFER_NX;
-			wrmsr(MSR_EFER, l, h);
-			nx_enabled = 1;
-			__supported_pte_mask |= _PAGE_NX;
-		}
+		__supported_pte_mask &= ~_PAGE_NX;
+		rdmsr(MSR_EFER, l, h);
+		l &= ~EFER_NX;
+		wrmsr(MSR_EFER, l, h);
 	}
 }
 #else
@@ -62,7 +55,7 @@ void __cpuinit check_efer(void)
 	unsigned long efer;
 
 	rdmsrl(MSR_EFER, efer);
-	if (!(efer & EFER_NX) || disable_nx)
+	if (!(efer & EFER_NX) || !nx_enabled)
 		__supported_pte_mask &= ~_PAGE_NX;
 }
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/mm/tlb.c linux-2.6.32.60-pax/arch/x86/mm/tlb.c
--- linux-2.6.32.60/arch/x86/mm/tlb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/mm/tlb.c	2012-03-13 13:15:34.852098005 +0100
@@ -61,7 +61,11 @@ void leave_mm(int cpu)
 		BUG();
 	cpumask_clear_cpu(cpu,
 			  mm_cpumask(percpu_read(cpu_tlbstate.active_mm)));
+
+#ifndef CONFIG_PAX_PER_CPU_PGD
 	load_cr3(swapper_pg_dir);
+#endif
+
 }
 EXPORT_SYMBOL_GPL(leave_mm);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/oprofile/backtrace.c linux-2.6.32.60-pax/arch/x86/oprofile/backtrace.c
--- linux-2.6.32.60/arch/x86/oprofile/backtrace.c	2012-10-09 11:00:35.436882465 +0200
+++ linux-2.6.32.60-pax/arch/x86/oprofile/backtrace.c	2012-10-09 11:00:39.272883032 +0200
@@ -115,7 +115,7 @@ x86_backtrace(struct pt_regs * const reg
 {
 	struct frame_head *head = (struct frame_head *)frame_pointer(regs);
 
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		unsigned long stack = kernel_stack_pointer(regs);
 		if (depth)
 			dump_trace(NULL, regs, (unsigned long *)stack, 0,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/oprofile/op_model_p4.c linux-2.6.32.60-pax/arch/x86/oprofile/op_model_p4.c
--- linux-2.6.32.60/arch/x86/oprofile/op_model_p4.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/oprofile/op_model_p4.c	2012-03-13 13:15:34.856098005 +0100
@@ -50,7 +50,7 @@ static inline void setup_num_counters(vo
 #endif
 }
 
-static int inline addr_increment(void)
+static inline int addr_increment(void)
 {
 #ifdef CONFIG_SMP
 	return smp_num_siblings == 2 ? 2 : 1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/pci/mmconfig-shared.c linux-2.6.32.60-pax/arch/x86/pci/mmconfig-shared.c
--- linux-2.6.32.60/arch/x86/pci/mmconfig-shared.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/pci/mmconfig-shared.c	2013-02-17 17:45:09.700075535 +0100
@@ -340,8 +340,7 @@ static void __init pci_mmcfg_insert_reso
 	char *names;
 	unsigned num_buses;
 
-	res = kcalloc(PCI_MMCFG_RESOURCE_NAME_LEN + sizeof(*res),
-			pci_mmcfg_config_num, GFP_KERNEL);
+	res = kcalloc(pci_mmcfg_config_num, PCI_MMCFG_RESOURCE_NAME_LEN + sizeof(*res), GFP_KERNEL);
 	if (!res) {
 		printk(KERN_ERR "PCI: Unable to allocate MMCONFIG resources\n");
 		return;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/pci/pcbios.c linux-2.6.32.60-pax/arch/x86/pci/pcbios.c
--- linux-2.6.32.60/arch/x86/pci/pcbios.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/pci/pcbios.c	2012-03-13 13:15:34.856098005 +0100
@@ -56,50 +56,93 @@ union bios32 {
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} bios32_indirect = { 0, __KERNEL_CS };
+} bios32_indirect __read_only = { 0, __PCIBIOS_CS };
 
 /*
  * Returns the entry point for the given service, NULL on error
  */
 
-static unsigned long bios32_service(unsigned long service)
+static unsigned long __devinit bios32_service(unsigned long service)
 {
 	unsigned char return_code;	/* %al */
 	unsigned long address;		/* %ebx */
 	unsigned long length;		/* %ecx */
 	unsigned long entry;		/* %edx */
 	unsigned long flags;
+	struct desc_struct d, *gdt;
 
 	local_irq_save(flags);
-	__asm__("lcall *(%%edi); cld"
+
+	gdt = get_cpu_gdt_table(smp_processor_id());
+
+	pack_descriptor(&d, 0UL, 0xFFFFFUL, 0x9B, 0xC);
+	write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_CS, &d, DESCTYPE_S);
+	pack_descriptor(&d, 0UL, 0xFFFFFUL, 0x93, 0xC);
+	write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_DS, &d, DESCTYPE_S);
+
+	__asm__("movw %w7, %%ds; lcall *(%%edi); push %%ss; pop %%ds; cld"
 		: "=a" (return_code),
 		  "=b" (address),
 		  "=c" (length),
 		  "=d" (entry)
 		: "0" (service),
 		  "1" (0),
-		  "D" (&bios32_indirect));
+		  "D" (&bios32_indirect),
+		  "r"(__PCIBIOS_DS)
+		: "memory");
+
+	pax_open_kernel();
+	gdt[GDT_ENTRY_PCIBIOS_CS].a = 0;
+	gdt[GDT_ENTRY_PCIBIOS_CS].b = 0;
+	gdt[GDT_ENTRY_PCIBIOS_DS].a = 0;
+	gdt[GDT_ENTRY_PCIBIOS_DS].b = 0;
+	pax_close_kernel();
+
 	local_irq_restore(flags);
 
 	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
-				service, return_code);
+	case 0: {
+		int cpu;
+		unsigned char flags;
+
+		printk(KERN_INFO "bios32_service: base:%08lx length:%08lx entry:%08lx\n", address, length, entry);
+		if (address >= 0xFFFF0 || length > 0x100000 - address || length <= entry) {
+			printk(KERN_WARNING "bios32_service: not valid\n");
 			return 0;
+		}
+		address = address + PAGE_OFFSET;
+		length += 16UL; /* some BIOSs underreport this... */
+		flags = 4;
+		if (length >= 64*1024*1024) {
+			length >>= PAGE_SHIFT;
+			flags |= 8;
+		}
+
+		for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
+			gdt = get_cpu_gdt_table(cpu);
+			pack_descriptor(&d, address, length, 0x9b, flags);
+			write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_CS, &d, DESCTYPE_S);
+			pack_descriptor(&d, address, length, 0x93, flags);
+			write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_DS, &d, DESCTYPE_S);
+		}
+		return entry;
+	}
+	case 0x80:	/* Not present */
+		printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
+		return 0;
+	default: /* Shouldn't happen */
+		printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
+			service, return_code);
+		return 0;
 	}
 }
 
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} pci_indirect = { 0, __KERNEL_CS };
+} pci_indirect __read_only = { 0, __PCIBIOS_CS };
 
-static int pci_bios_present;
+static int pci_bios_present __read_only;
 
 static int __devinit check_pcibios(void)
 {
@@ -108,11 +151,13 @@ static int __devinit check_pcibios(void)
 	unsigned long flags, pcibios_entry;
 
 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry + PAGE_OFFSET;
+		pci_indirect.address = pcibios_entry;
 
 		local_irq_save(flags);
-		__asm__(
-			"lcall *(%%edi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%edi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -121,7 +166,8 @@ static int __devinit check_pcibios(void)
 			  "=b" (ebx),
 			  "=c" (ecx)
 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
+			  "D" (&pci_indirect),
+			  "r" (__PCIBIOS_DS)
 			: "memory");
 		local_irq_restore(flags);
 
@@ -165,7 +211,10 @@ static int pci_bios_read(unsigned int se
 
 	switch (len) {
 	case 1:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -174,7 +223,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_BYTE),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		/*
 		 * Zero-extend the result beyond 8 bits, do not trust the
 		 * BIOS having done it:
@@ -182,7 +232,10 @@ static int pci_bios_read(unsigned int se
 		*value &= 0xff;
 		break;
 	case 2:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -191,7 +244,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_WORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		/*
 		 * Zero-extend the result beyond 16 bits, do not trust the
 		 * BIOS having done it:
@@ -199,7 +253,10 @@ static int pci_bios_read(unsigned int se
 		*value &= 0xffff;
 		break;
 	case 4:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -208,7 +265,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_DWORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -231,7 +289,10 @@ static int pci_bios_write(unsigned int s
 
 	switch (len) {
 	case 1:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -240,10 +301,14 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -252,10 +317,14 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -264,7 +333,8 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -368,10 +438,13 @@ struct irq_routing_table * pcibios_get_i
 
 	DBG("PCI: Fetching IRQ routing table... ");
 	__asm__("push %%es\n\t"
+		"movw %w8, %%ds\n\t"
 		"push %%ds\n\t"
 		"pop  %%es\n\t"
-		"lcall *(%%esi); cld\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
 		"pop %%es\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -382,7 +455,8 @@ struct irq_routing_table * pcibios_get_i
 		  "1" (0),
 		  "D" ((long) &opt),
 		  "S" (&pci_indirect),
-		  "m" (opt)
+		  "m" (opt),
+		  "r" (__PCIBIOS_DS)
 		: "memory");
 	DBG("OK  ret=%d, size=%d, map=%x\n", ret, opt.size, map);
 	if (ret & 0xff00)
@@ -406,7 +480,10 @@ int pcibios_set_irq_routing(struct pci_d
 {
 	int ret;
 
-	__asm__("lcall *(%%esi); cld\n\t"
+	__asm__("movw %w5, %%ds\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -414,7 +491,8 @@ int pcibios_set_irq_routing(struct pci_d
 		: "0" (PCIBIOS_SET_PCI_HW_INT),
 		  "b" ((dev->bus->number << 8) | dev->devfn),
 		  "c" ((irq << 8) | (pin + 10)),
-		  "S" (&pci_indirect));
+		  "S" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	return !(ret & 0xff00);
 }
 EXPORT_SYMBOL(pcibios_set_irq_routing);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/power/cpu.c linux-2.6.32.60-pax/arch/x86/power/cpu.c
--- linux-2.6.32.60/arch/x86/power/cpu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/power/cpu.c	2012-12-05 00:25:34.799667519 +0100
@@ -129,7 +129,7 @@ static void do_fpu_end(void)
 static void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
 
 	set_tss_desc(cpu, t);	/*
 				 * This just modifies memory; should not be
@@ -139,8 +139,6 @@ static void fix_processor_context(void)
 				 */
 
 #ifdef CONFIG_X86_64
-	get_cpu_gdt_table(cpu)[GDT_ENTRY_TSS].type = 9;
-
 	syscall_init();				/* This sets MSR_*STAR and related */
 #endif
 	load_TR_desc();				/* This does ltr */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/Makefile linux-2.6.32.60-pax/arch/x86/vdso/Makefile
--- linux-2.6.32.60/arch/x86/vdso/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/Makefile	2012-03-13 13:15:34.856098005 +0100
@@ -122,7 +122,7 @@ quiet_cmd_vdso = VDSO    $@
 		       $(VDSO_LDFLAGS) $(VDSO_LDFLAGS_$(filter %.lds,$(^F))) \
 		       -Wl,-T,$(filter %.lds,$^) $(filter %.o,$^)
 
-VDSO_LDFLAGS = -fPIC -shared $(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
+VDSO_LDFLAGS = -fPIC -shared -Wl,--no-undefined $(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 GCOV_PROFILE := n
 
 #
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/vclock_gettime.c linux-2.6.32.60-pax/arch/x86/vdso/vclock_gettime.c
--- linux-2.6.32.60/arch/x86/vdso/vclock_gettime.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/vclock_gettime.c	2012-03-13 13:15:34.856098005 +0100
@@ -22,24 +22,48 @@
 #include <asm/hpet.h>
 #include <asm/unistd.h>
 #include <asm/io.h>
+#include <asm/fixmap.h>
 #include "vextern.h"
 
 #define gtod vdso_vsyscall_gtod_data
 
+notrace noinline long __vdso_fallback_time(long *t)
+{
+	long secs;
+	asm volatile("syscall"
+		: "=a" (secs)
+		: "0" (__NR_time),"D" (t) : "r11", "cx", "memory");
+	return secs;
+}
+
 notrace static long vdso_fallback_gettime(long clock, struct timespec *ts)
 {
 	long ret;
 	asm("syscall" : "=a" (ret) :
-	    "0" (__NR_clock_gettime),"D" (clock), "S" (ts) : "memory");
+	    "0" (__NR_clock_gettime),"D" (clock), "S" (ts) : "r11", "cx", "memory");
 	return ret;
 }
 
+notrace static inline cycle_t __vdso_vread_hpet(void)
+{
+	return readl((const void __iomem *)fix_to_virt(VSYSCALL_HPET) + 0xf0);
+}
+
+notrace static inline cycle_t __vdso_vread_tsc(void)
+{
+	cycle_t ret = (cycle_t)vget_cycles();
+
+	return ret >= gtod->clock.cycle_last ? ret : gtod->clock.cycle_last;
+}
+
 notrace static inline long vgetns(void)
 {
 	long v;
-	cycles_t (*vread)(void);
-	vread = gtod->clock.vread;
-	v = (vread() - gtod->clock.cycle_last) & gtod->clock.mask;
+	if (gtod->clock.name[0] == 't' && gtod->clock.name[1] == 's' && gtod->clock.name[2] == 'c' && !gtod->clock.name[3])
+		v = __vdso_vread_tsc();
+	else
+		v = __vdso_vread_hpet();
+	v = (v - gtod->clock.cycle_last) & gtod->clock.mask;
 	return (v * gtod->clock.mult) >> gtod->clock.shift;
 }
 
@@ -113,7 +137,9 @@ notrace static noinline int do_monotonic
 
 notrace int __vdso_clock_gettime(clockid_t clock, struct timespec *ts)
 {
-	if (likely(gtod->sysctl_enabled))
+	if (likely(gtod->sysctl_enabled &&
+		   ((gtod->clock.name[0] == 'h' && gtod->clock.name[1] == 'p' && gtod->clock.name[2] == 'e' && gtod->clock.name[3] == 't' && !gtod->clock.name[4]) ||
+		    (gtod->clock.name[0] == 't' && gtod->clock.name[1] == 's' && gtod->clock.name[2] == 'c' && !gtod->clock.name[3]))))
 		switch (clock) {
 		case CLOCK_REALTIME:
 			if (likely(gtod->clock.vread))
@@ -133,10 +159,20 @@ notrace int __vdso_clock_gettime(clockid
 int clock_gettime(clockid_t, struct timespec *)
 	__attribute__((weak, alias("__vdso_clock_gettime")));
 
-notrace int __vdso_gettimeofday(struct timeval *tv, struct timezone *tz)
+notrace noinline int __vdso_fallback_gettimeofday(struct timeval *tv, struct timezone *tz)
 {
 	long ret;
-	if (likely(gtod->sysctl_enabled && gtod->clock.vread)) {
+	asm("syscall" : "=a" (ret) :
+	    "0" (__NR_gettimeofday), "D" (tv), "S" (tz) : "r11", "cx", "memory");
+	return ret;
+}
+
+notrace int __vdso_gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+	if (likely(gtod->sysctl_enabled &&
+		   ((gtod->clock.name[0] == 'h' && gtod->clock.name[1] == 'p' && gtod->clock.name[2] == 'e' && gtod->clock.name[3] == 't' && !gtod->clock.name[4]) ||
+		    (gtod->clock.name[0] == 't' && gtod->clock.name[1] == 's' && gtod->clock.name[2] == 'c' && !gtod->clock.name[3]))))
+	{
 		if (likely(tv != NULL)) {
 			BUILD_BUG_ON(offsetof(struct timeval, tv_usec) !=
 				     offsetof(struct timespec, tv_nsec) ||
@@ -151,9 +187,7 @@ notrace int __vdso_gettimeofday(struct t
 		}
 		return 0;
 	}
-	asm("syscall" : "=a" (ret) :
-	    "0" (__NR_gettimeofday), "D" (tv), "S" (tz) : "memory");
-	return ret;
+	return __vdso_fallback_gettimeofday(tv, tz);
 }
 int gettimeofday(struct timeval *, struct timezone *)
 	__attribute__((weak, alias("__vdso_gettimeofday")));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/vdso32-setup.c linux-2.6.32.60-pax/arch/x86/vdso/vdso32-setup.c
--- linux-2.6.32.60/arch/x86/vdso/vdso32-setup.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/vdso32-setup.c	2012-03-13 13:15:34.860098005 +0100
@@ -25,6 +25,7 @@
 #include <asm/tlbflush.h>
 #include <asm/vdso.h>
 #include <asm/proto.h>
+#include <asm/mman.h>
 
 enum {
 	VDSO_DISABLED = 0,
@@ -226,7 +227,7 @@ static inline void map_compat_vdso(int m
 void enable_sep_cpu(void)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	if (!boot_cpu_has(X86_FEATURE_SEP)) {
 		put_cpu();
@@ -249,7 +250,7 @@ static int __init gate_vma_init(void)
 	gate_vma.vm_start = FIXADDR_USER_START;
 	gate_vma.vm_end = FIXADDR_USER_END;
 	gate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;
-	gate_vma.vm_page_prot = __P101;
+	gate_vma.vm_page_prot = vm_get_page_prot(gate_vma.vm_flags);
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
@@ -331,14 +332,14 @@ int arch_setup_additional_pages(struct l
 	if (compat)
 		addr = VDSO_HIGH_BASE;
 	else {
-		addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
+		addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, MAP_EXECUTABLE);
 		if (IS_ERR_VALUE(addr)) {
 			ret = addr;
 			goto up_fail;
 		}
 	}
 
-	current->mm->context.vdso = (void *)addr;
+	current->mm->context.vdso = addr;
 
 	if (compat_uses_vma || !compat) {
 		/*
@@ -361,11 +362,11 @@ int arch_setup_additional_pages(struct l
 	}
 
 	current_thread_info()->sysenter_return =
-		VDSO32_SYMBOL(addr, SYSENTER_RETURN);
+		(__force void __user *)VDSO32_SYMBOL(addr, SYSENTER_RETURN);
 
   up_fail:
 	if (ret)
-		current->mm->context.vdso = NULL;
+		current->mm->context.vdso = 0;
 
 	up_write(&mm->mmap_sem);
 
@@ -413,8 +414,14 @@ __initcall(ia32_binfmt_init);
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
+	if (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso)
 		return "[vdso]";
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_mm && vma->vm_mirror && vma->vm_mirror->vm_start == vma->vm_mm->context.vdso)
+		return "[vdso]";
+#endif
+
 	return NULL;
 }
 
@@ -423,7 +430,7 @@ struct vm_area_struct *get_gate_vma(stru
 	struct mm_struct *mm = tsk->mm;
 
 	/* Check to see if this task was created in compat vdso mode */
-	if (mm && mm->context.vdso == (void *)VDSO_HIGH_BASE)
+	if (mm && mm->context.vdso == VDSO_HIGH_BASE)
 		return &gate_vma;
 	return NULL;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/vdso.lds.S linux-2.6.32.60-pax/arch/x86/vdso/vdso.lds.S
--- linux-2.6.32.60/arch/x86/vdso/vdso.lds.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/vdso.lds.S	2012-03-13 13:15:34.860098005 +0100
@@ -35,3 +35,9 @@ VDSO64_PRELINK = VDSO_PRELINK;
 #define VEXTERN(x)	VDSO64_ ## x = vdso_ ## x;
 #include "vextern.h"
 #undef	VEXTERN
+
+#define VEXTERN(x)	VDSO64_ ## x = __vdso_ ## x;
+VEXTERN(fallback_gettimeofday)
+VEXTERN(fallback_time)
+VEXTERN(getcpu)
+#undef	VEXTERN
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/vextern.h linux-2.6.32.60-pax/arch/x86/vdso/vextern.h
--- linux-2.6.32.60/arch/x86/vdso/vextern.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/vextern.h	2012-03-13 13:15:34.860098005 +0100
@@ -11,6 +11,5 @@
    put into vextern.h and be referenced as a pointer with vdso prefix.
    The main kernel later fills in the values.   */
 
-VEXTERN(jiffies)
 VEXTERN(vgetcpu_mode)
 VEXTERN(vsyscall_gtod_data)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/vdso/vma.c linux-2.6.32.60-pax/arch/x86/vdso/vma.c
--- linux-2.6.32.60/arch/x86/vdso/vma.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/vdso/vma.c	2012-03-13 13:15:34.860098005 +0100
@@ -17,8 +17,6 @@
 #include "vextern.h"		/* Just for VMAGIC.  */
 #undef VEXTERN
 
-unsigned int __read_mostly vdso_enabled = 1;
-
 extern char vdso_start[], vdso_end[];
 extern unsigned short vdso_sync_cpuid;
 
@@ -27,10 +25,8 @@ static unsigned vdso_size;
 
 static inline void *var_ref(void *p, char *name)
 {
-	if (*(void **)p != (void *)VMAGIC) {
-		printk("VDSO: variable %s broken\n", name);
-		vdso_enabled = 0;
-	}
+	if (*(void **)p != (void *)VMAGIC)
+		panic("VDSO: variable %s broken\n", name);
 	return p;
 }
 
@@ -57,21 +53,18 @@ static int __init init_vdso_vars(void)
 	if (!vbase)
 		goto oom;
 
-	if (memcmp(vbase, "\177ELF", 4)) {
-		printk("VDSO: I'm broken; not ELF\n");
-		vdso_enabled = 0;
-	}
+	if (memcmp(vbase, ELFMAG, SELFMAG))
+		panic("VDSO: I'm broken; not ELF\n");
 
 #define VEXTERN(x) \
 	*(typeof(__ ## x) **) var_ref(VDSO64_SYMBOL(vbase, x), #x) = &__ ## x;
 #include "vextern.h"
 #undef VEXTERN
+	vunmap(vbase);
 	return 0;
 
  oom:
-	printk("Cannot allocate vdso\n");
-	vdso_enabled = 0;
-	return -ENOMEM;
+	panic("Cannot allocate vdso\n");
 }
 __initcall(init_vdso_vars);
 
@@ -102,13 +95,15 @@ static unsigned long vdso_addr(unsigned
 int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 {
 	struct mm_struct *mm = current->mm;
-	unsigned long addr;
+	unsigned long addr = 0;
 	int ret;
 
-	if (!vdso_enabled)
-		return 0;
-
 	down_write(&mm->mmap_sem);
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	addr = vdso_addr(mm->start_stack, vdso_size);
 	addr = get_unmapped_area(NULL, addr, vdso_size, 0, 0);
 	if (IS_ERR_VALUE(addr)) {
@@ -116,7 +111,7 @@ int arch_setup_additional_pages(struct l
 		goto up_fail;
 	}
 
-	current->mm->context.vdso = (void *)addr;
+	current->mm->context.vdso = addr;
 
 	ret = install_special_mapping(mm, addr, vdso_size,
 				      VM_READ|VM_EXEC|
@@ -124,7 +119,7 @@ int arch_setup_additional_pages(struct l
 				      VM_ALWAYSDUMP,
 				      vdso_pages);
 	if (ret) {
-		current->mm->context.vdso = NULL;
+		current->mm->context.vdso = 0;
 		goto up_fail;
 	}
 
@@ -132,10 +127,3 @@ up_fail:
 	up_write(&mm->mmap_sem);
 	return ret;
 }
-
-static __init int vdso_setup(char *s)
-{
-	vdso_enabled = simple_strtoul(s, NULL, 0);
-	return 0;
-}
-__setup("vdso=", vdso_setup);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/enlighten.c linux-2.6.32.60-pax/arch/x86/xen/enlighten.c
--- linux-2.6.32.60/arch/x86/xen/enlighten.c	2012-10-09 11:00:35.436882465 +0200
+++ linux-2.6.32.60-pax/arch/x86/xen/enlighten.c	2013-02-17 17:38:43.444096159 +0100
@@ -71,8 +71,6 @@ EXPORT_SYMBOL_GPL(xen_start_info);
 
 struct shared_info xen_dummy_shared_info;
 
-void *xen_initial_gdt;
-
 /*
  * Point at some empty memory to start with. We map the real shared_info
  * page as soon as fixmap is up and running.
@@ -336,8 +334,7 @@ static void xen_load_gdt(const struct de
 {
 	unsigned long va = dtr->address;
 	unsigned int size = dtr->size + 1;
-	unsigned pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
-	unsigned long frames[pages];
+	unsigned long frames[65536 / PAGE_SIZE];
 	int f;
 
 	/*
@@ -385,8 +382,7 @@ static __init void xen_load_gdt_boot(con
 {
 	unsigned long va = dtr->address;
 	unsigned int size = dtr->size + 1;
-	unsigned pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
-	unsigned long frames[pages];
+	unsigned long frames[65536 / PAGE_SIZE];
 	int f;
 
 	/*
@@ -548,7 +544,7 @@ static void xen_write_idt_entry(gate_des
 
 	preempt_disable();
 
-	start = __get_cpu_var(idt_desc).address;
+	start = (unsigned long)__get_cpu_var(idt_desc).address;
 	end = start + __get_cpu_var(idt_desc).size + 1;
 
 	xen_mc_flush();
@@ -996,25 +992,25 @@ static const struct pv_apic_ops xen_apic
 #endif
 };
 
-static void xen_reboot(int reason)
+static __noreturn void xen_reboot(int reason)
 {
 	struct sched_shutdown r = { .reason = reason };
 
-	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
-		BUG();
+	HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);
+	BUG();
 }
 
-static void xen_restart(char *msg)
+static __noreturn void xen_restart(char *msg)
 {
 	xen_reboot(SHUTDOWN_reboot);
 }
 
-static void xen_emergency_restart(void)
+static __noreturn void xen_emergency_restart(void)
 {
 	xen_reboot(SHUTDOWN_reboot);
 }
 
-static void xen_machine_halt(void)
+static __noreturn void xen_machine_halt(void)
 {
 	xen_reboot(SHUTDOWN_poweroff);
 }
@@ -1062,10 +1058,10 @@ asmlinkage void __init xen_start_kernel(
 
 	/* Install Xen paravirt ops */
 	pv_info = xen_info;
-	pv_init_ops = xen_init_ops;
-	pv_time_ops = xen_time_ops;
-	pv_cpu_ops = xen_cpu_ops;
-	pv_apic_ops = xen_apic_ops;
+	memcpy((void *)&pv_init_ops, &xen_init_ops, sizeof pv_init_ops);
+	memcpy((void *)&pv_time_ops, &xen_time_ops, sizeof pv_time_ops);
+	memcpy((void *)&pv_cpu_ops, &xen_cpu_ops, sizeof pv_cpu_ops);
+	memcpy((void *)&pv_apic_ops, &xen_apic_ops, sizeof pv_apic_ops);
 
 	x86_init.resources.memory_setup = xen_memory_setup;
 	x86_init.oem.arch_setup = xen_arch_setup;
@@ -1098,9 +1094,20 @@ asmlinkage void __init xen_start_kernel(
 	 */
 	__userpte_alloc_gfp &= ~__GFP_HIGHMEM;
 
-#ifdef CONFIG_X86_64
 	/* Work out if we support NX */
-	check_efer();
+#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
+	if ((cpuid_eax(0x80000000) & 0xffff0000) == 0x80000000 &&
+	    (cpuid_edx(0x80000001) & (1U << (X86_FEATURE_NX & 31)))) {
+		unsigned l, h;
+
+#ifdef CONFIG_X86_PAE
+		nx_enabled = 1;
+#endif
+		__supported_pte_mask |= _PAGE_NX;
+		rdmsr(MSR_EFER, l, h);
+		l |= EFER_NX;
+		wrmsr(MSR_EFER, l, h);
+	}
 #endif
 
 	xen_setup_features();
@@ -1130,14 +1137,7 @@ asmlinkage void __init xen_start_kernel(
 		pv_mmu_ops.ptep_modify_prot_commit = xen_ptep_modify_prot_commit;
 	}
 
-	machine_ops = xen_machine_ops;
-
-	/*
-	 * The only reliable way to retain the initial address of the
-	 * percpu gdt_page is to remember it here, so we can go and
-	 * mark it RW later, when the initial percpu area is freed.
-	 */
-	xen_initial_gdt = &per_cpu(gdt_page, 0);
+	memcpy((void *)&machine_ops, &xen_machine_ops, sizeof machine_ops);
 
 	xen_smp_init();
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/mmu.c linux-2.6.32.60-pax/arch/x86/xen/mmu.c
--- linux-2.6.32.60/arch/x86/xen/mmu.c	2012-10-09 11:00:35.436882465 +0200
+++ linux-2.6.32.60-pax/arch/x86/xen/mmu.c	2013-02-17 17:33:15.864113649 +0100
@@ -1717,6 +1717,9 @@ __init pgd_t *xen_setup_kernel_pagetable
 	convert_pfn_mfn(init_level4_pgt);
 	convert_pfn_mfn(level3_ident_pgt);
 	convert_pfn_mfn(level3_kernel_pgt);
+	convert_pfn_mfn(level3_vmalloc_start_pgt);
+	convert_pfn_mfn(level3_vmalloc_end_pgt);
+	convert_pfn_mfn(level3_vmemmap_pgt);
 
 	l3 = m2v(pgd[pgd_index(__START_KERNEL_map)].pgd);
 	l2 = m2v(l3[pud_index(__START_KERNEL_map)].pud);
@@ -1735,7 +1738,11 @@ __init pgd_t *xen_setup_kernel_pagetable
 	set_page_prot(init_level4_pgt, PAGE_KERNEL_RO);
 	set_page_prot(level3_ident_pgt, PAGE_KERNEL_RO);
 	set_page_prot(level3_kernel_pgt, PAGE_KERNEL_RO);
+	set_page_prot(level3_vmalloc_start_pgt, PAGE_KERNEL_RO);
+	set_page_prot(level3_vmalloc_end_pgt, PAGE_KERNEL_RO);
+	set_page_prot(level3_vmemmap_pgt, PAGE_KERNEL_RO);
 	set_page_prot(level3_user_vsyscall, PAGE_KERNEL_RO);
+	set_page_prot(level2_vmemmap_pgt, PAGE_KERNEL_RO);
 	set_page_prot(level2_kernel_pgt, PAGE_KERNEL_RO);
 	set_page_prot(level2_fixmap_pgt, PAGE_KERNEL_RO);
 
@@ -1858,6 +1865,7 @@ static __init void xen_post_allocator_in
 	pv_mmu_ops.set_pud = xen_set_pud;
 #if PAGETABLE_LEVELS == 4
 	pv_mmu_ops.set_pgd = xen_set_pgd;
+	pv_mmu_ops.set_pgd_batched = xen_set_pgd;
 #endif
 
 	/* This will work as long as patching hasn't happened yet
@@ -1944,6 +1952,7 @@ static const struct pv_mmu_ops xen_mmu_o
 	.pud_val = PV_CALLEE_SAVE(xen_pud_val),
 	.make_pud = PV_CALLEE_SAVE(xen_make_pud),
 	.set_pgd = xen_set_pgd_hyper,
+	.set_pgd_batched = xen_set_pgd_hyper,
 
 	.alloc_pud = xen_alloc_pmd_init,
 	.release_pud = xen_release_pmd_init,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/smp.c linux-2.6.32.60-pax/arch/x86/xen/smp.c
--- linux-2.6.32.60/arch/x86/xen/smp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/xen/smp.c	2013-01-22 15:21:38.084981735 +0100
@@ -168,11 +168,6 @@ static void __init xen_smp_prepare_boot_
 {
 	BUG_ON(smp_processor_id() != 0);
 	native_smp_prepare_boot_cpu();
-
-	/* We've switched to the "real" per-cpu gdt, so make sure the
-	   old memory can be recycled */
-	make_lowmem_page_readwrite(xen_initial_gdt);
-
 	xen_setup_vcpu_info_placement();
 }
 
@@ -241,12 +236,12 @@ cpu_initialize_context(unsigned int cpu,
 	gdt = get_cpu_gdt_table(cpu);
 
 	ctxt->flags = VGCF_IN_KERNEL;
-	ctxt->user_regs.ds = __USER_DS;
-	ctxt->user_regs.es = __USER_DS;
+	ctxt->user_regs.ds = __KERNEL_DS;
+	ctxt->user_regs.es = __KERNEL_DS;
 	ctxt->user_regs.ss = __KERNEL_DS;
 #ifdef CONFIG_X86_32
 	ctxt->user_regs.fs = __KERNEL_PERCPU;
-	ctxt->user_regs.gs = __KERNEL_STACK_CANARY;
+	savesegment(gs, ctxt->user_regs.gs);
 #else
 	ctxt->gs_base_kernel = per_cpu_offset(cpu);
 #endif
@@ -297,13 +292,12 @@ static int __cpuinit xen_cpu_up(unsigned
 	int rc;
 
 	per_cpu(current_task, cpu) = idle;
+	per_cpu(current_tinfo, cpu) = &idle->tinfo;
 #ifdef CONFIG_X86_32
 	irq_ctx_init(cpu);
 #else
 	clear_tsk_thread_flag(idle, TIF_FORK);
-	per_cpu(kernel_stack, cpu) =
-		(unsigned long)task_stack_page(idle) -
-		KERNEL_STACK_OFFSET + THREAD_SIZE;
+	per_cpu(kernel_stack, cpu) = (unsigned long)task_stack_page(idle) - 16 + THREAD_SIZE;
 #endif
 	xen_setup_runstate_info(cpu);
 	xen_setup_timer(cpu);
@@ -485,7 +479,7 @@ static const struct smp_ops xen_smp_ops
 
 void __init xen_smp_init(void)
 {
-	smp_ops = xen_smp_ops;
+	memcpy((void *)&smp_ops, &xen_smp_ops, sizeof smp_ops);
 	xen_fill_possible_map();
 	xen_init_spinlocks();
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/xen-asm_32.S linux-2.6.32.60-pax/arch/x86/xen/xen-asm_32.S
--- linux-2.6.32.60/arch/x86/xen/xen-asm_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/xen/xen-asm_32.S	2012-03-13 13:15:34.864098004 +0100
@@ -83,14 +83,14 @@ ENTRY(xen_iret)
 	ESP_OFFSET=4	# bytes pushed onto stack
 
 	/*
-	 * Store vcpu_info pointer for easy access.  Do it this way to
-	 * avoid having to reload %fs
+	 * Store vcpu_info pointer for easy access.
 	 */
 #ifdef CONFIG_SMP
-	GET_THREAD_INFO(%eax)
-	movl TI_cpu(%eax), %eax
-	movl __per_cpu_offset(,%eax,4), %eax
-	mov per_cpu__xen_vcpu(%eax), %eax
+	push %fs
+	mov $(__KERNEL_PERCPU), %eax
+	mov %eax, %fs
+	mov PER_CPU_VAR(xen_vcpu), %eax
+	pop %fs
 #else
 	movl per_cpu__xen_vcpu, %eax
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/xen-head.S linux-2.6.32.60-pax/arch/x86/xen/xen-head.S
--- linux-2.6.32.60/arch/x86/xen/xen-head.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/xen/xen-head.S	2012-03-13 13:15:34.868098004 +0100
@@ -19,6 +19,17 @@ ENTRY(startup_xen)
 #ifdef CONFIG_X86_32
 	mov %esi,xen_start_info
 	mov $init_thread_union+THREAD_SIZE,%esp
+#ifdef CONFIG_SMP
+	movl $cpu_gdt_table,%edi
+	movl $__per_cpu_load,%eax
+	movw %ax,__KERNEL_PERCPU + 2(%edi)
+	rorl $16,%eax
+	movb %al,__KERNEL_PERCPU + 4(%edi)
+	movb %ah,__KERNEL_PERCPU + 7(%edi)
+	movl $__per_cpu_end - 1,%eax
+	subl $__per_cpu_start,%eax
+	movw %ax,__KERNEL_PERCPU + 0(%edi)
+#endif
 #else
 	mov %rsi,xen_start_info
 	mov $init_thread_union+THREAD_SIZE,%rsp
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/arch/x86/xen/xen-ops.h linux-2.6.32.60-pax/arch/x86/xen/xen-ops.h
--- linux-2.6.32.60/arch/x86/xen/xen-ops.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/arch/x86/xen/xen-ops.h	2012-03-13 13:15:34.868098004 +0100
@@ -10,8 +10,6 @@
 extern const char xen_hypervisor_callback[];
 extern const char xen_failsafe_callback[];
 
-extern void *xen_initial_gdt;
-
 struct trap_info;
 void xen_copy_trap_info(struct trap_info *traps);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/blk-iopoll.c linux-2.6.32.60-pax/block/blk-iopoll.c
--- linux-2.6.32.60/block/blk-iopoll.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/block/blk-iopoll.c	2012-03-13 13:15:34.868098004 +0100
@@ -77,7 +77,7 @@ void blk_iopoll_complete(struct blk_iopo
 }
 EXPORT_SYMBOL(blk_iopoll_complete);
 
-static void blk_iopoll_softirq(struct softirq_action *h)
+static void blk_iopoll_softirq(void)
 {
 	struct list_head *list = &__get_cpu_var(blk_cpu_iopoll);
 	int rearm = 0, budget = blk_iopoll_budget;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/blk-map.c linux-2.6.32.60-pax/block/blk-map.c
--- linux-2.6.32.60/block/blk-map.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/block/blk-map.c	2012-03-13 13:15:34.868098004 +0100
@@ -54,7 +54,7 @@ static int __blk_rq_map_user(struct requ
 	 * direct dma. else, set up kernel bounce buffers
 	 */
 	uaddr = (unsigned long) ubuf;
-	if (blk_rq_aligned(q, ubuf, len) && !map_data)
+	if (blk_rq_aligned(q, (__force void *)ubuf, len) && !map_data)
 		bio = bio_map_user(q, NULL, uaddr, len, reading, gfp_mask);
 	else
 		bio = bio_copy_user(q, map_data, uaddr, len, reading, gfp_mask);
@@ -201,12 +201,13 @@ int blk_rq_map_user_iov(struct request_q
 	for (i = 0; i < iov_count; i++) {
 		unsigned long uaddr = (unsigned long)iov[i].iov_base;
 
+		if (!iov[i].iov_len)
+			return -EINVAL;
+
 		if (uaddr & queue_dma_alignment(q)) {
 			unaligned = 1;
 			break;
 		}
-		if (!iov[i].iov_len)
-			return -EINVAL;
 	}
 
 	if (unaligned || (q->dma_pad_mask & len) || map_data)
@@ -299,7 +300,7 @@ int blk_rq_map_kern(struct request_queue
 	if (!len || !kbuf)
 		return -EINVAL;
 
-	do_copy = !blk_rq_aligned(q, kbuf, len) || object_is_on_stack(kbuf);
+	do_copy = !blk_rq_aligned(q, kbuf, len) || object_starts_on_stack(kbuf);
 	if (do_copy)
 		bio = bio_copy_kern(q, kbuf, len, gfp_mask, reading);
 	else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/blk-softirq.c linux-2.6.32.60-pax/block/blk-softirq.c
--- linux-2.6.32.60/block/blk-softirq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/block/blk-softirq.c	2012-03-13 13:15:34.868098004 +0100
@@ -17,7 +17,7 @@ static DEFINE_PER_CPU(struct list_head,
  * Softirq action handler - move entries to local list and loop over them
  * while passing them to the queue registered handler.
  */
-static void blk_done_softirq(struct softirq_action *h)
+static void blk_done_softirq(void)
 {
 	struct list_head *cpu_list, local_list;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/bsg.c linux-2.6.32.60-pax/block/bsg.c
--- linux-2.6.32.60/block/bsg.c	2012-03-18 17:44:12.472058990 +0100
+++ linux-2.6.32.60-pax/block/bsg.c	2012-03-18 17:44:18.424057492 +0100
@@ -175,16 +175,24 @@ static int blk_fill_sgv4_hdr_rq(struct r
 				struct sg_io_v4 *hdr, struct bsg_device *bd,
 				fmode_t has_write_perm)
 {
+	unsigned char tmpcmd[sizeof(rq->__cmd)];
+	unsigned char *cmdptr;
+
 	if (hdr->request_len > BLK_MAX_CDB) {
 		rq->cmd = kzalloc(hdr->request_len, GFP_KERNEL);
 		if (!rq->cmd)
 			return -ENOMEM;
-	}
+		cmdptr = rq->cmd;
+	} else
+		cmdptr = tmpcmd;
 
-	if (copy_from_user(rq->cmd, (void *)(unsigned long)hdr->request,
+	if (copy_from_user(cmdptr, (void __user *)(unsigned long)hdr->request,
 			   hdr->request_len))
 		return -EFAULT;
 
+	if (cmdptr != rq->cmd)
+		memcpy(rq->cmd, cmdptr, hdr->request_len);
+
 	if (hdr->subprotocol == BSG_SUB_PROTOCOL_SCSI_CMD) {
 		if (blk_verify_command(rq->cmd, has_write_perm))
 			return -EPERM;
@@ -282,7 +290,7 @@ bsg_map_hdr(struct bsg_device *bd, struc
 		rq->next_rq = next_rq;
 		next_rq->cmd_type = rq->cmd_type;
 
-		dxferp = (void*)(unsigned long)hdr->din_xferp;
+		dxferp = (void __user *)(unsigned long)hdr->din_xferp;
 		ret =  blk_rq_map_user(q, next_rq, NULL, dxferp,
 				       hdr->din_xfer_len, GFP_KERNEL);
 		if (ret)
@@ -291,10 +299,10 @@ bsg_map_hdr(struct bsg_device *bd, struc
 
 	if (hdr->dout_xfer_len) {
 		dxfer_len = hdr->dout_xfer_len;
-		dxferp = (void*)(unsigned long)hdr->dout_xferp;
+		dxferp = (void __user *)(unsigned long)hdr->dout_xferp;
 	} else if (hdr->din_xfer_len) {
 		dxfer_len = hdr->din_xfer_len;
-		dxferp = (void*)(unsigned long)hdr->din_xferp;
+		dxferp = (void __user *)(unsigned long)hdr->din_xferp;
 	} else
 		dxfer_len = 0;
 
@@ -436,7 +444,7 @@ static int blk_complete_sgv4_hdr_rq(stru
 		int len = min_t(unsigned int, hdr->max_response_len,
 					rq->sense_len);
 
-		ret = copy_to_user((void*)(unsigned long)hdr->response,
+		ret = copy_to_user((void __user *)(unsigned long)hdr->response,
 				   rq->sense, len);
 		if (!ret)
 			hdr->response_len = len;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/compat_ioctl.c linux-2.6.32.60-pax/block/compat_ioctl.c
--- linux-2.6.32.60/block/compat_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/block/compat_ioctl.c	2012-03-13 13:15:34.872098004 +0100
@@ -354,7 +354,7 @@ static int compat_fd_ioctl(struct block_
 		err |= __get_user(f->spec1, &uf->spec1);
 		err |= __get_user(f->fmt_gap, &uf->fmt_gap);
 		err |= __get_user(name, &uf->name);
-		f->name = compat_ptr(name);
+		f->name = (void __force_kernel *)compat_ptr(name);
 		if (err) {
 			err = -EFAULT;
 			goto out;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/block/scsi_ioctl.c linux-2.6.32.60-pax/block/scsi_ioctl.c
--- linux-2.6.32.60/block/scsi_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/block/scsi_ioctl.c	2012-03-13 13:15:34.872098004 +0100
@@ -221,8 +221,20 @@ EXPORT_SYMBOL(blk_verify_command);
 static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,
 			     struct sg_io_hdr *hdr, fmode_t mode)
 {
-	if (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))
+	unsigned char tmpcmd[sizeof(rq->__cmd)];
+	unsigned char *cmdptr;
+
+	if (rq->cmd != rq->__cmd)
+		cmdptr = rq->cmd;
+	else
+		cmdptr = tmpcmd;
+
+	if (copy_from_user(cmdptr, hdr->cmdp, hdr->cmd_len))
 		return -EFAULT;
+
+	if (cmdptr != rq->cmd)
+		memcpy(rq->cmd, cmdptr, hdr->cmd_len);
+
 	if (blk_verify_command(rq->cmd, mode & FMODE_WRITE))
 		return -EPERM;
 
@@ -431,6 +443,8 @@ int sg_scsi_ioctl(struct request_queue *
 	int err;
 	unsigned int in_len, out_len, bytes, opcode, cmdlen;
 	char *buffer = NULL, sense[SCSI_SENSE_BUFFERSIZE];
+	unsigned char tmpcmd[sizeof(rq->__cmd)];
+	unsigned char *cmdptr;
 
 	if (!sic)
 		return -EINVAL;
@@ -464,9 +478,18 @@ int sg_scsi_ioctl(struct request_queue *
 	 */
 	err = -EFAULT;
 	rq->cmd_len = cmdlen;
-	if (copy_from_user(rq->cmd, sic->data, cmdlen))
+
+	if (rq->cmd != rq->__cmd)
+		cmdptr = rq->cmd;
+	else
+		cmdptr = tmpcmd;
+
+	if (copy_from_user(cmdptr, sic->data, cmdlen))
 		goto error;
 
+	if (rq->cmd != cmdptr)
+		memcpy(rq->cmd, cmdptr, cmdlen);
+
 	if (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))
 		goto error;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/crypto/cryptd.c linux-2.6.32.60-pax/crypto/cryptd.c
--- linux-2.6.32.60/crypto/cryptd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/crypto/cryptd.c	2012-03-13 13:15:34.872098004 +0100
@@ -50,7 +50,7 @@ struct cryptd_blkcipher_ctx {
 
 struct cryptd_blkcipher_request_ctx {
 	crypto_completion_t complete;
-};
+} __no_const;
 
 struct cryptd_hash_ctx {
 	struct crypto_shash *child;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/crypto/gf128mul.c linux-2.6.32.60-pax/crypto/gf128mul.c
--- linux-2.6.32.60/crypto/gf128mul.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/crypto/gf128mul.c	2012-03-13 13:15:34.876098004 +0100
@@ -182,7 +182,7 @@ void gf128mul_lle(be128 *r, const be128
 	for (i = 0; i < 7; ++i)
 		gf128mul_x_lle(&p[i + 1], &p[i]);
 
-	memset(r, 0, sizeof(r));
+	memset(r, 0, sizeof(*r));
 	for (i = 0;;) {
 		u8 ch = ((u8 *)b)[15 - i];
 
@@ -220,7 +220,7 @@ void gf128mul_bbe(be128 *r, const be128
 	for (i = 0; i < 7; ++i)
 		gf128mul_x_bbe(&p[i + 1], &p[i]);
 
-	memset(r, 0, sizeof(r));
+	memset(r, 0, sizeof(*r));
 	for (i = 0;;) {
 		u8 ch = ((u8 *)b)[i];
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/Documentation/dontdiff linux-2.6.32.60-pax/Documentation/dontdiff
--- linux-2.6.32.60/Documentation/dontdiff	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/Documentation/dontdiff	2012-07-21 11:15:46.713044483 +0200
@@ -1,15 +1,20 @@
 *.a
 *.aux
 *.bin
+*.c.[012].*
+*.cis
 *.cpio
 *.csp
+*.dbg
 *.dsp
 *.dvi
 *.elf
 *.eps
 *.fw
+*.gcno
 *.gen.S
 *.gif
+*.gmo
 *.grep
 *.grp
 *.gz
@@ -38,22 +43,30 @@
 *.tab.h
 *.tex
 *.ver
+*.vim
 *.xml
 *_MODULES
+*_reg_safe.h
 *_vga16.c
 *~
 *.9
 *.9.gz
-.*
+.[^g]*
+.gen*
 .mm
 53c700_d.h
 CVS
 ChangeSet
+GPATH
+GRTAGS
+GSYMS
+GTAGS
 Image
 Kerntypes
 Module.markers
 Module.symvers
 PENDING
+PERF*
 SCCS
 System.map*
 TAGS
@@ -62,6 +75,7 @@ aic7*reg_print.c*
 aic7*seq.h*
 aicasm
 aicdb.h*
+ashldi3.S
 asm-offsets.h
 asm_offsets.h
 autoconf.h*
@@ -76,7 +90,11 @@ btfixupprep
 build
 bvmlinux
 bzImage*
+capability_names.h
+capflags.c
 classlist.h*
+clut_vga16.c
+common-cmds.h
 comp*.log
 compile.h*
 conf
@@ -84,6 +102,8 @@ config
 config-*
 config_data.h*
 config_data.gz*
+config.c
+config.tmp
 conmakehash
 consolemap_deftbl.c*
 cpustr.h
@@ -103,13 +123,16 @@ gen_crc32table
 gen_init_cpio
 genksyms
 *_gray256.c
+hash
+hid-example
 ihex2fw
 ikconfig.h*
 initramfs_data.cpio
+initramfs_data.cpio.bz2
 initramfs_data.cpio.gz
 initramfs_list
 kallsyms
-kconfig
+kern_constants.h
 keywords.c
 ksym.c*
 ksym.h*
@@ -117,6 +140,7 @@ kxgettext
 lkc_defs.h
 lex.c
 lex.*.c
+lib1funcs.S
 logo_*.c
 logo_*_clut224.c
 logo_*_mono.c
@@ -127,13 +151,16 @@ machtypes.h
 map
 maui_boot.h
 mconf
+mdp
 miboot*
 mk_elfconfig
 mkboot
 mkbugboot
 mkcpustr
 mkdep
+mkpiggy
 mkprep
+mkregtable
 mktables
 mktree
 modpost
@@ -149,6 +176,7 @@ patches*
 pca200e.bin
 pca200e_ecd.bin2
 piggy.gz
+piggy.S
 piggyback
 pnmtologo
 ppc_defs.h*
@@ -157,12 +185,16 @@ qconf
 raid6altivec*.c
 raid6int*.c
 raid6tables.c
+regdb.c
 relocs
+rlim_names.h
 series
 setup
 setup.bin
 setup.elf
+size_overflow_hash.h
 sImage
+slabinfo
 sm_tbl*
 split-include
 syscalltab.h
@@ -171,6 +203,7 @@ tftpboot.img
 timeconst.h
 times.h*
 trix_boot.h
+user_constants.h
 utsrelease.h*
 vdso-syms.lds
 vdso.lds
@@ -186,14 +219,20 @@ version.h*
 vmlinux
 vmlinux-*
 vmlinux.aout
+vmlinux.bin.all
+vmlinux.bin.bz2
 vmlinux.lds
+vmlinux.relocs
+voffset.h
 vsyscall.lds
 vsyscall_32.lds
 wanxlfw.inc
 uImage
 unifdef
+utsrelease.h
 wakeup.bin
 wakeup.elf
 wakeup.lds
 zImage*
 zconf.hash.c
+zoffset.h
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/Documentation/kernel-parameters.txt linux-2.6.32.60-pax/Documentation/kernel-parameters.txt
--- linux-2.6.32.60/Documentation/kernel-parameters.txt	2012-10-09 11:00:35.392882454 +0200
+++ linux-2.6.32.60-pax/Documentation/kernel-parameters.txt	2012-10-09 11:00:39.200883014 +0200
@@ -1842,6 +1842,13 @@ and is between 256 and 4096 characters.
 			the specified number of seconds.  This is to be used if
 			your oopses keep scrolling off the screen.
 
+	pax_nouderef	[X86] disables UDEREF.  Most likely needed under certain
+			virtualization environments that don't cope well with the
+			expand down segment used by UDEREF on X86-32 or the frequent
+			page table updates on X86-64.
+
+	pax_softmode=	0/1 to disable/enable PaX softmode on boot already.
+
 	pcbit=		[HW,ISDN]
 
 	pcd.		[PARIDE]
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/acpi_pad.c linux-2.6.32.60-pax/drivers/acpi/acpi_pad.c
--- linux-2.6.32.60/drivers/acpi/acpi_pad.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/acpi_pad.c	2012-03-13 13:15:34.880098003 +0100
@@ -30,7 +30,7 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#define ACPI_PROCESSOR_AGGREGATOR_CLASS	"processor_aggregator"
+#define ACPI_PROCESSOR_AGGREGATOR_CLASS	"acpi_pad"
 #define ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME "Processor Aggregator"
 #define ACPI_PROCESSOR_AGGREGATOR_NOTIFY 0x80
 static DEFINE_MUTEX(isolated_cpus_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/osl.c linux-2.6.32.60-pax/drivers/acpi/osl.c
--- linux-2.6.32.60/drivers/acpi/osl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/osl.c	2012-03-13 13:15:34.884098003 +0100
@@ -523,6 +523,8 @@ acpi_os_read_memory(acpi_physical_addres
 	void __iomem *virt_addr;
 
 	virt_addr = ioremap(phys_addr, width);
+	if (!virt_addr)
+		return AE_NO_MEMORY;
 	if (!value)
 		value = &dummy;
 
@@ -551,6 +553,8 @@ acpi_os_write_memory(acpi_physical_addre
 	void __iomem *virt_addr;
 
 	virt_addr = ioremap(phys_addr, width);
+	if (!virt_addr)
+		return AE_NO_MEMORY;
 
 	switch (width) {
 	case 8:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/power_meter.c linux-2.6.32.60-pax/drivers/acpi/power_meter.c
--- linux-2.6.32.60/drivers/acpi/power_meter.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/power_meter.c	2012-03-13 13:15:34.888098003 +0100
@@ -315,8 +315,6 @@ static ssize_t set_trip(struct device *d
 		return res;
 
 	temp /= 1000;
-	if (temp < 0)
-		return -EINVAL;
 
 	mutex_lock(&resource->lock);
 	resource->trip[attr->index - 7] = temp;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/proc.c linux-2.6.32.60-pax/drivers/acpi/proc.c
--- linux-2.6.32.60/drivers/acpi/proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/proc.c	2013-02-17 17:13:55.920175581 +0100
@@ -393,17 +393,14 @@ acpi_system_write_wakeup_device(struct f
 	struct list_head *node, *next;
 	char strbuf[5];
 	char str[5] = "";
-	unsigned int len = count;
 	struct acpi_device *found_dev = NULL;
 
-	if (len > 4)
-		len = 4;
-	if (len < 0)
-		return -EFAULT;
+	if (count > 4)
+		count = 4;
 
-	if (copy_from_user(strbuf, buffer, len))
+	if (copy_from_user(strbuf, buffer, count))
 		return -EFAULT;
-	strbuf[len] = '\0';
+	strbuf[count] = '\0';
 	sscanf(strbuf, "%s", str);
 
 	mutex_lock(&acpi_device_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/processor_core.c linux-2.6.32.60-pax/drivers/acpi/processor_core.c
--- linux-2.6.32.60/drivers/acpi/processor_core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/processor_core.c	2012-03-13 13:15:34.892098003 +0100
@@ -790,7 +790,7 @@ static int __cpuinit acpi_processor_add(
 		return 0;
 	}
 
-	BUG_ON((pr->id >= nr_cpu_ids) || (pr->id < 0));
+	BUG_ON(pr->id >= nr_cpu_ids);
 
 	/*
 	 * Buggy BIOS check
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/acpi/sbshc.c linux-2.6.32.60-pax/drivers/acpi/sbshc.c
--- linux-2.6.32.60/drivers/acpi/sbshc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/acpi/sbshc.c	2012-03-13 13:15:34.892098003 +0100
@@ -17,7 +17,7 @@
 
 #define PREFIX "ACPI: "
 
-#define ACPI_SMB_HC_CLASS	"smbus_host_controller"
+#define ACPI_SMB_HC_CLASS	"smbus_host_ctl"
 #define ACPI_SMB_HC_DEVICE_NAME	"ACPI SMBus HC"
 
 struct acpi_smb_hc {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ata/libata-core.c linux-2.6.32.60-pax/drivers/ata/libata-core.c
--- linux-2.6.32.60/drivers/ata/libata-core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ata/libata-core.c	2012-03-13 13:15:34.896098003 +0100
@@ -4954,7 +4954,7 @@ void ata_qc_free(struct ata_queued_cmd *
 	struct ata_port *ap;
 	unsigned int tag;
 
-	WARN_ON_ONCE(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
+	BUG_ON(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
 	ap = qc->ap;
 
 	qc->flags = 0;
@@ -4970,7 +4970,7 @@ void __ata_qc_complete(struct ata_queued
 	struct ata_port *ap;
 	struct ata_link *link;
 
-	WARN_ON_ONCE(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
+	BUG_ON(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
 	WARN_ON_ONCE(!(qc->flags & ATA_QCFLAG_ACTIVE));
 	ap = qc->ap;
 	link = qc->dev->link;
@@ -5999,6 +5999,7 @@ static void ata_finalize_port_ops(struct
 		return;
 
 	spin_lock(&lock);
+	pax_open_kernel();
 
 	for (cur = ops->inherits; cur; cur = cur->inherits) {
 		void **inherit = (void **)cur;
@@ -6012,8 +6013,9 @@ static void ata_finalize_port_ops(struct
 		if (IS_ERR(*pp))
 			*pp = NULL;
 
-	ops->inherits = NULL;
+	*(struct ata_port_operations **)&ops->inherits = NULL;
 
+	pax_close_kernel();
 	spin_unlock(&lock);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/adummy.c linux-2.6.32.60-pax/drivers/atm/adummy.c
--- linux-2.6.32.60/drivers/atm/adummy.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/adummy.c	2012-03-13 13:15:34.896098003 +0100
@@ -77,7 +77,7 @@ adummy_send(struct atm_vcc *vcc, struct
 		vcc->pop(vcc, skb);
 	else
 		dev_kfree_skb_any(skb);
-	atomic_inc(&vcc->stats->tx);
+	atomic_inc_unchecked(&vcc->stats->tx);
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/ambassador.c linux-2.6.32.60-pax/drivers/atm/ambassador.c
--- linux-2.6.32.60/drivers/atm/ambassador.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/ambassador.c	2012-03-13 13:15:34.900098002 +0100
@@ -453,7 +453,7 @@ static void tx_complete (amb_dev * dev,
   PRINTD (DBG_FLOW|DBG_TX, "tx_complete %p %p", dev, tx);
   
   // VC layer stats
-  atomic_inc(&ATM_SKB(skb)->vcc->stats->tx);
+  atomic_inc_unchecked(&ATM_SKB(skb)->vcc->stats->tx);
   
   // free the descriptor
   kfree (tx_descr);
@@ -494,7 +494,7 @@ static void rx_complete (amb_dev * dev,
 	  dump_skb ("<<<", vc, skb);
 	  
 	  // VC layer stats
-	  atomic_inc(&atm_vcc->stats->rx);
+	  atomic_inc_unchecked(&atm_vcc->stats->rx);
 	  __net_timestamp(skb);
 	  // end of our responsability
 	  atm_vcc->push (atm_vcc, skb);
@@ -509,7 +509,7 @@ static void rx_complete (amb_dev * dev,
       } else {
       	PRINTK (KERN_INFO, "dropped over-size frame");
 	// should we count this?
-	atomic_inc(&atm_vcc->stats->rx_drop);
+	atomic_inc_unchecked(&atm_vcc->stats->rx_drop);
       }
       
     } else {
@@ -1341,7 +1341,7 @@ static int amb_send (struct atm_vcc * at
   }
   
   if (check_area (skb->data, skb->len)) {
-    atomic_inc(&atm_vcc->stats->tx_err);
+    atomic_inc_unchecked(&atm_vcc->stats->tx_err);
     return -ENOMEM; // ?
   }
   
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/atmtcp.c linux-2.6.32.60-pax/drivers/atm/atmtcp.c
--- linux-2.6.32.60/drivers/atm/atmtcp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/atmtcp.c	2012-03-13 13:15:34.900098002 +0100
@@ -206,7 +206,7 @@ static int atmtcp_v_send(struct atm_vcc
 		if (vcc->pop) vcc->pop(vcc,skb);
 		else dev_kfree_skb(skb);
 		if (dev_data) return 0;
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		return -ENOLINK;
 	}
 	size = skb->len+sizeof(struct atmtcp_hdr);
@@ -214,7 +214,7 @@ static int atmtcp_v_send(struct atm_vcc
 	if (!new_skb) {
 		if (vcc->pop) vcc->pop(vcc,skb);
 		else dev_kfree_skb(skb);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		return -ENOBUFS;
 	}
 	hdr = (void *) skb_put(new_skb,sizeof(struct atmtcp_hdr));
@@ -225,8 +225,8 @@ static int atmtcp_v_send(struct atm_vcc
 	if (vcc->pop) vcc->pop(vcc,skb);
 	else dev_kfree_skb(skb);
 	out_vcc->push(out_vcc,new_skb);
-	atomic_inc(&vcc->stats->tx);
-	atomic_inc(&out_vcc->stats->rx);
+	atomic_inc_unchecked(&vcc->stats->tx);
+	atomic_inc_unchecked(&out_vcc->stats->rx);
 	return 0;
 }
 
@@ -300,7 +300,7 @@ static int atmtcp_c_send(struct atm_vcc
 	out_vcc = find_vcc(dev, ntohs(hdr->vpi), ntohs(hdr->vci));
 	read_unlock(&vcc_sklist_lock);
 	if (!out_vcc) {
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		goto done;
 	}
 	skb_pull(skb,sizeof(struct atmtcp_hdr));
@@ -312,8 +312,8 @@ static int atmtcp_c_send(struct atm_vcc
 	__net_timestamp(new_skb);
 	skb_copy_from_linear_data(skb, skb_put(new_skb, skb->len), skb->len);
 	out_vcc->push(out_vcc,new_skb);
-	atomic_inc(&vcc->stats->tx);
-	atomic_inc(&out_vcc->stats->rx);
+	atomic_inc_unchecked(&vcc->stats->tx);
+	atomic_inc_unchecked(&out_vcc->stats->rx);
 done:
 	if (vcc->pop) vcc->pop(vcc,skb);
 	else dev_kfree_skb(skb);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/eni.c linux-2.6.32.60-pax/drivers/atm/eni.c
--- linux-2.6.32.60/drivers/atm/eni.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/eni.c	2012-03-13 13:15:34.900098002 +0100
@@ -525,7 +525,7 @@ static int rx_aal0(struct atm_vcc *vcc)
 		DPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",
 		    vcc->dev->number);
 		length = 0;
-		atomic_inc(&vcc->stats->rx_err);
+		atomic_inc_unchecked(&vcc->stats->rx_err);
 	}
 	else {
 		length = ATM_CELL_SIZE-1; /* no HEC */
@@ -580,7 +580,7 @@ static int rx_aal5(struct atm_vcc *vcc)
 			    size);
 		}
 		eff = length = 0;
-		atomic_inc(&vcc->stats->rx_err);
+		atomic_inc_unchecked(&vcc->stats->rx_err);
 	}
 	else {
 		size = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);
@@ -597,7 +597,7 @@ static int rx_aal5(struct atm_vcc *vcc)
 			    "(VCI=%d,length=%ld,size=%ld (descr 0x%lx))\n",
 			    vcc->dev->number,vcc->vci,length,size << 2,descr);
 			length = eff = 0;
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 		}
 	}
 	skb = eff ? atm_alloc_charge(vcc,eff << 2,GFP_ATOMIC) : NULL;
@@ -770,7 +770,7 @@ rx_dequeued++;
 			vcc->push(vcc,skb);
 			pushed++;
 		}
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 	}
 	wake_up(&eni_dev->rx_wait);
 }
@@ -1227,7 +1227,7 @@ static void dequeue_tx(struct atm_dev *d
 		    PCI_DMA_TODEVICE);
 		if (vcc->pop) vcc->pop(vcc,skb);
 		else dev_kfree_skb_irq(skb);
-		atomic_inc(&vcc->stats->tx);
+		atomic_inc_unchecked(&vcc->stats->tx);
 		wake_up(&eni_dev->tx_wait);
 dma_complete++;
 	}
@@ -1570,7 +1570,7 @@ tx_complete++;
 /*--------------------------------- entries ---------------------------------*/
 
 
-static const char *media_name[] __devinitdata = {
+static const char *media_name[] __devinitconst = {
     "MMF", "SMF", "MMF", "03?", /*  0- 3 */
     "UTP", "05?", "06?", "07?", /*  4- 7 */
     "TAXI","09?", "10?", "11?", /*  8-11 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/firestream.c linux-2.6.32.60-pax/drivers/atm/firestream.c
--- linux-2.6.32.60/drivers/atm/firestream.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/firestream.c	2012-03-13 13:15:34.904098002 +0100
@@ -748,7 +748,7 @@ static void process_txdone_queue (struct
 				}
 			}
 
-			atomic_inc(&ATM_SKB(skb)->vcc->stats->tx);
+			atomic_inc_unchecked(&ATM_SKB(skb)->vcc->stats->tx);
 
 			fs_dprintk (FS_DEBUG_TXMEM, "i");
 			fs_dprintk (FS_DEBUG_ALLOC, "Free t-skb: %p\n", skb);
@@ -815,7 +815,7 @@ static void process_incoming (struct fs_
 #endif
 				skb_put (skb, qe->p1 & 0xffff); 
 				ATM_SKB(skb)->vcc = atm_vcc;
-				atomic_inc(&atm_vcc->stats->rx);
+				atomic_inc_unchecked(&atm_vcc->stats->rx);
 				__net_timestamp(skb);
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p (pushed)\n", skb);
 				atm_vcc->push (atm_vcc, skb);
@@ -836,12 +836,12 @@ static void process_incoming (struct fs_
 				kfree (pe);
 			}
 			if (atm_vcc)
-				atomic_inc(&atm_vcc->stats->rx_drop);
+				atomic_inc_unchecked(&atm_vcc->stats->rx_drop);
 			break;
 		case 0x1f: /*  Reassembly abort: no buffers. */
 			/* Silently increment error counter. */
 			if (atm_vcc)
-				atomic_inc(&atm_vcc->stats->rx_drop);
+				atomic_inc_unchecked(&atm_vcc->stats->rx_drop);
 			break;
 		default: /* Hmm. Haven't written the code to handle the others yet... -- REW */
 			printk (KERN_WARNING "Don't know what to do with RX status %x: %s.\n", 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/fore200e.c linux-2.6.32.60-pax/drivers/atm/fore200e.c
--- linux-2.6.32.60/drivers/atm/fore200e.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/fore200e.c	2012-03-13 13:15:34.904098002 +0100
@@ -931,9 +931,9 @@ fore200e_tx_irq(struct fore200e* fore200
 #endif
 		/* check error condition */
 		if (*entry->status & STATUS_ERROR)
-		    atomic_inc(&vcc->stats->tx_err);
+		    atomic_inc_unchecked(&vcc->stats->tx_err);
 		else
-		    atomic_inc(&vcc->stats->tx);
+		    atomic_inc_unchecked(&vcc->stats->tx);
 	    }
 	}
 
@@ -1082,7 +1082,7 @@ fore200e_push_rpd(struct fore200e* fore2
     if (skb == NULL) {
 	DPRINTK(2, "unable to alloc new skb, rx PDU length = %d\n", pdu_len);
 
-	atomic_inc(&vcc->stats->rx_drop);
+	atomic_inc_unchecked(&vcc->stats->rx_drop);
 	return -ENOMEM;
     } 
 
@@ -1125,14 +1125,14 @@ fore200e_push_rpd(struct fore200e* fore2
 
 	dev_kfree_skb_any(skb);
 
-	atomic_inc(&vcc->stats->rx_drop);
+	atomic_inc_unchecked(&vcc->stats->rx_drop);
 	return -ENOMEM;
     }
 
     ASSERT(atomic_read(&sk_atm(vcc)->sk_wmem_alloc) >= 0);
 
     vcc->push(vcc, skb);
-    atomic_inc(&vcc->stats->rx);
+    atomic_inc_unchecked(&vcc->stats->rx);
 
     ASSERT(atomic_read(&sk_atm(vcc)->sk_wmem_alloc) >= 0);
 
@@ -1210,7 +1210,7 @@ fore200e_rx_irq(struct fore200e* fore200
 		DPRINTK(2, "damaged PDU on %d.%d.%d\n",
 			fore200e->atm_dev->number,
 			entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);
-		atomic_inc(&vcc->stats->rx_err);
+		atomic_inc_unchecked(&vcc->stats->rx_err);
 	    }
 	}
 
@@ -1655,7 +1655,7 @@ fore200e_send(struct atm_vcc *vcc, struc
 		goto retry_here;
 	    }
 
-	    atomic_inc(&vcc->stats->tx_err);
+	    atomic_inc_unchecked(&vcc->stats->tx_err);
 
 	    fore200e->tx_sat++;
 	    DPRINTK(2, "tx queue of device %s is saturated, PDU dropped - heartbeat is %08x\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/he.c linux-2.6.32.60-pax/drivers/atm/he.c
--- linux-2.6.32.60/drivers/atm/he.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/he.c	2012-03-13 13:15:34.908098002 +0100
@@ -1769,7 +1769,7 @@ he_service_rbrq(struct he_dev *he_dev, i
 
 		if (RBRQ_HBUF_ERR(he_dev->rbrq_head)) {
 			hprintk("HBUF_ERR!  (cid 0x%x)\n", cid);
-				atomic_inc(&vcc->stats->rx_drop);
+				atomic_inc_unchecked(&vcc->stats->rx_drop);
 			goto return_host_buffers;
 		}
 
@@ -1802,7 +1802,7 @@ he_service_rbrq(struct he_dev *he_dev, i
 				RBRQ_LEN_ERR(he_dev->rbrq_head)
 							? "LEN_ERR" : "",
 							vcc->vpi, vcc->vci);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			goto return_host_buffers;
 		}
 
@@ -1861,7 +1861,7 @@ he_service_rbrq(struct he_dev *he_dev, i
 		vcc->push(vcc, skb);
 		spin_lock(&he_dev->global_lock);
 
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 
 return_host_buffers:
 		++pdus_assembled;
@@ -2206,7 +2206,7 @@ __enqueue_tpd(struct he_dev *he_dev, str
 					tpd->vcc->pop(tpd->vcc, tpd->skb);
 				else
 					dev_kfree_skb_any(tpd->skb);
-				atomic_inc(&tpd->vcc->stats->tx_err);
+				atomic_inc_unchecked(&tpd->vcc->stats->tx_err);
 			}
 			pci_pool_free(he_dev->tpd_pool, tpd, TPD_ADDR(tpd->status));
 			return;
@@ -2618,7 +2618,7 @@ he_send(struct atm_vcc *vcc, struct sk_b
 			vcc->pop(vcc, skb);
 		else
 			dev_kfree_skb_any(skb);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		return -EINVAL;
 	}
 
@@ -2629,7 +2629,7 @@ he_send(struct atm_vcc *vcc, struct sk_b
 			vcc->pop(vcc, skb);
 		else
 			dev_kfree_skb_any(skb);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		return -EINVAL;
 	}
 #endif
@@ -2641,7 +2641,7 @@ he_send(struct atm_vcc *vcc, struct sk_b
 			vcc->pop(vcc, skb);
 		else
 			dev_kfree_skb_any(skb);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		spin_unlock_irqrestore(&he_dev->global_lock, flags);
 		return -ENOMEM;
 	}
@@ -2683,7 +2683,7 @@ he_send(struct atm_vcc *vcc, struct sk_b
 					vcc->pop(vcc, skb);
 				else
 					dev_kfree_skb_any(skb);
-				atomic_inc(&vcc->stats->tx_err);
+				atomic_inc_unchecked(&vcc->stats->tx_err);
 				spin_unlock_irqrestore(&he_dev->global_lock, flags);
 				return -ENOMEM;
 			}
@@ -2714,7 +2714,7 @@ he_send(struct atm_vcc *vcc, struct sk_b
 	__enqueue_tpd(he_dev, tpd, cid);
 	spin_unlock_irqrestore(&he_dev->global_lock, flags);
 
-	atomic_inc(&vcc->stats->tx);
+	atomic_inc_unchecked(&vcc->stats->tx);
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/horizon.c linux-2.6.32.60-pax/drivers/atm/horizon.c
--- linux-2.6.32.60/drivers/atm/horizon.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/horizon.c	2012-03-13 13:15:34.908098002 +0100
@@ -1033,7 +1033,7 @@ static void rx_schedule (hrz_dev * dev,
 	{
 	  struct atm_vcc * vcc = ATM_SKB(skb)->vcc;
 	  // VC layer stats
-	  atomic_inc(&vcc->stats->rx);
+	  atomic_inc_unchecked(&vcc->stats->rx);
 	  __net_timestamp(skb);
 	  // end of our responsability
 	  vcc->push (vcc, skb);
@@ -1185,7 +1185,7 @@ static void tx_schedule (hrz_dev * const
 	dev->tx_iovec = NULL;
 	
 	// VC layer stats
-	atomic_inc(&ATM_SKB(skb)->vcc->stats->tx);
+	atomic_inc_unchecked(&ATM_SKB(skb)->vcc->stats->tx);
 	
 	// free the skb
 	hrz_kfree_skb (skb);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/idt77252.c linux-2.6.32.60-pax/drivers/atm/idt77252.c
--- linux-2.6.32.60/drivers/atm/idt77252.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/idt77252.c	2012-03-13 13:15:34.912098002 +0100
@@ -810,7 +810,7 @@ drain_scq(struct idt77252_dev *card, str
 		else
 			dev_kfree_skb(skb);
 
-		atomic_inc(&vcc->stats->tx);
+		atomic_inc_unchecked(&vcc->stats->tx);
 	}
 
 	atomic_dec(&scq->used);
@@ -1073,13 +1073,13 @@ dequeue_rx(struct idt77252_dev *card, st
 			if ((sb = dev_alloc_skb(64)) == NULL) {
 				printk("%s: Can't allocate buffers for aal0.\n",
 				       card->name);
-				atomic_add(i, &vcc->stats->rx_drop);
+				atomic_add_unchecked(i, &vcc->stats->rx_drop);
 				break;
 			}
 			if (!atm_charge(vcc, sb->truesize)) {
 				RXPRINTK("%s: atm_charge() dropped aal0 packets.\n",
 					 card->name);
-				atomic_add(i - 1, &vcc->stats->rx_drop);
+				atomic_add_unchecked(i - 1, &vcc->stats->rx_drop);
 				dev_kfree_skb(sb);
 				break;
 			}
@@ -1096,7 +1096,7 @@ dequeue_rx(struct idt77252_dev *card, st
 			ATM_SKB(sb)->vcc = vcc;
 			__net_timestamp(sb);
 			vcc->push(vcc, sb);
-			atomic_inc(&vcc->stats->rx);
+			atomic_inc_unchecked(&vcc->stats->rx);
 
 			cell += ATM_CELL_PAYLOAD;
 		}
@@ -1133,13 +1133,13 @@ dequeue_rx(struct idt77252_dev *card, st
 			         "(CDC: %08x)\n",
 			         card->name, len, rpp->len, readl(SAR_REG_CDC));
 			recycle_rx_pool_skb(card, rpp);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			return;
 		}
 		if (stat & SAR_RSQE_CRC) {
 			RXPRINTK("%s: AAL5 CRC error.\n", card->name);
 			recycle_rx_pool_skb(card, rpp);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			return;
 		}
 		if (skb_queue_len(&rpp->queue) > 1) {
@@ -1150,7 +1150,7 @@ dequeue_rx(struct idt77252_dev *card, st
 				RXPRINTK("%s: Can't alloc RX skb.\n",
 					 card->name);
 				recycle_rx_pool_skb(card, rpp);
-				atomic_inc(&vcc->stats->rx_err);
+				atomic_inc_unchecked(&vcc->stats->rx_err);
 				return;
 			}
 			if (!atm_charge(vcc, skb->truesize)) {
@@ -1169,7 +1169,7 @@ dequeue_rx(struct idt77252_dev *card, st
 			__net_timestamp(skb);
 
 			vcc->push(vcc, skb);
-			atomic_inc(&vcc->stats->rx);
+			atomic_inc_unchecked(&vcc->stats->rx);
 
 			return;
 		}
@@ -1191,7 +1191,7 @@ dequeue_rx(struct idt77252_dev *card, st
 		__net_timestamp(skb);
 
 		vcc->push(vcc, skb);
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 
 		if (skb->truesize > SAR_FB_SIZE_3)
 			add_rx_skb(card, 3, SAR_FB_SIZE_3, 1);
@@ -1303,14 +1303,14 @@ idt77252_rx_raw(struct idt77252_dev *car
 		if (vcc->qos.aal != ATM_AAL0) {
 			RPRINTK("%s: raw cell for non AAL0 vc %u.%u\n",
 				card->name, vpi, vci);
-			atomic_inc(&vcc->stats->rx_drop);
+			atomic_inc_unchecked(&vcc->stats->rx_drop);
 			goto drop;
 		}
 	
 		if ((sb = dev_alloc_skb(64)) == NULL) {
 			printk("%s: Can't allocate buffers for AAL0.\n",
 			       card->name);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			goto drop;
 		}
 
@@ -1329,7 +1329,7 @@ idt77252_rx_raw(struct idt77252_dev *car
 		ATM_SKB(sb)->vcc = vcc;
 		__net_timestamp(sb);
 		vcc->push(vcc, sb);
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 
 drop:
 		skb_pull(queue, 64);
@@ -1954,13 +1954,13 @@ idt77252_send_skb(struct atm_vcc *vcc, s
 
 	if (vc == NULL) {
 		printk("%s: NULL connection in send().\n", card->name);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		dev_kfree_skb(skb);
 		return -EINVAL;
 	}
 	if (!test_bit(VCF_TX, &vc->flags)) {
 		printk("%s: Trying to transmit on a non-tx VC.\n", card->name);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		dev_kfree_skb(skb);
 		return -EINVAL;
 	}
@@ -1972,14 +1972,14 @@ idt77252_send_skb(struct atm_vcc *vcc, s
 		break;
 	default:
 		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		dev_kfree_skb(skb);
 		return -EINVAL;
 	}
 
 	if (skb_shinfo(skb)->nr_frags != 0) {
 		printk("%s: No scatter-gather yet.\n", card->name);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		dev_kfree_skb(skb);
 		return -EINVAL;
 	}
@@ -1987,7 +1987,7 @@ idt77252_send_skb(struct atm_vcc *vcc, s
 
 	err = queue_skb(card, vc, skb, oam);
 	if (err) {
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		dev_kfree_skb(skb);
 		return err;
 	}
@@ -2010,7 +2010,7 @@ idt77252_send_oam(struct atm_vcc *vcc, v
 	skb = dev_alloc_skb(64);
 	if (!skb) {
 		printk("%s: Out of memory in send_oam().\n", card->name);
-		atomic_inc(&vcc->stats->tx_err);
+		atomic_inc_unchecked(&vcc->stats->tx_err);
 		return -ENOMEM;
 	}
 	atomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/iphase.c linux-2.6.32.60-pax/drivers/atm/iphase.c
--- linux-2.6.32.60/drivers/atm/iphase.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/iphase.c	2012-03-13 13:15:34.916098002 +0100
@@ -1123,7 +1123,7 @@ static int rx_pkt(struct atm_dev *dev)
 	status = (u_short) (buf_desc_ptr->desc_mode);  
 	if (status & (RX_CER | RX_PTE | RX_OFL))  
 	{  
-                atomic_inc(&vcc->stats->rx_err);
+                atomic_inc_unchecked(&vcc->stats->rx_err);
 		IF_ERR(printk("IA: bad packet, dropping it");)  
                 if (status & RX_CER) { 
                     IF_ERR(printk(" cause: packet CRC error\n");)
@@ -1146,7 +1146,7 @@ static int rx_pkt(struct atm_dev *dev)
 	len = dma_addr - buf_addr;  
         if (len > iadev->rx_buf_sz) {
            printk("Over %d bytes sdu received, dropped!!!\n", iadev->rx_buf_sz);
-           atomic_inc(&vcc->stats->rx_err);
+           atomic_inc_unchecked(&vcc->stats->rx_err);
 	   goto out_free_desc;
         }
 		  
@@ -1296,7 +1296,7 @@ static void rx_dle_intr(struct atm_dev *
           ia_vcc = INPH_IA_VCC(vcc);
           if (ia_vcc == NULL)
           {
-             atomic_inc(&vcc->stats->rx_err);
+             atomic_inc_unchecked(&vcc->stats->rx_err);
              dev_kfree_skb_any(skb);
              atm_return(vcc, atm_guess_pdu2truesize(len));
              goto INCR_DLE;
@@ -1308,7 +1308,7 @@ static void rx_dle_intr(struct atm_dev *
           if ((length > iadev->rx_buf_sz) || (length > 
                               (skb->len - sizeof(struct cpcs_trailer))))
           {
-             atomic_inc(&vcc->stats->rx_err);
+             atomic_inc_unchecked(&vcc->stats->rx_err);
              IF_ERR(printk("rx_dle_intr: Bad  AAL5 trailer %d (skb len %d)", 
                                                             length, skb->len);)
              dev_kfree_skb_any(skb);
@@ -1324,7 +1324,7 @@ static void rx_dle_intr(struct atm_dev *
 
 	  IF_RX(printk("rx_dle_intr: skb push");)  
 	  vcc->push(vcc,skb);  
-	  atomic_inc(&vcc->stats->rx);
+	  atomic_inc_unchecked(&vcc->stats->rx);
           iadev->rx_pkt_cnt++;
       }  
 INCR_DLE:
@@ -2806,15 +2806,15 @@ static int ia_ioctl(struct atm_dev *dev,
          {
              struct k_sonet_stats *stats;
              stats = &PRIV(_ia_dev[board])->sonet_stats;
-             printk("section_bip: %d\n", atomic_read(&stats->section_bip));
-             printk("line_bip   : %d\n", atomic_read(&stats->line_bip));
-             printk("path_bip   : %d\n", atomic_read(&stats->path_bip));
-             printk("line_febe  : %d\n", atomic_read(&stats->line_febe));
-             printk("path_febe  : %d\n", atomic_read(&stats->path_febe));
-             printk("corr_hcs   : %d\n", atomic_read(&stats->corr_hcs));
-             printk("uncorr_hcs : %d\n", atomic_read(&stats->uncorr_hcs));
-             printk("tx_cells   : %d\n", atomic_read(&stats->tx_cells));
-             printk("rx_cells   : %d\n", atomic_read(&stats->rx_cells));
+             printk("section_bip: %d\n", atomic_read_unchecked(&stats->section_bip));
+             printk("line_bip   : %d\n", atomic_read_unchecked(&stats->line_bip));
+             printk("path_bip   : %d\n", atomic_read_unchecked(&stats->path_bip));
+             printk("line_febe  : %d\n", atomic_read_unchecked(&stats->line_febe));
+             printk("path_febe  : %d\n", atomic_read_unchecked(&stats->path_febe));
+             printk("corr_hcs   : %d\n", atomic_read_unchecked(&stats->corr_hcs));
+             printk("uncorr_hcs : %d\n", atomic_read_unchecked(&stats->uncorr_hcs));
+             printk("tx_cells   : %d\n", atomic_read_unchecked(&stats->tx_cells));
+             printk("rx_cells   : %d\n", atomic_read_unchecked(&stats->rx_cells));
          }
             ia_cmds.status = 0;
             break;
@@ -2919,7 +2919,7 @@ static int ia_pkt_tx (struct atm_vcc *vc
 	if ((desc == 0) || (desc > iadev->num_tx_desc))  
 	{  
 		IF_ERR(printk(DEV_LABEL "invalid desc for send: %d\n", desc);) 
-                atomic_inc(&vcc->stats->tx);
+                atomic_inc_unchecked(&vcc->stats->tx);
 		if (vcc->pop)   
 		    vcc->pop(vcc, skb);   
 		else  
@@ -3024,14 +3024,14 @@ static int ia_pkt_tx (struct atm_vcc *vc
         ATM_DESC(skb) = vcc->vci;
         skb_queue_tail(&iadev->tx_dma_q, skb);
 
-        atomic_inc(&vcc->stats->tx);
+        atomic_inc_unchecked(&vcc->stats->tx);
         iadev->tx_pkt_cnt++;
 	/* Increment transaction counter */  
 	writel(2, iadev->dma+IPHASE5575_TX_COUNTER);  
         
 #if 0        
         /* add flow control logic */ 
-        if (atomic_read(&vcc->stats->tx) % 20 == 0) {
+        if (atomic_read_unchecked(&vcc->stats->tx) % 20 == 0) {
           if (iavcc->vc_desc_cnt > 10) {
              vcc->tx_quota =  vcc->tx_quota * 3 / 4;
             printk("Tx1:  vcc->tx_quota = %d \n", (u32)vcc->tx_quota );
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/lanai.c linux-2.6.32.60-pax/drivers/atm/lanai.c
--- linux-2.6.32.60/drivers/atm/lanai.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/lanai.c	2012-03-13 13:15:34.916098002 +0100
@@ -1305,7 +1305,7 @@ static void lanai_send_one_aal5(struct l
 	vcc_tx_add_aal5_trailer(lvcc, skb->len, 0, 0);
 	lanai_endtx(lanai, lvcc);
 	lanai_free_skb(lvcc->tx.atmvcc, skb);
-	atomic_inc(&lvcc->tx.atmvcc->stats->tx);
+	atomic_inc_unchecked(&lvcc->tx.atmvcc->stats->tx);
 }
 
 /* Try to fill the buffer - don't call unless there is backlog */
@@ -1428,7 +1428,7 @@ static void vcc_rx_aal5(struct lanai_vcc
 	ATM_SKB(skb)->vcc = lvcc->rx.atmvcc;
 	__net_timestamp(skb);
 	lvcc->rx.atmvcc->push(lvcc->rx.atmvcc, skb);
-	atomic_inc(&lvcc->rx.atmvcc->stats->rx);
+	atomic_inc_unchecked(&lvcc->rx.atmvcc->stats->rx);
     out:
 	lvcc->rx.buf.ptr = end;
 	cardvcc_write(lvcc, endptr, vcc_rxreadptr);
@@ -1670,7 +1670,7 @@ static int handle_service(struct lanai_d
 		DPRINTK("(itf %d) got RX service entry 0x%X for non-AAL5 "
 		    "vcc %d\n", lanai->number, (unsigned int) s, vci);
 		lanai->stats.service_rxnotaal5++;
-		atomic_inc(&lvcc->rx.atmvcc->stats->rx_err);
+		atomic_inc_unchecked(&lvcc->rx.atmvcc->stats->rx_err);
 		return 0;
 	}
 	if (likely(!(s & (SERVICE_TRASH | SERVICE_STREAM | SERVICE_CRCERR)))) {
@@ -1682,7 +1682,7 @@ static int handle_service(struct lanai_d
 		int bytes;
 		read_unlock(&vcc_sklist_lock);
 		DPRINTK("got trashed rx pdu on vci %d\n", vci);
-		atomic_inc(&lvcc->rx.atmvcc->stats->rx_err);
+		atomic_inc_unchecked(&lvcc->rx.atmvcc->stats->rx_err);
 		lvcc->stats.x.aal5.service_trash++;
 		bytes = (SERVICE_GET_END(s) * 16) -
 		    (((unsigned long) lvcc->rx.buf.ptr) -
@@ -1694,7 +1694,7 @@ static int handle_service(struct lanai_d
 	}
 	if (s & SERVICE_STREAM) {
 		read_unlock(&vcc_sklist_lock);
-		atomic_inc(&lvcc->rx.atmvcc->stats->rx_err);
+		atomic_inc_unchecked(&lvcc->rx.atmvcc->stats->rx_err);
 		lvcc->stats.x.aal5.service_stream++;
 		printk(KERN_ERR DEV_LABEL "(itf %d): Got AAL5 stream "
 		    "PDU on VCI %d!\n", lanai->number, vci);
@@ -1702,7 +1702,7 @@ static int handle_service(struct lanai_d
 		return 0;
 	}
 	DPRINTK("got rx crc error on vci %d\n", vci);
-	atomic_inc(&lvcc->rx.atmvcc->stats->rx_err);
+	atomic_inc_unchecked(&lvcc->rx.atmvcc->stats->rx_err);
 	lvcc->stats.x.aal5.service_rxcrc++;
 	lvcc->rx.buf.ptr = &lvcc->rx.buf.start[SERVICE_GET_END(s) * 4];
 	cardvcc_write(lvcc, SERVICE_GET_END(s), vcc_rxreadptr);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/nicstar.c linux-2.6.32.60-pax/drivers/atm/nicstar.c
--- linux-2.6.32.60/drivers/atm/nicstar.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/nicstar.c	2012-03-13 13:15:34.920098001 +0100
@@ -1723,7 +1723,7 @@ static int ns_send(struct atm_vcc *vcc,
    if ((vc = (vc_map *) vcc->dev_data) == NULL)
    {
       printk("nicstar%d: vcc->dev_data == NULL on ns_send().\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
+      atomic_inc_unchecked(&vcc->stats->tx_err);
       dev_kfree_skb_any(skb);
       return -EINVAL;
    }
@@ -1731,7 +1731,7 @@ static int ns_send(struct atm_vcc *vcc,
    if (!vc->tx)
    {
       printk("nicstar%d: Trying to transmit on a non-tx VC.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
+      atomic_inc_unchecked(&vcc->stats->tx_err);
       dev_kfree_skb_any(skb);
       return -EINVAL;
    }
@@ -1739,7 +1739,7 @@ static int ns_send(struct atm_vcc *vcc,
    if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0)
    {
       printk("nicstar%d: Only AAL0 and AAL5 are supported.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
+      atomic_inc_unchecked(&vcc->stats->tx_err);
       dev_kfree_skb_any(skb);
       return -EINVAL;
    }
@@ -1747,7 +1747,7 @@ static int ns_send(struct atm_vcc *vcc,
    if (skb_shinfo(skb)->nr_frags != 0)
    {
       printk("nicstar%d: No scatter-gather yet.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
+      atomic_inc_unchecked(&vcc->stats->tx_err);
       dev_kfree_skb_any(skb);
       return -EINVAL;
    }
@@ -1792,11 +1792,11 @@ static int ns_send(struct atm_vcc *vcc,
 
    if (push_scqe(card, vc, scq, &scqe, skb) != 0)
    {
-      atomic_inc(&vcc->stats->tx_err);
+      atomic_inc_unchecked(&vcc->stats->tx_err);
       dev_kfree_skb_any(skb);
       return -EIO;
    }
-   atomic_inc(&vcc->stats->tx);
+   atomic_inc_unchecked(&vcc->stats->tx);
 
    return 0;
 }
@@ -2111,14 +2111,14 @@ static void dequeue_rx(ns_dev *card, ns_
          {
             printk("nicstar%d: Can't allocate buffers for aal0.\n",
                    card->index);
-            atomic_add(i,&vcc->stats->rx_drop);
+            atomic_add_unchecked(i,&vcc->stats->rx_drop);
             break;
          }
          if (!atm_charge(vcc, sb->truesize))
          {
             RXPRINTK("nicstar%d: atm_charge() dropped aal0 packets.\n",
                      card->index);
-            atomic_add(i-1,&vcc->stats->rx_drop); /* already increased by 1 */
+            atomic_add_unchecked(i-1,&vcc->stats->rx_drop); /* already increased by 1 */
             dev_kfree_skb_any(sb);
             break;
          }
@@ -2133,7 +2133,7 @@ static void dequeue_rx(ns_dev *card, ns_
          ATM_SKB(sb)->vcc = vcc;
 	 __net_timestamp(sb);
          vcc->push(vcc, sb);
-         atomic_inc(&vcc->stats->rx);
+         atomic_inc_unchecked(&vcc->stats->rx);
          cell += ATM_CELL_PAYLOAD;
       }
 
@@ -2152,7 +2152,7 @@ static void dequeue_rx(ns_dev *card, ns_
 	 if (iovb == NULL)
 	 {
 	    printk("nicstar%d: Out of iovec buffers.\n", card->index);
-            atomic_inc(&vcc->stats->rx_drop);
+            atomic_inc_unchecked(&vcc->stats->rx_drop);
             recycle_rx_buf(card, skb);
             return;
 	 }
@@ -2182,7 +2182,7 @@ static void dequeue_rx(ns_dev *card, ns_
    else if (NS_SKB(iovb)->iovcnt >= NS_MAX_IOVECS)
    {
       printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
-      atomic_inc(&vcc->stats->rx_err);
+      atomic_inc_unchecked(&vcc->stats->rx_err);
       recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data, NS_MAX_IOVECS);
       NS_SKB(iovb)->iovcnt = 0;
       iovb->len = 0;
@@ -2202,7 +2202,7 @@ static void dequeue_rx(ns_dev *card, ns_
          printk("nicstar%d: Expected a small buffer, and this is not one.\n",
 	        card->index);
          which_list(card, skb);
-         atomic_inc(&vcc->stats->rx_err);
+         atomic_inc_unchecked(&vcc->stats->rx_err);
          recycle_rx_buf(card, skb);
          vc->rx_iov = NULL;
          recycle_iov_buf(card, iovb);
@@ -2216,7 +2216,7 @@ static void dequeue_rx(ns_dev *card, ns_
          printk("nicstar%d: Expected a large buffer, and this is not one.\n",
 	        card->index);
          which_list(card, skb);
-         atomic_inc(&vcc->stats->rx_err);
+         atomic_inc_unchecked(&vcc->stats->rx_err);
          recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
 	                       NS_SKB(iovb)->iovcnt);
          vc->rx_iov = NULL;
@@ -2240,7 +2240,7 @@ static void dequeue_rx(ns_dev *card, ns_
             printk(" - PDU size mismatch.\n");
          else
             printk(".\n");
-         atomic_inc(&vcc->stats->rx_err);
+         atomic_inc_unchecked(&vcc->stats->rx_err);
          recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
 	   NS_SKB(iovb)->iovcnt);
 	 vc->rx_iov = NULL;
@@ -2256,7 +2256,7 @@ static void dequeue_rx(ns_dev *card, ns_
          if (!atm_charge(vcc, skb->truesize))
          {
             push_rxbufs(card, skb);
-            atomic_inc(&vcc->stats->rx_drop);
+            atomic_inc_unchecked(&vcc->stats->rx_drop);
          }
          else
 	 {
@@ -2268,7 +2268,7 @@ static void dequeue_rx(ns_dev *card, ns_
             ATM_SKB(skb)->vcc = vcc;
 	    __net_timestamp(skb);
             vcc->push(vcc, skb);
-            atomic_inc(&vcc->stats->rx);
+            atomic_inc_unchecked(&vcc->stats->rx);
          }
       }
       else if (NS_SKB(iovb)->iovcnt == 2)	/* One small plus one large buffer */
@@ -2283,7 +2283,7 @@ static void dequeue_rx(ns_dev *card, ns_
             if (!atm_charge(vcc, sb->truesize))
             {
                push_rxbufs(card, sb);
-               atomic_inc(&vcc->stats->rx_drop);
+               atomic_inc_unchecked(&vcc->stats->rx_drop);
             }
             else
 	    {
@@ -2295,7 +2295,7 @@ static void dequeue_rx(ns_dev *card, ns_
                ATM_SKB(sb)->vcc = vcc;
 	       __net_timestamp(sb);
                vcc->push(vcc, sb);
-               atomic_inc(&vcc->stats->rx);
+               atomic_inc_unchecked(&vcc->stats->rx);
             }
 
             push_rxbufs(card, skb);
@@ -2306,7 +2306,7 @@ static void dequeue_rx(ns_dev *card, ns_
             if (!atm_charge(vcc, skb->truesize))
             {
                push_rxbufs(card, skb);
-               atomic_inc(&vcc->stats->rx_drop);
+               atomic_inc_unchecked(&vcc->stats->rx_drop);
             }
             else
             {
@@ -2320,7 +2320,7 @@ static void dequeue_rx(ns_dev *card, ns_
                ATM_SKB(skb)->vcc = vcc;
 	       __net_timestamp(skb);
                vcc->push(vcc, skb);
-               atomic_inc(&vcc->stats->rx);
+               atomic_inc_unchecked(&vcc->stats->rx);
             }
 
             push_rxbufs(card, sb);
@@ -2342,7 +2342,7 @@ static void dequeue_rx(ns_dev *card, ns_
             if (hb == NULL)
             {
                printk("nicstar%d: Out of huge buffers.\n", card->index);
-               atomic_inc(&vcc->stats->rx_drop);
+               atomic_inc_unchecked(&vcc->stats->rx_drop);
                recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
 	                             NS_SKB(iovb)->iovcnt);
                vc->rx_iov = NULL;
@@ -2393,7 +2393,7 @@ static void dequeue_rx(ns_dev *card, ns_
             }
 	    else
 	       dev_kfree_skb_any(hb);
-	    atomic_inc(&vcc->stats->rx_drop);
+	    atomic_inc_unchecked(&vcc->stats->rx_drop);
          }
          else
 	 {
@@ -2427,7 +2427,7 @@ static void dequeue_rx(ns_dev *card, ns_
 #endif /* NS_USE_DESTRUCTORS */
 	    __net_timestamp(hb);
             vcc->push(vcc, hb);
-            atomic_inc(&vcc->stats->rx);
+            atomic_inc_unchecked(&vcc->stats->rx);
          }
       }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/solos-pci.c linux-2.6.32.60-pax/drivers/atm/solos-pci.c
--- linux-2.6.32.60/drivers/atm/solos-pci.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/solos-pci.c	2012-03-13 13:15:34.920098001 +0100
@@ -708,7 +708,7 @@ void solos_bh(unsigned long card_arg)
 				}
 				atm_charge(vcc, skb->truesize);
 				vcc->push(vcc, skb);
-				atomic_inc(&vcc->stats->rx);
+				atomic_inc_unchecked(&vcc->stats->rx);
 				break;
 
 			case PKT_STATUS:
@@ -1023,7 +1023,7 @@ static uint32_t fpga_tx(struct solos_car
 			vcc = SKB_CB(oldskb)->vcc;
 
 			if (vcc) {
-				atomic_inc(&vcc->stats->tx);
+				atomic_inc_unchecked(&vcc->stats->tx);
 				solos_pop(vcc, oldskb);
 			} else
 				dev_kfree_skb_irq(oldskb);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/suni.c linux-2.6.32.60-pax/drivers/atm/suni.c
--- linux-2.6.32.60/drivers/atm/suni.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/suni.c	2012-03-13 13:15:34.920098001 +0100
@@ -49,8 +49,8 @@ static DEFINE_SPINLOCK(sunis_lock);
 
 
 #define ADD_LIMITED(s,v) \
-    atomic_add((v),&stats->s); \
-    if (atomic_read(&stats->s) < 0) atomic_set(&stats->s,INT_MAX);
+    atomic_add_unchecked((v),&stats->s); \
+    if (atomic_read_unchecked(&stats->s) < 0) atomic_set_unchecked(&stats->s,INT_MAX);
 
 
 static void suni_hz(unsigned long from_timer)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/uPD98402.c linux-2.6.32.60-pax/drivers/atm/uPD98402.c
--- linux-2.6.32.60/drivers/atm/uPD98402.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/uPD98402.c	2012-03-13 13:15:34.924098001 +0100
@@ -41,7 +41,7 @@ static int fetch_stats(struct atm_dev *d
 	struct sonet_stats tmp;
  	int error = 0;
 
-	atomic_add(GET(HECCT),&PRIV(dev)->sonet_stats.uncorr_hcs);
+	atomic_add_unchecked(GET(HECCT),&PRIV(dev)->sonet_stats.uncorr_hcs);
 	sonet_copy_stats(&PRIV(dev)->sonet_stats,&tmp);
 	if (arg) error = copy_to_user(arg,&tmp,sizeof(tmp));
 	if (zero && !error) {
@@ -160,9 +160,9 @@ static int uPD98402_ioctl(struct atm_dev
 
 
 #define ADD_LIMITED(s,v) \
-    { atomic_add(GET(v),&PRIV(dev)->sonet_stats.s); \
-    if (atomic_read(&PRIV(dev)->sonet_stats.s) < 0) \
-	atomic_set(&PRIV(dev)->sonet_stats.s,INT_MAX); }
+    { atomic_add_unchecked(GET(v),&PRIV(dev)->sonet_stats.s); \
+    if (atomic_read_unchecked(&PRIV(dev)->sonet_stats.s) < 0) \
+	atomic_set_unchecked(&PRIV(dev)->sonet_stats.s,INT_MAX); }
 
 
 static void stat_event(struct atm_dev *dev)
@@ -193,7 +193,7 @@ static void uPD98402_int(struct atm_dev
 		if (reason & uPD98402_INT_PFM) stat_event(dev);
 		if (reason & uPD98402_INT_PCO) {
 			(void) GET(PCOCR); /* clear interrupt cause */
-			atomic_add(GET(HECCT),
+			atomic_add_unchecked(GET(HECCT),
 			    &PRIV(dev)->sonet_stats.uncorr_hcs);
 		}
 		if ((reason & uPD98402_INT_RFO) && 
@@ -221,9 +221,9 @@ static int uPD98402_start(struct atm_dev
 	PUT(~(uPD98402_INT_PFM | uPD98402_INT_ALM | uPD98402_INT_RFO |
 	  uPD98402_INT_LOS),PIMR); /* enable them */
 	(void) fetch_stats(dev,NULL,1); /* clear kernel counters */
-	atomic_set(&PRIV(dev)->sonet_stats.corr_hcs,-1);
-	atomic_set(&PRIV(dev)->sonet_stats.tx_cells,-1);
-	atomic_set(&PRIV(dev)->sonet_stats.rx_cells,-1);
+	atomic_set_unchecked(&PRIV(dev)->sonet_stats.corr_hcs,-1);
+	atomic_set_unchecked(&PRIV(dev)->sonet_stats.tx_cells,-1);
+	atomic_set_unchecked(&PRIV(dev)->sonet_stats.rx_cells,-1);
 	return 0;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/atm/zatm.c linux-2.6.32.60-pax/drivers/atm/zatm.c
--- linux-2.6.32.60/drivers/atm/zatm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/atm/zatm.c	2012-03-13 13:15:34.924098001 +0100
@@ -458,7 +458,7 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy
 		}
 		if (!size) {
 			dev_kfree_skb_irq(skb);
-			if (vcc) atomic_inc(&vcc->stats->rx_err);
+			if (vcc) atomic_inc_unchecked(&vcc->stats->rx_err);
 			continue;
 		}
 		if (!atm_charge(vcc,skb->truesize)) {
@@ -468,7 +468,7 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy
 		skb->len = size;
 		ATM_SKB(skb)->vcc = vcc;
 		vcc->push(vcc,skb);
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 	}
 	zout(pos & 0xffff,MTA(mbx));
 #if 0 /* probably a stupid idea */
@@ -732,7 +732,7 @@ if (*ZATM_PRV_DSC(skb) != (uPD98401_TXPD
 			skb_queue_head(&zatm_vcc->backlog,skb);
 			break;
 		}
-	atomic_inc(&vcc->stats->tx);
+	atomic_inc_unchecked(&vcc->stats->tx);
 	wake_up(&zatm_vcc->tx_wait);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/block/cciss.c linux-2.6.32.60-pax/drivers/block/cciss.c
--- linux-2.6.32.60/drivers/block/cciss.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/block/cciss.c	2012-03-13 13:15:34.924098001 +0100
@@ -2852,7 +2852,7 @@ static unsigned long pollcomplete(int ct
 	/* Wait (up to 20 seconds) for a command to complete */
 
 	for (i = 20 * HZ; i > 0; i--) {
-		done = hba[ctlr]->access.command_completed(hba[ctlr]);
+		done = hba[ctlr]->access->command_completed(hba[ctlr]);
 		if (done == FIFO_EMPTY)
 			schedule_timeout_uninterruptible(1);
 		else
@@ -2876,7 +2876,7 @@ static int sendcmd_core(ctlr_info_t *h,
 resend_cmd1:
 
 	/* Disable interrupt on the board. */
-	h->access.set_intr_mask(h, CCISS_INTR_OFF);
+	h->access->set_intr_mask(h, CCISS_INTR_OFF);
 
 	/* Make sure there is room in the command FIFO */
 	/* Actually it should be completely empty at this time */
@@ -2884,13 +2884,13 @@ resend_cmd1:
 	/* tape side of the driver. */
 	for (i = 200000; i > 0; i--) {
 		/* if fifo isn't full go */
-		if (!(h->access.fifo_full(h)))
+		if (!(h->access->fifo_full(h)))
 			break;
 		udelay(10);
 		printk(KERN_WARNING "cciss cciss%d: SendCmd FIFO full,"
 		       " waiting!\n", h->ctlr);
 	}
-	h->access.submit_command(h, c); /* Send the cmd */
+	h->access->submit_command(h, c); /* Send the cmd */
 	do {
 		complete = pollcomplete(h->ctlr);
 
@@ -3023,7 +3023,7 @@ static void start_io(ctlr_info_t *h)
 	while (!hlist_empty(&h->reqQ)) {
 		c = hlist_entry(h->reqQ.first, CommandList_struct, list);
 		/* can't do anything if fifo is full */
-		if ((h->access.fifo_full(h))) {
+		if ((h->access->fifo_full(h))) {
 			printk(KERN_WARNING "cciss: fifo full\n");
 			break;
 		}
@@ -3033,7 +3033,7 @@ static void start_io(ctlr_info_t *h)
 		h->Qdepth--;
 
 		/* Tell the controller execute command */
-		h->access.submit_command(h, c);
+		h->access->submit_command(h, c);
 
 		/* Put job onto the completed Q */
 		addQ(&h->cmpQ, c);
@@ -3393,17 +3393,17 @@ startio:
 
 static inline unsigned long get_next_completion(ctlr_info_t *h)
 {
-	return h->access.command_completed(h);
+	return h->access->command_completed(h);
 }
 
 static inline int interrupt_pending(ctlr_info_t *h)
 {
-	return h->access.intr_pending(h);
+	return h->access->intr_pending(h);
 }
 
 static inline long interrupt_not_for_us(ctlr_info_t *h)
 {
-	return (((h->access.intr_pending(h) == 0) ||
+	return (((h->access->intr_pending(h) == 0) ||
 		 (h->interrupts_enabled == 0)));
 }
 
@@ -3892,7 +3892,7 @@ static int __devinit cciss_pci_init(ctlr
 	 */
 	c->max_commands = readl(&(c->cfgtable->CmdsOutMax));
 	c->product_name = products[prod_index].product_name;
-	c->access = *(products[prod_index].access);
+	c->access = products[prod_index].access;
 	c->nr_cmds = c->max_commands - 4;
 	if ((readb(&c->cfgtable->Signature[0]) != 'C') ||
 	    (readb(&c->cfgtable->Signature[1]) != 'I') ||
@@ -4291,7 +4291,7 @@ static int __devinit cciss_init_one(stru
 	}
 
 	/* make sure the board interrupts are off */
-	hba[i]->access.set_intr_mask(hba[i], CCISS_INTR_OFF);
+	hba[i]->access->set_intr_mask(hba[i], CCISS_INTR_OFF);
 	if (request_irq(hba[i]->intr[SIMPLE_MODE_INT], do_cciss_intr,
 			IRQF_DISABLED | IRQF_SHARED, hba[i]->devname, hba[i])) {
 		printk(KERN_ERR "cciss: Unable to get irq %d for %s\n",
@@ -4341,7 +4341,7 @@ static int __devinit cciss_init_one(stru
 	cciss_scsi_setup(i);
 
 	/* Turn the interrupts on so we can service requests */
-	hba[i]->access.set_intr_mask(hba[i], CCISS_INTR_ON);
+	hba[i]->access->set_intr_mask(hba[i], CCISS_INTR_ON);
 
 	/* Get the firmware version */
 	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/block/cciss.h linux-2.6.32.60-pax/drivers/block/cciss.h
--- linux-2.6.32.60/drivers/block/cciss.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/block/cciss.h	2012-03-13 13:15:34.928098001 +0100
@@ -90,7 +90,7 @@ struct ctlr_info
 	// information about each logical volume
 	drive_info_struct *drv[CISS_MAX_LUN];
 
-	struct access_method access;
+	struct access_method *access;
 
 	/* queue and queue Info */ 
 	struct hlist_head reqQ;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/block/cpqarray.c linux-2.6.32.60-pax/drivers/block/cpqarray.c
--- linux-2.6.32.60/drivers/block/cpqarray.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/block/cpqarray.c	2012-03-13 13:15:34.928098001 +0100
@@ -402,7 +402,7 @@ static int __init cpqarray_register_ctlr
 	if (register_blkdev(COMPAQ_SMART2_MAJOR+i, hba[i]->devname)) {
 		goto Enomem4;
 	}
-	hba[i]->access.set_intr_mask(hba[i], 0);
+	hba[i]->access->set_intr_mask(hba[i], 0);
 	if (request_irq(hba[i]->intr, do_ida_intr,
 		IRQF_DISABLED|IRQF_SHARED, hba[i]->devname, hba[i]))
 	{
@@ -460,7 +460,7 @@ static int __init cpqarray_register_ctlr
 	add_timer(&hba[i]->timer);
 
 	/* Enable IRQ now that spinlock and rate limit timer are set up */
-	hba[i]->access.set_intr_mask(hba[i], FIFO_NOT_EMPTY);
+	hba[i]->access->set_intr_mask(hba[i], FIFO_NOT_EMPTY);
 
 	for(j=0; j<NWD; j++) {
 		struct gendisk *disk = ida_gendisk[i][j];
@@ -695,7 +695,7 @@ DBGINFO(
 	for(i=0; i<NR_PRODUCTS; i++) {
 		if (board_id == products[i].board_id) {
 			c->product_name = products[i].product_name;
-			c->access = *(products[i].access);
+			c->access = products[i].access;
 			break;
 		}
 	}
@@ -793,7 +793,7 @@ static int __init cpqarray_eisa_detect(v
 		hba[ctlr]->intr = intr;
 		sprintf(hba[ctlr]->devname, "ida%d", nr_ctlr);
 		hba[ctlr]->product_name = products[j].product_name;
-		hba[ctlr]->access = *(products[j].access);
+		hba[ctlr]->access = products[j].access;
 		hba[ctlr]->ctlr = ctlr;
 		hba[ctlr]->board_id = board_id;
 		hba[ctlr]->pci_dev = NULL; /* not PCI */
@@ -968,7 +968,7 @@ static void start_io(ctlr_info_t *h)
 
 	while((c = h->reqQ) != NULL) {
 		/* Can't do anything if we're busy */
-		if (h->access.fifo_full(h) == 0)
+		if (h->access->fifo_full(h) == 0)
 			return;
 
 		/* Get the first entry from the request Q */
@@ -976,7 +976,7 @@ static void start_io(ctlr_info_t *h)
 		h->Qdepth--;
 	
 		/* Tell the controller to do our bidding */
-		h->access.submit_command(h, c);
+		h->access->submit_command(h, c);
 
 		/* Get onto the completion Q */
 		addQ(&h->cmpQ, c);
@@ -1038,7 +1038,7 @@ static irqreturn_t do_ida_intr(int irq,
 	unsigned long flags;
 	__u32 a,a1;
 
-	istat = h->access.intr_pending(h);
+	istat = h->access->intr_pending(h);
 	/* Is this interrupt for us? */
 	if (istat == 0)
 		return IRQ_NONE;
@@ -1049,7 +1049,7 @@ static irqreturn_t do_ida_intr(int irq,
 	 */
 	spin_lock_irqsave(IDA_LOCK(h->ctlr), flags);
 	if (istat & FIFO_NOT_EMPTY) {
-		while((a = h->access.command_completed(h))) {
+		while((a = h->access->command_completed(h))) {
 			a1 = a; a &= ~3;
 			if ((c = h->cmpQ) == NULL)
 			{  
@@ -1434,11 +1434,11 @@ static int sendcmd(
 	/*
 	 * Disable interrupt
 	 */
-	info_p->access.set_intr_mask(info_p, 0);
+	info_p->access->set_intr_mask(info_p, 0);
 	/* Make sure there is room in the command FIFO */
 	/* Actually it should be completely empty at this time. */
 	for (i = 200000; i > 0; i--) {
-		temp = info_p->access.fifo_full(info_p);
+		temp = info_p->access->fifo_full(info_p);
 		if (temp != 0) {
 			break;
 		}
@@ -1451,7 +1451,7 @@ DBG(
 	/*
 	 * Send the cmd
 	 */
-	info_p->access.submit_command(info_p, c);
+	info_p->access->submit_command(info_p, c);
 	complete = pollcomplete(ctlr);
 	
 	pci_unmap_single(info_p->pci_dev, (dma_addr_t) c->req.sg[0].addr, 
@@ -1534,9 +1534,9 @@ static int revalidate_allvol(ctlr_info_t
 	 * we check the new geometry.  Then turn interrupts back on when
 	 * we're done.
 	 */
-	host->access.set_intr_mask(host, 0);
+	host->access->set_intr_mask(host, 0);
 	getgeometry(ctlr);
-	host->access.set_intr_mask(host, FIFO_NOT_EMPTY);
+	host->access->set_intr_mask(host, FIFO_NOT_EMPTY);
 
 	for(i=0; i<NWD; i++) {
 		struct gendisk *disk = ida_gendisk[ctlr][i];
@@ -1576,7 +1576,7 @@ static int pollcomplete(int ctlr)
 	/* Wait (up to 2 seconds) for a command to complete */
 
 	for (i = 200000; i > 0; i--) {
-		done = hba[ctlr]->access.command_completed(hba[ctlr]);
+		done = hba[ctlr]->access->command_completed(hba[ctlr]);
 		if (done == 0) {
 			udelay(10);	/* a short fixed delay */
 		} else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/block/cpqarray.h linux-2.6.32.60-pax/drivers/block/cpqarray.h
--- linux-2.6.32.60/drivers/block/cpqarray.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/block/cpqarray.h	2012-03-13 13:15:34.928098001 +0100
@@ -99,7 +99,7 @@ struct ctlr_info {
 	drv_info_t	drv[NWD];
 	struct proc_dir_entry *proc;
 
-	struct access_method access;
+	struct access_method *access;
 
 	cmdlist_t *reqQ;
 	cmdlist_t *cmpQ;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/block/loop.c linux-2.6.32.60-pax/drivers/block/loop.c
--- linux-2.6.32.60/drivers/block/loop.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/block/loop.c	2012-03-13 13:15:34.932098001 +0100
@@ -282,7 +282,7 @@ static int __do_lo_send_write(struct fil
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(get_ds());
-	bw = file->f_op->write(file, buf, len, &pos);
+	bw = file->f_op->write(file, (const char __force_user *)buf, len, &pos);
 	set_fs(old_fs);
 	if (likely(bw == len))
 		return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/cdrom/cdrom.c linux-2.6.32.60-pax/drivers/cdrom/cdrom.c
--- linux-2.6.32.60/drivers/cdrom/cdrom.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/cdrom/cdrom.c	2013-01-22 17:38:23.548543627 +0100
@@ -410,7 +410,6 @@ int register_cdrom(struct cdrom_device_i
 	ENSURE(reset, CDC_RESET);
 	ENSURE(generic_packet, CDC_GENERIC_PACKET);
 	cdi->mc_flags = 0;
-	cdo->n_minors = 0;
         cdi->options = CDO_USE_FFLAGS;
 	
 	if (autoclose==1 && CDROM_CAN(CDC_CLOSE_TRAY))
@@ -430,8 +429,11 @@ int register_cdrom(struct cdrom_device_i
 	else
 		cdi->cdda_method = CDDA_OLD;
 
-	if (!cdo->generic_packet)
-		cdo->generic_packet = cdrom_dummy_generic_packet;
+	if (!cdo->generic_packet) {
+		pax_open_kernel();
+		*(void **)&cdo->generic_packet = cdrom_dummy_generic_packet;
+		pax_close_kernel();
+	}
 
 	cdinfo(CD_REG_UNREG, "drive \"/dev/%s\" registered\n", cdi->name);
 	mutex_lock(&cdrom_mutex);
@@ -452,7 +454,6 @@ void unregister_cdrom(struct cdrom_devic
 	if (cdi->exit)
 		cdi->exit(cdi);
 
-	cdi->ops->n_minors--;
 	cdinfo(CD_REG_UNREG, "drive \"/dev/%s\" unregistered\n", cdi->name);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/cdrom/gdrom.c linux-2.6.32.60-pax/drivers/cdrom/gdrom.c
--- linux-2.6.32.60/drivers/cdrom/gdrom.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/cdrom/gdrom.c	2013-01-22 17:38:23.548543627 +0100
@@ -487,7 +487,6 @@ static struct cdrom_device_ops gdrom_ops
 	.audio_ioctl		= gdrom_audio_ioctl,
 	.capability		= CDC_MULTI_SESSION | CDC_MEDIA_CHANGED |
 				  CDC_RESET | CDC_DRIVE_STATUS | CDC_CD_R,
-	.n_minors		= 1,
 };
 
 static int gdrom_bdops_open(struct block_device *bdev, fmode_t mode)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/agp/frontend.c linux-2.6.32.60-pax/drivers/char/agp/frontend.c
--- linux-2.6.32.60/drivers/char/agp/frontend.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/agp/frontend.c	2012-03-13 13:15:34.932098001 +0100
@@ -824,7 +824,7 @@ static int agpioc_reserve_wrap(struct ag
 	if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))
 		return -EFAULT;
 
-	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))
+	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment_priv))
 		return -EFAULT;
 
 	client = agp_find_client_by_pid(reserve.pid);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/hpet.c linux-2.6.32.60-pax/drivers/char/hpet.c
--- linux-2.6.32.60/drivers/char/hpet.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/hpet.c	2012-03-13 13:15:34.932098001 +0100
@@ -430,7 +430,7 @@ static int hpet_release(struct inode *in
 	return 0;
 }
 
-static int hpet_ioctl_common(struct hpet_dev *, int, unsigned long, int);
+static int hpet_ioctl_common(struct hpet_dev *, unsigned int, unsigned long, int);
 
 static int
 hpet_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
@@ -565,7 +565,7 @@ static inline unsigned long hpet_time_di
 }
 
 static int
-hpet_ioctl_common(struct hpet_dev *devp, int cmd, unsigned long arg, int kernel)
+hpet_ioctl_common(struct hpet_dev *devp, unsigned int cmd, unsigned long arg, int kernel)
 {
 	struct hpet_timer __iomem *timer;
 	struct hpet __iomem *hpet;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/hvcs.c linux-2.6.32.60-pax/drivers/char/hvcs.c
--- linux-2.6.32.60/drivers/char/hvcs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/hvcs.c	2012-03-13 13:15:34.932098001 +0100
@@ -82,6 +82,7 @@
 #include <asm/hvcserver.h>
 #include <asm/uaccess.h>
 #include <asm/vio.h>
+#include <asm/local.h>
 
 /*
  * 1.3.0 -> 1.3.1 In hvcs_open memset(..,0x00,..) instead of memset(..,0x3F,00).
@@ -269,7 +270,7 @@ struct hvcs_struct {
 	unsigned int index;
 
 	struct tty_struct *tty;
-	int open_count;
+	local_t open_count;
 
 	/*
 	 * Used to tell the driver kernel_thread what operations need to take
@@ -419,7 +420,7 @@ static ssize_t hvcs_vterm_state_store(st
 
 	spin_lock_irqsave(&hvcsd->lock, flags);
 
-	if (hvcsd->open_count > 0) {
+	if (local_read(&hvcsd->open_count) > 0) {
 		spin_unlock_irqrestore(&hvcsd->lock, flags);
 		printk(KERN_INFO "HVCS: vterm state unchanged.  "
 				"The hvcs device node is still in use.\n");
@@ -1135,7 +1136,7 @@ static int hvcs_open(struct tty_struct *
 		if ((retval = hvcs_partner_connect(hvcsd)))
 			goto error_release;
 
-	hvcsd->open_count = 1;
+	local_set(&hvcsd->open_count, 1);
 	hvcsd->tty = tty;
 	tty->driver_data = hvcsd;
 
@@ -1169,7 +1170,7 @@ fast_open:
 
 	spin_lock_irqsave(&hvcsd->lock, flags);
 	kref_get(&hvcsd->kref);
-	hvcsd->open_count++;
+	local_inc(&hvcsd->open_count);
 	hvcsd->todo_mask |= HVCS_SCHED_READ;
 	spin_unlock_irqrestore(&hvcsd->lock, flags);
 
@@ -1213,7 +1214,7 @@ static void hvcs_close(struct tty_struct
 	hvcsd = tty->driver_data;
 
 	spin_lock_irqsave(&hvcsd->lock, flags);
-	if (--hvcsd->open_count == 0) {
+	if (local_dec_and_test(&hvcsd->open_count)) {
 
 		vio_disable_interrupts(hvcsd->vdev);
 
@@ -1239,10 +1240,10 @@ static void hvcs_close(struct tty_struct
 		free_irq(irq, hvcsd);
 		kref_put(&hvcsd->kref, destroy_hvcs_struct);
 		return;
-	} else if (hvcsd->open_count < 0) {
+	} else if (local_read(&hvcsd->open_count) < 0) {
 		printk(KERN_ERR "HVCS: vty-server@%X open_count: %d"
 				" is missmanaged.\n",
-		hvcsd->vdev->unit_address, hvcsd->open_count);
+		hvcsd->vdev->unit_address, local_read(&hvcsd->open_count));
 	}
 
 	spin_unlock_irqrestore(&hvcsd->lock, flags);
@@ -1258,7 +1259,7 @@ static void hvcs_hangup(struct tty_struc
 
 	spin_lock_irqsave(&hvcsd->lock, flags);
 	/* Preserve this so that we know how many kref refs to put */
-	temp_open_count = hvcsd->open_count;
+	temp_open_count = local_read(&hvcsd->open_count);
 
 	/*
 	 * Don't kref put inside the spinlock because the destruction
@@ -1273,7 +1274,7 @@ static void hvcs_hangup(struct tty_struc
 	hvcsd->tty->driver_data = NULL;
 	hvcsd->tty = NULL;
 
-	hvcsd->open_count = 0;
+	local_set(&hvcsd->open_count, 0);
 
 	/* This will drop any buffered data on the floor which is OK in a hangup
 	 * scenario. */
@@ -1344,7 +1345,7 @@ static int hvcs_write(struct tty_struct
 	 * the middle of a write operation?  This is a crummy place to do this
 	 * but we want to keep it all in the spinlock.
 	 */
-	if (hvcsd->open_count <= 0) {
+	if (local_read(&hvcsd->open_count) <= 0) {
 		spin_unlock_irqrestore(&hvcsd->lock, flags);
 		return -ENODEV;
 	}
@@ -1418,7 +1419,7 @@ static int hvcs_write_room(struct tty_st
 {
 	struct hvcs_struct *hvcsd = tty->driver_data;
 
-	if (!hvcsd || hvcsd->open_count <= 0)
+	if (!hvcsd || local_read(&hvcsd->open_count) <= 0)
 		return 0;
 
 	return HVCS_BUFF_LEN - hvcsd->chars_in_buffer;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/ipmi/ipmi_msghandler.c linux-2.6.32.60-pax/drivers/char/ipmi/ipmi_msghandler.c
--- linux-2.6.32.60/drivers/char/ipmi/ipmi_msghandler.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/ipmi/ipmi_msghandler.c	2012-03-13 13:15:34.936098000 +0100
@@ -414,7 +414,7 @@ struct ipmi_smi {
 	struct proc_dir_entry *proc_dir;
 	char                  proc_dir_name[10];
 
-	atomic_t stats[IPMI_NUM_STATS];
+	atomic_unchecked_t stats[IPMI_NUM_STATS];
 
 	/*
 	 * run_to_completion duplicate of smb_info, smi_info
@@ -447,9 +447,9 @@ static DEFINE_MUTEX(smi_watchers_mutex);
 
 
 #define ipmi_inc_stat(intf, stat) \
-	atomic_inc(&(intf)->stats[IPMI_STAT_ ## stat])
+	atomic_inc_unchecked(&(intf)->stats[IPMI_STAT_ ## stat])
 #define ipmi_get_stat(intf, stat) \
-	((unsigned int) atomic_read(&(intf)->stats[IPMI_STAT_ ## stat]))
+	((unsigned int) atomic_read_unchecked(&(intf)->stats[IPMI_STAT_ ## stat]))
 
 static int is_lan_addr(struct ipmi_addr *addr)
 {
@@ -2808,7 +2808,7 @@ int ipmi_register_smi(struct ipmi_smi_ha
 	INIT_LIST_HEAD(&intf->cmd_rcvrs);
 	init_waitqueue_head(&intf->waitq);
 	for (i = 0; i < IPMI_NUM_STATS; i++)
-		atomic_set(&intf->stats[i], 0);
+		atomic_set_unchecked(&intf->stats[i], 0);
 
 	intf->proc_dir = NULL;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/ipmi/ipmi_si_intf.c linux-2.6.32.60-pax/drivers/char/ipmi/ipmi_si_intf.c
--- linux-2.6.32.60/drivers/char/ipmi/ipmi_si_intf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/ipmi/ipmi_si_intf.c	2012-03-13 13:15:34.936098000 +0100
@@ -277,7 +277,7 @@ struct smi_info {
 	unsigned char slave_addr;
 
 	/* Counters and things for the proc filesystem. */
-	atomic_t stats[SI_NUM_STATS];
+	atomic_unchecked_t stats[SI_NUM_STATS];
 
 	struct task_struct *thread;
 
@@ -285,9 +285,9 @@ struct smi_info {
 };
 
 #define smi_inc_stat(smi, stat) \
-	atomic_inc(&(smi)->stats[SI_STAT_ ## stat])
+	atomic_inc_unchecked(&(smi)->stats[SI_STAT_ ## stat])
 #define smi_get_stat(smi, stat) \
-	((unsigned int) atomic_read(&(smi)->stats[SI_STAT_ ## stat]))
+	((unsigned int) atomic_read_unchecked(&(smi)->stats[SI_STAT_ ## stat]))
 
 #define SI_MAX_PARMS 4
 
@@ -2931,7 +2931,7 @@ static int try_smi_init(struct smi_info
 	atomic_set(&new_smi->req_events, 0);
 	new_smi->run_to_completion = 0;
 	for (i = 0; i < SI_NUM_STATS; i++)
-		atomic_set(&new_smi->stats[i], 0);
+		atomic_set_unchecked(&new_smi->stats[i], 0);
 
 	new_smi->interrupt_disabled = 0;
 	atomic_set(&new_smi->stop_operation, 0);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/keyboard.c linux-2.6.32.60-pax/drivers/char/keyboard.c
--- linux-2.6.32.60/drivers/char/keyboard.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/keyboard.c	2012-03-13 13:15:34.940098000 +0100
@@ -1386,7 +1386,7 @@ static const struct input_device_id kbd_
                 .evbit = { BIT_MASK(EV_SND) },
         },
 
-	{ },    /* Terminating entry */
+	{ 0 },    /* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(input, kbd_ids);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/mbcs.c linux-2.6.32.60-pax/drivers/char/mbcs.c
--- linux-2.6.32.60/drivers/char/mbcs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/mbcs.c	2012-03-13 13:15:34.940098000 +0100
@@ -799,7 +799,7 @@ static int mbcs_remove(struct cx_dev *de
 	return 0;
 }
 
-static const struct cx_device_id __devinitdata mbcs_id_table[] = {
+static const struct cx_device_id __devinitconst mbcs_id_table[] = {
 	{
 	 .part_num = MBCS_PART_NUM,
 	 .mfg_num = MBCS_MFG_NUM,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/mem.c linux-2.6.32.60-pax/drivers/char/mem.c
--- linux-2.6.32.60/drivers/char/mem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/mem.c	2012-07-27 21:50:49.110341381 +0200
@@ -155,6 +155,8 @@ static ssize_t read_mem(struct file * fi
 #endif
 
 	while (count > 0) {
+		char *temp;
+
 		/*
 		 * Handle first page in case it's not aligned
 		 */
@@ -177,11 +179,31 @@ static ssize_t read_mem(struct file * fi
 		if (!ptr)
 			return -EFAULT;
 
-		if (copy_to_user(buf, ptr, sz)) {
+#ifdef CONFIG_PAX_USERCOPY
+		temp = kmalloc(sz, GFP_KERNEL|GFP_USERCOPY);
+		if (!temp) {
+			unxlate_dev_mem_ptr(p, ptr);
+			return -ENOMEM;
+		}
+		memcpy(temp, ptr, sz);
+#else
+		temp = ptr;
+#endif
+
+		if (copy_to_user(buf, temp, sz)) {
+
+#ifdef CONFIG_PAX_USERCOPY
+			kfree(temp);
+#endif
+
 			unxlate_dev_mem_ptr(p, ptr);
 			return -EFAULT;
 		}
 
+#ifdef CONFIG_PAX_USERCOPY
+		kfree(temp);
+#endif
+
 		unxlate_dev_mem_ptr(p, ptr);
 
 		buf += sz;
@@ -419,9 +441,8 @@ static ssize_t read_kmem(struct file *fi
 			 size_t count, loff_t *ppos)
 {
 	unsigned long p = *ppos;
-	ssize_t low_count, read, sz;
+	ssize_t low_count, read, sz, err = 0;
 	char * kbuf; /* k-addr because vread() takes vmlist_lock rwlock */
-	int err = 0;
 
 	read = 0;
 	if (p < (unsigned long) high_memory) {
@@ -444,6 +465,8 @@ static ssize_t read_kmem(struct file *fi
 		}
 #endif
 		while (low_count > 0) {
+			char *temp;
+
 			sz = size_inside_page(p, low_count);
 
 			/*
@@ -453,7 +476,22 @@ static ssize_t read_kmem(struct file *fi
 			 */
 			kbuf = xlate_dev_kmem_ptr((char *)p);
 
-			if (copy_to_user(buf, kbuf, sz))
+#ifdef CONFIG_PAX_USERCOPY
+			temp = kmalloc(sz, GFP_KERNEL|GFP_USERCOPY);
+			if (!temp)
+				return -ENOMEM;
+			memcpy(temp, kbuf, sz);
+#else
+			temp = kbuf;
+#endif
+
+			err = copy_to_user(buf, temp, sz);
+
+#ifdef CONFIG_PAX_USERCOPY
+			kfree(temp);
+#endif
+
+			if (err)
 				return -EFAULT;
 			buf += sz;
 			p += sz;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/mmtimer.c linux-2.6.32.60-pax/drivers/char/mmtimer.c
--- linux-2.6.32.60/drivers/char/mmtimer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/mmtimer.c	2012-03-13 13:15:34.944098000 +0100
@@ -756,7 +756,7 @@ static int sgi_timer_set(struct k_itimer
 	return err;
 }
 
-static struct k_clock sgi_clock = {
+static k_clock_no_const sgi_clock = {
 	.res = 0,
 	.clock_set = sgi_clock_set,
 	.clock_get = sgi_clock_get,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/pcmcia/ipwireless/tty.c linux-2.6.32.60-pax/drivers/char/pcmcia/ipwireless/tty.c
--- linux-2.6.32.60/drivers/char/pcmcia/ipwireless/tty.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/pcmcia/ipwireless/tty.c	2012-03-13 13:15:34.944098000 +0100
@@ -29,6 +29,7 @@
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/uaccess.h>
+#include <asm/local.h>
 
 #include "tty.h"
 #include "network.h"
@@ -51,7 +52,7 @@ struct ipw_tty {
 	int tty_type;
 	struct ipw_network *network;
 	struct tty_struct *linux_tty;
-	int open_count;
+	local_t open_count;
 	unsigned int control_lines;
 	struct mutex ipw_tty_mutex;
 	int tx_bytes_queued;
@@ -127,10 +128,10 @@ static int ipw_open(struct tty_struct *l
 		mutex_unlock(&tty->ipw_tty_mutex);
 		return -ENODEV;
 	}
-	if (tty->open_count == 0)
+	if (local_read(&tty->open_count) == 0)
 		tty->tx_bytes_queued = 0;
 
-	tty->open_count++;
+	local_inc(&tty->open_count);
 
 	tty->linux_tty = linux_tty;
 	linux_tty->driver_data = tty;
@@ -146,9 +147,7 @@ static int ipw_open(struct tty_struct *l
 
 static void do_ipw_close(struct ipw_tty *tty)
 {
-	tty->open_count--;
-
-	if (tty->open_count == 0) {
+	if (local_dec_return(&tty->open_count) == 0) {
 		struct tty_struct *linux_tty = tty->linux_tty;
 
 		if (linux_tty != NULL) {
@@ -169,7 +168,7 @@ static void ipw_hangup(struct tty_struct
 		return;
 
 	mutex_lock(&tty->ipw_tty_mutex);
-	if (tty->open_count == 0) {
+	if (local_read(&tty->open_count) == 0) {
 		mutex_unlock(&tty->ipw_tty_mutex);
 		return;
 	}
@@ -198,7 +197,7 @@ void ipwireless_tty_received(struct ipw_
 		return;
 	}
 
-	if (!tty->open_count) {
+	if (!local_read(&tty->open_count)) {
 		mutex_unlock(&tty->ipw_tty_mutex);
 		return;
 	}
@@ -240,7 +239,7 @@ static int ipw_write(struct tty_struct *
 		return -ENODEV;
 
 	mutex_lock(&tty->ipw_tty_mutex);
-	if (!tty->open_count) {
+	if (!local_read(&tty->open_count)) {
 		mutex_unlock(&tty->ipw_tty_mutex);
 		return -EINVAL;
 	}
@@ -280,7 +279,7 @@ static int ipw_write_room(struct tty_str
 	if (!tty)
 		return -ENODEV;
 
-	if (!tty->open_count)
+	if (!local_read(&tty->open_count))
 		return -EINVAL;
 
 	room = IPWIRELESS_TX_QUEUE_SIZE - tty->tx_bytes_queued;
@@ -322,7 +321,7 @@ static int ipw_chars_in_buffer(struct tt
 	if (!tty)
 		return 0;
 
-	if (!tty->open_count)
+	if (!local_read(&tty->open_count))
 		return 0;
 
 	return tty->tx_bytes_queued;
@@ -403,7 +402,7 @@ static int ipw_tiocmget(struct tty_struc
 	if (!tty)
 		return -ENODEV;
 
-	if (!tty->open_count)
+	if (!local_read(&tty->open_count))
 		return -EINVAL;
 
 	return get_control_lines(tty);
@@ -419,7 +418,7 @@ ipw_tiocmset(struct tty_struct *linux_tt
 	if (!tty)
 		return -ENODEV;
 
-	if (!tty->open_count)
+	if (!local_read(&tty->open_count))
 		return -EINVAL;
 
 	return set_control_lines(tty, set, clear);
@@ -433,7 +432,7 @@ static int ipw_ioctl(struct tty_struct *
 	if (!tty)
 		return -ENODEV;
 
-	if (!tty->open_count)
+	if (!local_read(&tty->open_count))
 		return -EINVAL;
 
 	/* FIXME: Exactly how is the tty object locked here .. */
@@ -591,7 +590,7 @@ void ipwireless_tty_free(struct ipw_tty
 				   against a parallel ioctl etc */
 				mutex_lock(&ttyj->ipw_tty_mutex);
 			}
-			while (ttyj->open_count)
+			while (local_read(&ttyj->open_count))
 				do_ipw_close(ttyj);
 			ipwireless_disassociate_network_ttys(network,
 							     ttyj->channel_idx);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/pty.c linux-2.6.32.60-pax/drivers/char/pty.c
--- linux-2.6.32.60/drivers/char/pty.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/pty.c	2012-03-13 13:15:34.944098000 +0100
@@ -736,8 +736,10 @@ static void __init unix98_pty_init(void)
 	register_sysctl_table(pty_root_table);
 
 	/* Now create the /dev/ptmx special device */
+	pax_open_kernel();
 	tty_default_fops(&ptmx_fops);
-	ptmx_fops.open = ptmx_open;
+	*(void **)&ptmx_fops.open = ptmx_open;
+	pax_close_kernel();
 
 	cdev_init(&ptmx_cdev, &ptmx_fops);
 	if (cdev_add(&ptmx_cdev, MKDEV(TTYAUX_MAJOR, 2), 1) ||
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/random.c linux-2.6.32.60-pax/drivers/char/random.c
--- linux-2.6.32.60/drivers/char/random.c	2012-10-09 11:00:35.440882466 +0200
+++ linux-2.6.32.60-pax/drivers/char/random.c	2013-01-22 17:38:23.384543635 +0100
@@ -524,8 +524,8 @@ static void __mix_pool_bytes(struct entr
 		input_rotate += i ? 7 : 14;
 	}
 
-	ACCESS_ONCE(r->input_rotate) = input_rotate;
-	ACCESS_ONCE(r->add_ptr) = i;
+	ACCESS_ONCE_RW(r->input_rotate) = input_rotate;
+	ACCESS_ONCE_RW(r->add_ptr) = i;
 	smp_wmb();
 
 	if (out)
@@ -1322,7 +1322,7 @@ EXPORT_SYMBOL(generate_random_uuid);
 #include <linux/sysctl.h>
 
 static int min_read_thresh = 8, min_write_thresh;
-static int max_read_thresh = INPUT_POOL_WORDS * 32;
+static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
 static int max_write_thresh = INPUT_POOL_WORDS * 32;
 static char sysctl_bootid[16];
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/sonypi.c linux-2.6.32.60-pax/drivers/char/sonypi.c
--- linux-2.6.32.60/drivers/char/sonypi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/sonypi.c	2012-03-13 13:15:34.948098000 +0100
@@ -55,6 +55,7 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/system.h>
+#include <asm/local.h>
 
 #include <linux/sonypi.h>
 
@@ -491,7 +492,7 @@ static struct sonypi_device {
 	spinlock_t fifo_lock;
 	wait_queue_head_t fifo_proc_list;
 	struct fasync_struct *fifo_async;
-	int open_count;
+	local_t open_count;
 	int model;
 	struct input_dev *input_jog_dev;
 	struct input_dev *input_key_dev;
@@ -895,7 +896,7 @@ static int sonypi_misc_fasync(int fd, st
 static int sonypi_misc_release(struct inode *inode, struct file *file)
 {
 	mutex_lock(&sonypi_device.lock);
-	sonypi_device.open_count--;
+	local_dec(&sonypi_device.open_count);
 	mutex_unlock(&sonypi_device.lock);
 	return 0;
 }
@@ -905,9 +906,9 @@ static int sonypi_misc_open(struct inode
 	lock_kernel();
 	mutex_lock(&sonypi_device.lock);
 	/* Flush input queue on first open */
-	if (!sonypi_device.open_count)
+	if (!local_read(&sonypi_device.open_count))
 		kfifo_reset(sonypi_device.fifo);
-	sonypi_device.open_count++;
+	local_inc(&sonypi_device.open_count);
 	mutex_unlock(&sonypi_device.lock);
 	unlock_kernel();
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/tpm/tpm_bios.c linux-2.6.32.60-pax/drivers/char/tpm/tpm_bios.c
--- linux-2.6.32.60/drivers/char/tpm/tpm_bios.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/tpm/tpm_bios.c	2012-03-13 13:15:34.948098000 +0100
@@ -172,7 +172,7 @@ static void *tpm_bios_measurements_start
 	event = addr;
 
 	if ((event->event_type == 0 && event->event_size == 0) ||
-	    ((addr + sizeof(struct tcpa_event) + event->event_size) >= limit))
+	    (event->event_size >= limit - addr - sizeof(struct tcpa_event)))
 		return NULL;
 
 	return addr;
@@ -197,7 +197,7 @@ static void *tpm_bios_measurements_next(
 		return NULL;
 
 	if ((event->event_type == 0 && event->event_size == 0) ||
-	    ((v + sizeof(struct tcpa_event) + event->event_size) >= limit))
+	    (event->event_size >= limit - v - sizeof(struct tcpa_event)))
 		return NULL;
 
 	(*pos)++;
@@ -290,7 +290,8 @@ static int tpm_binary_bios_measurements_
 	int i;
 
 	for (i = 0; i < sizeof(struct tcpa_event) + event->event_size; i++)
-		seq_putc(m, data[i]);
+		if (!seq_putc(m, data[i]))
+			return -EFAULT;
 
 	return 0;
 }
@@ -409,8 +410,13 @@ static int read_log(struct tpm_bios_log
 	log->bios_event_log_end = log->bios_event_log + len;
 
 	virt = acpi_os_map_memory(start, len);
+	if (!virt) {
+		kfree(log->bios_event_log);
+		log->bios_event_log = NULL;
+		return -EFAULT;
+	}
 
-	memcpy(log->bios_event_log, virt, len);
+	memcpy(log->bios_event_log, (const char __force_kernel *)virt, len);
 
 	acpi_os_unmap_memory(virt, len);
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/tpm/tpm.c linux-2.6.32.60-pax/drivers/char/tpm/tpm.c
--- linux-2.6.32.60/drivers/char/tpm/tpm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/tpm/tpm.c	2012-03-13 13:15:34.952098000 +0100
@@ -405,7 +405,7 @@ static ssize_t tpm_transmit(struct tpm_c
 		    chip->vendor.req_complete_val)
 			goto out_recv;
 
-		if ((status == chip->vendor.req_canceled)) {
+		if (status == chip->vendor.req_canceled) {
 			dev_err(chip->dev, "Operation Canceled\n");
 			rc = -ECANCELED;
 			goto out;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/tty_io.c linux-2.6.32.60-pax/drivers/char/tty_io.c
--- linux-2.6.32.60/drivers/char/tty_io.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/tty_io.c	2012-03-13 13:15:34.952098000 +0100
@@ -146,7 +146,7 @@ static int tty_open(struct inode *, stru
 static int tty_release(struct inode *, struct file *);
 long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 #ifdef CONFIG_COMPAT
-static long tty_compat_ioctl(struct file *file, unsigned int cmd,
+long tty_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg);
 #else
 #define tty_compat_ioctl NULL
@@ -2603,8 +2603,10 @@ long tty_ioctl(struct file *file, unsign
 	return retval;
 }
 
+EXPORT_SYMBOL(tty_ioctl);
+
 #ifdef CONFIG_COMPAT
-static long tty_compat_ioctl(struct file *file, unsigned int cmd,
+long tty_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
 {
 	struct inode *inode = file->f_dentry->d_inode;
@@ -2628,6 +2630,8 @@ static long tty_compat_ioctl(struct file
 
 	return retval;
 }
+
+EXPORT_SYMBOL(tty_compat_ioctl);
 #endif
 
 /*
@@ -3073,7 +3077,7 @@ EXPORT_SYMBOL_GPL(get_current_tty);
 
 void tty_default_fops(struct file_operations *fops)
 {
-	*fops = tty_fops;
+	memcpy((void *)fops, &tty_fops, sizeof(tty_fops));
 }
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/tty_ldisc.c linux-2.6.32.60-pax/drivers/char/tty_ldisc.c
--- linux-2.6.32.60/drivers/char/tty_ldisc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/tty_ldisc.c	2012-03-13 13:15:34.952098000 +0100
@@ -74,7 +74,7 @@ static void put_ldisc(struct tty_ldisc *
 	if (atomic_dec_and_lock(&ld->users, &tty_ldisc_lock)) {
 		struct tty_ldisc_ops *ldo = ld->ops;
 
-		ldo->refcount--;
+		atomic_dec(&ldo->refcount);
 		module_put(ldo->owner);
 		spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 
@@ -109,7 +109,7 @@ int tty_register_ldisc(int disc, struct
 	spin_lock_irqsave(&tty_ldisc_lock, flags);
 	tty_ldiscs[disc] = new_ldisc;
 	new_ldisc->num = disc;
-	new_ldisc->refcount = 0;
+	atomic_set(&new_ldisc->refcount, 0);
 	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 
 	return ret;
@@ -137,7 +137,7 @@ int tty_unregister_ldisc(int disc)
 		return -EINVAL;
 
 	spin_lock_irqsave(&tty_ldisc_lock, flags);
-	if (tty_ldiscs[disc]->refcount)
+	if (atomic_read(&tty_ldiscs[disc]->refcount))
 		ret = -EBUSY;
 	else
 		tty_ldiscs[disc] = NULL;
@@ -158,7 +158,7 @@ static struct tty_ldisc_ops *get_ldops(i
 	if (ldops) {
 		ret = ERR_PTR(-EAGAIN);
 		if (try_module_get(ldops->owner)) {
-			ldops->refcount++;
+			atomic_inc(&ldops->refcount);
 			ret = ldops;
 		}
 	}
@@ -171,7 +171,7 @@ static void put_ldops(struct tty_ldisc_o
 	unsigned long flags;
 
 	spin_lock_irqsave(&tty_ldisc_lock, flags);
-	ldops->refcount--;
+	atomic_dec(&ldops->refcount);
 	module_put(ldops->owner);
 	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/virtio_console.c linux-2.6.32.60-pax/drivers/char/virtio_console.c
--- linux-2.6.32.60/drivers/char/virtio_console.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/virtio_console.c	2012-03-13 13:15:34.956097999 +0100
@@ -133,7 +133,9 @@ static int get_chars(u32 vtermno, char *
  * virtqueue, so we let the drivers do some boutique early-output thing. */
 int __init virtio_cons_early_init(int (*put_chars)(u32, const char *, int))
 {
-	virtio_cons.put_chars = put_chars;
+	pax_open_kernel();
+	*(void **)&virtio_cons.put_chars = put_chars;
+	pax_close_kernel();
 	return hvc_instantiate(0, 0, &virtio_cons);
 }
 
@@ -213,11 +215,13 @@ static int __devinit virtcons_probe(stru
 	out_vq = vqs[1];
 
 	/* Start using the new console output. */
-	virtio_cons.get_chars = get_chars;
-	virtio_cons.put_chars = put_chars;
-	virtio_cons.notifier_add = notifier_add_vio;
-	virtio_cons.notifier_del = notifier_del_vio;
-	virtio_cons.notifier_hangup = notifier_del_vio;
+	pax_open_kernel();
+	*(void **)&virtio_cons.get_chars = get_chars;
+	*(void **)&virtio_cons.put_chars = put_chars;
+	*(void **)&virtio_cons.notifier_add = notifier_add_vio;
+	*(void **)&virtio_cons.notifier_del = notifier_del_vio;
+	*(void **)&virtio_cons.notifier_hangup = notifier_del_vio;
+	pax_close_kernel();
 
 	/* The first argument of hvc_alloc() is the virtual console number, so
 	 * we use zero.  The second argument is the parameter for the
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/char/vt.c linux-2.6.32.60-pax/drivers/char/vt.c
--- linux-2.6.32.60/drivers/char/vt.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/char/vt.c	2012-03-13 13:15:34.956097999 +0100
@@ -243,7 +243,7 @@ EXPORT_SYMBOL_GPL(unregister_vt_notifier
 
 static void notify_write(struct vc_data *vc, unsigned int unicode)
 {
-	struct vt_notifier_param param = { .vc = vc, unicode = unicode };
+	struct vt_notifier_param param = { .vc = vc, .c = unicode };
 	atomic_notifier_call_chain(&vt_notifier_list, VT_WRITE, &param);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/cpuidle/sysfs.c linux-2.6.32.60-pax/drivers/cpuidle/sysfs.c
--- linux-2.6.32.60/drivers/cpuidle/sysfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/cpuidle/sysfs.c	2012-03-13 13:15:34.956097999 +0100
@@ -294,7 +294,7 @@ static struct kobj_type ktype_state_cpui
 	.release = cpuidle_state_sysfs_release,
 };
 
-static void inline cpuidle_free_state_kobj(struct cpuidle_device *device, int i)
+static inline void cpuidle_free_state_kobj(struct cpuidle_device *device, int i)
 {
 	kobject_put(&device->kobjs[i]->kobj);
 	wait_for_completion(&device->kobjs[i]->kobj_unregister);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/dma/ioat/dma_v3.c linux-2.6.32.60-pax/drivers/dma/ioat/dma_v3.c
--- linux-2.6.32.60/drivers/dma/ioat/dma_v3.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/dma/ioat/dma_v3.c	2012-03-13 13:15:34.960097999 +0100
@@ -71,10 +71,10 @@
 /* provide a lookup table for setting the source address in the base or
  * extended descriptor of an xor or pq descriptor
  */
-static const u8 xor_idx_to_desc __read_mostly = 0xd0;
-static const u8 xor_idx_to_field[] __read_mostly = { 1, 4, 5, 6, 7, 0, 1, 2 };
-static const u8 pq_idx_to_desc __read_mostly = 0xf8;
-static const u8 pq_idx_to_field[] __read_mostly = { 1, 4, 5, 0, 1, 2, 4, 5 };
+static const u8 xor_idx_to_desc = 0xd0;
+static const u8 xor_idx_to_field[] = { 1, 4, 5, 6, 7, 0, 1, 2 };
+static const u8 pq_idx_to_desc = 0xf8;
+static const u8 pq_idx_to_field[] = { 1, 4, 5, 0, 1, 2, 4, 5 };
 
 static dma_addr_t xor_get_src(struct ioat_raw_descriptor *descs[2], int idx)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/amd64_edac.c linux-2.6.32.60-pax/drivers/edac/amd64_edac.c
--- linux-2.6.32.60/drivers/edac/amd64_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/amd64_edac.c	2012-03-13 13:15:34.960097999 +0100
@@ -3099,7 +3099,7 @@ static void __devexit amd64_remove_one_i
  * PCI core identifies what devices are on a system during boot, and then
  * inquiry this table to see if this driver is for a given device found.
  */
-static const struct pci_device_id amd64_pci_table[] __devinitdata = {
+static const struct pci_device_id amd64_pci_table[] __devinitconst = {
 	{
 		.vendor		= PCI_VENDOR_ID_AMD,
 		.device		= PCI_DEVICE_ID_AMD_K8_NB_MEMCTL,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/amd76x_edac.c linux-2.6.32.60-pax/drivers/edac/amd76x_edac.c
--- linux-2.6.32.60/drivers/edac/amd76x_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/amd76x_edac.c	2012-03-13 13:15:34.960097999 +0100
@@ -322,7 +322,7 @@ static void __devexit amd76x_remove_one(
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id amd76x_pci_tbl[] __devinitdata = {
+static const struct pci_device_id amd76x_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(AMD, FE_GATE_700C), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 AMD762},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/e752x_edac.c linux-2.6.32.60-pax/drivers/edac/e752x_edac.c
--- linux-2.6.32.60/drivers/edac/e752x_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/e752x_edac.c	2012-03-13 13:15:34.964097999 +0100
@@ -1282,7 +1282,7 @@ static void __devexit e752x_remove_one(s
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id e752x_pci_tbl[] __devinitdata = {
+static const struct pci_device_id e752x_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, 7520_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 E7520},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/e7xxx_edac.c linux-2.6.32.60-pax/drivers/edac/e7xxx_edac.c
--- linux-2.6.32.60/drivers/edac/e7xxx_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/e7xxx_edac.c	2012-03-13 13:15:34.964097999 +0100
@@ -526,7 +526,7 @@ static void __devexit e7xxx_remove_one(s
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id e7xxx_pci_tbl[] __devinitdata = {
+static const struct pci_device_id e7xxx_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, 7205_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 E7205},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/edac_pci_sysfs.c linux-2.6.32.60-pax/drivers/edac/edac_pci_sysfs.c
--- linux-2.6.32.60/drivers/edac/edac_pci_sysfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/edac_pci_sysfs.c	2012-03-13 13:15:34.964097999 +0100
@@ -25,8 +25,8 @@ static int edac_pci_log_pe = 1;		/* log
 static int edac_pci_log_npe = 1;	/* log PCI non-parity error errors */
 static int edac_pci_poll_msec = 1000;	/* one second workq period */
 
-static atomic_t pci_parity_count = ATOMIC_INIT(0);
-static atomic_t pci_nonparity_count = ATOMIC_INIT(0);
+static atomic_unchecked_t pci_parity_count = ATOMIC_INIT(0);
+static atomic_unchecked_t pci_nonparity_count = ATOMIC_INIT(0);
 
 static struct kobject *edac_pci_top_main_kobj;
 static atomic_t edac_pci_sysfs_refcount = ATOMIC_INIT(0);
@@ -579,7 +579,7 @@ static void edac_pci_dev_parity_test(str
 			edac_printk(KERN_CRIT, EDAC_PCI,
 				"Signaled System Error on %s\n",
 				pci_name(dev));
-			atomic_inc(&pci_nonparity_count);
+			atomic_inc_unchecked(&pci_nonparity_count);
 		}
 
 		if (status & (PCI_STATUS_PARITY)) {
@@ -587,7 +587,7 @@ static void edac_pci_dev_parity_test(str
 				"Master Data Parity Error on %s\n",
 				pci_name(dev));
 
-			atomic_inc(&pci_parity_count);
+			atomic_inc_unchecked(&pci_parity_count);
 		}
 
 		if (status & (PCI_STATUS_DETECTED_PARITY)) {
@@ -595,7 +595,7 @@ static void edac_pci_dev_parity_test(str
 				"Detected Parity Error on %s\n",
 				pci_name(dev));
 
-			atomic_inc(&pci_parity_count);
+			atomic_inc_unchecked(&pci_parity_count);
 		}
 	}
 
@@ -616,7 +616,7 @@ static void edac_pci_dev_parity_test(str
 				edac_printk(KERN_CRIT, EDAC_PCI, "Bridge "
 					"Signaled System Error on %s\n",
 					pci_name(dev));
-				atomic_inc(&pci_nonparity_count);
+				atomic_inc_unchecked(&pci_nonparity_count);
 			}
 
 			if (status & (PCI_STATUS_PARITY)) {
@@ -624,7 +624,7 @@ static void edac_pci_dev_parity_test(str
 					"Master Data Parity Error on "
 					"%s\n", pci_name(dev));
 
-				atomic_inc(&pci_parity_count);
+				atomic_inc_unchecked(&pci_parity_count);
 			}
 
 			if (status & (PCI_STATUS_DETECTED_PARITY)) {
@@ -632,7 +632,7 @@ static void edac_pci_dev_parity_test(str
 					"Detected Parity Error on %s\n",
 					pci_name(dev));
 
-				atomic_inc(&pci_parity_count);
+				atomic_inc_unchecked(&pci_parity_count);
 			}
 		}
 	}
@@ -674,7 +674,7 @@ void edac_pci_do_parity_check(void)
 	if (!check_pci_errors)
 		return;
 
-	before_count = atomic_read(&pci_parity_count);
+	before_count = atomic_read_unchecked(&pci_parity_count);
 
 	/* scan all PCI devices looking for a Parity Error on devices and
 	 * bridges.
@@ -686,7 +686,7 @@ void edac_pci_do_parity_check(void)
 	/* Only if operator has selected panic on PCI Error */
 	if (edac_pci_get_panic_on_pe()) {
 		/* If the count is different 'after' from 'before' */
-		if (before_count != atomic_read(&pci_parity_count))
+		if (before_count != atomic_read_unchecked(&pci_parity_count))
 			panic("EDAC: PCI Parity Error");
 	}
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i3000_edac.c linux-2.6.32.60-pax/drivers/edac/i3000_edac.c
--- linux-2.6.32.60/drivers/edac/i3000_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i3000_edac.c	2012-03-13 13:15:34.964097999 +0100
@@ -471,7 +471,7 @@ static void __devexit i3000_remove_one(s
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i3000_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i3000_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, 3000_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 I3000},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i3200_edac.c linux-2.6.32.60-pax/drivers/edac/i3200_edac.c
--- linux-2.6.32.60/drivers/edac/i3200_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i3200_edac.c	2012-03-13 13:15:34.968097999 +0100
@@ -444,7 +444,7 @@ static void __devexit i3200_remove_one(s
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i3200_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i3200_pci_tbl[] __devinitconst = {
 	{
 		PCI_VEND_DEV(INTEL, 3200_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 		I3200},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i5000_edac.c linux-2.6.32.60-pax/drivers/edac/i5000_edac.c
--- linux-2.6.32.60/drivers/edac/i5000_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i5000_edac.c	2012-03-13 13:15:34.968097999 +0100
@@ -1516,7 +1516,7 @@ static void __devexit i5000_remove_one(s
  *
  *	The "E500P" device is the first device supported.
  */
-static const struct pci_device_id i5000_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i5000_pci_tbl[] __devinitconst = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I5000_DEV16),
 	 .driver_data = I5000P},
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i5100_edac.c linux-2.6.32.60-pax/drivers/edac/i5100_edac.c
--- linux-2.6.32.60/drivers/edac/i5100_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i5100_edac.c	2012-03-13 13:15:34.968097999 +0100
@@ -944,7 +944,7 @@ static void __devexit i5100_remove_one(s
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i5100_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i5100_pci_tbl[] __devinitconst = {
 	/* Device 16, Function 0, Channel 0 Memory Map, Error Flag/Mask, ... */
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5100_16) },
 	{ 0, }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i5400_edac.c linux-2.6.32.60-pax/drivers/edac/i5400_edac.c
--- linux-2.6.32.60/drivers/edac/i5400_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i5400_edac.c	2012-03-13 13:15:34.972097999 +0100
@@ -1383,7 +1383,7 @@ static void __devexit i5400_remove_one(s
  *
  *	The "E500P" device is the first device supported.
  */
-static const struct pci_device_id i5400_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i5400_pci_tbl[] __devinitconst = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5400_ERR)},
 	{0,}			/* 0 terminated list. */
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i82443bxgx_edac.c linux-2.6.32.60-pax/drivers/edac/i82443bxgx_edac.c
--- linux-2.6.32.60/drivers/edac/i82443bxgx_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i82443bxgx_edac.c	2012-03-13 13:15:34.972097999 +0100
@@ -381,7 +381,7 @@ static void __devexit i82443bxgx_edacmc_
 
 EXPORT_SYMBOL_GPL(i82443bxgx_edacmc_remove_one);
 
-static const struct pci_device_id i82443bxgx_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i82443bxgx_pci_tbl[] __devinitconst = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443BX_0)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443BX_2)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_0)},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i82860_edac.c linux-2.6.32.60-pax/drivers/edac/i82860_edac.c
--- linux-2.6.32.60/drivers/edac/i82860_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i82860_edac.c	2012-03-13 13:15:34.972097999 +0100
@@ -271,7 +271,7 @@ static void __devexit i82860_remove_one(
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i82860_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i82860_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, 82860_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 I82860},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i82875p_edac.c linux-2.6.32.60-pax/drivers/edac/i82875p_edac.c
--- linux-2.6.32.60/drivers/edac/i82875p_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i82875p_edac.c	2012-03-13 13:15:34.972097999 +0100
@@ -512,7 +512,7 @@ static void __devexit i82875p_remove_one
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i82875p_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i82875p_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, 82875_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 I82875P},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/i82975x_edac.c linux-2.6.32.60-pax/drivers/edac/i82975x_edac.c
--- linux-2.6.32.60/drivers/edac/i82975x_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/i82975x_edac.c	2012-03-13 13:15:34.976097998 +0100
@@ -586,7 +586,7 @@ static void __devexit i82975x_remove_one
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id i82975x_pci_tbl[] __devinitdata = {
+static const struct pci_device_id i82975x_pci_tbl[] __devinitconst = {
 	{
 		PCI_VEND_DEV(INTEL, 82975_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 		I82975X
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/r82600_edac.c linux-2.6.32.60-pax/drivers/edac/r82600_edac.c
--- linux-2.6.32.60/drivers/edac/r82600_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/r82600_edac.c	2012-03-13 13:15:34.976097998 +0100
@@ -374,7 +374,7 @@ static void __devexit r82600_remove_one(
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id r82600_pci_tbl[] __devinitdata = {
+static const struct pci_device_id r82600_pci_tbl[] __devinitconst = {
 	{
 	 PCI_DEVICE(PCI_VENDOR_ID_RADISYS, R82600_BRIDGE_ID)
 	 },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/edac/x38_edac.c linux-2.6.32.60-pax/drivers/edac/x38_edac.c
--- linux-2.6.32.60/drivers/edac/x38_edac.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/edac/x38_edac.c	2012-03-13 13:15:34.976097998 +0100
@@ -441,7 +441,7 @@ static void __devexit x38_remove_one(str
 	edac_mc_free(mci);
 }
 
-static const struct pci_device_id x38_pci_tbl[] __devinitdata = {
+static const struct pci_device_id x38_pci_tbl[] __devinitconst = {
 	{
 	 PCI_VEND_DEV(INTEL, X38_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	 X38},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/firewire/core-card.c linux-2.6.32.60-pax/drivers/firewire/core-card.c
--- linux-2.6.32.60/drivers/firewire/core-card.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/firewire/core-card.c	2012-03-13 13:15:34.976097998 +0100
@@ -558,7 +558,7 @@ void fw_card_release(struct kref *kref)
 
 void fw_core_remove_card(struct fw_card *card)
 {
-	struct fw_card_driver dummy_driver = dummy_driver_template;
+	fw_card_driver_no_const dummy_driver = dummy_driver_template;
 
 	card->driver->update_phy_reg(card, 4,
 				     PHY_LINK_ACTIVE | PHY_CONTENDER, 0);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/firewire/core-cdev.c linux-2.6.32.60-pax/drivers/firewire/core-cdev.c
--- linux-2.6.32.60/drivers/firewire/core-cdev.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/firewire/core-cdev.c	2012-03-13 13:15:34.980097998 +0100
@@ -1141,8 +1141,7 @@ static int init_iso_resource(struct clie
 	int ret;
 
 	if ((request->channels == 0 && request->bandwidth == 0) ||
-	    request->bandwidth > BANDWIDTH_AVAILABLE_INITIAL ||
-	    request->bandwidth < 0)
+	    request->bandwidth > BANDWIDTH_AVAILABLE_INITIAL)
 		return -EINVAL;
 
 	r  = kmalloc(sizeof(*r), GFP_KERNEL);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/firewire/core.h linux-2.6.32.60-pax/drivers/firewire/core.h
--- linux-2.6.32.60/drivers/firewire/core.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/firewire/core.h	2012-03-13 13:15:34.980097998 +0100
@@ -86,6 +86,7 @@ struct fw_card_driver {
 
 	int (*stop_iso)(struct fw_iso_context *ctx);
 };
+typedef struct fw_card_driver __no_const fw_card_driver_no_const;
 
 void fw_card_initialize(struct fw_card *card,
 		const struct fw_card_driver *driver, struct device *device);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/firewire/core-transaction.c linux-2.6.32.60-pax/drivers/firewire/core-transaction.c
--- linux-2.6.32.60/drivers/firewire/core-transaction.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/firewire/core-transaction.c	2012-03-13 13:15:34.980097998 +0100
@@ -36,6 +36,7 @@
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/types.h>
+#include <linux/sched.h>
 
 #include <asm/byteorder.h>
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/firmware/dmi_scan.c linux-2.6.32.60-pax/drivers/firmware/dmi_scan.c
--- linux-2.6.32.60/drivers/firmware/dmi_scan.c	2012-10-09 11:00:35.440882466 +0200
+++ linux-2.6.32.60-pax/drivers/firmware/dmi_scan.c	2012-10-09 11:00:39.276883033 +0200
@@ -394,11 +394,6 @@ void __init dmi_scan_machine(void)
 		}
 	}
 	else {
-		/*
-		 * no iounmap() for that ioremap(); it would be a no-op, but
-		 * it's so early in setup that sucker gets confused into doing
-		 * what it shouldn't if we actually call it.
-		 */
 		p = dmi_ioremap(0xF0000, 0x10000);
 		if (p == NULL)
 			goto error;
@@ -670,7 +665,7 @@ int dmi_walk(void (*decode)(const struct
 	if (buf == NULL)
 		return -1;
 
-	dmi_table(buf, dmi_len, dmi_num, decode, private_data);
+	dmi_table((char __force_kernel *)buf, dmi_len, dmi_num, decode, private_data);
 
 	iounmap(buf);
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpio/vr41xx_giu.c linux-2.6.32.60-pax/drivers/gpio/vr41xx_giu.c
--- linux-2.6.32.60/drivers/gpio/vr41xx_giu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpio/vr41xx_giu.c	2012-03-13 13:15:34.984097998 +0100
@@ -204,7 +204,7 @@ static int giu_get_irq(unsigned int irq)
 	printk(KERN_ERR "spurious GIU interrupt: %04x(%04x),%04x(%04x)\n",
 	       maskl, pendl, maskh, pendh);
 
-	atomic_inc(&irq_err_count);
+	atomic_inc_unchecked(&irq_err_count);
 
 	return -EINVAL;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_crtc.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_crtc.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_crtc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_crtc.c	2012-03-13 13:15:34.984097998 +0100
@@ -1323,7 +1323,7 @@ int drm_mode_getconnector(struct drm_dev
 	 */
 	if ((out_resp->count_modes >= mode_count) && mode_count) {
 		copied = 0;
-		mode_ptr = (struct drm_mode_modeinfo *)(unsigned long)out_resp->modes_ptr;
+		mode_ptr = (struct drm_mode_modeinfo __user *)(unsigned long)out_resp->modes_ptr;
 		list_for_each_entry(mode, &connector->modes, head) {
 			drm_crtc_convert_to_umode(&u_mode, mode);
 			if (copy_to_user(mode_ptr + copied,
@@ -1338,8 +1338,8 @@ int drm_mode_getconnector(struct drm_dev
 
 	if ((out_resp->count_props >= props_count) && props_count) {
 		copied = 0;
-		prop_ptr = (uint32_t *)(unsigned long)(out_resp->props_ptr);
-		prop_values = (uint64_t *)(unsigned long)(out_resp->prop_values_ptr);
+		prop_ptr = (uint32_t __user *)(unsigned long)(out_resp->props_ptr);
+		prop_values = (uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr);
 		for (i = 0; i < DRM_CONNECTOR_MAX_PROPERTY; i++) {
 			if (connector->property_ids[i] != 0) {
 				if (put_user(connector->property_ids[i],
@@ -1361,7 +1361,7 @@ int drm_mode_getconnector(struct drm_dev
 
 	if ((out_resp->count_encoders >= encoders_count) && encoders_count) {
 		copied = 0;
-		encoder_ptr = (uint32_t *)(unsigned long)(out_resp->encoders_ptr);
+		encoder_ptr = (uint32_t __user *)(unsigned long)(out_resp->encoders_ptr);
 		for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
 			if (connector->encoder_ids[i] != 0) {
 				if (put_user(connector->encoder_ids[i],
@@ -1513,7 +1513,7 @@ int drm_mode_setcrtc(struct drm_device *
 		}
 
 		for (i = 0; i < crtc_req->count_connectors; i++) {
-			set_connectors_ptr = (uint32_t *)(unsigned long)crtc_req->set_connectors_ptr;
+			set_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;
 			if (get_user(out_id, &set_connectors_ptr[i])) {
 				ret = -EFAULT;
 				goto out;
@@ -2118,7 +2118,7 @@ int drm_mode_getproperty_ioctl(struct dr
 	out_resp->flags = property->flags;
 
 	if ((out_resp->count_values >= value_count) && value_count) {
-		values_ptr = (uint64_t *)(unsigned long)out_resp->values_ptr;
+		values_ptr = (uint64_t __user *)(unsigned long)out_resp->values_ptr;
 		for (i = 0; i < value_count; i++) {
 			if (copy_to_user(values_ptr + i, &property->values[i], sizeof(uint64_t))) {
 				ret = -EFAULT;
@@ -2131,7 +2131,7 @@ int drm_mode_getproperty_ioctl(struct dr
 	if (property->flags & DRM_MODE_PROP_ENUM) {
 		if ((out_resp->count_enum_blobs >= enum_count) && enum_count) {
 			copied = 0;
-			enum_ptr = (struct drm_mode_property_enum *)(unsigned long)out_resp->enum_blob_ptr;
+			enum_ptr = (struct drm_mode_property_enum __user *)(unsigned long)out_resp->enum_blob_ptr;
 			list_for_each_entry(prop_enum, &property->enum_blob_list, head) {
 
 				if (copy_to_user(&enum_ptr[copied].value, &prop_enum->value, sizeof(uint64_t))) {
@@ -2154,7 +2154,7 @@ int drm_mode_getproperty_ioctl(struct dr
 		if ((out_resp->count_enum_blobs >= blob_count) && blob_count) {
 			copied = 0;
 			blob_id_ptr = (uint32_t *)(unsigned long)out_resp->enum_blob_ptr;
-			blob_length_ptr = (uint32_t *)(unsigned long)out_resp->values_ptr;
+			blob_length_ptr = (uint32_t __user *)(unsigned long)out_resp->values_ptr;
 
 			list_for_each_entry(prop_blob, &property->enum_blob_list, head) {
 				if (put_user(prop_blob->base.id, blob_id_ptr + copied)) {
@@ -2226,7 +2226,7 @@ int drm_mode_getblob_ioctl(struct drm_de
 	blob = obj_to_blob(obj);
 
 	if (out_resp->length == blob->length) {
-		blob_ptr = (void *)(unsigned long)out_resp->data;
+		blob_ptr = (void __user *)(unsigned long)out_resp->data;
 		if (copy_to_user(blob_ptr, blob->data, blob->length)){
 			ret = -EFAULT;
 			goto done;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_crtc_helper.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_crtc_helper.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_crtc_helper.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_crtc_helper.c	2012-03-13 13:15:34.984097998 +0100
@@ -573,7 +573,7 @@ static bool drm_encoder_crtc_ok(struct d
 	struct drm_crtc *tmp;
 	int crtc_mask = 1;
 
-	WARN(!crtc, "checking null crtc?");
+	BUG_ON(!crtc);
 
 	dev = crtc->dev;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_drv.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_drv.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_drv.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_drv.c	2012-03-13 13:15:34.988097998 +0100
@@ -417,7 +417,7 @@ int drm_ioctl(struct inode *inode, struc
 	char *kdata = NULL;
 
 	atomic_inc(&dev->ioctl_count);
-	atomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);
+	atomic_inc_unchecked(&dev->counts[_DRM_STAT_IOCTLS]);
 	++file_priv->ioctl_count;
 
 	DRM_DEBUG("pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_fops.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_fops.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_fops.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_fops.c	2012-03-13 13:15:34.988097998 +0100
@@ -66,7 +66,7 @@ static int drm_setup(struct drm_device *
 	}
 
 	for (i = 0; i < ARRAY_SIZE(dev->counts); i++)
-		atomic_set(&dev->counts[i], 0);
+		atomic_set_unchecked(&dev->counts[i], 0);
 
 	dev->sigdata.lock = NULL;
 
@@ -130,9 +130,9 @@ int drm_open(struct inode *inode, struct
 
 	retcode = drm_open_helper(inode, filp, dev);
 	if (!retcode) {
-		atomic_inc(&dev->counts[_DRM_STAT_OPENS]);
+		atomic_inc_unchecked(&dev->counts[_DRM_STAT_OPENS]);
 		spin_lock(&dev->count_lock);
-		if (!dev->open_count++) {
+		if (local_inc_return(&dev->open_count) == 1) {
 			spin_unlock(&dev->count_lock);
 			retcode = drm_setup(dev);
 			goto out;
@@ -435,7 +435,7 @@ int drm_release(struct inode *inode, str
 
 	lock_kernel();
 
-	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	DRM_DEBUG("open_count = %d\n", local_read(&dev->open_count));
 
 	if (dev->driver->preclose)
 		dev->driver->preclose(dev, file_priv);
@@ -447,7 +447,7 @@ int drm_release(struct inode *inode, str
 	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
 		  task_pid_nr(current),
 		  (long)old_encode_dev(file_priv->minor->device),
-		  dev->open_count);
+		  local_read(&dev->open_count));
 
 	/* Release any auth tokens that might point to this file_priv,
 	   (do that under the drm_global_mutex) */
@@ -529,9 +529,9 @@ int drm_release(struct inode *inode, str
 	 * End inline drm_release
 	 */
 
-	atomic_inc(&dev->counts[_DRM_STAT_CLOSES]);
+	atomic_inc_unchecked(&dev->counts[_DRM_STAT_CLOSES]);
 	spin_lock(&dev->count_lock);
-	if (!--dev->open_count) {
+	if (local_dec_and_test(&dev->open_count)) {
 		if (atomic_read(&dev->ioctl_count)) {
 			DRM_ERROR("Device busy: %d\n",
 				  atomic_read(&dev->ioctl_count));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_gem.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_gem.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_gem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_gem.c	2012-03-13 13:15:34.988097998 +0100
@@ -83,11 +83,11 @@ drm_gem_init(struct drm_device *dev)
 	spin_lock_init(&dev->object_name_lock);
 	idr_init(&dev->object_name_idr);
 	atomic_set(&dev->object_count, 0);
-	atomic_set(&dev->object_memory, 0);
+	atomic_set_unchecked(&dev->object_memory, 0);
 	atomic_set(&dev->pin_count, 0);
-	atomic_set(&dev->pin_memory, 0);
+	atomic_set_unchecked(&dev->pin_memory, 0);
 	atomic_set(&dev->gtt_count, 0);
-	atomic_set(&dev->gtt_memory, 0);
+	atomic_set_unchecked(&dev->gtt_memory, 0);
 
 	mm = kzalloc(sizeof(struct drm_gem_mm), GFP_KERNEL);
 	if (!mm) {
@@ -150,7 +150,7 @@ drm_gem_object_alloc(struct drm_device *
 		goto fput;
 	}
 	atomic_inc(&dev->object_count);
-	atomic_add(obj->size, &dev->object_memory);
+	atomic_add_unchecked(obj->size, &dev->object_memory);
 	return obj;
 fput:
 	fput(obj->filp);
@@ -429,7 +429,7 @@ drm_gem_object_free(struct kref *kref)
 
 	fput(obj->filp);
 	atomic_dec(&dev->object_count);
-	atomic_sub(obj->size, &dev->object_memory);
+	atomic_sub_unchecked(obj->size, &dev->object_memory);
 	kfree(obj);
 }
 EXPORT_SYMBOL(drm_gem_object_free);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_info.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_info.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_info.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_info.c	2012-03-13 13:15:34.988097998 +0100
@@ -75,10 +75,14 @@ int drm_vm_info(struct seq_file *m, void
 	struct drm_local_map *map;
 	struct drm_map_list *r_list;
 
-	/* Hardcoded from _DRM_FRAME_BUFFER,
-	   _DRM_REGISTERS, _DRM_SHM, _DRM_AGP, and
-	   _DRM_SCATTER_GATHER and _DRM_CONSISTENT */
-	const char *types[] = { "FB", "REG", "SHM", "AGP", "SG", "PCI" };
+	static const char * const types[] = {
+		[_DRM_FRAME_BUFFER] = "FB",
+		[_DRM_REGISTERS] = "REG",
+		[_DRM_SHM] = "SHM",
+		[_DRM_AGP] = "AGP",
+		[_DRM_SCATTER_GATHER] = "SG",
+		[_DRM_CONSISTENT] = "PCI",
+		[_DRM_GEM] = "GEM" };
 	const char *type;
 	int i;
 
@@ -89,7 +93,7 @@ int drm_vm_info(struct seq_file *m, void
 		map = r_list->map;
 		if (!map)
 			continue;
-		if (map->type < 0 || map->type > 5)
+		if (map->type >= ARRAY_SIZE(types))
 			type = "??";
 		else
 			type = types[map->type];
@@ -265,10 +269,10 @@ int drm_gem_object_info(struct seq_file
 	struct drm_device *dev = node->minor->dev;
 
 	seq_printf(m, "%d objects\n", atomic_read(&dev->object_count));
-	seq_printf(m, "%d object bytes\n", atomic_read(&dev->object_memory));
+	seq_printf(m, "%d object bytes\n", atomic_read_unchecked(&dev->object_memory));
 	seq_printf(m, "%d pinned\n", atomic_read(&dev->pin_count));
-	seq_printf(m, "%d pin bytes\n", atomic_read(&dev->pin_memory));
-	seq_printf(m, "%d gtt bytes\n", atomic_read(&dev->gtt_memory));
+	seq_printf(m, "%d pin bytes\n", atomic_read_unchecked(&dev->pin_memory));
+	seq_printf(m, "%d gtt bytes\n", atomic_read_unchecked(&dev->gtt_memory));
 	seq_printf(m, "%d gtt total\n", dev->gtt_total);
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_ioc32.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_ioc32.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_ioc32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_ioc32.c	2012-03-13 13:15:34.992097998 +0100
@@ -463,7 +463,7 @@ static int compat_drm_infobufs(struct fi
 	request = compat_alloc_user_space(nbytes);
 	if (!access_ok(VERIFY_WRITE, request, nbytes))
 		return -EFAULT;
-	list = (struct drm_buf_desc *) (request + 1);
+	list = (struct drm_buf_desc __user *) (request + 1);
 
 	if (__put_user(count, &request->count)
 	    || __put_user(list, &request->list))
@@ -525,7 +525,7 @@ static int compat_drm_mapbufs(struct fil
 	request = compat_alloc_user_space(nbytes);
 	if (!access_ok(VERIFY_WRITE, request, nbytes))
 		return -EFAULT;
-	list = (struct drm_buf_pub *) (request + 1);
+	list = (struct drm_buf_pub __user *) (request + 1);
 
 	if (__put_user(count, &request->count)
 	    || __put_user(list, &request->list))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_ioctl.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_ioctl.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_ioctl.c	2012-03-13 13:15:34.992097998 +0100
@@ -283,7 +283,7 @@ int drm_getstats(struct drm_device *dev,
 			stats->data[i].value =
 			    (file_priv->master->lock.hw_lock ? file_priv->master->lock.hw_lock->lock : 0);
 		else
-			stats->data[i].value = atomic_read(&dev->counts[i]);
+			stats->data[i].value = atomic_read_unchecked(&dev->counts[i]);
 		stats->data[i].type = dev->types[i];
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/drm_lock.c linux-2.6.32.60-pax/drivers/gpu/drm/drm_lock.c
--- linux-2.6.32.60/drivers/gpu/drm/drm_lock.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/drm_lock.c	2012-03-13 13:15:34.992097998 +0100
@@ -87,7 +87,7 @@ int drm_lock(struct drm_device *dev, voi
 		if (drm_lock_take(&master->lock, lock->context)) {
 			master->lock.file_priv = file_priv;
 			master->lock.lock_time = jiffies;
-			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
+			atomic_inc_unchecked(&dev->counts[_DRM_STAT_LOCKS]);
 			break;	/* Got lock */
 		}
 
@@ -165,7 +165,7 @@ int drm_unlock(struct drm_device *dev, v
 		return -EINVAL;
 	}
 
-	atomic_inc(&dev->counts[_DRM_STAT_UNLOCKS]);
+	atomic_inc_unchecked(&dev->counts[_DRM_STAT_UNLOCKS]);
 
 	/* kernel_context_switch isn't used by any of the x86 drm
 	 * modules but is required by the Sparc driver.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i810/i810_dma.c linux-2.6.32.60-pax/drivers/gpu/drm/i810/i810_dma.c
--- linux-2.6.32.60/drivers/gpu/drm/i810/i810_dma.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i810/i810_dma.c	2012-03-13 13:15:34.992097998 +0100
@@ -952,8 +952,8 @@ static int i810_dma_vertex(struct drm_de
 				 dma->buflist[vertex->idx],
 				 vertex->discard, vertex->used);
 
-	atomic_add(vertex->used, &dev->counts[_DRM_STAT_SECONDARY]);
-	atomic_inc(&dev->counts[_DRM_STAT_DMA]);
+	atomic_add_unchecked(vertex->used, &dev->counts[_DRM_STAT_SECONDARY]);
+	atomic_inc_unchecked(&dev->counts[_DRM_STAT_DMA]);
 	sarea_priv->last_enqueue = dev_priv->counter - 1;
 	sarea_priv->last_dispatch = (int)hw_status[5];
 
@@ -1115,8 +1115,8 @@ static int i810_dma_mc(struct drm_device
 	i810_dma_dispatch_mc(dev, dma->buflist[mc->idx], mc->used,
 			     mc->last_render);
 
-	atomic_add(mc->used, &dev->counts[_DRM_STAT_SECONDARY]);
-	atomic_inc(&dev->counts[_DRM_STAT_DMA]);
+	atomic_add_unchecked(mc->used, &dev->counts[_DRM_STAT_SECONDARY]);
+	atomic_inc_unchecked(&dev->counts[_DRM_STAT_DMA]);
 	sarea_priv->last_enqueue = dev_priv->counter - 1;
 	sarea_priv->last_dispatch = (int)hw_status[5];
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i810/i810_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/i810/i810_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/i810/i810_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i810/i810_drv.h	2012-03-13 13:15:34.996097997 +0100
@@ -108,8 +108,8 @@ typedef struct drm_i810_private {
 	int page_flipping;
 
 	wait_queue_head_t irq_queue;
-	atomic_t irq_received;
-	atomic_t irq_emitted;
+	atomic_unchecked_t irq_received;
+	atomic_unchecked_t irq_emitted;
 
 	int front_offset;
 } drm_i810_private_t;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i830/i830_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/i830/i830_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/i830/i830_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i830/i830_drv.h	2012-03-13 13:15:34.996097997 +0100
@@ -115,8 +115,8 @@ typedef struct drm_i830_private {
 	int page_flipping;
 
 	wait_queue_head_t irq_queue;
-	atomic_t irq_received;
-	atomic_t irq_emitted;
+	atomic_unchecked_t irq_received;
+	atomic_unchecked_t irq_emitted;
 
 	int use_mi_batchbuffer_start;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i830/i830_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/i830/i830_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/i830/i830_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i830/i830_irq.c	2012-03-13 13:15:34.996097997 +0100
@@ -47,7 +47,7 @@ irqreturn_t i830_driver_irq_handler(DRM_
 
 	I830_WRITE16(I830REG_INT_IDENTITY_R, temp);
 
-	atomic_inc(&dev_priv->irq_received);
+	atomic_inc_unchecked(&dev_priv->irq_received);
 	wake_up_interruptible(&dev_priv->irq_queue);
 
 	return IRQ_HANDLED;
@@ -60,14 +60,14 @@ static int i830_emit_irq(struct drm_devi
 
 	DRM_DEBUG("%s\n", __func__);
 
-	atomic_inc(&dev_priv->irq_emitted);
+	atomic_inc_unchecked(&dev_priv->irq_emitted);
 
 	BEGIN_LP_RING(2);
 	OUT_RING(0);
 	OUT_RING(GFX_OP_USER_INTERRUPT);
 	ADVANCE_LP_RING();
 
-	return atomic_read(&dev_priv->irq_emitted);
+	return atomic_read_unchecked(&dev_priv->irq_emitted);
 }
 
 static int i830_wait_irq(struct drm_device * dev, int irq_nr)
@@ -79,7 +79,7 @@ static int i830_wait_irq(struct drm_devi
 
 	DRM_DEBUG("%s\n", __func__);
 
-	if (atomic_read(&dev_priv->irq_received) >= irq_nr)
+	if (atomic_read_unchecked(&dev_priv->irq_received) >= irq_nr)
 		return 0;
 
 	dev_priv->sarea_priv->perf_boxes |= I830_BOX_WAIT;
@@ -88,7 +88,7 @@ static int i830_wait_irq(struct drm_devi
 
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
-		if (atomic_read(&dev_priv->irq_received) >= irq_nr)
+		if (atomic_read_unchecked(&dev_priv->irq_received) >= irq_nr)
 			break;
 		if ((signed)(end - jiffies) <= 0) {
 			DRM_ERROR("timeout iir %x imr %x ier %x hwstam %x\n",
@@ -163,8 +163,8 @@ void i830_driver_irq_preinstall(struct d
 	I830_WRITE16(I830REG_HWSTAM, 0xffff);
 	I830_WRITE16(I830REG_INT_MASK_R, 0x0);
 	I830_WRITE16(I830REG_INT_ENABLE_R, 0x0);
-	atomic_set(&dev_priv->irq_received, 0);
-	atomic_set(&dev_priv->irq_emitted, 0);
+	atomic_set_unchecked(&dev_priv->irq_received, 0);
+	atomic_set_unchecked(&dev_priv->irq_emitted, 0);
 	init_waitqueue_head(&dev_priv->irq_queue);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i915/i915_debugfs.c linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_debugfs.c
--- linux-2.6.32.60/drivers/gpu/drm/i915/i915_debugfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_debugfs.c	2012-03-13 13:15:34.996097997 +0100
@@ -192,7 +192,7 @@ static int i915_interrupt_info(struct se
 			   I915_READ(GTIMR));
 	}
 	seq_printf(m, "Interrupts received: %d\n",
-		   atomic_read(&dev_priv->irq_received));
+		   atomic_read_unchecked(&dev_priv->irq_received));
 	if (dev_priv->hw_status_page != NULL) {
 		seq_printf(m, "Current sequence:    %d\n",
 			   i915_get_gem_seqno(dev));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i915/i915_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/i915/i915_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_drv.h	2013-01-22 15:22:16.840979666 +0100
@@ -197,7 +197,7 @@ typedef struct drm_i915_private {
 	int page_flipping;
 
 	wait_queue_head_t irq_queue;
-	atomic_t irq_received;
+	atomic_unchecked_t irq_received;
 	/** Protects user_irq_refcount and irq_mask_reg */
 	spinlock_t user_irq_lock;
 	/** Refcount for i915_user_irq_get() versus i915_user_irq_put(). */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i915/i915_gem.c linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_gem.c
--- linux-2.6.32.60/drivers/gpu/drm/i915/i915_gem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_gem.c	2013-02-17 18:05:09.632011468 +0100
@@ -102,7 +102,7 @@ i915_gem_get_aperture_ioctl(struct drm_d
 
 	args->aper_size = dev->gtt_total;
 	args->aper_available_size = (args->aper_size -
-				     atomic_read(&dev->pin_memory));
+				     atomic_read_unchecked(&dev->pin_memory));
 
 	return 0;
 }
@@ -495,6 +495,11 @@ i915_gem_pread_ioctl(struct drm_device *
 		goto err;
 	}
 
+	if (!access_ok(VERIFY_WRITE, (char __user *) (uintptr_t)args->data_ptr, args->size)) {
+		drm_gem_object_unreference(obj);
+		return -EFAULT;
+	}
+
 	if (i915_gem_object_needs_bit17_swizzle(obj)) {
 		ret = i915_gem_shmem_pread_slow(dev, obj, args, file_priv);
 	} else {
@@ -969,6 +974,11 @@ i915_gem_pwrite_ioctl(struct drm_device
 		goto err;
 	}
 
+	if (!access_ok(VERIFY_READ, (char __user *) (uintptr_t)args->data_ptr, args->size)) {
+		drm_gem_object_unreference(obj);
+		return -EFAULT;
+	}
+
 	/* We can only do the GTT pwrite on untiled buffers, as otherwise
 	 * it would end up going through the fenced access, and we'll get
 	 * different detiling behavior between reading and writing.
@@ -2058,7 +2068,7 @@ i915_gem_object_unbind(struct drm_gem_ob
 
 	if (obj_priv->gtt_space) {
 		atomic_dec(&dev->gtt_count);
-		atomic_sub(obj->size, &dev->gtt_memory);
+		atomic_sub_unchecked(obj->size, &dev->gtt_memory);
 
 		drm_mm_put_block(obj_priv->gtt_space);
 		obj_priv->gtt_space = NULL;
@@ -2701,7 +2711,7 @@ i915_gem_object_bind_to_gtt(struct drm_g
 		goto search_free;
 	}
 	atomic_inc(&dev->gtt_count);
-	atomic_add(obj->size, &dev->gtt_memory);
+	atomic_add_unchecked(obj->size, &dev->gtt_memory);
 
 	/* Assert that the object is not currently in any GPU domain. As it
 	 * wasn't in the GTT, there shouldn't be any way it could have been in
@@ -3639,8 +3649,8 @@ i915_gem_execbuffer(struct drm_device *d
 		return -EINVAL;
 	}
 	/* Copy in the exec list from userland */
-	exec_list = drm_calloc_large(sizeof(*exec_list), args->buffer_count);
-	object_list = drm_calloc_large(sizeof(*object_list), args->buffer_count);
+	exec_list = drm_calloc_large(args->buffer_count, sizeof(*exec_list));
+	object_list = drm_calloc_large(args->buffer_count, sizeof(*object_list));
 	if (exec_list == NULL || object_list == NULL) {
 		DRM_ERROR("Failed to allocate exec or object list "
 			  "for %d buffers\n",
@@ -3755,9 +3765,9 @@ i915_gem_execbuffer(struct drm_device *d
 					  "%d/%d gtt bytes\n",
 					  atomic_read(&dev->object_count),
 					  atomic_read(&dev->pin_count),
-					  atomic_read(&dev->object_memory),
-					  atomic_read(&dev->pin_memory),
-					  atomic_read(&dev->gtt_memory),
+					  atomic_read_unchecked(&dev->object_memory),
+					  atomic_read_unchecked(&dev->pin_memory),
+					  atomic_read_unchecked(&dev->gtt_memory),
 					  dev->gtt_total);
 			}
 			goto err;
@@ -3989,7 +3999,7 @@ i915_gem_object_pin(struct drm_gem_objec
 	 */
 	if (obj_priv->pin_count == 1) {
 		atomic_inc(&dev->pin_count);
-		atomic_add(obj->size, &dev->pin_memory);
+		atomic_add_unchecked(obj->size, &dev->pin_memory);
 		if (!obj_priv->active &&
 		    (obj->write_domain & I915_GEM_GPU_DOMAINS) == 0 &&
 		    !list_empty(&obj_priv->list))
@@ -4022,7 +4032,7 @@ i915_gem_object_unpin(struct drm_gem_obj
 			list_move_tail(&obj_priv->list,
 				       &dev_priv->mm.inactive_list);
 		atomic_dec(&dev->pin_count);
-		atomic_sub(obj->size, &dev->pin_memory);
+		atomic_sub_unchecked(obj->size, &dev->pin_memory);
 	}
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i915/i915_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/i915/i915_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i915/i915_irq.c	2012-03-13 13:15:35.004097997 +0100
@@ -528,7 +528,7 @@ irqreturn_t i915_driver_irq_handler(DRM_
 	int irq_received;
 	int ret = IRQ_NONE;
 
-	atomic_inc(&dev_priv->irq_received);
+	atomic_inc_unchecked(&dev_priv->irq_received);
 
 	if (IS_IGDNG(dev))
 		return igdng_irq_handler(dev);
@@ -1021,7 +1021,7 @@ void i915_driver_irq_preinstall(struct d
 {
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
 
-	atomic_set(&dev_priv->irq_received, 0);
+	atomic_set_unchecked(&dev_priv->irq_received, 0);
 
 	INIT_WORK(&dev_priv->hotplug_work, i915_hotplug_work_func);
 	INIT_WORK(&dev_priv->error_work, i915_error_work_func);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/i915/intel_sdvo.c linux-2.6.32.60-pax/drivers/gpu/drm/i915/intel_sdvo.c
--- linux-2.6.32.60/drivers/gpu/drm/i915/intel_sdvo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/i915/intel_sdvo.c	2012-03-13 13:15:35.004097997 +0100
@@ -2795,7 +2795,9 @@ bool intel_sdvo_init(struct drm_device *
 	sdvo_priv->slave_addr = intel_sdvo_get_slave_addr(dev, output_device);
 
 	/* Save the bit-banging i2c functionality for use by the DDC wrapper */
-	intel_sdvo_i2c_bit_algo.functionality = intel_output->i2c_bus->algo->functionality;
+	pax_open_kernel();
+	*(void **)&intel_sdvo_i2c_bit_algo.functionality = intel_output->i2c_bus->algo->functionality;
+	pax_close_kernel();
 
 	/* Read the regs to test if we can talk to the device */
 	for (i = 0; i < 0x40; i++) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/mga/mga_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/mga/mga_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/mga/mga_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/mga/mga_drv.h	2012-03-13 13:15:35.004097997 +0100
@@ -120,9 +120,9 @@ typedef struct drm_mga_private {
 	u32 clear_cmd;
 	u32 maccess;
 
-	atomic_t vbl_received;          /**< Number of vblanks received. */
+	atomic_unchecked_t vbl_received;          /**< Number of vblanks received. */
 	wait_queue_head_t fence_queue;
-	atomic_t last_fence_retired;
+	atomic_unchecked_t last_fence_retired;
 	u32 next_fence_to_post;
 
 	unsigned int fb_cpp;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/mga/mga_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/mga/mga_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/mga/mga_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/mga/mga_irq.c	2012-03-13 13:15:35.008097997 +0100
@@ -44,7 +44,7 @@ u32 mga_get_vblank_counter(struct drm_de
 	if (crtc != 0)
 		return 0;
 
-	return atomic_read(&dev_priv->vbl_received);
+	return atomic_read_unchecked(&dev_priv->vbl_received);
 }
 
 
@@ -60,7 +60,7 @@ irqreturn_t mga_driver_irq_handler(DRM_I
 	/* VBLANK interrupt */
 	if (status & MGA_VLINEPEN) {
 		MGA_WRITE(MGA_ICLEAR, MGA_VLINEICLR);
-		atomic_inc(&dev_priv->vbl_received);
+		atomic_inc_unchecked(&dev_priv->vbl_received);
 		drm_handle_vblank(dev, 0);
 		handled = 1;
 	}
@@ -80,7 +80,7 @@ irqreturn_t mga_driver_irq_handler(DRM_I
 			MGA_WRITE(MGA_PRIMEND, prim_end);
 		}
 
-		atomic_inc(&dev_priv->last_fence_retired);
+		atomic_inc_unchecked(&dev_priv->last_fence_retired);
 		DRM_WAKEUP(&dev_priv->fence_queue);
 		handled = 1;
 	}
@@ -131,7 +131,7 @@ int mga_driver_fence_wait(struct drm_dev
 	 * using fences.
 	 */
 	DRM_WAIT_ON(ret, dev_priv->fence_queue, 3 * DRM_HZ,
-		    (((cur_fence = atomic_read(&dev_priv->last_fence_retired))
+		    (((cur_fence = atomic_read_unchecked(&dev_priv->last_fence_retired))
 		      - *sequence) <= (1 << 23)));
 
 	*sequence = cur_fence;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/r128/r128_cce.c linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_cce.c
--- linux-2.6.32.60/drivers/gpu/drm/r128/r128_cce.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_cce.c	2012-03-13 13:15:35.008097997 +0100
@@ -377,7 +377,7 @@ static int r128_do_init_cce(struct drm_d
 
 	/* GH: Simple idle check.
 	 */
-	atomic_set(&dev_priv->idle_count, 0);
+	atomic_set_unchecked(&dev_priv->idle_count, 0);
 
 	/* We don't support anything other than bus-mastering ring mode,
 	 * but the ring can be in either AGP or PCI space for the ring
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/r128/r128_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/r128/r128_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_drv.h	2012-03-13 13:15:35.008097997 +0100
@@ -90,14 +90,14 @@ typedef struct drm_r128_private {
 	int is_pci;
 	unsigned long cce_buffers_offset;
 
-	atomic_t idle_count;
+	atomic_unchecked_t idle_count;
 
 	int page_flipping;
 	int current_page;
 	u32 crtc_offset;
 	u32 crtc_offset_cntl;
 
-	atomic_t vbl_received;
+	atomic_unchecked_t vbl_received;
 
 	u32 color_fmt;
 	unsigned int front_offset;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/r128/r128_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/r128/r128_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_irq.c	2012-03-13 13:15:35.008097997 +0100
@@ -42,7 +42,7 @@ u32 r128_get_vblank_counter(struct drm_d
 	if (crtc != 0)
 		return 0;
 
-	return atomic_read(&dev_priv->vbl_received);
+	return atomic_read_unchecked(&dev_priv->vbl_received);
 }
 
 irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS)
@@ -56,7 +56,7 @@ irqreturn_t r128_driver_irq_handler(DRM_
 	/* VBLANK interrupt */
 	if (status & R128_CRTC_VBLANK_INT) {
 		R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
-		atomic_inc(&dev_priv->vbl_received);
+		atomic_inc_unchecked(&dev_priv->vbl_received);
 		drm_handle_vblank(dev, 0);
 		return IRQ_HANDLED;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/r128/r128_state.c linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_state.c
--- linux-2.6.32.60/drivers/gpu/drm/r128/r128_state.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/r128/r128_state.c	2012-03-13 13:15:35.012097996 +0100
@@ -323,10 +323,10 @@ static void r128_clear_box(drm_r128_priv
 
 static void r128_cce_performance_boxes(drm_r128_private_t * dev_priv)
 {
-	if (atomic_read(&dev_priv->idle_count) == 0) {
+	if (atomic_read_unchecked(&dev_priv->idle_count) == 0) {
 		r128_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
 	} else {
-		atomic_set(&dev_priv->idle_count, 0);
+		atomic_set_unchecked(&dev_priv->idle_count, 0);
 	}
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/mkregtable.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/mkregtable.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/mkregtable.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/mkregtable.c	2012-03-13 13:15:35.012097996 +0100
@@ -637,14 +637,14 @@ static int parser_auth(struct table *t,
 	regex_t mask_rex;
 	regmatch_t match[4];
 	char buf[1024];
-	size_t end;
+	long end;
 	int len;
 	int done = 0;
 	int r;
 	unsigned o;
 	struct offset *offset;
 	char last_reg_s[10];
-	int last_reg;
+	unsigned long last_reg;
 
 	if (regcomp
 	    (&mask_rex, "(0x[0-9a-fA-F]*) *([_a-zA-Z0-9]*)", REG_EXTENDED)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/r100.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/r100.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/r100.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/r100.c	2013-01-22 17:00:21.396665476 +0100
@@ -89,8 +89,10 @@ int r100_pci_gart_init(struct radeon_dev
 	if (r)
 		return r;
 	rdev->gart.table_size = rdev->gart.num_gpu_pages * 4;
-	rdev->asic->gart_tlb_flush = &r100_pci_gart_tlb_flush;
-	rdev->asic->gart_set_page = &r100_pci_gart_set_page;
+	pax_open_kernel();
+	*(void **)&rdev->asic->gart_tlb_flush = &r100_pci_gart_tlb_flush;
+	*(void **)&rdev->asic->gart_set_page = &r100_pci_gart_set_page;
+	pax_close_kernel();
 	return radeon_gart_table_ram_alloc(rdev);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/r300.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/r300.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/r300.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/r300.c	2013-01-22 17:01:33.000661653 +0100
@@ -91,8 +91,10 @@ int rv370_pcie_gart_init(struct radeon_d
 	if (r)
 		DRM_ERROR("Failed to register debugfs file for PCIE gart !\n");
 	rdev->gart.table_size = rdev->gart.num_gpu_pages * 4;
-	rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
-	rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+	pax_open_kernel();
+	*(void **)&rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
+	*(void **)&rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+	pax_close_kernel();
 	return radeon_gart_table_vram_alloc(rdev);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_atombios.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_atombios.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_atombios.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_atombios.c	2012-03-13 13:15:35.012097996 +0100
@@ -520,13 +520,13 @@ static uint16_t atombios_get_connector_o
 	}
 }
 
-struct bios_connector {
+static struct bios_connector {
 	bool valid;
 	uint16_t line_mux;
 	uint16_t devices;
 	int connector_type;
 	struct radeon_i2c_bus_rec ddc_bus;
-};
+} bios_connectors[ATOM_MAX_SUPPORTED_DEVICE];
 
 bool radeon_get_atom_connector_info_from_supported_devices_table(struct
 								 drm_device
@@ -542,7 +542,6 @@ bool radeon_get_atom_connector_info_from
 	uint8_t dac;
 	union atom_supported_devices *supported_devices;
 	int i, j;
-	struct bios_connector bios_connectors[ATOM_MAX_SUPPORTED_DEVICE];
 
 	atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_device.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_device.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_device.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_device.c	2013-01-23 00:04:28.711306787 +0100
@@ -322,8 +322,10 @@ int radeon_asic_init(struct radeon_devic
 	case CHIP_RV380:
 		rdev->asic = &r300_asic;
 		if (rdev->flags & RADEON_IS_PCIE) {
-			rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
-			rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+			pax_open_kernel();
+			*(void **)&rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
+			*(void **)&rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+			pax_close_kernel();
 		}
 		break;
 	case CHIP_R420:
@@ -506,13 +508,17 @@ void radeon_agp_disable(struct radeon_de
 			rdev->family == CHIP_R423) {
 		DRM_INFO("Forcing AGP to PCIE mode\n");
 		rdev->flags |= RADEON_IS_PCIE;
-		rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
-		rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+		pax_open_kernel();
+		*(void **)&rdev->asic->gart_tlb_flush = &rv370_pcie_gart_tlb_flush;
+		*(void **)&rdev->asic->gart_set_page = &rv370_pcie_gart_set_page;
+		pax_close_kernel();
 	} else {
 		DRM_INFO("Forcing AGP to PCI mode\n");
 		rdev->flags |= RADEON_IS_PCI;
-		rdev->asic->gart_tlb_flush = &r100_pci_gart_tlb_flush;
-		rdev->asic->gart_set_page = &r100_pci_gart_set_page;
+		pax_open_kernel();
+		*(void **)&rdev->asic->gart_tlb_flush = &r100_pci_gart_tlb_flush;
+		*(void **)&rdev->asic->gart_set_page = &r100_pci_gart_set_page;
+		pax_close_kernel();
 	}
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_display.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_display.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_display.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_display.c	2012-03-13 13:15:35.016097996 +0100
@@ -482,7 +482,7 @@ void radeon_compute_pll(struct radeon_pl
 
 					if (flags & RADEON_PLL_PREFER_CLOSEST_LOWER) {
 						error = freq - current_freq;
-						error = error < 0 ? 0xffffffff : error;
+						error = (int32_t)error < 0 ? 0xffffffff : error;
 					} else
 						error = abs(current_freq - freq);
 					vco_diff = abs(vco - best_vco);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_drv.h	2012-03-13 13:15:35.016097996 +0100
@@ -253,7 +253,7 @@ typedef struct drm_radeon_private {
 
 	/* SW interrupt */
 	wait_queue_head_t swi_queue;
-	atomic_t swi_emitted;
+	atomic_unchecked_t swi_emitted;
 	int vblank_crtc;
 	uint32_t irq_enable_reg;
 	uint32_t r500_disp_irq_reg;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_fence.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_fence.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_fence.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_fence.c	2012-03-13 13:15:35.020097996 +0100
@@ -47,7 +47,7 @@ int radeon_fence_emit(struct radeon_devi
 		write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
 		return 0;
 	}
-	fence->seq = atomic_add_return(1, &rdev->fence_drv.seq);
+	fence->seq = atomic_add_return_unchecked(1, &rdev->fence_drv.seq);
 	if (!rdev->cp.ready) {
 		/* FIXME: cp is not running assume everythings is done right
 		 * away
@@ -364,7 +364,7 @@ int radeon_fence_driver_init(struct rade
 		return r;
 	}
 	WREG32(rdev->fence_drv.scratch_reg, 0);
-	atomic_set(&rdev->fence_drv.seq, 0);
+	atomic_set_unchecked(&rdev->fence_drv.seq, 0);
 	INIT_LIST_HEAD(&rdev->fence_drv.created);
 	INIT_LIST_HEAD(&rdev->fence_drv.emited);
 	INIT_LIST_HEAD(&rdev->fence_drv.signaled);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon.h linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon.h
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon.h	2013-01-22 15:23:56.284974356 +0100
@@ -149,7 +149,7 @@ int radeon_pm_init(struct radeon_device
  */
 struct radeon_fence_driver {
 	uint32_t			scratch_reg;
-	atomic_t			seq;
+	atomic_unchecked_t		seq;
 	uint32_t			last_seq;
 	unsigned long			count_timeout;
 	wait_queue_head_t		queue;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_ioc32.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_ioc32.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_ioc32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_ioc32.c	2012-03-13 13:15:35.020097996 +0100
@@ -368,7 +368,7 @@ static int compat_radeon_cp_setparam(str
 	request = compat_alloc_user_space(sizeof(*request));
 	if (!access_ok(VERIFY_WRITE, request, sizeof(*request))
 	    || __put_user(req32.param, &request->param)
-	    || __put_user((void __user *)(unsigned long)req32.value,
+	    || __put_user((unsigned long)req32.value,
 			  &request->value))
 		return -EFAULT;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_irq.c	2012-03-13 13:15:35.020097996 +0100
@@ -225,8 +225,8 @@ static int radeon_emit_irq(struct drm_de
 	unsigned int ret;
 	RING_LOCALS;
 
-	atomic_inc(&dev_priv->swi_emitted);
-	ret = atomic_read(&dev_priv->swi_emitted);
+	atomic_inc_unchecked(&dev_priv->swi_emitted);
+	ret = atomic_read_unchecked(&dev_priv->swi_emitted);
 
 	BEGIN_RING(4);
 	OUT_RING_REG(RADEON_LAST_SWI_REG, ret);
@@ -352,7 +352,7 @@ int radeon_driver_irq_postinstall(struct
 	drm_radeon_private_t *dev_priv =
 	    (drm_radeon_private_t *) dev->dev_private;
 
-	atomic_set(&dev_priv->swi_emitted, 0);
+	atomic_set_unchecked(&dev_priv->swi_emitted, 0);
 	DRM_INIT_WAITQUEUE(&dev_priv->swi_queue);
 
 	dev->max_vblank_count = 0x001fffff;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_state.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_state.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_state.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_state.c	2012-03-13 13:15:35.024097996 +0100
@@ -3021,7 +3021,7 @@ static int radeon_cp_getparam(struct drm
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
 	drm_radeon_getparam_t *param = data;
-	int value;
+	int value = 0;
 
 	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_ttm.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_ttm.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/radeon_ttm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/radeon_ttm.c	2012-03-13 13:15:35.024097996 +0100
@@ -535,27 +535,10 @@ void radeon_ttm_fini(struct radeon_devic
 	DRM_INFO("radeon: ttm finalized\n");
 }
 
-static struct vm_operations_struct radeon_ttm_vm_ops;
-static const struct vm_operations_struct *ttm_vm_ops = NULL;
-
-static int radeon_ttm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
-{
-	struct ttm_buffer_object *bo;
-	int r;
-
-	bo = (struct ttm_buffer_object *)vma->vm_private_data;
-	if (bo == NULL) {
-		return VM_FAULT_NOPAGE;
-	}
-	r = ttm_vm_ops->fault(vma, vmf);
-	return r;
-}
-
 int radeon_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	struct drm_file *file_priv;
 	struct radeon_device *rdev;
-	int r;
 
 	if (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET)) {
 		return drm_mmap(filp, vma);
@@ -563,20 +546,9 @@ int radeon_mmap(struct file *filp, struc
 
 	file_priv = (struct drm_file *)filp->private_data;
 	rdev = file_priv->minor->dev->dev_private;
-	if (rdev == NULL) {
+	if (!rdev)
 		return -EINVAL;
-	}
-	r = ttm_bo_mmap(filp, vma, &rdev->mman.bdev);
-	if (unlikely(r != 0)) {
-		return r;
-	}
-	if (unlikely(ttm_vm_ops == NULL)) {
-		ttm_vm_ops = vma->vm_ops;
-		radeon_ttm_vm_ops = *ttm_vm_ops;
-		radeon_ttm_vm_ops.fault = &radeon_ttm_fault;
-	}
-	vma->vm_ops = &radeon_ttm_vm_ops;
-	return 0;
+	return ttm_bo_mmap(filp, vma, &rdev->mman.bdev);
 }
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/radeon/rs690.c linux-2.6.32.60-pax/drivers/gpu/drm/radeon/rs690.c
--- linux-2.6.32.60/drivers/gpu/drm/radeon/rs690.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/radeon/rs690.c	2012-03-13 13:15:35.024097996 +0100
@@ -302,9 +302,11 @@ void rs690_crtc_bandwidth_compute(struct
 		if (rdev->pm.max_bandwidth.full > rdev->pm.sideport_bandwidth.full &&
 			rdev->pm.sideport_bandwidth.full)
 			rdev->pm.max_bandwidth = rdev->pm.sideport_bandwidth;
-		read_delay_latency.full = rfixed_const(370 * 800 * 1000);
+		read_delay_latency.full = rfixed_const(800 * 1000);
 		read_delay_latency.full = rfixed_div(read_delay_latency,
 			rdev->pm.igp_sideport_mclk);
+		a.full = rfixed_const(370);
+		read_delay_latency.full = rfixed_mul(read_delay_latency, a);
 	} else {
 		if (rdev->pm.max_bandwidth.full > rdev->pm.k8_bandwidth.full &&
 			rdev->pm.k8_bandwidth.full)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/ttm/ttm_bo_vm.c linux-2.6.32.60-pax/drivers/gpu/drm/ttm/ttm_bo_vm.c
--- linux-2.6.32.60/drivers/gpu/drm/ttm/ttm_bo_vm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/ttm/ttm_bo_vm.c	2012-03-13 13:15:35.028097996 +0100
@@ -73,7 +73,7 @@ static int ttm_bo_vm_fault(struct vm_are
 {
 	struct ttm_buffer_object *bo = (struct ttm_buffer_object *)
 	    vma->vm_private_data;
-	struct ttm_bo_device *bdev = bo->bdev;
+	struct ttm_bo_device *bdev;
 	unsigned long bus_base;
 	unsigned long bus_offset;
 	unsigned long bus_size;
@@ -88,6 +88,10 @@ static int ttm_bo_vm_fault(struct vm_are
 	unsigned long address = (unsigned long)vmf->virtual_address;
 	int retval = VM_FAULT_NOPAGE;
 
+	if (!bo)
+		return VM_FAULT_NOPAGE;
+	bdev = bo->bdev;
+
 	/*
 	 * Work around locking order reversal in fault / nopfn
 	 * between mmap_sem and bo_reserve: Perform a trylock operation
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/ttm/ttm_global.c linux-2.6.32.60-pax/drivers/gpu/drm/ttm/ttm_global.c
--- linux-2.6.32.60/drivers/gpu/drm/ttm/ttm_global.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/ttm/ttm_global.c	2012-03-13 13:15:35.028097996 +0100
@@ -36,7 +36,7 @@
 struct ttm_global_item {
 	struct mutex mutex;
 	void *object;
-	int refcount;
+	atomic_t refcount;
 };
 
 static struct ttm_global_item glob[TTM_GLOBAL_NUM];
@@ -49,7 +49,7 @@ void ttm_global_init(void)
 		struct ttm_global_item *item = &glob[i];
 		mutex_init(&item->mutex);
 		item->object = NULL;
-		item->refcount = 0;
+		atomic_set(&item->refcount, 0);
 	}
 }
 
@@ -59,7 +59,7 @@ void ttm_global_release(void)
 	for (i = 0; i < TTM_GLOBAL_NUM; ++i) {
 		struct ttm_global_item *item = &glob[i];
 		BUG_ON(item->object != NULL);
-		BUG_ON(item->refcount != 0);
+		BUG_ON(atomic_read(&item->refcount) != 0);
 	}
 }
 
@@ -70,7 +70,7 @@ int ttm_global_item_ref(struct ttm_globa
 	void *object;
 
 	mutex_lock(&item->mutex);
-	if (item->refcount == 0) {
+	if (atomic_read(&item->refcount) == 0) {
 		item->object = kzalloc(ref->size, GFP_KERNEL);
 		if (unlikely(item->object == NULL)) {
 			ret = -ENOMEM;
@@ -83,7 +83,7 @@ int ttm_global_item_ref(struct ttm_globa
 			goto out_err;
 
 	}
-	++item->refcount;
+	atomic_inc(&item->refcount);
 	ref->object = item->object;
 	object = item->object;
 	mutex_unlock(&item->mutex);
@@ -100,9 +100,9 @@ void ttm_global_item_unref(struct ttm_gl
 	struct ttm_global_item *item = &glob[ref->global_type];
 
 	mutex_lock(&item->mutex);
-	BUG_ON(item->refcount == 0);
+	BUG_ON(atomic_read(&item->refcount) == 0);
 	BUG_ON(ref->object != item->object);
-	if (--item->refcount == 0) {
+	if (atomic_dec_and_test(&item->refcount)) {
 		ref->release(ref);
 		item->object = NULL;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/via/via_drv.h linux-2.6.32.60-pax/drivers/gpu/drm/via/via_drv.h
--- linux-2.6.32.60/drivers/gpu/drm/via/via_drv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/via/via_drv.h	2012-03-13 13:15:35.028097996 +0100
@@ -51,7 +51,7 @@ typedef struct drm_via_ring_buffer {
 typedef uint32_t maskarray_t[5];
 
 typedef struct drm_via_irq {
-	atomic_t irq_received;
+	atomic_unchecked_t irq_received;
 	uint32_t pending_mask;
 	uint32_t enable_mask;
 	wait_queue_head_t irq_queue;
@@ -75,7 +75,7 @@ typedef struct drm_via_private {
 	struct timeval last_vblank;
 	int last_vblank_valid;
 	unsigned usec_per_vblank;
-	atomic_t vbl_received;
+	atomic_unchecked_t vbl_received;
 	drm_via_state_t hc_state;
 	char pci_buf[VIA_PCI_BUF_SIZE];
 	const uint32_t *fire_offsets[VIA_FIRE_BUF_SIZE];
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/gpu/drm/via/via_irq.c linux-2.6.32.60-pax/drivers/gpu/drm/via/via_irq.c
--- linux-2.6.32.60/drivers/gpu/drm/via/via_irq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/gpu/drm/via/via_irq.c	2012-03-13 13:15:35.028097996 +0100
@@ -102,7 +102,7 @@ u32 via_get_vblank_counter(struct drm_de
 	if (crtc != 0)
 		return 0;
 
-	return atomic_read(&dev_priv->vbl_received);
+	return atomic_read_unchecked(&dev_priv->vbl_received);
 }
 
 irqreturn_t via_driver_irq_handler(DRM_IRQ_ARGS)
@@ -117,8 +117,8 @@ irqreturn_t via_driver_irq_handler(DRM_I
 
 	status = VIA_READ(VIA_REG_INTERRUPT);
 	if (status & VIA_IRQ_VBLANK_PENDING) {
-		atomic_inc(&dev_priv->vbl_received);
-		if (!(atomic_read(&dev_priv->vbl_received) & 0x0F)) {
+		atomic_inc_unchecked(&dev_priv->vbl_received);
+		if (!(atomic_read_unchecked(&dev_priv->vbl_received) & 0x0F)) {
 			do_gettimeofday(&cur_vblank);
 			if (dev_priv->last_vblank_valid) {
 				dev_priv->usec_per_vblank =
@@ -128,7 +128,7 @@ irqreturn_t via_driver_irq_handler(DRM_I
 			dev_priv->last_vblank = cur_vblank;
 			dev_priv->last_vblank_valid = 1;
 		}
-		if (!(atomic_read(&dev_priv->vbl_received) & 0xFF)) {
+		if (!(atomic_read_unchecked(&dev_priv->vbl_received) & 0xFF)) {
 			DRM_DEBUG("US per vblank is: %u\n",
 				  dev_priv->usec_per_vblank);
 		}
@@ -138,7 +138,7 @@ irqreturn_t via_driver_irq_handler(DRM_I
 
 	for (i = 0; i < dev_priv->num_irqs; ++i) {
 		if (status & cur_irq->pending_mask) {
-			atomic_inc(&cur_irq->irq_received);
+			atomic_inc_unchecked(&cur_irq->irq_received);
 			DRM_WAKEUP(&cur_irq->irq_queue);
 			handled = 1;
 			if (dev_priv->irq_map[drm_via_irq_dma0_td] == i) {
@@ -244,11 +244,11 @@ via_driver_irq_wait(struct drm_device *
 		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
 			    ((VIA_READ(masks[irq][2]) & masks[irq][3]) ==
 			     masks[irq][4]));
-		cur_irq_sequence = atomic_read(&cur_irq->irq_received);
+		cur_irq_sequence = atomic_read_unchecked(&cur_irq->irq_received);
 	} else {
 		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
 			    (((cur_irq_sequence =
-			       atomic_read(&cur_irq->irq_received)) -
+			       atomic_read_unchecked(&cur_irq->irq_received)) -
 			      *sequence) <= (1 << 23)));
 	}
 	*sequence = cur_irq_sequence;
@@ -286,7 +286,7 @@ void via_driver_irq_preinstall(struct dr
 		}
 
 		for (i = 0; i < dev_priv->num_irqs; ++i) {
-			atomic_set(&cur_irq->irq_received, 0);
+			atomic_set_unchecked(&cur_irq->irq_received, 0);
 			cur_irq->enable_mask = dev_priv->irq_masks[i][0];
 			cur_irq->pending_mask = dev_priv->irq_masks[i][1];
 			DRM_INIT_WAITQUEUE(&cur_irq->irq_queue);
@@ -368,7 +368,7 @@ int via_wait_irq(struct drm_device *dev,
 	switch (irqwait->request.type & ~VIA_IRQ_FLAGS_MASK) {
 	case VIA_IRQ_RELATIVE:
 		irqwait->request.sequence +=
-			atomic_read(&cur_irq->irq_received);
+			atomic_read_unchecked(&cur_irq->irq_received);
 		irqwait->request.type &= ~_DRM_VBLANK_RELATIVE;
 	case VIA_IRQ_ABSOLUTE:
 		break;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hid/hid-core.c linux-2.6.32.60-pax/drivers/hid/hid-core.c
--- linux-2.6.32.60/drivers/hid/hid-core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hid/hid-core.c	2012-03-13 13:15:35.028097996 +0100
@@ -1752,7 +1752,7 @@ static bool hid_ignore(struct hid_device
 
 int hid_add_device(struct hid_device *hdev)
 {
-	static atomic_t id = ATOMIC_INIT(0);
+	static atomic_unchecked_t id = ATOMIC_INIT(0);
 	int ret;
 
 	if (WARN_ON(hdev->status & HID_STAT_ADDED))
@@ -1766,7 +1766,7 @@ int hid_add_device(struct hid_device *hd
 	/* XXX hack, any other cleaner solution after the driver core
 	 * is converted to allow more than 20 bytes as the device name? */
 	dev_set_name(&hdev->dev, "%04X:%04X:%04X.%04X", hdev->bus,
-		     hdev->vendor, hdev->product, atomic_inc_return(&id));
+		     hdev->vendor, hdev->product, atomic_inc_return_unchecked(&id));
 
 	ret = device_add(&hdev->dev);
 	if (!ret)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hid/usbhid/hiddev.c linux-2.6.32.60-pax/drivers/hid/usbhid/hiddev.c
--- linux-2.6.32.60/drivers/hid/usbhid/hiddev.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hid/usbhid/hiddev.c	2012-03-13 13:15:35.032097995 +0100
@@ -617,7 +617,7 @@ static long hiddev_ioctl(struct file *fi
 		return put_user(HID_VERSION, (int __user *)arg);
 
 	case HIDIOCAPPLICATION:
-		if (arg < 0 || arg >= hid->maxapplication)
+		if (arg >= hid->maxapplication)
 			return -EINVAL;
 
 		for (i = 0; i < hid->maxcollection; i++)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hwmon/lis3lv02d.c linux-2.6.32.60-pax/drivers/hwmon/lis3lv02d.c
--- linux-2.6.32.60/drivers/hwmon/lis3lv02d.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hwmon/lis3lv02d.c	2012-03-13 13:15:35.032097995 +0100
@@ -146,7 +146,7 @@ static irqreturn_t lis302dl_interrupt(in
 	 * the lid is closed. This leads to interrupts as soon as a little move
 	 * is done.
 	 */
-	atomic_inc(&lis3_dev.count);
+	atomic_inc_unchecked(&lis3_dev.count);
 
 	wake_up_interruptible(&lis3_dev.misc_wait);
 	kill_fasync(&lis3_dev.async_queue, SIGIO, POLL_IN);
@@ -160,7 +160,7 @@ static int lis3lv02d_misc_open(struct in
 	if (test_and_set_bit(0, &lis3_dev.misc_opened))
 		return -EBUSY; /* already open */
 
-	atomic_set(&lis3_dev.count, 0);
+	atomic_set_unchecked(&lis3_dev.count, 0);
 
 	/*
 	 * The sensor can generate interrupts for free-fall and direction
@@ -206,7 +206,7 @@ static ssize_t lis3lv02d_misc_read(struc
 	add_wait_queue(&lis3_dev.misc_wait, &wait);
 	while (true) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		data = atomic_xchg(&lis3_dev.count, 0);
+		data = atomic_xchg_unchecked(&lis3_dev.count, 0);
 		if (data)
 			break;
 
@@ -244,7 +244,7 @@ out:
 static unsigned int lis3lv02d_misc_poll(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &lis3_dev.misc_wait, wait);
-	if (atomic_read(&lis3_dev.count))
+	if (atomic_read_unchecked(&lis3_dev.count))
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hwmon/lis3lv02d.h linux-2.6.32.60-pax/drivers/hwmon/lis3lv02d.h
--- linux-2.6.32.60/drivers/hwmon/lis3lv02d.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hwmon/lis3lv02d.h	2012-03-13 13:15:35.032097995 +0100
@@ -201,7 +201,7 @@ struct lis3lv02d {
 
 	struct input_polled_dev	*idev;     /* input device */
 	struct platform_device	*pdev;     /* platform device */
-	atomic_t		count;     /* interrupt count after last read */
+	atomic_unchecked_t	count;     /* interrupt count after last read */
 	int			xcalib;    /* calibrated null value for x */
 	int			ycalib;    /* calibrated null value for y */
 	int			zcalib;    /* calibrated null value for z */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hwmon/sht15.c linux-2.6.32.60-pax/drivers/hwmon/sht15.c
--- linux-2.6.32.60/drivers/hwmon/sht15.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hwmon/sht15.c	2012-03-13 13:15:35.032097995 +0100
@@ -112,7 +112,7 @@ struct sht15_data {
 	int				supply_uV;
 	int				supply_uV_valid;
 	struct work_struct		update_supply_work;
-	atomic_t			interrupt_handled;
+	atomic_unchecked_t		interrupt_handled;
 };
 
 /**
@@ -245,13 +245,13 @@ static inline int sht15_update_single_va
 		return ret;
 
 	gpio_direction_input(data->pdata->gpio_data);
-	atomic_set(&data->interrupt_handled, 0);
+	atomic_set_unchecked(&data->interrupt_handled, 0);
 
 	enable_irq(gpio_to_irq(data->pdata->gpio_data));
 	if (gpio_get_value(data->pdata->gpio_data) == 0) {
 		disable_irq_nosync(gpio_to_irq(data->pdata->gpio_data));
 		/* Only relevant if the interrupt hasn't occured. */
-		if (!atomic_read(&data->interrupt_handled))
+		if (!atomic_read_unchecked(&data->interrupt_handled))
 			schedule_work(&data->read_work);
 	}
 	ret = wait_event_timeout(data->wait_queue,
@@ -398,7 +398,7 @@ static irqreturn_t sht15_interrupt_fired
 	struct sht15_data *data = d;
 	/* First disable the interrupt */
 	disable_irq_nosync(irq);
-	atomic_inc(&data->interrupt_handled);
+	atomic_inc_unchecked(&data->interrupt_handled);
 	/* Then schedule a reading work struct */
 	if (data->flag != SHT15_READING_NOTHING)
 		schedule_work(&data->read_work);
@@ -449,11 +449,11 @@ static void sht15_bh_read_data(struct wo
 		   here as could have gone low in meantime so verify
 		   it hasn't!
 		*/
-		atomic_set(&data->interrupt_handled, 0);
+		atomic_set_unchecked(&data->interrupt_handled, 0);
 		enable_irq(gpio_to_irq(data->pdata->gpio_data));
 		/* If still not occured or another handler has been scheduled */
 		if (gpio_get_value(data->pdata->gpio_data)
-		    || atomic_read(&data->interrupt_handled))
+		    || atomic_read_unchecked(&data->interrupt_handled))
 			return;
 	}
 	/* Read the data back from the device */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/hwmon/w83791d.c linux-2.6.32.60-pax/drivers/hwmon/w83791d.c
--- linux-2.6.32.60/drivers/hwmon/w83791d.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/hwmon/w83791d.c	2012-03-13 13:15:35.036097995 +0100
@@ -330,8 +330,8 @@ static int w83791d_detect(struct i2c_cli
 			  struct i2c_board_info *info);
 static int w83791d_remove(struct i2c_client *client);
 
-static int w83791d_read(struct i2c_client *client, u8 register);
-static int w83791d_write(struct i2c_client *client, u8 register, u8 value);
+static int w83791d_read(struct i2c_client *client, u8 reg);
+static int w83791d_write(struct i2c_client *client, u8 reg, u8 value);
 static struct w83791d_data *w83791d_update_device(struct device *dev);
 
 #ifdef DEBUG
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/i2c/busses/i2c-amd756-s4882.c linux-2.6.32.60-pax/drivers/i2c/busses/i2c-amd756-s4882.c
--- linux-2.6.32.60/drivers/i2c/busses/i2c-amd756-s4882.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/i2c/busses/i2c-amd756-s4882.c	2012-03-13 13:15:35.036097995 +0100
@@ -43,7 +43,7 @@
 extern struct i2c_adapter amd756_smbus;
 
 static struct i2c_adapter *s4882_adapter;
-static struct i2c_algorithm *s4882_algo;
+static i2c_algorithm_no_const *s4882_algo;
 
 /* Wrapper access functions for multiplexed SMBus */
 static DEFINE_MUTEX(amd756_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/i2c/busses/i2c-nforce2-s4985.c linux-2.6.32.60-pax/drivers/i2c/busses/i2c-nforce2-s4985.c
--- linux-2.6.32.60/drivers/i2c/busses/i2c-nforce2-s4985.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/i2c/busses/i2c-nforce2-s4985.c	2012-03-13 13:15:35.036097995 +0100
@@ -41,7 +41,7 @@
 extern struct i2c_adapter *nforce2_smbus;
 
 static struct i2c_adapter *s4985_adapter;
-static struct i2c_algorithm *s4985_algo;
+static i2c_algorithm_no_const *s4985_algo;
 
 /* Wrapper access functions for multiplexed SMBus */
 static DEFINE_MUTEX(nforce2_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/aec62xx.c linux-2.6.32.60-pax/drivers/ide/aec62xx.c
--- linux-2.6.32.60/drivers/ide/aec62xx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/aec62xx.c	2012-03-13 13:15:35.036097995 +0100
@@ -180,7 +180,7 @@ static const struct ide_port_ops atp86x_
 	.cable_detect		= atp86x_cable_detect,
 };
 
-static const struct ide_port_info aec62xx_chipsets[] __devinitdata = {
+static const struct ide_port_info aec62xx_chipsets[] __devinitconst = {
 	{	/* 0: AEC6210 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_aec62xx,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/alim15x3.c linux-2.6.32.60-pax/drivers/ide/alim15x3.c
--- linux-2.6.32.60/drivers/ide/alim15x3.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/alim15x3.c	2012-03-13 13:15:35.040097995 +0100
@@ -509,7 +509,7 @@ static const struct ide_dma_ops ali_dma_
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info ali15x3_chipset __devinitdata = {
+static const struct ide_port_info ali15x3_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_ali15x3,
 	.init_hwif	= init_hwif_ali15x3,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/amd74xx.c linux-2.6.32.60-pax/drivers/ide/amd74xx.c
--- linux-2.6.32.60/drivers/ide/amd74xx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/amd74xx.c	2012-03-13 13:15:35.040097995 +0100
@@ -221,7 +221,7 @@ static const struct ide_port_ops amd_por
 		.udma_mask	= udma,					\
 	}
 
-static const struct ide_port_info amd74xx_chipsets[] __devinitdata = {
+static const struct ide_port_info amd74xx_chipsets[] __devinitconst = {
 	/* 0: AMD7401 */	DECLARE_AMD_DEV(0x00, ATA_UDMA2),
 	/* 1: AMD7409 */	DECLARE_AMD_DEV(ATA_SWDMA2, ATA_UDMA4),
 	/* 2: AMD7411/7441 */	DECLARE_AMD_DEV(ATA_SWDMA2, ATA_UDMA5),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/atiixp.c linux-2.6.32.60-pax/drivers/ide/atiixp.c
--- linux-2.6.32.60/drivers/ide/atiixp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/atiixp.c	2012-03-13 13:15:35.040097995 +0100
@@ -137,7 +137,7 @@ static const struct ide_port_ops atiixp_
 	.cable_detect		= atiixp_cable_detect,
 };
 
-static const struct ide_port_info atiixp_pci_info[] __devinitdata = {
+static const struct ide_port_info atiixp_pci_info[] __devinitconst = {
 	{	/* 0: IXP200/300/400/700 */
 		.name		= DRV_NAME,
 		.enablebits	= {{0x48,0x01,0x00}, {0x48,0x08,0x00}},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/cmd64x.c linux-2.6.32.60-pax/drivers/ide/cmd64x.c
--- linux-2.6.32.60/drivers/ide/cmd64x.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/cmd64x.c	2012-03-13 13:15:35.040097995 +0100
@@ -372,7 +372,7 @@ static const struct ide_dma_ops cmd646_r
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info cmd64x_chipsets[] __devinitdata = {
+static const struct ide_port_info cmd64x_chipsets[] __devinitconst = {
 	{	/* 0: CMD643 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_cmd64x,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/cs5520.c linux-2.6.32.60-pax/drivers/ide/cs5520.c
--- linux-2.6.32.60/drivers/ide/cs5520.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/cs5520.c	2012-03-13 13:15:35.040097995 +0100
@@ -93,7 +93,7 @@ static const struct ide_port_ops cs5520_
 	.set_dma_mode		= cs5520_set_dma_mode,
 };
 
-static const struct ide_port_info cyrix_chipset __devinitdata = {
+static const struct ide_port_info cyrix_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= { { 0x60, 0x01, 0x01 }, { 0x60, 0x02, 0x02 } },
 	.port_ops	= &cs5520_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/cs5530.c linux-2.6.32.60-pax/drivers/ide/cs5530.c
--- linux-2.6.32.60/drivers/ide/cs5530.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/cs5530.c	2012-03-13 13:15:35.044097995 +0100
@@ -244,7 +244,7 @@ static const struct ide_port_ops cs5530_
 	.udma_filter		= cs5530_udma_filter,
 };
 
-static const struct ide_port_info cs5530_chipset __devinitdata = {
+static const struct ide_port_info cs5530_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_cs5530,
 	.init_hwif	= init_hwif_cs5530,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/cs5535.c linux-2.6.32.60-pax/drivers/ide/cs5535.c
--- linux-2.6.32.60/drivers/ide/cs5535.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/cs5535.c	2012-03-13 13:15:35.044097995 +0100
@@ -170,7 +170,7 @@ static const struct ide_port_ops cs5535_
 	.cable_detect		= cs5535_cable_detect,
 };
 
-static const struct ide_port_info cs5535_chipset __devinitdata = {
+static const struct ide_port_info cs5535_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.port_ops	= &cs5535_port_ops,
 	.host_flags	= IDE_HFLAG_SINGLE | IDE_HFLAG_POST_SET_MODE,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/cy82c693.c linux-2.6.32.60-pax/drivers/ide/cy82c693.c
--- linux-2.6.32.60/drivers/ide/cy82c693.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/cy82c693.c	2012-03-13 13:15:35.044097995 +0100
@@ -288,7 +288,7 @@ static const struct ide_port_ops cy82c69
 	.set_dma_mode		= cy82c693_set_dma_mode,
 };
 
-static const struct ide_port_info cy82c693_chipset __devinitdata = {
+static const struct ide_port_info cy82c693_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_iops	= init_iops_cy82c693,
 	.port_ops	= &cy82c693_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/hpt366.c linux-2.6.32.60-pax/drivers/ide/hpt366.c
--- linux-2.6.32.60/drivers/ide/hpt366.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/hpt366.c	2012-03-13 13:15:35.044097995 +0100
@@ -507,7 +507,7 @@ static struct hpt_timings hpt37x_timings
 	}
 };
 
-static const struct hpt_info hpt36x __devinitdata = {
+static const struct hpt_info hpt36x __devinitconst = {
 	.chip_name	= "HPT36x",
 	.chip_type	= HPT36x,
 	.udma_mask	= HPT366_ALLOW_ATA66_3 ? (HPT366_ALLOW_ATA66_4 ? ATA_UDMA4 : ATA_UDMA3) : ATA_UDMA2,
@@ -515,7 +515,7 @@ static const struct hpt_info hpt36x __de
 	.timings	= &hpt36x_timings
 };
 
-static const struct hpt_info hpt370 __devinitdata = {
+static const struct hpt_info hpt370 __devinitconst = {
 	.chip_name	= "HPT370",
 	.chip_type	= HPT370,
 	.udma_mask	= HPT370_ALLOW_ATA100_5 ? ATA_UDMA5 : ATA_UDMA4,
@@ -523,7 +523,7 @@ static const struct hpt_info hpt370 __de
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt370a __devinitdata = {
+static const struct hpt_info hpt370a __devinitconst = {
 	.chip_name	= "HPT370A",
 	.chip_type	= HPT370A,
 	.udma_mask	= HPT370_ALLOW_ATA100_5 ? ATA_UDMA5 : ATA_UDMA4,
@@ -531,7 +531,7 @@ static const struct hpt_info hpt370a __d
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt374 __devinitdata = {
+static const struct hpt_info hpt374 __devinitconst = {
 	.chip_name	= "HPT374",
 	.chip_type	= HPT374,
 	.udma_mask	= ATA_UDMA5,
@@ -539,7 +539,7 @@ static const struct hpt_info hpt374 __de
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt372 __devinitdata = {
+static const struct hpt_info hpt372 __devinitconst = {
 	.chip_name	= "HPT372",
 	.chip_type	= HPT372,
 	.udma_mask	= HPT372_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -547,7 +547,7 @@ static const struct hpt_info hpt372 __de
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt372a __devinitdata = {
+static const struct hpt_info hpt372a __devinitconst = {
 	.chip_name	= "HPT372A",
 	.chip_type	= HPT372A,
 	.udma_mask	= HPT372_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -555,7 +555,7 @@ static const struct hpt_info hpt372a __d
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt302 __devinitdata = {
+static const struct hpt_info hpt302 __devinitconst = {
 	.chip_name	= "HPT302",
 	.chip_type	= HPT302,
 	.udma_mask	= HPT302_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -563,7 +563,7 @@ static const struct hpt_info hpt302 __de
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt371 __devinitdata = {
+static const struct hpt_info hpt371 __devinitconst = {
 	.chip_name	= "HPT371",
 	.chip_type	= HPT371,
 	.udma_mask	= HPT371_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -571,7 +571,7 @@ static const struct hpt_info hpt371 __de
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt372n __devinitdata = {
+static const struct hpt_info hpt372n __devinitconst = {
 	.chip_name	= "HPT372N",
 	.chip_type	= HPT372N,
 	.udma_mask	= HPT372_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -579,7 +579,7 @@ static const struct hpt_info hpt372n __d
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt302n __devinitdata = {
+static const struct hpt_info hpt302n __devinitconst = {
 	.chip_name	= "HPT302N",
 	.chip_type	= HPT302N,
 	.udma_mask	= HPT302_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -587,7 +587,7 @@ static const struct hpt_info hpt302n __d
 	.timings	= &hpt37x_timings
 };
 
-static const struct hpt_info hpt371n __devinitdata = {
+static const struct hpt_info hpt371n __devinitconst = {
 	.chip_name	= "HPT371N",
 	.chip_type	= HPT371N,
 	.udma_mask	= HPT371_ALLOW_ATA133_6 ? ATA_UDMA6 : ATA_UDMA5,
@@ -1422,7 +1422,7 @@ static const struct ide_dma_ops hpt36x_d
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info hpt366_chipsets[] __devinitdata = {
+static const struct ide_port_info hpt366_chipsets[] __devinitconst = {
 	{	/* 0: HPT36x */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_hpt366,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/ide-cd.c linux-2.6.32.60-pax/drivers/ide/ide-cd.c
--- linux-2.6.32.60/drivers/ide/ide-cd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/ide-cd.c	2012-03-13 13:15:35.048097995 +0100
@@ -774,7 +774,7 @@ static void cdrom_do_block_pc(ide_drive_
 		alignment = queue_dma_alignment(q) | q->dma_pad_mask;
 		if ((unsigned long)buf & alignment
 		    || blk_rq_bytes(rq) & q->dma_pad_mask
-		    || object_is_on_stack(buf))
+		    || object_starts_on_stack(buf))
 			drive->dma = 0;
 	}
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/ide-pci-generic.c linux-2.6.32.60-pax/drivers/ide/ide-pci-generic.c
--- linux-2.6.32.60/drivers/ide/ide-pci-generic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/ide-pci-generic.c	2012-03-13 13:15:35.048097995 +0100
@@ -53,7 +53,7 @@ static const struct ide_port_ops netcell
 		.udma_mask	= ATA_UDMA6, \
 	}
 
-static const struct ide_port_info generic_chipsets[] __devinitdata = {
+static const struct ide_port_info generic_chipsets[] __devinitconst = {
 	/*  0: Unknown */
 	DECLARE_GENERIC_PCI_DEV(0),
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/it8172.c linux-2.6.32.60-pax/drivers/ide/it8172.c
--- linux-2.6.32.60/drivers/ide/it8172.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/it8172.c	2012-03-13 13:15:35.048097995 +0100
@@ -115,7 +115,7 @@ static const struct ide_port_ops it8172_
 	.set_dma_mode	= it8172_set_dma_mode,
 };
 
-static const struct ide_port_info it8172_port_info __devinitdata = {
+static const struct ide_port_info it8172_port_info __devinitconst = {
 	.name		= DRV_NAME,
 	.port_ops	= &it8172_port_ops,
 	.enablebits	= { {0x41, 0x80, 0x80}, {0x00, 0x00, 0x00} },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/it8213.c linux-2.6.32.60-pax/drivers/ide/it8213.c
--- linux-2.6.32.60/drivers/ide/it8213.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/it8213.c	2012-03-13 13:15:35.048097995 +0100
@@ -156,7 +156,7 @@ static const struct ide_port_ops it8213_
 	.cable_detect		= it8213_cable_detect,
 };
 
-static const struct ide_port_info it8213_chipset __devinitdata = {
+static const struct ide_port_info it8213_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= { {0x41, 0x80, 0x80} },
 	.port_ops	= &it8213_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/it821x.c linux-2.6.32.60-pax/drivers/ide/it821x.c
--- linux-2.6.32.60/drivers/ide/it821x.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/it821x.c	2012-03-13 13:15:35.052097994 +0100
@@ -627,7 +627,7 @@ static const struct ide_port_ops it821x_
 	.cable_detect		= it821x_cable_detect,
 };
 
-static const struct ide_port_info it821x_chipset __devinitdata = {
+static const struct ide_port_info it821x_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_it821x,
 	.init_hwif	= init_hwif_it821x,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/jmicron.c linux-2.6.32.60-pax/drivers/ide/jmicron.c
--- linux-2.6.32.60/drivers/ide/jmicron.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/jmicron.c	2012-03-13 13:15:35.052097994 +0100
@@ -102,7 +102,7 @@ static const struct ide_port_ops jmicron
 	.cable_detect		= jmicron_cable_detect,
 };
 
-static const struct ide_port_info jmicron_chipset __devinitdata = {
+static const struct ide_port_info jmicron_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= { { 0x40, 0x01, 0x01 }, { 0x40, 0x10, 0x10 } },
 	.port_ops	= &jmicron_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/ns87415.c linux-2.6.32.60-pax/drivers/ide/ns87415.c
--- linux-2.6.32.60/drivers/ide/ns87415.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/ns87415.c	2012-03-13 13:15:35.052097994 +0100
@@ -293,7 +293,7 @@ static const struct ide_dma_ops ns87415_
 	.dma_sff_read_status	= superio_dma_sff_read_status,
 };
 
-static const struct ide_port_info ns87415_chipset __devinitdata = {
+static const struct ide_port_info ns87415_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_hwif	= init_hwif_ns87415,
 	.tp_ops 	= &ns87415_tp_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/opti621.c linux-2.6.32.60-pax/drivers/ide/opti621.c
--- linux-2.6.32.60/drivers/ide/opti621.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/opti621.c	2012-03-13 13:15:35.052097994 +0100
@@ -202,7 +202,7 @@ static const struct ide_port_ops opti621
 	.set_pio_mode		= opti621_set_pio_mode,
 };
 
-static const struct ide_port_info opti621_chipset __devinitdata = {
+static const struct ide_port_info opti621_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= { {0x45, 0x80, 0x00}, {0x40, 0x08, 0x00} },
 	.port_ops	= &opti621_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/pdc202xx_new.c linux-2.6.32.60-pax/drivers/ide/pdc202xx_new.c
--- linux-2.6.32.60/drivers/ide/pdc202xx_new.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/pdc202xx_new.c	2012-03-13 13:15:35.052097994 +0100
@@ -465,7 +465,7 @@ static const struct ide_port_ops pdcnew_
 		.udma_mask	= udma, \
 	}
 
-static const struct ide_port_info pdcnew_chipsets[] __devinitdata = {
+static const struct ide_port_info pdcnew_chipsets[] __devinitconst = {
 	/* 0: PDC202{68,70} */		DECLARE_PDCNEW_DEV(ATA_UDMA5),
 	/* 1: PDC202{69,71,75,76,77} */	DECLARE_PDCNEW_DEV(ATA_UDMA6),
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/pdc202xx_old.c linux-2.6.32.60-pax/drivers/ide/pdc202xx_old.c
--- linux-2.6.32.60/drivers/ide/pdc202xx_old.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/pdc202xx_old.c	2012-03-13 13:15:35.056097994 +0100
@@ -285,7 +285,7 @@ static const struct ide_dma_ops pdc2026x
 		.max_sectors	= sectors, \
 	}
 
-static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
+static const struct ide_port_info pdc202xx_chipsets[] __devinitconst = {
 	{	/* 0: PDC20246 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_pdc202xx,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/piix.c linux-2.6.32.60-pax/drivers/ide/piix.c
--- linux-2.6.32.60/drivers/ide/piix.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/piix.c	2012-03-13 13:15:35.060097994 +0100
@@ -344,7 +344,7 @@ static const struct ide_port_ops ich_por
 		.udma_mask	= udma, \
 	}
 
-static const struct ide_port_info piix_pci_info[] __devinitdata = {
+static const struct ide_port_info piix_pci_info[] __devinitconst = {
 	/* 0: MPIIX */
 	{	/*
 		 * MPIIX actually has only a single IDE channel mapped to
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/rz1000.c linux-2.6.32.60-pax/drivers/ide/rz1000.c
--- linux-2.6.32.60/drivers/ide/rz1000.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/rz1000.c	2012-03-13 13:15:35.064097994 +0100
@@ -38,7 +38,7 @@ static int __devinit rz1000_disable_read
 	}
 }
 
-static const struct ide_port_info rz1000_chipset __devinitdata = {
+static const struct ide_port_info rz1000_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.host_flags	= IDE_HFLAG_NO_DMA,
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/sc1200.c linux-2.6.32.60-pax/drivers/ide/sc1200.c
--- linux-2.6.32.60/drivers/ide/sc1200.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/sc1200.c	2012-03-13 13:15:35.064097994 +0100
@@ -290,7 +290,7 @@ static const struct ide_dma_ops sc1200_d
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info sc1200_chipset __devinitdata = {
+static const struct ide_port_info sc1200_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.port_ops	= &sc1200_port_ops,
 	.dma_ops	= &sc1200_dma_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/scc_pata.c linux-2.6.32.60-pax/drivers/ide/scc_pata.c
--- linux-2.6.32.60/drivers/ide/scc_pata.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/scc_pata.c	2012-03-13 13:15:35.068097993 +0100
@@ -811,7 +811,7 @@ static const struct ide_dma_ops scc_dma_
 	.dma_sff_read_status	= scc_dma_sff_read_status,
 };
 
-static const struct ide_port_info scc_chipset __devinitdata = {
+static const struct ide_port_info scc_chipset __devinitconst = {
 	.name		= "sccIDE",
 	.init_iops	= init_iops_scc,
 	.init_dma	= scc_init_dma,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/serverworks.c linux-2.6.32.60-pax/drivers/ide/serverworks.c
--- linux-2.6.32.60/drivers/ide/serverworks.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/serverworks.c	2012-03-13 13:15:35.072097993 +0100
@@ -353,7 +353,7 @@ static const struct ide_port_ops svwks_p
 	.cable_detect		= svwks_cable_detect,
 };
 
-static const struct ide_port_info serverworks_chipsets[] __devinitdata = {
+static const struct ide_port_info serverworks_chipsets[] __devinitconst = {
 	{	/* 0: OSB4 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_svwks,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/siimage.c linux-2.6.32.60-pax/drivers/ide/siimage.c
--- linux-2.6.32.60/drivers/ide/siimage.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/siimage.c	2012-03-13 13:15:35.072097993 +0100
@@ -719,7 +719,7 @@ static const struct ide_dma_ops sil_dma_
 		.udma_mask	= ATA_UDMA6,		\
 	}
 
-static const struct ide_port_info siimage_chipsets[] __devinitdata = {
+static const struct ide_port_info siimage_chipsets[] __devinitconst = {
 	/* 0: SiI680 */  DECLARE_SII_DEV(&sil_pata_port_ops),
 	/* 1: SiI3112 */ DECLARE_SII_DEV(&sil_sata_port_ops)
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/sis5513.c linux-2.6.32.60-pax/drivers/ide/sis5513.c
--- linux-2.6.32.60/drivers/ide/sis5513.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/sis5513.c	2012-03-13 13:15:35.072097993 +0100
@@ -561,7 +561,7 @@ static const struct ide_port_ops sis_ata
 	.cable_detect		= sis_cable_detect,
 };
 
-static const struct ide_port_info sis5513_chipset __devinitdata = {
+static const struct ide_port_info sis5513_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_sis5513,
 	.enablebits	= { {0x4a, 0x02, 0x02}, {0x4a, 0x04, 0x04} },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/sl82c105.c linux-2.6.32.60-pax/drivers/ide/sl82c105.c
--- linux-2.6.32.60/drivers/ide/sl82c105.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/sl82c105.c	2012-03-13 13:15:35.072097993 +0100
@@ -319,7 +319,7 @@ static const struct ide_dma_ops sl82c105
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info sl82c105_chipset __devinitdata = {
+static const struct ide_port_info sl82c105_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_sl82c105,
 	.enablebits	= {{0x40,0x01,0x01}, {0x40,0x10,0x10}},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/slc90e66.c linux-2.6.32.60-pax/drivers/ide/slc90e66.c
--- linux-2.6.32.60/drivers/ide/slc90e66.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/slc90e66.c	2012-03-13 13:15:35.076097993 +0100
@@ -131,7 +131,7 @@ static const struct ide_port_ops slc90e6
 	.cable_detect		= slc90e66_cable_detect,
 };
 
-static const struct ide_port_info slc90e66_chipset __devinitdata = {
+static const struct ide_port_info slc90e66_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= { {0x41, 0x80, 0x80}, {0x43, 0x80, 0x80} },
 	.port_ops	= &slc90e66_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/tc86c001.c linux-2.6.32.60-pax/drivers/ide/tc86c001.c
--- linux-2.6.32.60/drivers/ide/tc86c001.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/tc86c001.c	2012-03-13 13:15:35.076097993 +0100
@@ -190,7 +190,7 @@ static const struct ide_dma_ops tc86c001
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
-static const struct ide_port_info tc86c001_chipset __devinitdata = {
+static const struct ide_port_info tc86c001_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_hwif	= init_hwif_tc86c001,
 	.port_ops	= &tc86c001_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/triflex.c linux-2.6.32.60-pax/drivers/ide/triflex.c
--- linux-2.6.32.60/drivers/ide/triflex.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/triflex.c	2012-03-13 13:15:35.076097993 +0100
@@ -92,7 +92,7 @@ static const struct ide_port_ops triflex
 	.set_dma_mode		= triflex_set_mode,
 };
 
-static const struct ide_port_info triflex_device __devinitdata = {
+static const struct ide_port_info triflex_device __devinitconst = {
 	.name		= DRV_NAME,
 	.enablebits	= {{0x80, 0x01, 0x01}, {0x80, 0x02, 0x02}},
 	.port_ops	= &triflex_port_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/trm290.c linux-2.6.32.60-pax/drivers/ide/trm290.c
--- linux-2.6.32.60/drivers/ide/trm290.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/trm290.c	2012-03-13 13:15:35.076097993 +0100
@@ -324,7 +324,7 @@ static struct ide_dma_ops trm290_dma_ops
 	.dma_check		= trm290_dma_check,
 };
 
-static const struct ide_port_info trm290_chipset __devinitdata = {
+static const struct ide_port_info trm290_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_hwif	= init_hwif_trm290,
 	.tp_ops 	= &trm290_tp_ops,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ide/via82cxxx.c linux-2.6.32.60-pax/drivers/ide/via82cxxx.c
--- linux-2.6.32.60/drivers/ide/via82cxxx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ide/via82cxxx.c	2012-03-13 13:15:35.076097993 +0100
@@ -374,7 +374,7 @@ static const struct ide_port_ops via_por
 	.cable_detect		= via82cxxx_cable_detect,
 };
 
-static const struct ide_port_info via82cxxx_chipset __devinitdata = {
+static const struct ide_port_info via82cxxx_chipset __devinitconst = {
 	.name		= DRV_NAME,
 	.init_chipset	= init_chipset_via82cxxx,
 	.enablebits	= { { 0x40, 0x02, 0x02 }, { 0x40, 0x01, 0x01 } },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ieee1394/dv1394.c linux-2.6.32.60-pax/drivers/ieee1394/dv1394.c
--- linux-2.6.32.60/drivers/ieee1394/dv1394.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ieee1394/dv1394.c	2012-03-13 13:15:35.080097993 +0100
@@ -739,7 +739,7 @@ static void frame_prepare(struct video_c
 	based upon DIF section and sequence
 */
 
-static void inline
+static inline void
 frame_put_packet (struct frame *f, struct packet *p)
 {
 	int section_type = p->data[0] >> 5;           /* section type is in bits 5 - 7 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ieee1394/hosts.c linux-2.6.32.60-pax/drivers/ieee1394/hosts.c
--- linux-2.6.32.60/drivers/ieee1394/hosts.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ieee1394/hosts.c	2012-03-13 13:15:35.080097993 +0100
@@ -78,6 +78,7 @@ static int dummy_isoctl(struct hpsb_iso
 }
 
 static struct hpsb_host_driver dummy_driver = {
+	.name =		   "dummy",
 	.transmit_packet = dummy_transmit_packet,
 	.devctl =	   dummy_devctl,
 	.isoctl =	   dummy_isoctl
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ieee1394/init_ohci1394_dma.c linux-2.6.32.60-pax/drivers/ieee1394/init_ohci1394_dma.c
--- linux-2.6.32.60/drivers/ieee1394/init_ohci1394_dma.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ieee1394/init_ohci1394_dma.c	2012-03-13 13:15:35.080097993 +0100
@@ -257,7 +257,7 @@ void __init init_ohci1394_dma_on_all_con
 			for (func = 0; func < 8; func++) {
 				u32 class = read_pci_config(num,slot,func,
 							PCI_CLASS_REVISION);
-				if ((class == 0xffffffff))
+				if (class == 0xffffffff)
 					continue; /* No device at this func */
 
 				if (class>>8 != PCI_CLASS_SERIAL_FIREWIRE_OHCI)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ieee1394/ohci1394.c linux-2.6.32.60-pax/drivers/ieee1394/ohci1394.c
--- linux-2.6.32.60/drivers/ieee1394/ohci1394.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ieee1394/ohci1394.c	2012-03-13 13:15:35.084097993 +0100
@@ -147,9 +147,9 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 /* Module Parameters */
-static int phys_dma = 1;
+static int phys_dma;
 module_param(phys_dma, int, 0444);
-MODULE_PARM_DESC(phys_dma, "Enable physical DMA (default = 1).");
+MODULE_PARM_DESC(phys_dma, "Enable physical DMA (default = 0).");
 
 static void dma_trm_tasklet(unsigned long data);
 static void dma_trm_reset(struct dma_trm_ctx *d);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/ieee1394/sbp2.c linux-2.6.32.60-pax/drivers/ieee1394/sbp2.c
--- linux-2.6.32.60/drivers/ieee1394/sbp2.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/ieee1394/sbp2.c	2012-03-13 13:15:35.084097993 +0100
@@ -2111,7 +2111,7 @@ MODULE_DESCRIPTION("IEEE-1394 SBP-2 prot
 MODULE_SUPPORTED_DEVICE(SBP2_DEVICE_NAME);
 MODULE_LICENSE("GPL");
 
-static int sbp2_module_init(void)
+static int __init sbp2_module_init(void)
 {
 	int ret;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/core/cm.c linux-2.6.32.60-pax/drivers/infiniband/core/cm.c
--- linux-2.6.32.60/drivers/infiniband/core/cm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/core/cm.c	2012-03-13 13:15:35.092097992 +0100
@@ -112,7 +112,7 @@ static char const counter_group_names[CM
 
 struct cm_counter_group {
 	struct kobject obj;
-	atomic_long_t counter[CM_ATTR_COUNT];
+	atomic_long_unchecked_t counter[CM_ATTR_COUNT];
 };
 
 struct cm_counter_attribute {
@@ -1386,7 +1386,7 @@ static void cm_dup_req_handler(struct cm
 	struct ib_mad_send_buf *msg = NULL;
 	int ret;
 
-	atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+	atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 			counter[CM_REQ_COUNTER]);
 
 	/* Quick state check to discard duplicate REQs. */
@@ -1764,7 +1764,7 @@ static void cm_dup_rep_handler(struct cm
 	if (!cm_id_priv)
 		return;
 
-	atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+	atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 			counter[CM_REP_COUNTER]);
 	ret = cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg);
 	if (ret)
@@ -1931,7 +1931,7 @@ static int cm_rtu_handler(struct cm_work
 	if (cm_id_priv->id.state != IB_CM_REP_SENT &&
 	    cm_id_priv->id.state != IB_CM_MRA_REP_RCVD) {
 		spin_unlock_irq(&cm_id_priv->lock);
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_RTU_COUNTER]);
 		goto out;
 	}
@@ -2110,7 +2110,7 @@ static int cm_dreq_handler(struct cm_wor
 	cm_id_priv = cm_acquire_id(dreq_msg->remote_comm_id,
 				   dreq_msg->local_comm_id);
 	if (!cm_id_priv) {
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_DREQ_COUNTER]);
 		cm_issue_drep(work->port, work->mad_recv_wc);
 		return -EINVAL;
@@ -2131,7 +2131,7 @@ static int cm_dreq_handler(struct cm_wor
 	case IB_CM_MRA_REP_RCVD:
 		break;
 	case IB_CM_TIMEWAIT:
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_DREQ_COUNTER]);
 		if (cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg))
 			goto unlock;
@@ -2145,7 +2145,7 @@ static int cm_dreq_handler(struct cm_wor
 			cm_free_msg(msg);
 		goto deref;
 	case IB_CM_DREQ_RCVD:
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_DREQ_COUNTER]);
 		goto unlock;
 	default:
@@ -2501,7 +2501,7 @@ static int cm_mra_handler(struct cm_work
 		    ib_modify_mad(cm_id_priv->av.port->mad_agent,
 				  cm_id_priv->msg, timeout)) {
 			if (cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)
-				atomic_long_inc(&work->port->
+				atomic_long_inc_unchecked(&work->port->
 						counter_group[CM_RECV_DUPLICATES].
 						counter[CM_MRA_COUNTER]);
 			goto out;
@@ -2510,7 +2510,7 @@ static int cm_mra_handler(struct cm_work
 		break;
 	case IB_CM_MRA_REQ_RCVD:
 	case IB_CM_MRA_REP_RCVD:
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_MRA_COUNTER]);
 		/* fall through */
 	default:
@@ -2672,7 +2672,7 @@ static int cm_lap_handler(struct cm_work
 	case IB_CM_LAP_IDLE:
 		break;
 	case IB_CM_MRA_LAP_SENT:
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_LAP_COUNTER]);
 		if (cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg))
 			goto unlock;
@@ -2688,7 +2688,7 @@ static int cm_lap_handler(struct cm_work
 			cm_free_msg(msg);
 		goto deref;
 	case IB_CM_LAP_RCVD:
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_LAP_COUNTER]);
 		goto unlock;
 	default:
@@ -2972,7 +2972,7 @@ static int cm_sidr_req_handler(struct cm
 	cur_cm_id_priv = cm_insert_remote_sidr(cm_id_priv);
 	if (cur_cm_id_priv) {
 		spin_unlock_irq(&cm.lock);
-		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
+		atomic_long_inc_unchecked(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_SIDR_REQ_COUNTER]);
 		goto out; /* Duplicate message. */
 	}
@@ -3184,10 +3184,10 @@ static void cm_send_handler(struct ib_ma
 	if (!msg->context[0] && (attr_index != CM_REJ_COUNTER))
 		msg->retries = 1;
 
-	atomic_long_add(1 + msg->retries,
+	atomic_long_add_unchecked(1 + msg->retries,
 			&port->counter_group[CM_XMIT].counter[attr_index]);
 	if (msg->retries)
-		atomic_long_add(msg->retries,
+		atomic_long_add_unchecked(msg->retries,
 				&port->counter_group[CM_XMIT_RETRIES].
 				counter[attr_index]);
 
@@ -3397,7 +3397,7 @@ static void cm_recv_handler(struct ib_ma
 	}
 
 	attr_id = be16_to_cpu(mad_recv_wc->recv_buf.mad->mad_hdr.attr_id);
-	atomic_long_inc(&port->counter_group[CM_RECV].
+	atomic_long_inc_unchecked(&port->counter_group[CM_RECV].
 			counter[attr_id - CM_ATTR_ID_OFFSET]);
 
 	work = kmalloc(sizeof *work + sizeof(struct ib_sa_path_rec) * paths,
@@ -3595,7 +3595,7 @@ static ssize_t cm_show_counter(struct ko
 	cm_attr = container_of(attr, struct cm_counter_attribute, attr);
 
 	return sprintf(buf, "%ld\n",
-		       atomic_long_read(&group->counter[cm_attr->index]));
+		       atomic_long_read_unchecked(&group->counter[cm_attr->index]));
 }
 
 static struct sysfs_ops cm_counter_ops = {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/core/fmr_pool.c linux-2.6.32.60-pax/drivers/infiniband/core/fmr_pool.c
--- linux-2.6.32.60/drivers/infiniband/core/fmr_pool.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/core/fmr_pool.c	2012-03-13 13:15:35.096097992 +0100
@@ -97,8 +97,8 @@ struct ib_fmr_pool {
 
 	struct task_struct       *thread;
 
-	atomic_t                  req_ser;
-	atomic_t                  flush_ser;
+	atomic_unchecked_t        req_ser;
+	atomic_unchecked_t        flush_ser;
 
 	wait_queue_head_t         force_wait;
 };
@@ -179,10 +179,10 @@ static int ib_fmr_cleanup_thread(void *p
 	struct ib_fmr_pool *pool = pool_ptr;
 
 	do {
-		if (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) < 0) {
+		if (atomic_read_unchecked(&pool->flush_ser) - atomic_read_unchecked(&pool->req_ser) < 0) {
 			ib_fmr_batch_release(pool);
 
-			atomic_inc(&pool->flush_ser);
+			atomic_inc_unchecked(&pool->flush_ser);
 			wake_up_interruptible(&pool->force_wait);
 
 			if (pool->flush_function)
@@ -190,7 +190,7 @@ static int ib_fmr_cleanup_thread(void *p
 		}
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) >= 0 &&
+		if (atomic_read_unchecked(&pool->flush_ser) - atomic_read_unchecked(&pool->req_ser) >= 0 &&
 		    !kthread_should_stop())
 			schedule();
 		__set_current_state(TASK_RUNNING);
@@ -282,8 +282,8 @@ struct ib_fmr_pool *ib_create_fmr_pool(s
 	pool->dirty_watermark = params->dirty_watermark;
 	pool->dirty_len       = 0;
 	spin_lock_init(&pool->pool_lock);
-	atomic_set(&pool->req_ser,   0);
-	atomic_set(&pool->flush_ser, 0);
+	atomic_set_unchecked(&pool->req_ser,   0);
+	atomic_set_unchecked(&pool->flush_ser, 0);
 	init_waitqueue_head(&pool->force_wait);
 
 	pool->thread = kthread_run(ib_fmr_cleanup_thread,
@@ -411,11 +411,11 @@ int ib_flush_fmr_pool(struct ib_fmr_pool
 	}
 	spin_unlock_irq(&pool->pool_lock);
 
-	serial = atomic_inc_return(&pool->req_ser);
+	serial = atomic_inc_return_unchecked(&pool->req_ser);
 	wake_up_process(pool->thread);
 
 	if (wait_event_interruptible(pool->force_wait,
-				     atomic_read(&pool->flush_ser) - serial >= 0))
+				     atomic_read_unchecked(&pool->flush_ser) - serial >= 0))
 		return -EINTR;
 
 	return 0;
@@ -525,7 +525,7 @@ int ib_fmr_pool_unmap(struct ib_pool_fmr
 		} else {
 			list_add_tail(&fmr->list, &pool->dirty_list);
 			if (++pool->dirty_len >= pool->dirty_watermark) {
-				atomic_inc(&pool->req_ser);
+				atomic_inc_unchecked(&pool->req_ser);
 				wake_up_process(pool->thread);
 			}
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/hw/nes/nes.c linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes.c
--- linux-2.6.32.60/drivers/infiniband/hw/nes/nes.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes.c	2012-03-13 13:15:35.104097992 +0100
@@ -102,7 +102,7 @@ MODULE_PARM_DESC(limit_maxrdreqsz, "Limi
 LIST_HEAD(nes_adapter_list);
 static LIST_HEAD(nes_dev_list);
 
-atomic_t qps_destroyed;
+atomic_unchecked_t qps_destroyed;
 
 static unsigned int ee_flsh_adapter;
 static unsigned int sysfs_nonidx_addr;
@@ -259,7 +259,7 @@ static void nes_cqp_rem_ref_callback(str
 	struct nes_adapter *nesadapter = nesdev->nesadapter;
 	u32 qp_id;
 
-	atomic_inc(&qps_destroyed);
+	atomic_inc_unchecked(&qps_destroyed);
 
 	/* Free the control structures */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/hw/nes/nes_cm.c linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_cm.c
--- linux-2.6.32.60/drivers/infiniband/hw/nes/nes_cm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_cm.c	2012-03-13 13:15:35.108097991 +0100
@@ -69,11 +69,11 @@ u32 cm_packets_received;
 u32 cm_listens_created;
 u32 cm_listens_destroyed;
 u32 cm_backlog_drops;
-atomic_t cm_loopbacks;
-atomic_t cm_nodes_created;
-atomic_t cm_nodes_destroyed;
-atomic_t cm_accel_dropped_pkts;
-atomic_t cm_resets_recvd;
+atomic_unchecked_t cm_loopbacks;
+atomic_unchecked_t cm_nodes_created;
+atomic_unchecked_t cm_nodes_destroyed;
+atomic_unchecked_t cm_accel_dropped_pkts;
+atomic_unchecked_t cm_resets_recvd;
 
 static inline int mini_cm_accelerated(struct nes_cm_core *,
 	struct nes_cm_node *);
@@ -149,13 +149,13 @@ static struct nes_cm_ops nes_cm_api = {
 
 static struct nes_cm_core *g_cm_core;
 
-atomic_t cm_connects;
-atomic_t cm_accepts;
-atomic_t cm_disconnects;
-atomic_t cm_closes;
-atomic_t cm_connecteds;
-atomic_t cm_connect_reqs;
-atomic_t cm_rejects;
+atomic_unchecked_t cm_connects;
+atomic_unchecked_t cm_accepts;
+atomic_unchecked_t cm_disconnects;
+atomic_unchecked_t cm_closes;
+atomic_unchecked_t cm_connecteds;
+atomic_unchecked_t cm_connect_reqs;
+atomic_unchecked_t cm_rejects;
 
 
 /**
@@ -1195,7 +1195,7 @@ static struct nes_cm_node *make_cm_node(
 		  cm_node->rem_mac);
 
 	add_hte_node(cm_core, cm_node);
-	atomic_inc(&cm_nodes_created);
+	atomic_inc_unchecked(&cm_nodes_created);
 
 	return cm_node;
 }
@@ -1253,7 +1253,7 @@ static int rem_ref_cm_node(struct nes_cm
 	}
 
 	atomic_dec(&cm_core->node_cnt);
-	atomic_inc(&cm_nodes_destroyed);
+	atomic_inc_unchecked(&cm_nodes_destroyed);
 	nesqp = cm_node->nesqp;
 	if (nesqp) {
 		nesqp->cm_node = NULL;
@@ -1320,7 +1320,7 @@ static int process_options(struct nes_cm
 
 static void drop_packet(struct sk_buff *skb)
 {
-	atomic_inc(&cm_accel_dropped_pkts);
+	atomic_inc_unchecked(&cm_accel_dropped_pkts);
 	dev_kfree_skb_any(skb);
 }
 
@@ -1377,7 +1377,7 @@ static void handle_rst_pkt(struct nes_cm
 
 	int	reset = 0;	/* whether to send reset in case of err.. */
 	int	passive_state;
-	atomic_inc(&cm_resets_recvd);
+	atomic_inc_unchecked(&cm_resets_recvd);
 	nes_debug(NES_DBG_CM, "Received Reset, cm_node = %p, state = %u."
 			" refcnt=%d\n", cm_node, cm_node->state,
 			atomic_read(&cm_node->ref_count));
@@ -2000,7 +2000,7 @@ static struct nes_cm_node *mini_cm_conne
 				rem_ref_cm_node(cm_node->cm_core, cm_node);
 				return NULL;
 			}
-			atomic_inc(&cm_loopbacks);
+			atomic_inc_unchecked(&cm_loopbacks);
 			loopbackremotenode->loopbackpartner = cm_node;
 			loopbackremotenode->tcp_cntxt.rcv_wscale =
 				NES_CM_DEFAULT_RCV_WND_SCALE;
@@ -2262,7 +2262,7 @@ static int mini_cm_recv_pkt(struct nes_c
 			add_ref_cm_node(cm_node);
 		} else if (cm_node->state == NES_CM_STATE_TSA) {
 			rem_ref_cm_node(cm_core, cm_node);
-			atomic_inc(&cm_accel_dropped_pkts);
+			atomic_inc_unchecked(&cm_accel_dropped_pkts);
 			dev_kfree_skb_any(skb);
 			break;
 		}
@@ -2568,7 +2568,7 @@ static int nes_cm_disconn_true(struct ne
 
 	if ((cm_id) && (cm_id->event_handler)) {
 		if (issue_disconn) {
-			atomic_inc(&cm_disconnects);
+			atomic_inc_unchecked(&cm_disconnects);
 			cm_event.event = IW_CM_EVENT_DISCONNECT;
 			cm_event.status = disconn_status;
 			cm_event.local_addr = cm_id->local_addr;
@@ -2590,7 +2590,7 @@ static int nes_cm_disconn_true(struct ne
 		}
 
 		if (issue_close) {
-			atomic_inc(&cm_closes);
+			atomic_inc_unchecked(&cm_closes);
 			nes_disconnect(nesqp, 1);
 
 			cm_id->provider_data = nesqp;
@@ -2710,7 +2710,7 @@ int nes_accept(struct iw_cm_id *cm_id, s
 
 	nes_debug(NES_DBG_CM, "QP%u, cm_node=%p, jiffies = %lu listener = %p\n",
 		nesqp->hwqp.qp_id, cm_node, jiffies, cm_node->listener);
-	atomic_inc(&cm_accepts);
+	atomic_inc_unchecked(&cm_accepts);
 
 	nes_debug(NES_DBG_CM, "netdev refcnt = %u.\n",
 			atomic_read(&nesvnic->netdev->refcnt));
@@ -2919,7 +2919,7 @@ int nes_reject(struct iw_cm_id *cm_id, c
 
 	struct nes_cm_core *cm_core;
 
-	atomic_inc(&cm_rejects);
+	atomic_inc_unchecked(&cm_rejects);
 	cm_node = (struct nes_cm_node *) cm_id->provider_data;
 	loopback = cm_node->loopbackpartner;
 	cm_core = cm_node->cm_core;
@@ -2982,7 +2982,7 @@ int nes_connect(struct iw_cm_id *cm_id,
 		ntohl(cm_id->local_addr.sin_addr.s_addr),
 		ntohs(cm_id->local_addr.sin_port));
 
-	atomic_inc(&cm_connects);
+	atomic_inc_unchecked(&cm_connects);
 	nesqp->active_conn = 1;
 
 	/* cache the cm_id in the qp */
@@ -3195,7 +3195,7 @@ static void cm_event_connected(struct ne
 	if (nesqp->destroyed) {
 		return;
 	}
-	atomic_inc(&cm_connecteds);
+	atomic_inc_unchecked(&cm_connecteds);
 	nes_debug(NES_DBG_CM, "QP%u attempting to connect to  0x%08X:0x%04X on"
 			" local port 0x%04X. jiffies = %lu.\n",
 			nesqp->hwqp.qp_id,
@@ -3403,7 +3403,7 @@ static void cm_event_reset(struct nes_cm
 
 	ret = cm_id->event_handler(cm_id, &cm_event);
 	cm_id->add_ref(cm_id);
-	atomic_inc(&cm_closes);
+	atomic_inc_unchecked(&cm_closes);
 	cm_event.event = IW_CM_EVENT_CLOSE;
 	cm_event.status = IW_CM_EVENT_STATUS_OK;
 	cm_event.provider_data = cm_id->provider_data;
@@ -3439,7 +3439,7 @@ static void cm_event_mpa_req(struct nes_
 		return;
 	cm_id = cm_node->cm_id;
 
-	atomic_inc(&cm_connect_reqs);
+	atomic_inc_unchecked(&cm_connect_reqs);
 	nes_debug(NES_DBG_CM, "cm_node = %p - cm_id = %p, jiffies = %lu\n",
 			cm_node, cm_id, jiffies);
 
@@ -3477,7 +3477,7 @@ static void cm_event_mpa_reject(struct n
 		return;
 	cm_id = cm_node->cm_id;
 
-	atomic_inc(&cm_connect_reqs);
+	atomic_inc_unchecked(&cm_connect_reqs);
 	nes_debug(NES_DBG_CM, "cm_node = %p - cm_id = %p, jiffies = %lu\n",
 			cm_node, cm_id, jiffies);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/hw/nes/nes.h linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes.h
--- linux-2.6.32.60/drivers/infiniband/hw/nes/nes.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes.h	2012-03-13 13:15:35.108097991 +0100
@@ -174,17 +174,17 @@ extern unsigned int nes_debug_level;
 extern unsigned int wqm_quanta;
 extern struct list_head nes_adapter_list;
 
-extern atomic_t cm_connects;
-extern atomic_t cm_accepts;
-extern atomic_t cm_disconnects;
-extern atomic_t cm_closes;
-extern atomic_t cm_connecteds;
-extern atomic_t cm_connect_reqs;
-extern atomic_t cm_rejects;
-extern atomic_t mod_qp_timouts;
-extern atomic_t qps_created;
-extern atomic_t qps_destroyed;
-extern atomic_t sw_qps_destroyed;
+extern atomic_unchecked_t cm_connects;
+extern atomic_unchecked_t cm_accepts;
+extern atomic_unchecked_t cm_disconnects;
+extern atomic_unchecked_t cm_closes;
+extern atomic_unchecked_t cm_connecteds;
+extern atomic_unchecked_t cm_connect_reqs;
+extern atomic_unchecked_t cm_rejects;
+extern atomic_unchecked_t mod_qp_timouts;
+extern atomic_unchecked_t qps_created;
+extern atomic_unchecked_t qps_destroyed;
+extern atomic_unchecked_t sw_qps_destroyed;
 extern u32 mh_detected;
 extern u32 mh_pauses_sent;
 extern u32 cm_packets_sent;
@@ -196,11 +196,11 @@ extern u32 cm_packets_retrans;
 extern u32 cm_listens_created;
 extern u32 cm_listens_destroyed;
 extern u32 cm_backlog_drops;
-extern atomic_t cm_loopbacks;
-extern atomic_t cm_nodes_created;
-extern atomic_t cm_nodes_destroyed;
-extern atomic_t cm_accel_dropped_pkts;
-extern atomic_t cm_resets_recvd;
+extern atomic_unchecked_t cm_loopbacks;
+extern atomic_unchecked_t cm_nodes_created;
+extern atomic_unchecked_t cm_nodes_destroyed;
+extern atomic_unchecked_t cm_accel_dropped_pkts;
+extern atomic_unchecked_t cm_resets_recvd;
 
 extern u32 int_mod_timer_init;
 extern u32 int_mod_cq_depth_256;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/hw/nes/nes_nic.c linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_nic.c
--- linux-2.6.32.60/drivers/infiniband/hw/nes/nes_nic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_nic.c	2012-03-13 13:15:35.108097991 +0100
@@ -1210,17 +1210,17 @@ static void nes_netdev_get_ethtool_stats
 	target_stat_values[++index] = mh_detected;
 	target_stat_values[++index] = mh_pauses_sent;
 	target_stat_values[++index] = nesvnic->endnode_ipv4_tcp_retransmits;
-	target_stat_values[++index] = atomic_read(&cm_connects);
-	target_stat_values[++index] = atomic_read(&cm_accepts);
-	target_stat_values[++index] = atomic_read(&cm_disconnects);
-	target_stat_values[++index] = atomic_read(&cm_connecteds);
-	target_stat_values[++index] = atomic_read(&cm_connect_reqs);
-	target_stat_values[++index] = atomic_read(&cm_rejects);
-	target_stat_values[++index] = atomic_read(&mod_qp_timouts);
-	target_stat_values[++index] = atomic_read(&qps_created);
-	target_stat_values[++index] = atomic_read(&sw_qps_destroyed);
-	target_stat_values[++index] = atomic_read(&qps_destroyed);
-	target_stat_values[++index] = atomic_read(&cm_closes);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_connects);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_accepts);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_disconnects);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_connecteds);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_connect_reqs);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_rejects);
+	target_stat_values[++index] = atomic_read_unchecked(&mod_qp_timouts);
+	target_stat_values[++index] = atomic_read_unchecked(&qps_created);
+	target_stat_values[++index] = atomic_read_unchecked(&sw_qps_destroyed);
+	target_stat_values[++index] = atomic_read_unchecked(&qps_destroyed);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_closes);
 	target_stat_values[++index] = cm_packets_sent;
 	target_stat_values[++index] = cm_packets_bounced;
 	target_stat_values[++index] = cm_packets_created;
@@ -1230,11 +1230,11 @@ static void nes_netdev_get_ethtool_stats
 	target_stat_values[++index] = cm_listens_created;
 	target_stat_values[++index] = cm_listens_destroyed;
 	target_stat_values[++index] = cm_backlog_drops;
-	target_stat_values[++index] = atomic_read(&cm_loopbacks);
-	target_stat_values[++index] = atomic_read(&cm_nodes_created);
-	target_stat_values[++index] = atomic_read(&cm_nodes_destroyed);
-	target_stat_values[++index] = atomic_read(&cm_accel_dropped_pkts);
-	target_stat_values[++index] = atomic_read(&cm_resets_recvd);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_loopbacks);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_nodes_created);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_nodes_destroyed);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_accel_dropped_pkts);
+	target_stat_values[++index] = atomic_read_unchecked(&cm_resets_recvd);
 	target_stat_values[++index] = int_mod_timer_init;
 	target_stat_values[++index] = int_mod_cq_depth_1;
 	target_stat_values[++index] = int_mod_cq_depth_4;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/infiniband/hw/nes/nes_verbs.c linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_verbs.c
--- linux-2.6.32.60/drivers/infiniband/hw/nes/nes_verbs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/infiniband/hw/nes/nes_verbs.c	2012-03-13 13:15:35.112097991 +0100
@@ -45,9 +45,9 @@
 
 #include <rdma/ib_umem.h>
 
-atomic_t mod_qp_timouts;
-atomic_t qps_created;
-atomic_t sw_qps_destroyed;
+atomic_unchecked_t mod_qp_timouts;
+atomic_unchecked_t qps_created;
+atomic_unchecked_t sw_qps_destroyed;
 
 static void nes_unregister_ofa_device(struct nes_ib_device *nesibdev);
 
@@ -1240,7 +1240,7 @@ static struct ib_qp *nes_create_qp(struc
 	if (init_attr->create_flags)
 		return ERR_PTR(-EINVAL);
 
-	atomic_inc(&qps_created);
+	atomic_inc_unchecked(&qps_created);
 	switch (init_attr->qp_type) {
 		case IB_QPT_RC:
 			if (nes_drv_opt & NES_DRV_OPT_NO_INLINE_DATA) {
@@ -1568,7 +1568,7 @@ static int nes_destroy_qp(struct ib_qp *
 	struct iw_cm_event cm_event;
 	int ret;
 
-	atomic_inc(&sw_qps_destroyed);
+	atomic_inc_unchecked(&sw_qps_destroyed);
 	nesqp->destroyed = 1;
 
 	/* Blow away the connection if it exists. */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/input/gameport/gameport.c linux-2.6.32.60-pax/drivers/input/gameport/gameport.c
--- linux-2.6.32.60/drivers/input/gameport/gameport.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/input/gameport/gameport.c	2012-03-13 13:15:35.112097991 +0100
@@ -515,13 +515,13 @@ EXPORT_SYMBOL(gameport_set_phys);
  */
 static void gameport_init_port(struct gameport *gameport)
 {
-	static atomic_t gameport_no = ATOMIC_INIT(0);
+	static atomic_unchecked_t gameport_no = ATOMIC_INIT(0);
 
 	__module_get(THIS_MODULE);
 
 	mutex_init(&gameport->drv_mutex);
 	device_initialize(&gameport->dev);
-	dev_set_name(&gameport->dev, "gameport%lu", (unsigned long)atomic_inc_return(&gameport_no) - 1);
+	dev_set_name(&gameport->dev, "gameport%lu", (unsigned long)atomic_inc_return_unchecked(&gameport_no) - 1);
 	gameport->dev.bus = &gameport_bus;
 	gameport->dev.release = gameport_release_port;
 	if (gameport->parent)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/input/input.c linux-2.6.32.60-pax/drivers/input/input.c
--- linux-2.6.32.60/drivers/input/input.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/input/input.c	2012-03-13 13:15:35.116097991 +0100
@@ -1558,7 +1558,7 @@ EXPORT_SYMBOL(input_set_capability);
  */
 int input_register_device(struct input_dev *dev)
 {
-	static atomic_t input_no = ATOMIC_INIT(0);
+	static atomic_unchecked_t input_no = ATOMIC_INIT(0);
 	struct input_handler *handler;
 	const char *path;
 	int error;
@@ -1585,7 +1585,7 @@ int input_register_device(struct input_d
 		dev->setkeycode = input_default_setkeycode;
 
 	dev_set_name(&dev->dev, "input%ld",
-		     (unsigned long) atomic_inc_return(&input_no) - 1);
+		     (unsigned long) atomic_inc_return_unchecked(&input_no) - 1);
 
 	error = device_add(&dev->dev);
 	if (error)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/input/joystick/sidewinder.c linux-2.6.32.60-pax/drivers/input/joystick/sidewinder.c
--- linux-2.6.32.60/drivers/input/joystick/sidewinder.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/input/joystick/sidewinder.c	2012-03-13 13:15:35.116097991 +0100
@@ -30,6 +30,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/input.h>
 #include <linux/gameport.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/input/joystick/xpad.c linux-2.6.32.60-pax/drivers/input/joystick/xpad.c
--- linux-2.6.32.60/drivers/input/joystick/xpad.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/input/joystick/xpad.c	2012-03-13 13:15:35.116097991 +0100
@@ -621,7 +621,7 @@ static void xpad_led_set(struct led_clas
 
 static int xpad_led_probe(struct usb_xpad *xpad)
 {
-	static atomic_t led_seq	= ATOMIC_INIT(0);
+	static atomic_unchecked_t led_seq	= ATOMIC_INIT(0);
 	long led_no;
 	struct xpad_led *led;
 	struct led_classdev *led_cdev;
@@ -634,7 +634,7 @@ static int xpad_led_probe(struct usb_xpa
 	if (!led)
 		return -ENOMEM;
 
-	led_no = (long)atomic_inc_return(&led_seq) - 1;
+	led_no = (long)atomic_inc_return_unchecked(&led_seq) - 1;
 
 	snprintf(led->name, sizeof(led->name), "xpad%ld", led_no);
 	led->xpad = xpad;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/input/serio/serio.c linux-2.6.32.60-pax/drivers/input/serio/serio.c
--- linux-2.6.32.60/drivers/input/serio/serio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/input/serio/serio.c	2012-03-13 13:15:35.120097991 +0100
@@ -527,7 +527,7 @@ static void serio_release_port(struct de
  */
 static void serio_init_port(struct serio *serio)
 {
-	static atomic_t serio_no = ATOMIC_INIT(0);
+	static atomic_unchecked_t serio_no = ATOMIC_INIT(0);
 
 	__module_get(THIS_MODULE);
 
@@ -536,7 +536,7 @@ static void serio_init_port(struct serio
 	mutex_init(&serio->drv_mutex);
 	device_initialize(&serio->dev);
 	dev_set_name(&serio->dev, "serio%ld",
-			(long)atomic_inc_return(&serio_no) - 1);
+			(long)atomic_inc_return_unchecked(&serio_no) - 1);
 	serio->dev.bus = &serio_bus;
 	serio->dev.release = serio_release_port;
 	if (serio->parent) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/isdn/gigaset/common.c linux-2.6.32.60-pax/drivers/isdn/gigaset/common.c
--- linux-2.6.32.60/drivers/isdn/gigaset/common.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/isdn/gigaset/common.c	2012-03-13 13:15:35.120097991 +0100
@@ -712,7 +712,7 @@ struct cardstate *gigaset_initcs(struct
 	cs->commands_pending = 0;
 	cs->cur_at_seq = 0;
 	cs->gotfwver = -1;
-	cs->open_count = 0;
+	local_set(&cs->open_count, 0);
 	cs->dev = NULL;
 	cs->tty = NULL;
 	cs->tty_dev = NULL;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/isdn/gigaset/gigaset.h linux-2.6.32.60-pax/drivers/isdn/gigaset/gigaset.h
--- linux-2.6.32.60/drivers/isdn/gigaset/gigaset.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/isdn/gigaset/gigaset.h	2012-03-13 13:15:35.120097991 +0100
@@ -34,6 +34,7 @@
 #include <linux/tty_driver.h>
 #include <linux/list.h>
 #include <asm/atomic.h>
+#include <asm/local.h>
 
 #define GIG_VERSION {0,5,0,0}
 #define GIG_COMPAT  {0,4,0,0}
@@ -446,7 +447,7 @@ struct cardstate {
 	spinlock_t cmdlock;
 	unsigned curlen, cmdbytes;
 
-	unsigned open_count;
+	local_t open_count;
 	struct tty_struct *tty;
 	struct tasklet_struct if_wake_tasklet;
 	unsigned control_state;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/isdn/gigaset/interface.c linux-2.6.32.60-pax/drivers/isdn/gigaset/interface.c
--- linux-2.6.32.60/drivers/isdn/gigaset/interface.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/isdn/gigaset/interface.c	2012-03-13 13:15:35.120097991 +0100
@@ -165,9 +165,7 @@ static int if_open(struct tty_struct *tt
 		return -ERESTARTSYS; // FIXME -EINTR?
 	tty->driver_data = cs;
 
-	++cs->open_count;
-
-	if (cs->open_count == 1) {
+	if (local_inc_return(&cs->open_count) == 1) {
 		spin_lock_irqsave(&cs->lock, flags);
 		cs->tty = tty;
 		spin_unlock_irqrestore(&cs->lock, flags);
@@ -195,10 +193,10 @@ static void if_close(struct tty_struct *
 
 	if (!cs->connected)
 		gig_dbg(DEBUG_IF, "not connected");	/* nothing to do */
-	else if (!cs->open_count)
+	else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else {
-		if (!--cs->open_count) {
+		if (!local_dec_return(&cs->open_count)) {
 			spin_lock_irqsave(&cs->lock, flags);
 			cs->tty = NULL;
 			spin_unlock_irqrestore(&cs->lock, flags);
@@ -233,7 +231,7 @@ static int if_ioctl(struct tty_struct *t
 	if (!cs->connected) {
 		gig_dbg(DEBUG_IF, "not connected");
 		retval = -ENODEV;
-	} else if (!cs->open_count)
+	} else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else {
 		retval = 0;
@@ -361,7 +359,7 @@ static int if_write(struct tty_struct *t
 	if (!cs->connected) {
 		gig_dbg(DEBUG_IF, "not connected");
 		retval = -ENODEV;
-	} else if (!cs->open_count)
+	} else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else if (cs->mstate != MS_LOCKED) {
 		dev_warn(cs->dev, "can't write to unlocked device\n");
@@ -395,7 +393,7 @@ static int if_write_room(struct tty_stru
 	if (!cs->connected) {
 		gig_dbg(DEBUG_IF, "not connected");
 		retval = -ENODEV;
-	} else if (!cs->open_count)
+	} else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else if (cs->mstate != MS_LOCKED) {
 		dev_warn(cs->dev, "can't write to unlocked device\n");
@@ -425,7 +423,7 @@ static int if_chars_in_buffer(struct tty
 
 	if (!cs->connected)
 		gig_dbg(DEBUG_IF, "not connected");
-	else if (!cs->open_count)
+	else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else if (cs->mstate != MS_LOCKED)
 		dev_warn(cs->dev, "can't write to unlocked device\n");
@@ -453,7 +451,7 @@ static void if_throttle(struct tty_struc
 
 	if (!cs->connected)
 		gig_dbg(DEBUG_IF, "not connected");	/* nothing to do */
-	else if (!cs->open_count)
+	else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else {
 		//FIXME
@@ -478,7 +476,7 @@ static void if_unthrottle(struct tty_str
 
 	if (!cs->connected)
 		gig_dbg(DEBUG_IF, "not connected");	/* nothing to do */
-	else if (!cs->open_count)
+	else if (!local_read(&cs->open_count))
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 	else {
 		//FIXME
@@ -510,7 +508,7 @@ static void if_set_termios(struct tty_st
 		goto out;
 	}
 
-	if (!cs->open_count) {
+	if (!local_read(&cs->open_count)) {
 		dev_warn(cs->dev, "%s: device not opened\n", __func__);
 		goto out;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/isdn/hardware/avm/b1.c linux-2.6.32.60-pax/drivers/isdn/hardware/avm/b1.c
--- linux-2.6.32.60/drivers/isdn/hardware/avm/b1.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/isdn/hardware/avm/b1.c	2012-03-13 13:15:35.124097990 +0100
@@ -173,7 +173,7 @@ int b1_load_t4file(avmcard *card, capilo
 	}
 	if (left) {
 		if (t4file->user) {
-			if (copy_from_user(buf, dp, left))
+			if (left > sizeof buf || copy_from_user(buf, dp, left))
 				return -EFAULT;
 		} else {
 			memcpy(buf, dp, left);
@@ -221,7 +221,7 @@ int b1_load_config(avmcard *card, capilo
 	}
 	if (left) {
 		if (config->user) {
-			if (copy_from_user(buf, dp, left))
+			if (left > sizeof buf || copy_from_user(buf, dp, left))
 				return -EFAULT;
 		} else {
 			memcpy(buf, dp, left);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/isdn/icn/icn.c linux-2.6.32.60-pax/drivers/isdn/icn/icn.c
--- linux-2.6.32.60/drivers/isdn/icn/icn.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/isdn/icn/icn.c	2012-03-13 13:15:35.124097990 +0100
@@ -1044,7 +1044,7 @@ icn_writecmd(const u_char * buf, int len
 		if (count > len)
 			count = len;
 		if (user) {
-			if (copy_from_user(msg, buf, count))
+			if (count > sizeof msg || copy_from_user(msg, buf, count))
 				return -EFAULT;
 		} else
 			memcpy(msg, buf, count);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/lguest/core.c linux-2.6.32.60-pax/drivers/lguest/core.c
--- linux-2.6.32.60/drivers/lguest/core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/lguest/core.c	2012-03-13 13:15:35.128097990 +0100
@@ -91,9 +91,17 @@ static __init int map_switcher(void)
 	 * it's worked so far.  The end address needs +1 because __get_vm_area
 	 * allocates an extra guard page, so we need space for that.
 	 */
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	switcher_vma = __get_vm_area(TOTAL_SWITCHER_PAGES * PAGE_SIZE,
+				     VM_ALLOC | VM_KERNEXEC, SWITCHER_ADDR, SWITCHER_ADDR
+				     + (TOTAL_SWITCHER_PAGES+1) * PAGE_SIZE);
+#else
 	switcher_vma = __get_vm_area(TOTAL_SWITCHER_PAGES * PAGE_SIZE,
 				     VM_ALLOC, SWITCHER_ADDR, SWITCHER_ADDR
 				     + (TOTAL_SWITCHER_PAGES+1) * PAGE_SIZE);
+#endif
+
 	if (!switcher_vma) {
 		err = -ENOMEM;
 		printk("lguest: could not map switcher pages high\n");
@@ -118,7 +126,7 @@ static __init int map_switcher(void)
 	 * Now the Switcher is mapped at the right address, we can't fail!
 	 * Copy in the compiled-in Switcher code (from <arch>_switcher.S).
 	 */
-	memcpy(switcher_vma->addr, start_switcher_text,
+	memcpy(switcher_vma->addr, ktla_ktva(start_switcher_text),
 	       end_switcher_text - start_switcher_text);
 
 	printk(KERN_INFO "lguest: mapped switcher at %p\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/lguest/x86/core.c linux-2.6.32.60-pax/drivers/lguest/x86/core.c
--- linux-2.6.32.60/drivers/lguest/x86/core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/lguest/x86/core.c	2012-03-13 13:15:35.128097990 +0100
@@ -59,7 +59,7 @@ static struct {
 /* Offset from where switcher.S was compiled to where we've copied it */
 static unsigned long switcher_offset(void)
 {
-	return SWITCHER_ADDR - (unsigned long)start_switcher_text;
+	return SWITCHER_ADDR - (unsigned long)ktla_ktva(start_switcher_text);
 }
 
 /* This cpu's struct lguest_pages. */
@@ -100,7 +100,13 @@ static void copy_in_guest_info(struct lg
 	 * These copies are pretty cheap, so we do them unconditionally: */
 	/* Save the current Host top-level page directory.
 	 */
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	pages->state.host_cr3 = read_cr3();
+#else
 	pages->state.host_cr3 = __pa(current->mm->pgd);
+#endif
+
 	/*
 	 * Set up the Guest's page tables to see this CPU's pages (and no
 	 * other CPU's pages).
@@ -535,7 +541,7 @@ void __init lguest_arch_host_init(void)
 	 * compiled-in switcher code and the high-mapped copy we just made.
 	 */
 	for (i = 0; i < IDT_ENTRIES; i++)
-		default_idt_entries[i] += switcher_offset();
+		default_idt_entries[i] = ktla_ktva(default_idt_entries[i]) + switcher_offset();
 
 	/*
 	 * Set up the Switcher's per-cpu areas.
@@ -618,7 +624,7 @@ void __init lguest_arch_host_init(void)
 	 * it will be undisturbed when we switch.  To change %cs and jump we
 	 * need this structure to feed to Intel's "lcall" instruction.
 	 */
-	lguest_entry.offset = (long)switch_to_guest + switcher_offset();
+	lguest_entry.offset = (long)ktla_ktva(switch_to_guest) + switcher_offset();
 	lguest_entry.segment = LGUEST_CS;
 
 	/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/lguest/x86/switcher_32.S linux-2.6.32.60-pax/drivers/lguest/x86/switcher_32.S
--- linux-2.6.32.60/drivers/lguest/x86/switcher_32.S	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/lguest/x86/switcher_32.S	2012-03-13 13:15:35.128097990 +0100
@@ -87,6 +87,7 @@
 #include <asm/page.h>
 #include <asm/segment.h>
 #include <asm/lguest.h>
+#include <asm/processor-flags.h>
 
 // We mark the start of the code to copy
 // It's placed in .text tho it's never run here
@@ -149,6 +150,13 @@ ENTRY(switch_to_guest)
 	// Changes type when we load it: damn Intel!
 	// For after we switch over our page tables
 	// That entry will be read-only: we'd crash.
+
+#ifdef CONFIG_PAX_KERNEXEC
+	mov	%cr0, %edx
+	xor	$X86_CR0_WP, %edx
+	mov	%edx, %cr0
+#endif
+
 	movl	$(GDT_ENTRY_TSS*8), %edx
 	ltr	%dx
 
@@ -157,9 +165,15 @@ ENTRY(switch_to_guest)
 	// Let's clear it again for our return.
 	// The GDT descriptor of the Host
 	// Points to the table after two "size" bytes
-	movl	(LGUEST_PAGES_host_gdt_desc+2)(%eax), %edx
+	movl	(LGUEST_PAGES_host_gdt_desc+2)(%eax), %eax
 	// Clear "used" from type field (byte 5, bit 2)
-	andb	$0xFD, (GDT_ENTRY_TSS*8 + 5)(%edx)
+	andb	$0xFD, (GDT_ENTRY_TSS*8 + 5)(%eax)
+
+#ifdef CONFIG_PAX_KERNEXEC
+	mov	%cr0, %eax
+	xor	$X86_CR0_WP, %eax
+	mov	%eax, %cr0
+#endif
 
 	// Once our page table's switched, the Guest is live!
 	// The Host fades as we run this final step.
@@ -295,13 +309,12 @@ deliver_to_host:
 	// I consulted gcc, and it gave
 	// These instructions, which I gladly credit:
 	leal	(%edx,%ebx,8), %eax
-	movzwl	(%eax),%edx
-	movl	4(%eax), %eax
-	xorw	%ax, %ax
-	orl	%eax, %edx
+	movl	4(%eax), %edx
+	movw	(%eax), %dx
 	// Now the address of the handler's in %edx
 	// We call it now: its "iret" drops us home.
-	jmp	*%edx
+	ljmp	$__KERNEL_CS, $1f
+1:	jmp	*%edx
 
 // Every interrupt can come to us here
 // But we must truly tell each apart.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/macintosh/macio_asic.c linux-2.6.32.60-pax/drivers/macintosh/macio_asic.c
--- linux-2.6.32.60/drivers/macintosh/macio_asic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/macintosh/macio_asic.c	2012-03-13 13:15:35.128097990 +0100
@@ -701,7 +701,7 @@ static void __devexit macio_pci_remove(s
  * MacIO is matched against any Apple ID, it's probe() function
  * will then decide wether it applies or not
  */
-static const struct pci_device_id __devinitdata pci_ids [] = { {
+static const struct pci_device_id __devinitconst pci_ids [] = { {
 	.vendor		= PCI_VENDOR_ID_APPLE,
 	.device		= PCI_ANY_ID,
 	.subvendor	= PCI_ANY_ID,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/dm.c linux-2.6.32.60-pax/drivers/md/dm.c
--- linux-2.6.32.60/drivers/md/dm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/dm.c	2012-03-13 13:15:35.132097990 +0100
@@ -165,9 +165,9 @@ struct mapped_device {
 	/*
 	 * Event handling.
 	 */
-	atomic_t event_nr;
+	atomic_unchecked_t event_nr;
 	wait_queue_head_t eventq;
-	atomic_t uevent_seq;
+	atomic_unchecked_t uevent_seq;
 	struct list_head uevent_list;
 	spinlock_t uevent_lock; /* Protect access to uevent_list */
 
@@ -1776,8 +1776,8 @@ static struct mapped_device *alloc_dev(i
 	rwlock_init(&md->map_lock);
 	atomic_set(&md->holders, 1);
 	atomic_set(&md->open_count, 0);
-	atomic_set(&md->event_nr, 0);
-	atomic_set(&md->uevent_seq, 0);
+	atomic_set_unchecked(&md->event_nr, 0);
+	atomic_set_unchecked(&md->uevent_seq, 0);
 	INIT_LIST_HEAD(&md->uevent_list);
 	spin_lock_init(&md->uevent_lock);
 
@@ -1927,7 +1927,7 @@ static void event_callback(void *context
 
 	dm_send_uevents(&uevents, &disk_to_dev(md->disk)->kobj);
 
-	atomic_inc(&md->event_nr);
+	atomic_inc_unchecked(&md->event_nr);
 	wake_up(&md->eventq);
 }
 
@@ -2562,18 +2562,18 @@ void dm_kobject_uevent(struct mapped_dev
 
 uint32_t dm_next_uevent_seq(struct mapped_device *md)
 {
-	return atomic_add_return(1, &md->uevent_seq);
+	return atomic_add_return_unchecked(1, &md->uevent_seq);
 }
 
 uint32_t dm_get_event_nr(struct mapped_device *md)
 {
-	return atomic_read(&md->event_nr);
+	return atomic_read_unchecked(&md->event_nr);
 }
 
 int dm_wait_event(struct mapped_device *md, int event_nr)
 {
 	return wait_event_interruptible(md->eventq,
-			(event_nr != atomic_read(&md->event_nr)));
+			(event_nr != atomic_read_unchecked(&md->event_nr)));
 }
 
 void dm_uevent_add(struct mapped_device *md, struct list_head *elist)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/dm-ioctl.c linux-2.6.32.60-pax/drivers/md/dm-ioctl.c
--- linux-2.6.32.60/drivers/md/dm-ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/dm-ioctl.c	2012-03-13 13:15:35.132097990 +0100
@@ -1437,7 +1437,7 @@ static int validate_params(uint cmd, str
 	    cmd == DM_LIST_VERSIONS_CMD)
 		return 0;
 
-	if ((cmd == DM_DEV_CREATE_CMD)) {
+	if (cmd == DM_DEV_CREATE_CMD) {
 		if (!*param->name) {
 			DMWARN("name not supplied when creating device");
 			return -EINVAL;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/dm-raid1.c linux-2.6.32.60-pax/drivers/md/dm-raid1.c
--- linux-2.6.32.60/drivers/md/dm-raid1.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/dm-raid1.c	2012-03-13 13:15:35.132097990 +0100
@@ -41,7 +41,7 @@ enum dm_raid1_error {
 
 struct mirror {
 	struct mirror_set *ms;
-	atomic_t error_count;
+	atomic_unchecked_t error_count;
 	unsigned long error_type;
 	struct dm_dev *dev;
 	sector_t offset;
@@ -203,7 +203,7 @@ static void fail_mirror(struct mirror *m
 	 * simple way to tell if a device has encountered
 	 * errors.
 	 */
-	atomic_inc(&m->error_count);
+	atomic_inc_unchecked(&m->error_count);
 
 	if (test_and_set_bit(error_type, &m->error_type))
 		return;
@@ -225,7 +225,7 @@ static void fail_mirror(struct mirror *m
 	}
 
 	for (new = ms->mirror; new < ms->mirror + ms->nr_mirrors; new++)
-		if (!atomic_read(&new->error_count)) {
+		if (!atomic_read_unchecked(&new->error_count)) {
 			set_default_mirror(new);
 			break;
 		}
@@ -363,7 +363,7 @@ static struct mirror *choose_mirror(stru
 	struct mirror *m = get_default_mirror(ms);
 
 	do {
-		if (likely(!atomic_read(&m->error_count)))
+		if (likely(!atomic_read_unchecked(&m->error_count)))
 			return m;
 
 		if (m-- == ms->mirror)
@@ -377,7 +377,7 @@ static int default_ok(struct mirror *m)
 {
 	struct mirror *default_mirror = get_default_mirror(m->ms);
 
-	return !atomic_read(&default_mirror->error_count);
+	return !atomic_read_unchecked(&default_mirror->error_count);
 }
 
 static int mirror_available(struct mirror_set *ms, struct bio *bio)
@@ -484,7 +484,7 @@ static void do_reads(struct mirror_set *
 		 */
 		if (likely(region_in_sync(ms, region, 1)))
 			m = choose_mirror(ms, bio->bi_sector);
-		else if (m && atomic_read(&m->error_count))
+		else if (m && atomic_read_unchecked(&m->error_count))
 			m = NULL;
 
 		if (likely(m))
@@ -855,7 +855,7 @@ static int get_mirror(struct mirror_set
 	}
 
 	ms->mirror[mirror].ms = ms;
-	atomic_set(&(ms->mirror[mirror].error_count), 0);
+	atomic_set_unchecked(&(ms->mirror[mirror].error_count), 0);
 	ms->mirror[mirror].error_type = 0;
 	ms->mirror[mirror].offset = offset;
 
@@ -1241,7 +1241,7 @@ static void mirror_resume(struct dm_targ
  */
 static char device_status_char(struct mirror *m)
 {
-	if (!atomic_read(&(m->error_count)))
+	if (!atomic_read_unchecked(&(m->error_count)))
 		return 'A';
 
 	return (test_bit(DM_RAID1_WRITE_ERROR, &(m->error_type))) ? 'D' :
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/dm-stripe.c linux-2.6.32.60-pax/drivers/md/dm-stripe.c
--- linux-2.6.32.60/drivers/md/dm-stripe.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/dm-stripe.c	2012-03-13 13:15:35.136097990 +0100
@@ -20,7 +20,7 @@ struct stripe {
 	struct dm_dev *dev;
 	sector_t physical_start;
 
-	atomic_t error_count;
+	atomic_unchecked_t error_count;
 };
 
 struct stripe_c {
@@ -188,7 +188,7 @@ static int stripe_ctr(struct dm_target *
 			kfree(sc);
 			return r;
 		}
-		atomic_set(&(sc->stripe[i].error_count), 0);
+		atomic_set_unchecked(&(sc->stripe[i].error_count), 0);
 	}
 
 	ti->private = sc;
@@ -257,7 +257,7 @@ static int stripe_status(struct dm_targe
 		DMEMIT("%d ", sc->stripes);
 		for (i = 0; i < sc->stripes; i++)  {
 			DMEMIT("%s ", sc->stripe[i].dev->name);
-			buffer[i] = atomic_read(&(sc->stripe[i].error_count)) ?
+			buffer[i] = atomic_read_unchecked(&(sc->stripe[i].error_count)) ?
 				'D' : 'A';
 		}
 		buffer[i] = '\0';
@@ -304,8 +304,8 @@ static int stripe_end_io(struct dm_targe
 	 */
 	for (i = 0; i < sc->stripes; i++)
 		if (!strcmp(sc->stripe[i].dev->name, major_minor)) {
-			atomic_inc(&(sc->stripe[i].error_count));
-			if (atomic_read(&(sc->stripe[i].error_count)) <
+			atomic_inc_unchecked(&(sc->stripe[i].error_count));
+			if (atomic_read_unchecked(&(sc->stripe[i].error_count)) <
 			    DM_IO_ERROR_THRESHOLD)
 				queue_work(kstriped, &sc->kstriped_ws);
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/dm-table.c linux-2.6.32.60-pax/drivers/md/dm-table.c
--- linux-2.6.32.60/drivers/md/dm-table.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/dm-table.c	2012-03-13 13:15:35.136097990 +0100
@@ -376,7 +376,7 @@ static int device_area_is_invalid(struct
 	if (!dev_size)
 		return 0;
 
-	if ((start >= dev_size) || (start + len > dev_size)) {
+	if ((start >= dev_size) || (len > dev_size - start)) {
 		DMWARN("%s: %s too small for target: "
 		       "start=%llu, len=%llu, dev_size=%llu",
 		       dm_device_name(ti->table->md), bdevname(bdev, b),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/md.c linux-2.6.32.60-pax/drivers/md/md.c
--- linux-2.6.32.60/drivers/md/md.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/md.c	2012-03-13 13:15:35.140097990 +0100
@@ -153,10 +153,10 @@ static int start_readonly;
  *  start build, activate spare
  */
 static DECLARE_WAIT_QUEUE_HEAD(md_event_waiters);
-static atomic_t md_event_count;
+static atomic_unchecked_t md_event_count;
 void md_new_event(mddev_t *mddev)
 {
-	atomic_inc(&md_event_count);
+	atomic_inc_unchecked(&md_event_count);
 	wake_up(&md_event_waiters);
 }
 EXPORT_SYMBOL_GPL(md_new_event);
@@ -166,7 +166,7 @@ EXPORT_SYMBOL_GPL(md_new_event);
  */
 static void md_new_event_inintr(mddev_t *mddev)
 {
-	atomic_inc(&md_event_count);
+	atomic_inc_unchecked(&md_event_count);
 	wake_up(&md_event_waiters);
 }
 
@@ -1226,7 +1226,7 @@ static int super_1_load(mdk_rdev_t *rdev
 
 	rdev->preferred_minor = 0xffff;
 	rdev->data_offset = le64_to_cpu(sb->data_offset);
-	atomic_set(&rdev->corrected_errors, le32_to_cpu(sb->cnt_corrected_read));
+	atomic_set_unchecked(&rdev->corrected_errors, le32_to_cpu(sb->cnt_corrected_read));
 
 	rdev->sb_size = le32_to_cpu(sb->max_dev) * 2 + 256;
 	bmask = queue_logical_block_size(rdev->bdev->bd_disk->queue)-1;
@@ -1400,7 +1400,7 @@ static void super_1_sync(mddev_t *mddev,
 	else
 		sb->resync_offset = cpu_to_le64(0);
 
-	sb->cnt_corrected_read = cpu_to_le32(atomic_read(&rdev->corrected_errors));
+	sb->cnt_corrected_read = cpu_to_le32(atomic_read_unchecked(&rdev->corrected_errors));
 
 	sb->raid_disks = cpu_to_le32(mddev->raid_disks);
 	sb->size = cpu_to_le64(mddev->dev_sectors);
@@ -2222,7 +2222,7 @@ __ATTR(state, S_IRUGO|S_IWUSR, state_sho
 static ssize_t
 errors_show(mdk_rdev_t *rdev, char *page)
 {
-	return sprintf(page, "%d\n", atomic_read(&rdev->corrected_errors));
+	return sprintf(page, "%d\n", atomic_read_unchecked(&rdev->corrected_errors));
 }
 
 static ssize_t
@@ -2231,7 +2231,7 @@ errors_store(mdk_rdev_t *rdev, const cha
 	char *e;
 	unsigned long n = simple_strtoul(buf, &e, 10);
 	if (*buf && (*e == 0 || *e == '\n')) {
-		atomic_set(&rdev->corrected_errors, n);
+		atomic_set_unchecked(&rdev->corrected_errors, n);
 		return len;
 	}
 	return -EINVAL;
@@ -2574,8 +2574,8 @@ static mdk_rdev_t *md_import_device(dev_
 	rdev->data_offset = 0;
 	rdev->sb_events = 0;
 	atomic_set(&rdev->nr_pending, 0);
-	atomic_set(&rdev->read_errors, 0);
-	atomic_set(&rdev->corrected_errors, 0);
+	atomic_set_unchecked(&rdev->read_errors, 0);
+	atomic_set_unchecked(&rdev->corrected_errors, 0);
 
 	size = rdev->bdev->bd_inode->i_size >> BLOCK_SIZE_BITS;
 	if (!size) {
@@ -5962,7 +5962,7 @@ static int md_seq_show(struct seq_file *
 
 		spin_unlock(&pers_lock);
 		seq_printf(seq, "\n");
-		mi->event = atomic_read(&md_event_count);
+		mi->event = atomic_read_unchecked(&md_event_count);
 		return 0;
 	}
 	if (v == (void*)2) {
@@ -6051,7 +6051,7 @@ static int md_seq_show(struct seq_file *
 				chunk_kb ? "KB" : "B");
 			if (bitmap->file) {
 				seq_printf(seq, ", file: ");
-				seq_path(seq, &bitmap->file->f_path, " \t\n");
+				seq_path(seq, &bitmap->file->f_path, " \t\n\\");
 			}
 
 			seq_printf(seq, "\n");
@@ -6085,7 +6085,7 @@ static int md_seq_open(struct inode *ino
 	else {
 		struct seq_file *p = file->private_data;
 		p->private = mi;
-		mi->event = atomic_read(&md_event_count);
+		mi->event = atomic_read_unchecked(&md_event_count);
 	}
 	return error;
 }
@@ -6101,7 +6101,7 @@ static unsigned int mdstat_poll(struct f
 	/* always allow read */
 	mask = POLLIN | POLLRDNORM;
 
-	if (mi->event != atomic_read(&md_event_count))
+	if (mi->event != atomic_read_unchecked(&md_event_count))
 		mask |= POLLERR | POLLPRI;
 	return mask;
 }
@@ -6145,7 +6145,7 @@ static int is_mddev_idle(mddev_t *mddev,
 		struct gendisk *disk = rdev->bdev->bd_contains->bd_disk;
 		curr_events = (int)part_stat_read(&disk->part0, sectors[0]) +
 			      (int)part_stat_read(&disk->part0, sectors[1]) -
-			      atomic_read(&disk->sync_io);
+			      atomic_read_unchecked(&disk->sync_io);
 		/* sync IO will cause sync_io to increase before the disk_stats
 		 * as sync_io is counted when a request starts, and
 		 * disk_stats is counted when it completes.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/md.h linux-2.6.32.60-pax/drivers/md/md.h
--- linux-2.6.32.60/drivers/md/md.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/md.h	2012-03-13 13:15:35.140097990 +0100
@@ -94,10 +94,10 @@ struct mdk_rdev_s
 					 * only maintained for arrays that
 					 * support hot removal
 					 */
-	atomic_t	read_errors;	/* number of consecutive read errors that
+	atomic_unchecked_t	read_errors;	/* number of consecutive read errors that
 					 * we have tried to ignore.
 					 */
-	atomic_t	corrected_errors; /* number of corrected read errors,
+	atomic_unchecked_t	corrected_errors; /* number of corrected read errors,
 					   * for reporting to userspace and storing
 					   * in superblock.
 					   */
@@ -304,7 +304,7 @@ static inline void rdev_dec_pending(mdk_
 
 static inline void md_sync_acct(struct block_device *bdev, unsigned long nr_sectors)
 {
-        atomic_add(nr_sectors, &bdev->bd_contains->bd_disk->sync_io);
+	atomic_add_unchecked(nr_sectors, &bdev->bd_contains->bd_disk->sync_io);
 }
 
 struct mdk_personality
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/raid10.c linux-2.6.32.60-pax/drivers/md/raid10.c
--- linux-2.6.32.60/drivers/md/raid10.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/raid10.c	2012-03-13 13:15:35.140097990 +0100
@@ -1255,7 +1255,7 @@ static void end_sync_read(struct bio *bi
 	if (test_bit(BIO_UPTODATE, &bio->bi_flags))
 		set_bit(R10BIO_Uptodate, &r10_bio->state);
 	else {
-		atomic_add(r10_bio->sectors,
+		atomic_add_unchecked(r10_bio->sectors,
 			   &conf->mirrors[d].rdev->corrected_errors);
 		if (!test_bit(MD_RECOVERY_SYNC, &conf->mddev->recovery))
 			md_error(r10_bio->mddev,
@@ -1520,7 +1520,7 @@ static void fix_read_error(conf_t *conf,
 			    test_bit(In_sync, &rdev->flags)) {
 				atomic_inc(&rdev->nr_pending);
 				rcu_read_unlock();
-				atomic_add(s, &rdev->corrected_errors);
+				atomic_add_unchecked(s, &rdev->corrected_errors);
 				if (sync_page_io(rdev->bdev,
 						 r10_bio->devs[sl].addr +
 						 sect + rdev->data_offset,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/raid1.c linux-2.6.32.60-pax/drivers/md/raid1.c
--- linux-2.6.32.60/drivers/md/raid1.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/raid1.c	2012-03-13 13:15:35.144097989 +0100
@@ -1415,7 +1415,7 @@ static void sync_request_write(mddev_t *
 					if (r1_bio->bios[d]->bi_end_io != end_sync_read)
 						continue;
 					rdev = conf->mirrors[d].rdev;
-					atomic_add(s, &rdev->corrected_errors);
+					atomic_add_unchecked(s, &rdev->corrected_errors);
 					if (sync_page_io(rdev->bdev,
 							 sect + rdev->data_offset,
 							 s<<9,
@@ -1564,7 +1564,7 @@ static void fix_read_error(conf_t *conf,
 					/* Well, this device is dead */
 					md_error(mddev, rdev);
 				else {
-					atomic_add(s, &rdev->corrected_errors);
+					atomic_add_unchecked(s, &rdev->corrected_errors);
 					printk(KERN_INFO
 					       "raid1:%s: read error corrected "
 					       "(%d sectors at %llu on %s)\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/md/raid5.c linux-2.6.32.60-pax/drivers/md/raid5.c
--- linux-2.6.32.60/drivers/md/raid5.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/md/raid5.c	2012-03-13 13:15:35.144097989 +0100
@@ -482,7 +482,7 @@ static void ops_run_io(struct stripe_hea
 			bi->bi_next = NULL;
 			if ((rw & WRITE) &&
 			    test_bit(R5_ReWrite, &sh->dev[i].flags))
-				atomic_add(STRIPE_SECTORS,
+				atomic_add_unchecked(STRIPE_SECTORS,
 					&rdev->corrected_errors);
 			generic_make_request(bi);
 		} else {
@@ -1517,15 +1517,15 @@ static void raid5_end_read_request(struc
 			clear_bit(R5_ReadError, &sh->dev[i].flags);
 			clear_bit(R5_ReWrite, &sh->dev[i].flags);
 		}
-		if (atomic_read(&conf->disks[i].rdev->read_errors))
-			atomic_set(&conf->disks[i].rdev->read_errors, 0);
+		if (atomic_read_unchecked(&conf->disks[i].rdev->read_errors))
+			atomic_set_unchecked(&conf->disks[i].rdev->read_errors, 0);
 	} else {
 		const char *bdn = bdevname(conf->disks[i].rdev->bdev, b);
 		int retry = 0;
 		rdev = conf->disks[i].rdev;
 
 		clear_bit(R5_UPTODATE, &sh->dev[i].flags);
-		atomic_inc(&rdev->read_errors);
+		atomic_inc_unchecked(&rdev->read_errors);
 		if (conf->mddev->degraded >= conf->max_degraded)
 			printk_rl(KERN_WARNING
 				  "raid5:%s: read error not correctable "
@@ -1543,7 +1543,7 @@ static void raid5_end_read_request(struc
 				  (unsigned long long)(sh->sector
 						       + rdev->data_offset),
 				  bdn);
-		else if (atomic_read(&rdev->read_errors)
+		else if (atomic_read_unchecked(&rdev->read_errors)
 			 > conf->max_nr_stripes)
 			printk(KERN_WARNING
 			       "raid5:%s: Too many read errors, failing device %s.\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.32.60-pax/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.32.60/drivers/media/dvb/dvb-core/dvbdev.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/dvb/dvb-core/dvbdev.c	2012-03-13 13:15:35.148097989 +0100
@@ -191,7 +191,7 @@ int dvb_register_device(struct dvb_adapt
 			const struct dvb_device *template, void *priv, int type)
 {
 	struct dvb_device *dvbdev;
-	struct file_operations *dvbdevfops;
+	file_operations_no_const *dvbdevfops;
 	struct device *clsdev;
 	int minor;
 	int id;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/dvb/dvb-usb/cxusb.c linux-2.6.32.60-pax/drivers/media/dvb/dvb-usb/cxusb.c
--- linux-2.6.32.60/drivers/media/dvb/dvb-usb/cxusb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/dvb/dvb-usb/cxusb.c	2012-03-13 13:15:35.148097989 +0100
@@ -1040,7 +1040,7 @@ static struct dib0070_config dib7070p_di
 struct dib0700_adapter_state {
 	int (*set_param_save) (struct dvb_frontend *,
 			       struct dvb_frontend_parameters *);
-};
+} __no_const;
 
 static int dib7070_set_param_override(struct dvb_frontend *fe,
 				      struct dvb_frontend_parameters *fep)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/dvb/dvb-usb/dib0700_devices.c linux-2.6.32.60-pax/drivers/media/dvb/dvb-usb/dib0700_devices.c
--- linux-2.6.32.60/drivers/media/dvb/dvb-usb/dib0700_devices.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/dvb/dvb-usb/dib0700_devices.c	2012-03-13 13:15:35.152097989 +0100
@@ -28,7 +28,7 @@ MODULE_PARM_DESC(force_lna_activation, "
 
 struct dib0700_adapter_state {
 	int (*set_param_save) (struct dvb_frontend *, struct dvb_frontend_parameters *);
-};
+} __no_const;
 
 /* Hauppauge Nova-T 500 (aka Bristol)
  *  has a LNA on GPIO0 which is enabled by setting 1 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/dvb/frontends/dib3000.h linux-2.6.32.60-pax/drivers/media/dvb/frontends/dib3000.h
--- linux-2.6.32.60/drivers/media/dvb/frontends/dib3000.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/dvb/frontends/dib3000.h	2012-03-13 13:15:35.152097989 +0100
@@ -39,7 +39,7 @@ struct dib_fe_xfer_ops
 	int (*fifo_ctrl)(struct dvb_frontend *fe, int onoff);
 	int (*pid_ctrl)(struct dvb_frontend *fe, int index, int pid, int onoff);
 	int (*tuner_pass_ctrl)(struct dvb_frontend *fe, int onoff, u8 pll_ctrl);
-};
+} __no_const;
 
 #if defined(CONFIG_DVB_DIB3000MB) || (defined(CONFIG_DVB_DIB3000MB_MODULE) && defined(MODULE))
 extern struct dvb_frontend* dib3000mb_attach(const struct dib3000_config* config,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/radio/radio-cadet.c linux-2.6.32.60-pax/drivers/media/radio/radio-cadet.c
--- linux-2.6.32.60/drivers/media/radio/radio-cadet.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/radio/radio-cadet.c	2012-03-13 13:15:35.152097989 +0100
@@ -347,7 +347,7 @@ static ssize_t cadet_read(struct file *f
 	while (i < count && dev->rdsin != dev->rdsout)
 		readbuf[i++] = dev->rdsbuf[dev->rdsout++];
 
-	if (copy_to_user(data, readbuf, i))
+	if (i > sizeof readbuf || copy_to_user(data, readbuf, i))
 		return -EFAULT;
 	return i;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/cx18/cx18-driver.c linux-2.6.32.60-pax/drivers/media/video/cx18/cx18-driver.c
--- linux-2.6.32.60/drivers/media/video/cx18/cx18-driver.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/cx18/cx18-driver.c	2012-03-13 13:15:35.156097989 +0100
@@ -56,7 +56,7 @@ static struct pci_device_id cx18_pci_tbl
 
 MODULE_DEVICE_TABLE(pci, cx18_pci_tbl);
 
-static atomic_t cx18_instance = ATOMIC_INIT(0);
+static atomic_unchecked_t cx18_instance = ATOMIC_INIT(0);
 
 /* Parameter declarations */
 static int cardtype[CX18_MAX_CARDS];
@@ -800,7 +800,7 @@ static int __devinit cx18_probe(struct p
 	struct cx18 *cx;
 
 	/* FIXME - module parameter arrays constrain max instances */
-	i = atomic_inc_return(&cx18_instance) - 1;
+	i = atomic_inc_return_unchecked(&cx18_instance) - 1;
 	if (i >= CX18_MAX_CARDS) {
 		printk(KERN_ERR "cx18: cannot manage card %d, driver has a "
 		       "limit of 0 - %d\n", i, CX18_MAX_CARDS - 1);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/ivtv/ivtv-driver.c linux-2.6.32.60-pax/drivers/media/video/ivtv/ivtv-driver.c
--- linux-2.6.32.60/drivers/media/video/ivtv/ivtv-driver.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/ivtv/ivtv-driver.c	2012-03-13 13:15:35.156097989 +0100
@@ -79,7 +79,7 @@ static struct pci_device_id ivtv_pci_tbl
 MODULE_DEVICE_TABLE(pci,ivtv_pci_tbl);
 
 /* ivtv instance counter */
-static atomic_t ivtv_instance = ATOMIC_INIT(0);
+static atomic_unchecked_t ivtv_instance = ATOMIC_INIT(0);
 
 /* Parameter declarations */
 static int cardtype[IVTV_MAX_CARDS];
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/omap24xxcam.c linux-2.6.32.60-pax/drivers/media/video/omap24xxcam.c
--- linux-2.6.32.60/drivers/media/video/omap24xxcam.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/omap24xxcam.c	2012-03-13 13:15:35.156097989 +0100
@@ -401,7 +401,7 @@ static void omap24xxcam_vbq_complete(str
 	spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
 
 	do_gettimeofday(&vb->ts);
-	vb->field_count = atomic_add_return(2, &fh->field_count);
+	vb->field_count = atomic_add_return_unchecked(2, &fh->field_count);
 	if (csr & csr_error) {
 		vb->state = VIDEOBUF_ERROR;
 		if (!atomic_read(&fh->cam->in_reset)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/omap24xxcam.h linux-2.6.32.60-pax/drivers/media/video/omap24xxcam.h
--- linux-2.6.32.60/drivers/media/video/omap24xxcam.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/omap24xxcam.h	2012-03-13 13:15:35.156097989 +0100
@@ -533,7 +533,7 @@ struct omap24xxcam_fh {
 	spinlock_t vbq_lock; /* spinlock for the videobuf queue */
 	struct videobuf_queue vbq;
 	struct v4l2_pix_format pix; /* serialise pix by vbq->lock */
-	atomic_t field_count; /* field counter for videobuf_buffer */
+	atomic_unchecked_t field_count; /* field counter for videobuf_buffer */
 	/* accessing cam here doesn't need serialisation: it's constant */
 	struct omap24xxcam_device *cam;
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/usbvideo/ibmcam.c linux-2.6.32.60-pax/drivers/media/video/usbvideo/ibmcam.c
--- linux-2.6.32.60/drivers/media/video/usbvideo/ibmcam.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/usbvideo/ibmcam.c	2013-02-17 20:10:01.975611435 +0100
@@ -3947,7 +3947,7 @@ static struct usb_device_id id_table[] =
 static int __init ibmcam_init(void)
 {
 	struct usbvideo_cb cbTbl;
-	memset(&cbTbl, 0, sizeof(cbTbl));
+	memset((void *)&cbTbl, 0, sizeof(cbTbl));
 	cbTbl.probe = ibmcam_probe;
 	cbTbl.setupOnOpen = ibmcam_setup_on_open;
 	cbTbl.videoStart = ibmcam_video_start;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/usbvideo/konicawc.c linux-2.6.32.60-pax/drivers/media/video/usbvideo/konicawc.c
--- linux-2.6.32.60/drivers/media/video/usbvideo/konicawc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/usbvideo/konicawc.c	2013-02-17 20:09:43.387612428 +0100
@@ -225,7 +225,7 @@ static void konicawc_register_input(stru
 	int error;
 
 	usb_make_path(dev, cam->input_physname, sizeof(cam->input_physname));
-	strncat(cam->input_physname, "/input0", sizeof(cam->input_physname));
+	strlcat(cam->input_physname, "/input0", sizeof(cam->input_physname));
 
 	cam->input = input_dev = input_allocate_device();
 	if (!input_dev) {
@@ -935,7 +935,7 @@ static int __init konicawc_init(void)
 	struct usbvideo_cb cbTbl;
 	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
 	       DRIVER_DESC "\n");
-	memset(&cbTbl, 0, sizeof(cbTbl));
+	memset((void * )&cbTbl, 0, sizeof(cbTbl));
 	cbTbl.probe = konicawc_probe;
 	cbTbl.setupOnOpen = konicawc_setup_on_open;
 	cbTbl.processData = konicawc_process_isoc;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/usbvideo/quickcam_messenger.c linux-2.6.32.60-pax/drivers/media/video/usbvideo/quickcam_messenger.c
--- linux-2.6.32.60/drivers/media/video/usbvideo/quickcam_messenger.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/usbvideo/quickcam_messenger.c	2012-03-13 13:15:35.164097988 +0100
@@ -89,7 +89,7 @@ static void qcm_register_input(struct qc
 	int error;
 
 	usb_make_path(dev, cam->input_physname, sizeof(cam->input_physname));
-	strncat(cam->input_physname, "/input0", sizeof(cam->input_physname));
+	strlcat(cam->input_physname, "/input0", sizeof(cam->input_physname));
 
 	cam->input = input_dev = input_allocate_device();
 	if (!input_dev) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/usbvideo/usbvideo.c linux-2.6.32.60-pax/drivers/media/video/usbvideo/usbvideo.c
--- linux-2.6.32.60/drivers/media/video/usbvideo/usbvideo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/usbvideo/usbvideo.c	2013-02-17 20:06:01.587624270 +0100
@@ -697,7 +697,7 @@ int usbvideo_register(
 	    __func__, cams, base_size, num_cams);
 
 	/* Copy callbacks, apply defaults for those that are not set */
-	memmove(&cams->cb, cbTbl, sizeof(cams->cb));
+	memmove((void *)&cams->cb, cbTbl, sizeof(cams->cb));
 	if (cams->cb.getFrame == NULL)
 		cams->cb.getFrame = usbvideo_GetFrame;
 	if (cams->cb.disconnect == NULL)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/usbvideo/usbvideo.h linux-2.6.32.60-pax/drivers/media/video/usbvideo/usbvideo.h
--- linux-2.6.32.60/drivers/media/video/usbvideo/usbvideo.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/usbvideo/usbvideo.h	2012-03-13 13:15:35.168097988 +0100
@@ -268,7 +268,7 @@ struct usbvideo_cb {
 	int (*startDataPump)(struct uvd *uvd);
 	void (*stopDataPump)(struct uvd *uvd);
 	int (*setVideoMode)(struct uvd *uvd, struct video_window *vw);
-};
+} __no_const;
 
 struct usbvideo {
 	int num_cameras;		/* As allocated */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/media/video/v4l2-device.c linux-2.6.32.60-pax/drivers/media/video/v4l2-device.c
--- linux-2.6.32.60/drivers/media/video/v4l2-device.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/media/video/v4l2-device.c	2012-03-13 13:15:35.168097988 +0100
@@ -50,9 +50,9 @@ int v4l2_device_register(struct device *
 EXPORT_SYMBOL_GPL(v4l2_device_register);
 
 int v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,
-						atomic_t *instance)
+						atomic_unchecked_t *instance)
 {
-	int num = atomic_inc_return(instance) - 1;
+	int num = atomic_inc_return_unchecked(instance) - 1;
 	int len = strlen(basename);
 
 	if (basename[len - 1] >= '0' && basename[len - 1] <= '9')
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/message/fusion/mptsas.c linux-2.6.32.60-pax/drivers/message/fusion/mptsas.c
--- linux-2.6.32.60/drivers/message/fusion/mptsas.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/message/fusion/mptsas.c	2012-03-13 13:15:35.168097988 +0100
@@ -436,6 +436,23 @@ mptsas_is_end_device(struct mptsas_devin
 		return 0;
 }
 
+static inline void
+mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
+{
+	if (phy_info->port_details) {
+		phy_info->port_details->rphy = rphy;
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
+		    ioc->name, rphy));
+	}
+
+	if (rphy) {
+		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
+		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
+		    ioc->name, rphy, rphy->dev.release));
+	}
+}
+
 /* no mutex */
 static void
 mptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)
@@ -474,23 +491,6 @@ mptsas_get_rphy(struct mptsas_phyinfo *p
 		return NULL;
 }
 
-static inline void
-mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
-{
-	if (phy_info->port_details) {
-		phy_info->port_details->rphy = rphy;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
-		    ioc->name, rphy));
-	}
-
-	if (rphy) {
-		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
-		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
-		    ioc->name, rphy, rphy->dev.release));
-	}
-}
-
 static inline struct sas_port *
 mptsas_get_port(struct mptsas_phyinfo *phy_info)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/message/fusion/mptscsih.c linux-2.6.32.60-pax/drivers/message/fusion/mptscsih.c
--- linux-2.6.32.60/drivers/message/fusion/mptscsih.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/message/fusion/mptscsih.c	2012-03-13 13:15:35.172097988 +0100
@@ -1248,15 +1248,16 @@ mptscsih_info(struct Scsi_Host *SChost)
 
 	h = shost_priv(SChost);
 
-	if (h) {
-		if (h->info_kbuf == NULL)
-			if ((h->info_kbuf = kmalloc(0x1000 /* 4Kb */, GFP_KERNEL)) == NULL)
-				return h->info_kbuf;
-		h->info_kbuf[0] = '\0';
+	if (!h)
+		return NULL;
 
-		mpt_print_ioc_summary(h->ioc, h->info_kbuf, &size, 0, 0);
-		h->info_kbuf[size-1] = '\0';
-	}
+	if (h->info_kbuf == NULL)
+		if ((h->info_kbuf = kmalloc(0x1000 /* 4Kb */, GFP_KERNEL)) == NULL)
+			return h->info_kbuf;
+	h->info_kbuf[0] = '\0';
+
+	mpt_print_ioc_summary(h->ioc, h->info_kbuf, &size, 0, 0);
+	h->info_kbuf[size-1] = '\0';
 
 	return h->info_kbuf;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/message/i2o/i2o_proc.c linux-2.6.32.60-pax/drivers/message/i2o/i2o_proc.c
--- linux-2.6.32.60/drivers/message/i2o/i2o_proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/message/i2o/i2o_proc.c	2012-03-13 13:15:35.172097988 +0100
@@ -259,13 +259,6 @@ static char *scsi_devices[] = {
 	"Array Controller Device"
 };
 
-static char *chtostr(u8 * chars, int n)
-{
-	char tmp[256];
-	tmp[0] = 0;
-	return strncat(tmp, (char *)chars, n);
-}
-
 static int i2o_report_query_status(struct seq_file *seq, int block_status,
 				   char *group)
 {
@@ -842,8 +835,7 @@ static int i2o_seq_show_ddm_table(struct
 
 		seq_printf(seq, "%-#7x", ddm_table.i2o_vendor_id);
 		seq_printf(seq, "%-#8x", ddm_table.module_id);
-		seq_printf(seq, "%-29s",
-			   chtostr(ddm_table.module_name_version, 28));
+		seq_printf(seq, "%-.28s", ddm_table.module_name_version);
 		seq_printf(seq, "%9d  ", ddm_table.data_size);
 		seq_printf(seq, "%8d", ddm_table.code_size);
 
@@ -944,8 +936,8 @@ static int i2o_seq_show_drivers_stored(s
 
 		seq_printf(seq, "%-#7x", dst->i2o_vendor_id);
 		seq_printf(seq, "%-#8x", dst->module_id);
-		seq_printf(seq, "%-29s", chtostr(dst->module_name_version, 28));
-		seq_printf(seq, "%-9s", chtostr(dst->date, 8));
+		seq_printf(seq, "%-.28s", dst->module_name_version);
+		seq_printf(seq, "%-.8s", dst->date);
 		seq_printf(seq, "%8d ", dst->module_size);
 		seq_printf(seq, "%8d ", dst->mpb_size);
 		seq_printf(seq, "0x%04x", dst->module_flags);
@@ -1276,14 +1268,10 @@ static int i2o_seq_show_dev_identity(str
 	seq_printf(seq, "Device Class  : %s\n", i2o_get_class_name(work16[0]));
 	seq_printf(seq, "Owner TID     : %0#5x\n", work16[2]);
 	seq_printf(seq, "Parent TID    : %0#5x\n", work16[3]);
-	seq_printf(seq, "Vendor info   : %s\n",
-		   chtostr((u8 *) (work32 + 2), 16));
-	seq_printf(seq, "Product info  : %s\n",
-		   chtostr((u8 *) (work32 + 6), 16));
-	seq_printf(seq, "Description   : %s\n",
-		   chtostr((u8 *) (work32 + 10), 16));
-	seq_printf(seq, "Product rev.  : %s\n",
-		   chtostr((u8 *) (work32 + 14), 8));
+	seq_printf(seq, "Vendor info   : %.16s\n", (u8 *) (work32 + 2));
+	seq_printf(seq, "Product info  : %.16s\n", (u8 *) (work32 + 6));
+	seq_printf(seq, "Description   : %.16s\n", (u8 *) (work32 + 10));
+	seq_printf(seq, "Product rev.  : %.8s\n", (u8 *) (work32 + 14));
 
 	seq_printf(seq, "Serial number : ");
 	print_serial_number(seq, (u8 *) (work32 + 16),
@@ -1328,10 +1316,8 @@ static int i2o_seq_show_ddm_identity(str
 	}
 
 	seq_printf(seq, "Registering DDM TID : 0x%03x\n", result.ddm_tid);
-	seq_printf(seq, "Module name         : %s\n",
-		   chtostr(result.module_name, 24));
-	seq_printf(seq, "Module revision     : %s\n",
-		   chtostr(result.module_rev, 8));
+	seq_printf(seq, "Module name         : %.24s\n", result.module_name);
+	seq_printf(seq, "Module revision     : %.8s\n", result.module_rev);
 
 	seq_printf(seq, "Serial number       : ");
 	print_serial_number(seq, result.serial_number, sizeof(result) - 36);
@@ -1362,14 +1348,10 @@ static int i2o_seq_show_uinfo(struct seq
 		return 0;
 	}
 
-	seq_printf(seq, "Device name     : %s\n",
-		   chtostr(result.device_name, 64));
-	seq_printf(seq, "Service name    : %s\n",
-		   chtostr(result.service_name, 64));
-	seq_printf(seq, "Physical name   : %s\n",
-		   chtostr(result.physical_location, 64));
-	seq_printf(seq, "Instance number : %s\n",
-		   chtostr(result.instance_number, 4));
+	seq_printf(seq, "Device name     : %.64s\n", result.device_name);
+	seq_printf(seq, "Service name    : %.64s\n", result.service_name);
+	seq_printf(seq, "Physical name   : %.64s\n", result.physical_location);
+	seq_printf(seq, "Instance number : %.4s\n", result.instance_number);
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/message/i2o/iop.c linux-2.6.32.60-pax/drivers/message/i2o/iop.c
--- linux-2.6.32.60/drivers/message/i2o/iop.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/message/i2o/iop.c	2012-03-13 13:15:35.176097988 +0100
@@ -110,10 +110,10 @@ u32 i2o_cntxt_list_add(struct i2o_contro
 
 	spin_lock_irqsave(&c->context_list_lock, flags);
 
-	if (unlikely(atomic_inc_and_test(&c->context_list_counter)))
-		atomic_inc(&c->context_list_counter);
+	if (unlikely(atomic_inc_and_test_unchecked(&c->context_list_counter)))
+		atomic_inc_unchecked(&c->context_list_counter);
 
-	entry->context = atomic_read(&c->context_list_counter);
+	entry->context = atomic_read_unchecked(&c->context_list_counter);
 
 	list_add(&entry->list, &c->context_list);
 
@@ -1076,7 +1076,7 @@ struct i2o_controller *i2o_iop_alloc(voi
 
 #if BITS_PER_LONG == 64
 	spin_lock_init(&c->context_list_lock);
-	atomic_set(&c->context_list_counter, 0);
+	atomic_set_unchecked(&c->context_list_counter, 0);
 	INIT_LIST_HEAD(&c->context_list);
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/mfd/ab3100-core.c linux-2.6.32.60-pax/drivers/mfd/ab3100-core.c
--- linux-2.6.32.60/drivers/mfd/ab3100-core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/mfd/ab3100-core.c	2012-03-13 13:15:35.176097988 +0100
@@ -777,7 +777,7 @@ struct ab_family_id {
 	char	*name;
 };
 
-static const struct ab_family_id ids[] __initdata = {
+static const struct ab_family_id ids[] __initconst = {
 	/* AB3100 */
 	{
 		.id = 0xc0,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/kgdbts.c linux-2.6.32.60-pax/drivers/misc/kgdbts.c
--- linux-2.6.32.60/drivers/misc/kgdbts.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/kgdbts.c	2012-12-14 20:55:58.765797047 +0100
@@ -740,7 +740,7 @@ static void run_plant_and_detach_test(in
 	char before[BREAK_INSTR_SIZE];
 	char after[BREAK_INSTR_SIZE];
 
-	probe_kernel_read(before, (char *)kgdbts_break_test,
+	probe_kernel_read(before, ktla_ktva((char *)kgdbts_break_test),
 	  BREAK_INSTR_SIZE);
 	init_simple_test();
 	ts.tst = plant_and_detach_test;
@@ -748,7 +748,7 @@ static void run_plant_and_detach_test(in
 	/* Activate test with initial breakpoint */
 	if (!is_early)
 		kgdb_breakpoint();
-	probe_kernel_read(after, (char *)kgdbts_break_test,
+	probe_kernel_read(after, ktla_ktva((char *)kgdbts_break_test),
 	  BREAK_INSTR_SIZE);
 	if (memcmp(before, after, BREAK_INSTR_SIZE)) {
 		printk(KERN_CRIT "kgdbts: ERROR kgdb corrupted memory\n");
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-gru/gruhandles.c linux-2.6.32.60-pax/drivers/misc/sgi-gru/gruhandles.c
--- linux-2.6.32.60/drivers/misc/sgi-gru/gruhandles.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-gru/gruhandles.c	2012-03-13 13:15:35.176097988 +0100
@@ -39,8 +39,8 @@ struct mcs_op_statistic mcs_op_statistic
 
 static void update_mcs_stats(enum mcs_op op, unsigned long clks)
 {
-	atomic_long_inc(&mcs_op_statistics[op].count);
-	atomic_long_add(clks, &mcs_op_statistics[op].total);
+	atomic_long_inc_unchecked(&mcs_op_statistics[op].count);
+	atomic_long_add_unchecked(clks, &mcs_op_statistics[op].total);
 	if (mcs_op_statistics[op].max < clks)
 		mcs_op_statistics[op].max = clks;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-gru/gruprocfs.c linux-2.6.32.60-pax/drivers/misc/sgi-gru/gruprocfs.c
--- linux-2.6.32.60/drivers/misc/sgi-gru/gruprocfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-gru/gruprocfs.c	2012-03-13 13:15:35.180097987 +0100
@@ -32,9 +32,9 @@
 
 #define printstat(s, f)		printstat_val(s, &gru_stats.f, #f)
 
-static void printstat_val(struct seq_file *s, atomic_long_t *v, char *id)
+static void printstat_val(struct seq_file *s, atomic_long_unchecked_t *v, char *id)
 {
-	unsigned long val = atomic_long_read(v);
+	unsigned long val = atomic_long_read_unchecked(v);
 
 	if (val)
 		seq_printf(s, "%16lu %s\n", val, id);
@@ -136,8 +136,8 @@ static int mcs_statistics_show(struct se
 		"cch_interrupt_sync", "cch_deallocate", "tgh_invalidate"};
 
 	for (op = 0; op < mcsop_last; op++) {
-		count = atomic_long_read(&mcs_op_statistics[op].count);
-		total = atomic_long_read(&mcs_op_statistics[op].total);
+		count = atomic_long_read_unchecked(&mcs_op_statistics[op].count);
+		total = atomic_long_read_unchecked(&mcs_op_statistics[op].total);
 		max = mcs_op_statistics[op].max;
 		seq_printf(s, "%-20s%12ld%12ld%12ld\n", id[op], count,
 			   count ? total / count : 0, max);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-gru/grutables.h linux-2.6.32.60-pax/drivers/misc/sgi-gru/grutables.h
--- linux-2.6.32.60/drivers/misc/sgi-gru/grutables.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-gru/grutables.h	2012-03-13 13:15:35.180097987 +0100
@@ -167,84 +167,84 @@ extern unsigned int gru_max_gids;
  * GRU statistics.
  */
 struct gru_stats_s {
-	atomic_long_t vdata_alloc;
-	atomic_long_t vdata_free;
-	atomic_long_t gts_alloc;
-	atomic_long_t gts_free;
-	atomic_long_t vdata_double_alloc;
-	atomic_long_t gts_double_allocate;
-	atomic_long_t assign_context;
-	atomic_long_t assign_context_failed;
-	atomic_long_t free_context;
-	atomic_long_t load_user_context;
-	atomic_long_t load_kernel_context;
-	atomic_long_t lock_kernel_context;
-	atomic_long_t unlock_kernel_context;
-	atomic_long_t steal_user_context;
-	atomic_long_t steal_kernel_context;
-	atomic_long_t steal_context_failed;
-	atomic_long_t nopfn;
-	atomic_long_t break_cow;
-	atomic_long_t asid_new;
-	atomic_long_t asid_next;
-	atomic_long_t asid_wrap;
-	atomic_long_t asid_reuse;
-	atomic_long_t intr;
-	atomic_long_t intr_mm_lock_failed;
-	atomic_long_t call_os;
-	atomic_long_t call_os_offnode_reference;
-	atomic_long_t call_os_check_for_bug;
-	atomic_long_t call_os_wait_queue;
-	atomic_long_t user_flush_tlb;
-	atomic_long_t user_unload_context;
-	atomic_long_t user_exception;
-	atomic_long_t set_context_option;
-	atomic_long_t migrate_check;
-	atomic_long_t migrated_retarget;
-	atomic_long_t migrated_unload;
-	atomic_long_t migrated_unload_delay;
-	atomic_long_t migrated_nopfn_retarget;
-	atomic_long_t migrated_nopfn_unload;
-	atomic_long_t tlb_dropin;
-	atomic_long_t tlb_dropin_fail_no_asid;
-	atomic_long_t tlb_dropin_fail_upm;
-	atomic_long_t tlb_dropin_fail_invalid;
-	atomic_long_t tlb_dropin_fail_range_active;
-	atomic_long_t tlb_dropin_fail_idle;
-	atomic_long_t tlb_dropin_fail_fmm;
-	atomic_long_t tlb_dropin_fail_no_exception;
-	atomic_long_t tlb_dropin_fail_no_exception_war;
-	atomic_long_t tfh_stale_on_fault;
-	atomic_long_t mmu_invalidate_range;
-	atomic_long_t mmu_invalidate_page;
-	atomic_long_t mmu_clear_flush_young;
-	atomic_long_t flush_tlb;
-	atomic_long_t flush_tlb_gru;
-	atomic_long_t flush_tlb_gru_tgh;
-	atomic_long_t flush_tlb_gru_zero_asid;
-
-	atomic_long_t copy_gpa;
-
-	atomic_long_t mesq_receive;
-	atomic_long_t mesq_receive_none;
-	atomic_long_t mesq_send;
-	atomic_long_t mesq_send_failed;
-	atomic_long_t mesq_noop;
-	atomic_long_t mesq_send_unexpected_error;
-	atomic_long_t mesq_send_lb_overflow;
-	atomic_long_t mesq_send_qlimit_reached;
-	atomic_long_t mesq_send_amo_nacked;
-	atomic_long_t mesq_send_put_nacked;
-	atomic_long_t mesq_qf_not_full;
-	atomic_long_t mesq_qf_locked;
-	atomic_long_t mesq_qf_noop_not_full;
-	atomic_long_t mesq_qf_switch_head_failed;
-	atomic_long_t mesq_qf_unexpected_error;
-	atomic_long_t mesq_noop_unexpected_error;
-	atomic_long_t mesq_noop_lb_overflow;
-	atomic_long_t mesq_noop_qlimit_reached;
-	atomic_long_t mesq_noop_amo_nacked;
-	atomic_long_t mesq_noop_put_nacked;
+	atomic_long_unchecked_t vdata_alloc;
+	atomic_long_unchecked_t vdata_free;
+	atomic_long_unchecked_t gts_alloc;
+	atomic_long_unchecked_t gts_free;
+	atomic_long_unchecked_t vdata_double_alloc;
+	atomic_long_unchecked_t gts_double_allocate;
+	atomic_long_unchecked_t assign_context;
+	atomic_long_unchecked_t assign_context_failed;
+	atomic_long_unchecked_t free_context;
+	atomic_long_unchecked_t load_user_context;
+	atomic_long_unchecked_t load_kernel_context;
+	atomic_long_unchecked_t lock_kernel_context;
+	atomic_long_unchecked_t unlock_kernel_context;
+	atomic_long_unchecked_t steal_user_context;
+	atomic_long_unchecked_t steal_kernel_context;
+	atomic_long_unchecked_t steal_context_failed;
+	atomic_long_unchecked_t nopfn;
+	atomic_long_unchecked_t break_cow;
+	atomic_long_unchecked_t asid_new;
+	atomic_long_unchecked_t asid_next;
+	atomic_long_unchecked_t asid_wrap;
+	atomic_long_unchecked_t asid_reuse;
+	atomic_long_unchecked_t intr;
+	atomic_long_unchecked_t intr_mm_lock_failed;
+	atomic_long_unchecked_t call_os;
+	atomic_long_unchecked_t call_os_offnode_reference;
+	atomic_long_unchecked_t call_os_check_for_bug;
+	atomic_long_unchecked_t call_os_wait_queue;
+	atomic_long_unchecked_t user_flush_tlb;
+	atomic_long_unchecked_t user_unload_context;
+	atomic_long_unchecked_t user_exception;
+	atomic_long_unchecked_t set_context_option;
+	atomic_long_unchecked_t migrate_check;
+	atomic_long_unchecked_t migrated_retarget;
+	atomic_long_unchecked_t migrated_unload;
+	atomic_long_unchecked_t migrated_unload_delay;
+	atomic_long_unchecked_t migrated_nopfn_retarget;
+	atomic_long_unchecked_t migrated_nopfn_unload;
+	atomic_long_unchecked_t tlb_dropin;
+	atomic_long_unchecked_t tlb_dropin_fail_no_asid;
+	atomic_long_unchecked_t tlb_dropin_fail_upm;
+	atomic_long_unchecked_t tlb_dropin_fail_invalid;
+	atomic_long_unchecked_t tlb_dropin_fail_range_active;
+	atomic_long_unchecked_t tlb_dropin_fail_idle;
+	atomic_long_unchecked_t tlb_dropin_fail_fmm;
+	atomic_long_unchecked_t tlb_dropin_fail_no_exception;
+	atomic_long_unchecked_t tlb_dropin_fail_no_exception_war;
+	atomic_long_unchecked_t tfh_stale_on_fault;
+	atomic_long_unchecked_t mmu_invalidate_range;
+	atomic_long_unchecked_t mmu_invalidate_page;
+	atomic_long_unchecked_t mmu_clear_flush_young;
+	atomic_long_unchecked_t flush_tlb;
+	atomic_long_unchecked_t flush_tlb_gru;
+	atomic_long_unchecked_t flush_tlb_gru_tgh;
+	atomic_long_unchecked_t flush_tlb_gru_zero_asid;
+
+	atomic_long_unchecked_t copy_gpa;
+
+	atomic_long_unchecked_t mesq_receive;
+	atomic_long_unchecked_t mesq_receive_none;
+	atomic_long_unchecked_t mesq_send;
+	atomic_long_unchecked_t mesq_send_failed;
+	atomic_long_unchecked_t mesq_noop;
+	atomic_long_unchecked_t mesq_send_unexpected_error;
+	atomic_long_unchecked_t mesq_send_lb_overflow;
+	atomic_long_unchecked_t mesq_send_qlimit_reached;
+	atomic_long_unchecked_t mesq_send_amo_nacked;
+	atomic_long_unchecked_t mesq_send_put_nacked;
+	atomic_long_unchecked_t mesq_qf_not_full;
+	atomic_long_unchecked_t mesq_qf_locked;
+	atomic_long_unchecked_t mesq_qf_noop_not_full;
+	atomic_long_unchecked_t mesq_qf_switch_head_failed;
+	atomic_long_unchecked_t mesq_qf_unexpected_error;
+	atomic_long_unchecked_t mesq_noop_unexpected_error;
+	atomic_long_unchecked_t mesq_noop_lb_overflow;
+	atomic_long_unchecked_t mesq_noop_qlimit_reached;
+	atomic_long_unchecked_t mesq_noop_amo_nacked;
+	atomic_long_unchecked_t mesq_noop_put_nacked;
 
 };
 
@@ -252,8 +252,8 @@ enum mcs_op {cchop_allocate, cchop_start
 	cchop_deallocate, tghop_invalidate, mcsop_last};
 
 struct mcs_op_statistic {
-	atomic_long_t	count;
-	atomic_long_t	total;
+	atomic_long_unchecked_t	count;
+	atomic_long_unchecked_t	total;
 	unsigned long	max;
 };
 
@@ -276,7 +276,7 @@ extern struct mcs_op_statistic mcs_op_st
 
 #define STAT(id)	do {						\
 				if (gru_options & OPT_STATS)		\
-					atomic_long_inc(&gru_stats.id);	\
+					atomic_long_inc_unchecked(&gru_stats.id);	\
 			} while (0)
 
 #ifdef CONFIG_SGI_GRU_DEBUG
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-xp/xpc.h linux-2.6.32.60-pax/drivers/misc/sgi-xp/xpc.h
--- linux-2.6.32.60/drivers/misc/sgi-xp/xpc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-xp/xpc.h	2012-03-13 13:15:35.180097987 +0100
@@ -835,6 +835,7 @@ struct xpc_arch_operations {
 	void (*received_payload) (struct xpc_channel *, void *);
 	void (*notify_senders_of_disconnect) (struct xpc_channel *);
 };
+typedef struct xpc_arch_operations __no_const xpc_arch_operations_no_const;
 
 /* struct xpc_partition act_state values (for XPC HB) */
 
@@ -876,7 +877,7 @@ extern struct xpc_registration xpc_regis
 /* found in xpc_main.c */
 extern struct device *xpc_part;
 extern struct device *xpc_chan;
-extern struct xpc_arch_operations xpc_arch_ops;
+extern xpc_arch_operations_no_const xpc_arch_ops;
 extern int xpc_disengage_timelimit;
 extern int xpc_disengage_timedout;
 extern int xpc_activate_IRQ_rcvd;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-xp/xpc_main.c linux-2.6.32.60-pax/drivers/misc/sgi-xp/xpc_main.c
--- linux-2.6.32.60/drivers/misc/sgi-xp/xpc_main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-xp/xpc_main.c	2012-03-13 13:15:35.180097987 +0100
@@ -169,7 +169,7 @@ static struct notifier_block xpc_die_not
 	.notifier_call = xpc_system_die,
 };
 
-struct xpc_arch_operations xpc_arch_ops;
+xpc_arch_operations_no_const xpc_arch_ops;
 
 /*
  * Timer function to enforce the timelimit on the partition disengage.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/misc/sgi-xp/xp.h linux-2.6.32.60-pax/drivers/misc/sgi-xp/xp.h
--- linux-2.6.32.60/drivers/misc/sgi-xp/xp.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/misc/sgi-xp/xp.h	2012-03-13 13:15:35.184097987 +0100
@@ -289,7 +289,7 @@ struct xpc_interface {
 					xpc_notify_func, void *);
 	void (*received) (short, int, void *);
 	enum xp_retval (*partid_to_nasids) (short, void *);
-};
+} __no_const;
 
 extern struct xpc_interface xpc_interface;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/mmc/host/sdhci-pci.c linux-2.6.32.60-pax/drivers/mmc/host/sdhci-pci.c
--- linux-2.6.32.60/drivers/mmc/host/sdhci-pci.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/mmc/host/sdhci-pci.c	2012-03-13 13:15:35.184097987 +0100
@@ -297,7 +297,7 @@ static const struct sdhci_pci_fixes sdhc
 	.probe		= via_probe,
 };
 
-static const struct pci_device_id pci_ids[] __devinitdata = {
+static const struct pci_device_id pci_ids[] __devinitconst = {
 	{
 		.vendor		= PCI_VENDOR_ID_RICOH,
 		.device		= PCI_DEVICE_ID_RICOH_R5C822,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/mtd/devices/doc2000.c linux-2.6.32.60-pax/drivers/mtd/devices/doc2000.c
--- linux-2.6.32.60/drivers/mtd/devices/doc2000.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/mtd/devices/doc2000.c	2012-03-13 13:15:35.184097987 +0100
@@ -776,7 +776,7 @@ static int doc_write(struct mtd_info *mt
 
 		/* The ECC will not be calculated correctly if less than 512 is written */
 /* DBB-
-		if (len != 0x200 && eccbuf)
+		if (len != 0x200)
 			printk(KERN_WARNING
 			       "ECC needs a full sector write (adr: %lx size %lx)\n",
 			       (long) to, (long) len);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/mtd/devices/doc2001.c linux-2.6.32.60-pax/drivers/mtd/devices/doc2001.c
--- linux-2.6.32.60/drivers/mtd/devices/doc2001.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/mtd/devices/doc2001.c	2012-03-13 13:15:35.184097987 +0100
@@ -393,7 +393,7 @@ static int doc_read (struct mtd_info *mt
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 
 	/* Don't allow read past end of device */
-	if (from >= this->totlen)
+	if (from >= this->totlen || !len)
 		return -EINVAL;
 
 	/* Don't allow a single read to cross a 512-byte block boundary */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/mtd/nftlmount.c linux-2.6.32.60-pax/drivers/mtd/nftlmount.c
--- linux-2.6.32.60/drivers/mtd/nftlmount.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/mtd/nftlmount.c	2012-03-13 13:15:35.188097987 +0100
@@ -23,6 +23,7 @@
 #include <asm/errno.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/nftl.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/atlx/atl2.c linux-2.6.32.60-pax/drivers/net/atlx/atl2.c
--- linux-2.6.32.60/drivers/net/atlx/atl2.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/atlx/atl2.c	2012-03-13 13:15:35.188097987 +0100
@@ -2845,7 +2845,7 @@ static void atl2_force_ps(struct atl2_hw
  */
 
 #define ATL2_PARAM(X, desc) \
-    static const int __devinitdata X[ATL2_MAX_NIC + 1] = ATL2_PARAM_INIT; \
+    static const int __devinitconst X[ATL2_MAX_NIC + 1] = ATL2_PARAM_INIT; \
     MODULE_PARM(X, "1-" __MODULE_STRING(ATL2_MAX_NIC) "i"); \
     MODULE_PARM_DESC(X, desc);
 #else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/cxgb3/l2t.h linux-2.6.32.60-pax/drivers/net/cxgb3/l2t.h
--- linux-2.6.32.60/drivers/net/cxgb3/l2t.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/cxgb3/l2t.h	2012-03-13 13:15:35.192097987 +0100
@@ -86,7 +86,7 @@ typedef void (*arp_failure_handler_func)
  */
 struct l2t_skb_cb {
 	arp_failure_handler_func arp_failure_handler;
-};
+} __no_const;
 
 #define L2T_SKB_CB(skb) ((struct l2t_skb_cb *)(skb)->cb)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/e1000e/82571.c linux-2.6.32.60-pax/drivers/net/e1000e/82571.c
--- linux-2.6.32.60/drivers/net/e1000e/82571.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/e1000e/82571.c	2013-01-23 00:13:09.895278959 +0100
@@ -212,7 +212,6 @@ static s32 e1000_init_mac_params_82571(s
 {
 	struct e1000_hw *hw = &adapter->hw;
 	struct e1000_mac_info *mac = &hw->mac;
-	struct e1000_mac_operations *func = &mac->ops;
 	u32 swsm = 0;
 	u32 swsm2 = 0;
 	bool force_clear_smbi = false;
@@ -245,22 +244,22 @@ static s32 e1000_init_mac_params_82571(s
 	/* check for link */
 	switch (hw->phy.media_type) {
 	case e1000_media_type_copper:
-		func->setup_physical_interface = e1000_setup_copper_link_82571;
-		func->check_for_link = e1000e_check_for_copper_link;
-		func->get_link_up_info = e1000e_get_speed_and_duplex_copper;
+		mac->ops.setup_physical_interface = e1000_setup_copper_link_82571;
+		mac->ops.check_for_link = e1000e_check_for_copper_link;
+		mac->ops.get_link_up_info = e1000e_get_speed_and_duplex_copper;
 		break;
 	case e1000_media_type_fiber:
-		func->setup_physical_interface =
+		mac->ops.setup_physical_interface =
 			e1000_setup_fiber_serdes_link_82571;
-		func->check_for_link = e1000e_check_for_fiber_link;
-		func->get_link_up_info =
+		mac->ops.check_for_link = e1000e_check_for_fiber_link;
+		mac->ops.get_link_up_info =
 			e1000e_get_speed_and_duplex_fiber_serdes;
 		break;
 	case e1000_media_type_internal_serdes:
-		func->setup_physical_interface =
+		mac->ops.setup_physical_interface =
 			e1000_setup_fiber_serdes_link_82571;
-		func->check_for_link = e1000_check_for_serdes_link_82571;
-		func->get_link_up_info =
+		mac->ops.check_for_link = e1000_check_for_serdes_link_82571;
+		mac->ops.get_link_up_info =
 			e1000e_get_speed_and_duplex_fiber_serdes;
 		break;
 	default:
@@ -271,12 +270,12 @@ static s32 e1000_init_mac_params_82571(s
 	switch (hw->mac.type) {
 	case e1000_82574:
 	case e1000_82583:
-		func->check_mng_mode = e1000_check_mng_mode_82574;
-		func->led_on = e1000_led_on_82574;
+		mac->ops.check_mng_mode = e1000_check_mng_mode_82574;
+		mac->ops.led_on = e1000_led_on_82574;
 		break;
 	default:
-		func->check_mng_mode = e1000e_check_mng_mode_generic;
-		func->led_on = e1000e_led_on_generic;
+		mac->ops.check_mng_mode = e1000e_check_mng_mode_generic;
+		mac->ops.led_on = e1000e_led_on_generic;
 		break;
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/e1000e/es2lan.c linux-2.6.32.60-pax/drivers/net/e1000e/es2lan.c
--- linux-2.6.32.60/drivers/net/e1000e/es2lan.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/e1000e/es2lan.c	2013-01-23 01:08:10.207102748 +0100
@@ -207,7 +207,6 @@ static s32 e1000_init_mac_params_80003es
 {
 	struct e1000_hw *hw = &adapter->hw;
 	struct e1000_mac_info *mac = &hw->mac;
-	struct e1000_mac_operations *func = &mac->ops;
 
 	/* Set media type */
 	switch (adapter->pdev->device) {
@@ -229,16 +228,16 @@ static s32 e1000_init_mac_params_80003es
 	/* check for link */
 	switch (hw->phy.media_type) {
 	case e1000_media_type_copper:
-		func->setup_physical_interface = e1000_setup_copper_link_80003es2lan;
-		func->check_for_link = e1000e_check_for_copper_link;
+		mac->ops.setup_physical_interface = e1000_setup_copper_link_80003es2lan;
+		mac->ops.check_for_link = e1000e_check_for_copper_link;
 		break;
 	case e1000_media_type_fiber:
-		func->setup_physical_interface = e1000e_setup_fiber_serdes_link;
-		func->check_for_link = e1000e_check_for_fiber_link;
+		mac->ops.setup_physical_interface = e1000e_setup_fiber_serdes_link;
+		mac->ops.check_for_link = e1000e_check_for_fiber_link;
 		break;
 	case e1000_media_type_internal_serdes:
-		func->setup_physical_interface = e1000e_setup_fiber_serdes_link;
-		func->check_for_link = e1000e_check_for_serdes_link;
+		mac->ops.setup_physical_interface = e1000e_setup_fiber_serdes_link;
+		mac->ops.check_for_link = e1000e_check_for_serdes_link;
 		break;
 	default:
 		return -E1000_ERR_CONFIG;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/fealnx.c linux-2.6.32.60-pax/drivers/net/fealnx.c
--- linux-2.6.32.60/drivers/net/fealnx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/fealnx.c	2012-03-13 13:15:35.196097987 +0100
@@ -151,7 +151,7 @@ struct chip_info {
 	int flags;
 };
 
-static const struct chip_info skel_netdrv_tbl[] __devinitdata = {
+static const struct chip_info skel_netdrv_tbl[] __devinitconst = {
  	{ "100/10M Ethernet PCI Adapter",	HAS_MII_XCVR },
 	{ "100/10M Ethernet PCI Adapter",	HAS_CHIP_XCVR },
 	{ "1000/100/10M Ethernet PCI Adapter",	HAS_MII_XCVR },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/macvlan.c linux-2.6.32.60-pax/drivers/net/macvlan.c
--- linux-2.6.32.60/drivers/net/macvlan.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/macvlan.c	2013-01-23 01:23:28.843053700 +0100
@@ -568,7 +568,7 @@ static void macvlan_dellink(struct net_d
 		macvlan_port_destroy(port->dev);
 }
 
-static struct rtnl_link_ops macvlan_link_ops __read_mostly = {
+static struct rtnl_link_ops macvlan_link_ops = {
 	.kind		= "macvlan",
 	.priv_size	= sizeof(struct macvlan_dev),
 	.get_tx_queues  = macvlan_get_tx_queues,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/mlx4/eq.c linux-2.6.32.60-pax/drivers/net/mlx4/eq.c
--- linux-2.6.32.60/drivers/net/mlx4/eq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/mlx4/eq.c	2013-02-17 18:23:59.243951156 +0100
@@ -552,8 +552,7 @@ int mlx4_init_eq_table(struct mlx4_dev *
 	int err;
 	int i;
 
-	priv->eq_table.uar_map = kcalloc(sizeof *priv->eq_table.uar_map,
-					 mlx4_num_eq_uar(dev), GFP_KERNEL);
+	priv->eq_table.uar_map = kcalloc(mlx4_num_eq_uar(dev), sizeof *priv->eq_table.uar_map, GFP_KERNEL);
 	if (!priv->eq_table.uar_map) {
 		err = -ENOMEM;
 		goto err_out_free;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/mlx4/main.c linux-2.6.32.60-pax/drivers/net/mlx4/main.c
--- linux-2.6.32.60/drivers/net/mlx4/main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/mlx4/main.c	2012-03-13 13:15:35.200097986 +0100
@@ -38,6 +38,7 @@
 #include <linux/errno.h>
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
+#include <linux/sched.h>
 
 #include <linux/mlx4/device.h>
 #include <linux/mlx4/doorbell.h>
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/pcnet32.c linux-2.6.32.60-pax/drivers/net/pcnet32.c
--- linux-2.6.32.60/drivers/net/pcnet32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/pcnet32.c	2012-03-13 13:15:35.204097986 +0100
@@ -79,7 +79,7 @@ static int cards_found;
 /*
  * VLB I/O addresses
  */
-static unsigned int pcnet32_portlist[] __initdata =
+static unsigned int pcnet32_portlist[] __devinitdata =
     { 0x300, 0x320, 0x340, 0x360, 0 };
 
 static int pcnet32_debug = 0;
@@ -267,7 +267,7 @@ struct pcnet32_private {
 	struct sk_buff		**rx_skbuff;
 	dma_addr_t		*tx_dma_addr;
 	dma_addr_t		*rx_dma_addr;
-	struct pcnet32_access	a;
+	struct pcnet32_access	*a;
 	spinlock_t		lock;		/* Guard lock */
 	unsigned int		cur_rx, cur_tx;	/* The next free ring entry */
 	unsigned int		rx_ring_size;	/* current rx ring size */
@@ -457,9 +457,9 @@ static void pcnet32_netif_start(struct n
 	u16 val;
 
 	netif_wake_queue(dev);
-	val = lp->a.read_csr(ioaddr, CSR3);
+	val = lp->a->read_csr(ioaddr, CSR3);
 	val &= 0x00ff;
-	lp->a.write_csr(ioaddr, CSR3, val);
+	lp->a->write_csr(ioaddr, CSR3, val);
 	napi_enable(&lp->napi);
 }
 
@@ -744,7 +744,7 @@ static u32 pcnet32_get_link(struct net_d
 		r = mii_link_ok(&lp->mii_if);
 	} else if (lp->chip_version >= PCNET32_79C970A) {
 		ulong ioaddr = dev->base_addr;	/* card base I/O address */
-		r = (lp->a.read_bcr(ioaddr, 4) != 0xc0);
+		r = (lp->a->read_bcr(ioaddr, 4) != 0xc0);
 	} else {	/* can not detect link on really old chips */
 		r = 1;
 	}
@@ -806,7 +806,7 @@ static int pcnet32_set_ringparam(struct
 		pcnet32_netif_stop(dev);
 
 	spin_lock_irqsave(&lp->lock, flags);
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);	/* stop the chip */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);	/* stop the chip */
 
 	size = min(ering->tx_pending, (unsigned int)TX_MAX_RING_SIZE);
 
@@ -886,7 +886,7 @@ static void pcnet32_ethtool_test(struct
 static int pcnet32_loopback_test(struct net_device *dev, uint64_t * data1)
 {
 	struct pcnet32_private *lp = netdev_priv(dev);
-	struct pcnet32_access *a = &lp->a;	/* access to registers */
+	struct pcnet32_access *a = lp->a;	/* access to registers */
 	ulong ioaddr = dev->base_addr;	/* card base I/O address */
 	struct sk_buff *skb;	/* sk buff */
 	int x, i;		/* counters */
@@ -906,21 +906,21 @@ static int pcnet32_loopback_test(struct
 		pcnet32_netif_stop(dev);
 
 	spin_lock_irqsave(&lp->lock, flags);
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);	/* stop the chip */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);	/* stop the chip */
 
 	numbuffs = min(numbuffs, (int)min(lp->rx_ring_size, lp->tx_ring_size));
 
 	/* Reset the PCNET32 */
-	lp->a.reset(ioaddr);
-	lp->a.write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
+	lp->a->reset(ioaddr);
+	lp->a->write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
 
 	/* switch pcnet32 to 32bit mode */
-	lp->a.write_bcr(ioaddr, 20, 2);
+	lp->a->write_bcr(ioaddr, 20, 2);
 
 	/* purge & init rings but don't actually restart */
 	pcnet32_restart(dev, 0x0000);
 
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);	/* Set STOP bit */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);	/* Set STOP bit */
 
 	/* Initialize Transmit buffers. */
 	size = data_len + 15;
@@ -966,10 +966,10 @@ static int pcnet32_loopback_test(struct
 
 	/* set int loopback in CSR15 */
 	x = a->read_csr(ioaddr, CSR15) & 0xfffc;
-	lp->a.write_csr(ioaddr, CSR15, x | 0x0044);
+	lp->a->write_csr(ioaddr, CSR15, x | 0x0044);
 
 	teststatus = cpu_to_le16(0x8000);
-	lp->a.write_csr(ioaddr, CSR0, CSR0_START);	/* Set STRT bit */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_START);	/* Set STRT bit */
 
 	/* Check status of descriptors */
 	for (x = 0; x < numbuffs; x++) {
@@ -990,7 +990,7 @@ static int pcnet32_loopback_test(struct
 		}
 	}
 
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);	/* Set STOP bit */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);	/* Set STOP bit */
 	wmb();
 	if (netif_msg_hw(lp) && netif_msg_pktdata(lp)) {
 		printk(KERN_DEBUG "%s: RX loopback packets:\n", dev->name);
@@ -1039,7 +1039,7 @@ static int pcnet32_loopback_test(struct
 		pcnet32_restart(dev, CSR0_NORMAL);
 	} else {
 		pcnet32_purge_rx_ring(dev);
-		lp->a.write_bcr(ioaddr, 20, 4);	/* return to 16bit mode */
+		lp->a->write_bcr(ioaddr, 20, 4);	/* return to 16bit mode */
 	}
 	spin_unlock_irqrestore(&lp->lock, flags);
 
@@ -1049,7 +1049,7 @@ static int pcnet32_loopback_test(struct
 static void pcnet32_led_blink_callback(struct net_device *dev)
 {
 	struct pcnet32_private *lp = netdev_priv(dev);
-	struct pcnet32_access *a = &lp->a;
+	struct pcnet32_access *a = lp->a;
 	ulong ioaddr = dev->base_addr;
 	unsigned long flags;
 	int i;
@@ -1066,7 +1066,7 @@ static void pcnet32_led_blink_callback(s
 static int pcnet32_phys_id(struct net_device *dev, u32 data)
 {
 	struct pcnet32_private *lp = netdev_priv(dev);
-	struct pcnet32_access *a = &lp->a;
+	struct pcnet32_access *a = lp->a;
 	ulong ioaddr = dev->base_addr;
 	unsigned long flags;
 	int i, regs[4];
@@ -1112,7 +1112,7 @@ static int pcnet32_suspend(struct net_de
 {
 	int csr5;
 	struct pcnet32_private *lp = netdev_priv(dev);
-	struct pcnet32_access *a = &lp->a;
+	struct pcnet32_access *a = lp->a;
 	ulong ioaddr = dev->base_addr;
 	int ticks;
 
@@ -1388,8 +1388,8 @@ static int pcnet32_poll(struct napi_stru
 	spin_lock_irqsave(&lp->lock, flags);
 	if (pcnet32_tx(dev)) {
 		/* reset the chip to clear the error condition, then restart */
-		lp->a.reset(ioaddr);
-		lp->a.write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
+		lp->a->reset(ioaddr);
+		lp->a->write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
 		pcnet32_restart(dev, CSR0_START);
 		netif_wake_queue(dev);
 	}
@@ -1401,12 +1401,12 @@ static int pcnet32_poll(struct napi_stru
 		__napi_complete(napi);
 
 		/* clear interrupt masks */
-		val = lp->a.read_csr(ioaddr, CSR3);
+		val = lp->a->read_csr(ioaddr, CSR3);
 		val &= 0x00ff;
-		lp->a.write_csr(ioaddr, CSR3, val);
+		lp->a->write_csr(ioaddr, CSR3, val);
 
 		/* Set interrupt enable. */
-		lp->a.write_csr(ioaddr, CSR0, CSR0_INTEN);
+		lp->a->write_csr(ioaddr, CSR0, CSR0_INTEN);
 
 		spin_unlock_irqrestore(&lp->lock, flags);
 	}
@@ -1429,7 +1429,7 @@ static void pcnet32_get_regs(struct net_
 	int i, csr0;
 	u16 *buff = ptr;
 	struct pcnet32_private *lp = netdev_priv(dev);
-	struct pcnet32_access *a = &lp->a;
+	struct pcnet32_access *a = lp->a;
 	ulong ioaddr = dev->base_addr;
 	unsigned long flags;
 
@@ -1466,9 +1466,9 @@ static void pcnet32_get_regs(struct net_
 		for (j = 0; j < PCNET32_MAX_PHYS; j++) {
 			if (lp->phymask & (1 << j)) {
 				for (i = 0; i < PCNET32_REGS_PER_PHY; i++) {
-					lp->a.write_bcr(ioaddr, 33,
+					lp->a->write_bcr(ioaddr, 33,
 							(j << 5) | i);
-					*buff++ = lp->a.read_bcr(ioaddr, 34);
+					*buff++ = lp->a->read_bcr(ioaddr, 34);
 				}
 			}
 		}
@@ -1858,7 +1858,7 @@ pcnet32_probe1(unsigned long ioaddr, int
 	    ((cards_found >= MAX_UNITS) || full_duplex[cards_found]))
 		lp->options |= PCNET32_PORT_FD;
 
-	lp->a = *a;
+	lp->a = a;
 
 	/* prior to register_netdev, dev->name is not yet correct */
 	if (pcnet32_alloc_ring(dev, pci_name(lp->pci_dev))) {
@@ -1917,7 +1917,7 @@ pcnet32_probe1(unsigned long ioaddr, int
 	if (lp->mii) {
 		/* lp->phycount and lp->phymask are set to 0 by memset above */
 
-		lp->mii_if.phy_id = ((lp->a.read_bcr(ioaddr, 33)) >> 5) & 0x1f;
+		lp->mii_if.phy_id = ((lp->a->read_bcr(ioaddr, 33)) >> 5) & 0x1f;
 		/* scan for PHYs */
 		for (i = 0; i < PCNET32_MAX_PHYS; i++) {
 			unsigned short id1, id2;
@@ -1938,7 +1938,7 @@ pcnet32_probe1(unsigned long ioaddr, int
 				       "Found PHY %04x:%04x at address %d.\n",
 				       id1, id2, i);
 		}
-		lp->a.write_bcr(ioaddr, 33, (lp->mii_if.phy_id) << 5);
+		lp->a->write_bcr(ioaddr, 33, (lp->mii_if.phy_id) << 5);
 		if (lp->phycount > 1) {
 			lp->options |= PCNET32_PORT_MII;
 		}
@@ -2109,10 +2109,10 @@ static int pcnet32_open(struct net_devic
 	}
 
 	/* Reset the PCNET32 */
-	lp->a.reset(ioaddr);
+	lp->a->reset(ioaddr);
 
 	/* switch pcnet32 to 32bit mode */
-	lp->a.write_bcr(ioaddr, 20, 2);
+	lp->a->write_bcr(ioaddr, 20, 2);
 
 	if (netif_msg_ifup(lp))
 		printk(KERN_DEBUG
@@ -2122,14 +2122,14 @@ static int pcnet32_open(struct net_devic
 		       (u32) (lp->init_dma_addr));
 
 	/* set/reset autoselect bit */
-	val = lp->a.read_bcr(ioaddr, 2) & ~2;
+	val = lp->a->read_bcr(ioaddr, 2) & ~2;
 	if (lp->options & PCNET32_PORT_ASEL)
 		val |= 2;
-	lp->a.write_bcr(ioaddr, 2, val);
+	lp->a->write_bcr(ioaddr, 2, val);
 
 	/* handle full duplex setting */
 	if (lp->mii_if.full_duplex) {
-		val = lp->a.read_bcr(ioaddr, 9) & ~3;
+		val = lp->a->read_bcr(ioaddr, 9) & ~3;
 		if (lp->options & PCNET32_PORT_FD) {
 			val |= 1;
 			if (lp->options == (PCNET32_PORT_FD | PCNET32_PORT_AUI))
@@ -2139,14 +2139,14 @@ static int pcnet32_open(struct net_devic
 			if (lp->chip_version == 0x2627)
 				val |= 3;
 		}
-		lp->a.write_bcr(ioaddr, 9, val);
+		lp->a->write_bcr(ioaddr, 9, val);
 	}
 
 	/* set/reset GPSI bit in test register */
-	val = lp->a.read_csr(ioaddr, 124) & ~0x10;
+	val = lp->a->read_csr(ioaddr, 124) & ~0x10;
 	if ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)
 		val |= 0x10;
-	lp->a.write_csr(ioaddr, 124, val);
+	lp->a->write_csr(ioaddr, 124, val);
 
 	/* Allied Telesyn AT 2700/2701 FX are 100Mbit only and do not negotiate */
 	if (pdev && pdev->subsystem_vendor == PCI_VENDOR_ID_AT &&
@@ -2167,24 +2167,24 @@ static int pcnet32_open(struct net_devic
 		 * duplex, and/or enable auto negotiation, and clear DANAS
 		 */
 		if (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {
-			lp->a.write_bcr(ioaddr, 32,
-					lp->a.read_bcr(ioaddr, 32) | 0x0080);
+			lp->a->write_bcr(ioaddr, 32,
+					lp->a->read_bcr(ioaddr, 32) | 0x0080);
 			/* disable Auto Negotiation, set 10Mpbs, HD */
-			val = lp->a.read_bcr(ioaddr, 32) & ~0xb8;
+			val = lp->a->read_bcr(ioaddr, 32) & ~0xb8;
 			if (lp->options & PCNET32_PORT_FD)
 				val |= 0x10;
 			if (lp->options & PCNET32_PORT_100)
 				val |= 0x08;
-			lp->a.write_bcr(ioaddr, 32, val);
+			lp->a->write_bcr(ioaddr, 32, val);
 		} else {
 			if (lp->options & PCNET32_PORT_ASEL) {
-				lp->a.write_bcr(ioaddr, 32,
-						lp->a.read_bcr(ioaddr,
+				lp->a->write_bcr(ioaddr, 32,
+						lp->a->read_bcr(ioaddr,
 							       32) | 0x0080);
 				/* enable auto negotiate, setup, disable fd */
-				val = lp->a.read_bcr(ioaddr, 32) & ~0x98;
+				val = lp->a->read_bcr(ioaddr, 32) & ~0x98;
 				val |= 0x20;
-				lp->a.write_bcr(ioaddr, 32, val);
+				lp->a->write_bcr(ioaddr, 32, val);
 			}
 		}
 	} else {
@@ -2197,10 +2197,10 @@ static int pcnet32_open(struct net_devic
 		 * There is really no good other way to handle multiple PHYs
 		 * other than turning off all automatics
 		 */
-		val = lp->a.read_bcr(ioaddr, 2);
-		lp->a.write_bcr(ioaddr, 2, val & ~2);
-		val = lp->a.read_bcr(ioaddr, 32);
-		lp->a.write_bcr(ioaddr, 32, val & ~(1 << 7));	/* stop MII manager */
+		val = lp->a->read_bcr(ioaddr, 2);
+		lp->a->write_bcr(ioaddr, 2, val & ~2);
+		val = lp->a->read_bcr(ioaddr, 32);
+		lp->a->write_bcr(ioaddr, 32, val & ~(1 << 7));	/* stop MII manager */
 
 		if (!(lp->options & PCNET32_PORT_ASEL)) {
 			/* setup ecmd */
@@ -2210,7 +2210,7 @@ static int pcnet32_open(struct net_devic
 			ecmd.speed =
 			    lp->
 			    options & PCNET32_PORT_100 ? SPEED_100 : SPEED_10;
-			bcr9 = lp->a.read_bcr(ioaddr, 9);
+			bcr9 = lp->a->read_bcr(ioaddr, 9);
 
 			if (lp->options & PCNET32_PORT_FD) {
 				ecmd.duplex = DUPLEX_FULL;
@@ -2219,7 +2219,7 @@ static int pcnet32_open(struct net_devic
 				ecmd.duplex = DUPLEX_HALF;
 				bcr9 |= ~(1 << 0);
 			}
-			lp->a.write_bcr(ioaddr, 9, bcr9);
+			lp->a->write_bcr(ioaddr, 9, bcr9);
 		}
 
 		for (i = 0; i < PCNET32_MAX_PHYS; i++) {
@@ -2252,9 +2252,9 @@ static int pcnet32_open(struct net_devic
 
 #ifdef DO_DXSUFLO
 	if (lp->dxsuflo) {	/* Disable transmit stop on underflow */
-		val = lp->a.read_csr(ioaddr, CSR3);
+		val = lp->a->read_csr(ioaddr, CSR3);
 		val |= 0x40;
-		lp->a.write_csr(ioaddr, CSR3, val);
+		lp->a->write_csr(ioaddr, CSR3, val);
 	}
 #endif
 
@@ -2270,11 +2270,11 @@ static int pcnet32_open(struct net_devic
 	napi_enable(&lp->napi);
 
 	/* Re-initialize the PCNET32, and start it when done. */
-	lp->a.write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));
-	lp->a.write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));
+	lp->a->write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));
+	lp->a->write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));
 
-	lp->a.write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
-	lp->a.write_csr(ioaddr, CSR0, CSR0_INIT);
+	lp->a->write_csr(ioaddr, CSR4, 0x0915);	/* auto tx pad */
+	lp->a->write_csr(ioaddr, CSR0, CSR0_INIT);
 
 	netif_start_queue(dev);
 
@@ -2286,20 +2286,20 @@ static int pcnet32_open(struct net_devic
 
 	i = 0;
 	while (i++ < 100)
-		if (lp->a.read_csr(ioaddr, CSR0) & CSR0_IDON)
+		if (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)
 			break;
 	/*
 	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton
 	 * reports that doing so triggers a bug in the '974.
 	 */
-	lp->a.write_csr(ioaddr, CSR0, CSR0_NORMAL);
+	lp->a->write_csr(ioaddr, CSR0, CSR0_NORMAL);
 
 	if (netif_msg_ifup(lp))
 		printk(KERN_DEBUG
 		       "%s: pcnet32 open after %d ticks, init block %#x csr0 %4.4x.\n",
 		       dev->name, i,
 		       (u32) (lp->init_dma_addr),
-		       lp->a.read_csr(ioaddr, CSR0));
+		       lp->a->read_csr(ioaddr, CSR0));
 
 	spin_unlock_irqrestore(&lp->lock, flags);
 
@@ -2313,7 +2313,7 @@ static int pcnet32_open(struct net_devic
 	 * Switch back to 16bit mode to avoid problems with dumb
 	 * DOS packet driver after a warm reboot
 	 */
-	lp->a.write_bcr(ioaddr, 20, 4);
+	lp->a->write_bcr(ioaddr, 20, 4);
 
       err_free_irq:
 	spin_unlock_irqrestore(&lp->lock, flags);
@@ -2420,7 +2420,7 @@ static void pcnet32_restart(struct net_d
 
 	/* wait for stop */
 	for (i = 0; i < 100; i++)
-		if (lp->a.read_csr(ioaddr, CSR0) & CSR0_STOP)
+		if (lp->a->read_csr(ioaddr, CSR0) & CSR0_STOP)
 			break;
 
 	if (i >= 100 && netif_msg_drv(lp))
@@ -2433,13 +2433,13 @@ static void pcnet32_restart(struct net_d
 		return;
 
 	/* ReInit Ring */
-	lp->a.write_csr(ioaddr, CSR0, CSR0_INIT);
+	lp->a->write_csr(ioaddr, CSR0, CSR0_INIT);
 	i = 0;
 	while (i++ < 1000)
-		if (lp->a.read_csr(ioaddr, CSR0) & CSR0_IDON)
+		if (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)
 			break;
 
-	lp->a.write_csr(ioaddr, CSR0, csr0_bits);
+	lp->a->write_csr(ioaddr, CSR0, csr0_bits);
 }
 
 static void pcnet32_tx_timeout(struct net_device *dev)
@@ -2452,8 +2452,8 @@ static void pcnet32_tx_timeout(struct ne
 	if (pcnet32_debug & NETIF_MSG_DRV)
 		printk(KERN_ERR
 		       "%s: transmit timed out, status %4.4x, resetting.\n",
-		       dev->name, lp->a.read_csr(ioaddr, CSR0));
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);
+		       dev->name, lp->a->read_csr(ioaddr, CSR0));
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);
 	dev->stats.tx_errors++;
 	if (netif_msg_tx_err(lp)) {
 		int i;
@@ -2497,7 +2497,7 @@ static netdev_tx_t pcnet32_start_xmit(st
 	if (netif_msg_tx_queued(lp)) {
 		printk(KERN_DEBUG
 		       "%s: pcnet32_start_xmit() called, csr0 %4.4x.\n",
-		       dev->name, lp->a.read_csr(ioaddr, CSR0));
+		       dev->name, lp->a->read_csr(ioaddr, CSR0));
 	}
 
 	/* Default status -- will not enable Successful-TxDone
@@ -2528,7 +2528,7 @@ static netdev_tx_t pcnet32_start_xmit(st
 	dev->stats.tx_bytes += skb->len;
 
 	/* Trigger an immediate send poll. */
-	lp->a.write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_TXPOLL);
+	lp->a->write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_TXPOLL);
 
 	dev->trans_start = jiffies;
 
@@ -2555,18 +2555,18 @@ pcnet32_interrupt(int irq, void *dev_id)
 
 	spin_lock(&lp->lock);
 
-	csr0 = lp->a.read_csr(ioaddr, CSR0);
+	csr0 = lp->a->read_csr(ioaddr, CSR0);
 	while ((csr0 & 0x8f00) && --boguscnt >= 0) {
 		if (csr0 == 0xffff) {
 			break;	/* PCMCIA remove happened */
 		}
 		/* Acknowledge all of the current interrupt sources ASAP. */
-		lp->a.write_csr(ioaddr, CSR0, csr0 & ~0x004f);
+		lp->a->write_csr(ioaddr, CSR0, csr0 & ~0x004f);
 
 		if (netif_msg_intr(lp))
 			printk(KERN_DEBUG
 			       "%s: interrupt  csr0=%#2.2x new csr=%#2.2x.\n",
-			       dev->name, csr0, lp->a.read_csr(ioaddr, CSR0));
+			       dev->name, csr0, lp->a->read_csr(ioaddr, CSR0));
 
 		/* Log misc errors. */
 		if (csr0 & 0x4000)
@@ -2595,19 +2595,19 @@ pcnet32_interrupt(int irq, void *dev_id)
 		if (napi_schedule_prep(&lp->napi)) {
 			u16 val;
 			/* set interrupt masks */
-			val = lp->a.read_csr(ioaddr, CSR3);
+			val = lp->a->read_csr(ioaddr, CSR3);
 			val |= 0x5f00;
-			lp->a.write_csr(ioaddr, CSR3, val);
+			lp->a->write_csr(ioaddr, CSR3, val);
 
 			__napi_schedule(&lp->napi);
 			break;
 		}
-		csr0 = lp->a.read_csr(ioaddr, CSR0);
+		csr0 = lp->a->read_csr(ioaddr, CSR0);
 	}
 
 	if (netif_msg_intr(lp))
 		printk(KERN_DEBUG "%s: exiting interrupt, csr0=%#4.4x.\n",
-		       dev->name, lp->a.read_csr(ioaddr, CSR0));
+		       dev->name, lp->a->read_csr(ioaddr, CSR0));
 
 	spin_unlock(&lp->lock);
 
@@ -2627,21 +2627,21 @@ static int pcnet32_close(struct net_devi
 
 	spin_lock_irqsave(&lp->lock, flags);
 
-	dev->stats.rx_missed_errors = lp->a.read_csr(ioaddr, 112);
+	dev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);
 
 	if (netif_msg_ifdown(lp))
 		printk(KERN_DEBUG
 		       "%s: Shutting down ethercard, status was %2.2x.\n",
-		       dev->name, lp->a.read_csr(ioaddr, CSR0));
+		       dev->name, lp->a->read_csr(ioaddr, CSR0));
 
 	/* We stop the PCNET32 here -- it occasionally polls memory if we don't. */
-	lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);
+	lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);
 
 	/*
 	 * Switch back to 16bit mode to avoid problems with dumb
 	 * DOS packet driver after a warm reboot
 	 */
-	lp->a.write_bcr(ioaddr, 20, 4);
+	lp->a->write_bcr(ioaddr, 20, 4);
 
 	spin_unlock_irqrestore(&lp->lock, flags);
 
@@ -2664,7 +2664,7 @@ static struct net_device_stats *pcnet32_
 	unsigned long flags;
 
 	spin_lock_irqsave(&lp->lock, flags);
-	dev->stats.rx_missed_errors = lp->a.read_csr(ioaddr, 112);
+	dev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);
 	spin_unlock_irqrestore(&lp->lock, flags);
 
 	return &dev->stats;
@@ -2686,10 +2686,10 @@ static void pcnet32_load_multicast(struc
 	if (dev->flags & IFF_ALLMULTI) {
 		ib->filter[0] = cpu_to_le32(~0U);
 		ib->filter[1] = cpu_to_le32(~0U);
-		lp->a.write_csr(ioaddr, PCNET32_MC_FILTER, 0xffff);
-		lp->a.write_csr(ioaddr, PCNET32_MC_FILTER+1, 0xffff);
-		lp->a.write_csr(ioaddr, PCNET32_MC_FILTER+2, 0xffff);
-		lp->a.write_csr(ioaddr, PCNET32_MC_FILTER+3, 0xffff);
+		lp->a->write_csr(ioaddr, PCNET32_MC_FILTER, 0xffff);
+		lp->a->write_csr(ioaddr, PCNET32_MC_FILTER+1, 0xffff);
+		lp->a->write_csr(ioaddr, PCNET32_MC_FILTER+2, 0xffff);
+		lp->a->write_csr(ioaddr, PCNET32_MC_FILTER+3, 0xffff);
 		return;
 	}
 	/* clear the multicast filter */
@@ -2710,7 +2710,7 @@ static void pcnet32_load_multicast(struc
 		mcast_table[crc >> 4] |= cpu_to_le16(1 << (crc & 0xf));
 	}
 	for (i = 0; i < 4; i++)
-		lp->a.write_csr(ioaddr, PCNET32_MC_FILTER + i,
+		lp->a->write_csr(ioaddr, PCNET32_MC_FILTER + i,
 				le16_to_cpu(mcast_table[i]));
 	return;
 }
@@ -2726,7 +2726,7 @@ static void pcnet32_set_multicast_list(s
 
 	spin_lock_irqsave(&lp->lock, flags);
 	suspended = pcnet32_suspend(dev, &flags, 0);
-	csr15 = lp->a.read_csr(ioaddr, CSR15);
+	csr15 = lp->a->read_csr(ioaddr, CSR15);
 	if (dev->flags & IFF_PROMISC) {
 		/* Log any net taps. */
 		if (netif_msg_hw(lp))
@@ -2735,21 +2735,21 @@ static void pcnet32_set_multicast_list(s
 		lp->init_block->mode =
 		    cpu_to_le16(0x8000 | (lp->options & PCNET32_PORT_PORTSEL) <<
 				7);
-		lp->a.write_csr(ioaddr, CSR15, csr15 | 0x8000);
+		lp->a->write_csr(ioaddr, CSR15, csr15 | 0x8000);
 	} else {
 		lp->init_block->mode =
 		    cpu_to_le16((lp->options & PCNET32_PORT_PORTSEL) << 7);
-		lp->a.write_csr(ioaddr, CSR15, csr15 & 0x7fff);
+		lp->a->write_csr(ioaddr, CSR15, csr15 & 0x7fff);
 		pcnet32_load_multicast(dev);
 	}
 
 	if (suspended) {
 		int csr5;
 		/* clear SUSPEND (SPND) - CSR5 bit 0 */
-		csr5 = lp->a.read_csr(ioaddr, CSR5);
-		lp->a.write_csr(ioaddr, CSR5, csr5 & (~CSR5_SUSPEND));
+		csr5 = lp->a->read_csr(ioaddr, CSR5);
+		lp->a->write_csr(ioaddr, CSR5, csr5 & (~CSR5_SUSPEND));
 	} else {
-		lp->a.write_csr(ioaddr, CSR0, CSR0_STOP);
+		lp->a->write_csr(ioaddr, CSR0, CSR0_STOP);
 		pcnet32_restart(dev, CSR0_NORMAL);
 		netif_wake_queue(dev);
 	}
@@ -2767,8 +2767,8 @@ static int mdio_read(struct net_device *
 	if (!lp->mii)
 		return 0;
 
-	lp->a.write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
-	val_out = lp->a.read_bcr(ioaddr, 34);
+	lp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
+	val_out = lp->a->read_bcr(ioaddr, 34);
 
 	return val_out;
 }
@@ -2782,8 +2782,8 @@ static void mdio_write(struct net_device
 	if (!lp->mii)
 		return;
 
-	lp->a.write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
-	lp->a.write_bcr(ioaddr, 34, val);
+	lp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
+	lp->a->write_bcr(ioaddr, 34, val);
 }
 
 static int pcnet32_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
@@ -2862,7 +2862,7 @@ static void pcnet32_check_media(struct n
 		curr_link = mii_link_ok(&lp->mii_if);
 	} else {
 		ulong ioaddr = dev->base_addr;	/* card base I/O address */
-		curr_link = (lp->a.read_bcr(ioaddr, 4) != 0xc0);
+		curr_link = (lp->a->read_bcr(ioaddr, 4) != 0xc0);
 	}
 	if (!curr_link) {
 		if (prev_link || verbose) {
@@ -2887,13 +2887,13 @@ static void pcnet32_check_media(struct n
 				       (ecmd.duplex ==
 					DUPLEX_FULL) ? "full" : "half");
 			}
-			bcr9 = lp->a.read_bcr(dev->base_addr, 9);
+			bcr9 = lp->a->read_bcr(dev->base_addr, 9);
 			if ((bcr9 & (1 << 0)) != lp->mii_if.full_duplex) {
 				if (lp->mii_if.full_duplex)
 					bcr9 |= (1 << 0);
 				else
 					bcr9 &= ~(1 << 0);
-				lp->a.write_bcr(dev->base_addr, 9, bcr9);
+				lp->a->write_bcr(dev->base_addr, 9, bcr9);
 			}
 		} else {
 			if (netif_msg_link(lp))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/sis190.c linux-2.6.32.60-pax/drivers/net/sis190.c
--- linux-2.6.32.60/drivers/net/sis190.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/sis190.c	2012-03-13 13:15:35.204097986 +0100
@@ -1598,7 +1598,7 @@ static int __devinit sis190_get_mac_addr
 static int __devinit sis190_get_mac_addr_from_apc(struct pci_dev *pdev,
 						  struct net_device *dev)
 {
-	static const u16 __devinitdata ids[] = { 0x0965, 0x0966, 0x0968 };
+	static const u16 __devinitconst ids[] = { 0x0965, 0x0966, 0x0968 };
 	struct sis190_private *tp = netdev_priv(dev);
 	struct pci_dev *isa_bridge;
 	u8 reg, tmp8;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/sundance.c linux-2.6.32.60-pax/drivers/net/sundance.c
--- linux-2.6.32.60/drivers/net/sundance.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/sundance.c	2012-03-13 13:15:35.208097986 +0100
@@ -225,7 +225,7 @@ enum {
 struct pci_id_info {
         const char *name;
 };
-static const struct pci_id_info pci_id_tbl[] __devinitdata = {
+static const struct pci_id_info pci_id_tbl[] __devinitconst = {
 	{"D-Link DFE-550TX FAST Ethernet Adapter"},
 	{"D-Link DFE-550FX 100Mbps Fiber-optics Adapter"},
 	{"D-Link DFE-580TX 4 port Server Adapter"},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tg3.h linux-2.6.32.60-pax/drivers/net/tg3.h
--- linux-2.6.32.60/drivers/net/tg3.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tg3.h	2012-03-13 13:15:35.208097986 +0100
@@ -95,6 +95,7 @@
 #define  CHIPREV_ID_5750_A0		 0x4000
 #define  CHIPREV_ID_5750_A1		 0x4001
 #define  CHIPREV_ID_5750_A3		 0x4003
+#define  CHIPREV_ID_5750_C1		 0x4201
 #define  CHIPREV_ID_5750_C2		 0x4202
 #define  CHIPREV_ID_5752_A0_HW		 0x5000
 #define  CHIPREV_ID_5752_A0		 0x6000
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tokenring/abyss.c linux-2.6.32.60-pax/drivers/net/tokenring/abyss.c
--- linux-2.6.32.60/drivers/net/tokenring/abyss.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tokenring/abyss.c	2012-03-13 13:15:35.212097986 +0100
@@ -451,10 +451,12 @@ static struct pci_driver abyss_driver =
 
 static int __init abyss_init (void)
 {
-	abyss_netdev_ops = tms380tr_netdev_ops;
+	pax_open_kernel();
+	memcpy((void *)&abyss_netdev_ops, &tms380tr_netdev_ops, sizeof(tms380tr_netdev_ops));
 
-	abyss_netdev_ops.ndo_open = abyss_open;
-	abyss_netdev_ops.ndo_stop = abyss_close;
+	*(void **)&abyss_netdev_ops.ndo_open = abyss_open;
+	*(void **)&abyss_netdev_ops.ndo_stop = abyss_close;
+	pax_close_kernel();
 
 	return pci_register_driver(&abyss_driver);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tokenring/madgemc.c linux-2.6.32.60-pax/drivers/net/tokenring/madgemc.c
--- linux-2.6.32.60/drivers/net/tokenring/madgemc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tokenring/madgemc.c	2012-03-13 13:15:35.212097986 +0100
@@ -755,9 +755,11 @@ static struct mca_driver madgemc_driver
 
 static int __init madgemc_init (void)
 {
-	madgemc_netdev_ops = tms380tr_netdev_ops;
-	madgemc_netdev_ops.ndo_open = madgemc_open;
-	madgemc_netdev_ops.ndo_stop = madgemc_close;
+	pax_open_kernel();
+	memcpy((void *)&madgemc_netdev_ops, &tms380tr_netdev_ops, sizeof(tms380tr_netdev_ops));
+	*(void **)&madgemc_netdev_ops.ndo_open = madgemc_open;
+	*(void **)&madgemc_netdev_ops.ndo_stop = madgemc_close;
+	pax_close_kernel();
 
 	return mca_register_driver (&madgemc_driver);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tokenring/proteon.c linux-2.6.32.60-pax/drivers/net/tokenring/proteon.c
--- linux-2.6.32.60/drivers/net/tokenring/proteon.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tokenring/proteon.c	2012-03-13 13:15:35.212097986 +0100
@@ -353,9 +353,11 @@ static int __init proteon_init(void)
 	struct platform_device *pdev;
 	int i, num = 0, err = 0;
 
-	proteon_netdev_ops = tms380tr_netdev_ops;
-	proteon_netdev_ops.ndo_open = proteon_open;
-	proteon_netdev_ops.ndo_stop = tms380tr_close;
+	pax_open_kernel();
+	memcpy((void *)&proteon_netdev_ops, &tms380tr_netdev_ops, sizeof(tms380tr_netdev_ops));
+	*(void **)&proteon_netdev_ops.ndo_open = proteon_open;
+	*(void **)&proteon_netdev_ops.ndo_stop = tms380tr_close;
+	pax_close_kernel();
 
 	err = platform_driver_register(&proteon_driver);
 	if (err)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tokenring/skisa.c linux-2.6.32.60-pax/drivers/net/tokenring/skisa.c
--- linux-2.6.32.60/drivers/net/tokenring/skisa.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tokenring/skisa.c	2012-03-13 13:15:35.212097986 +0100
@@ -363,9 +363,11 @@ static int __init sk_isa_init(void)
 	struct platform_device *pdev;
 	int i, num = 0, err = 0;
 
-	sk_isa_netdev_ops = tms380tr_netdev_ops;
-	sk_isa_netdev_ops.ndo_open = sk_isa_open;
-	sk_isa_netdev_ops.ndo_stop = tms380tr_close;
+	pax_open_kernel();
+	memcpy((void *)&sk_isa_netdev_ops, &tms380tr_netdev_ops, sizeof(tms380tr_netdev_ops));
+	*(void **)&sk_isa_netdev_ops.ndo_open = sk_isa_open;
+	*(void **)&sk_isa_netdev_ops.ndo_stop = tms380tr_close;
+	pax_close_kernel();
 
 	err = platform_driver_register(&sk_isa_driver);
 	if (err)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tulip/de4x5.c linux-2.6.32.60-pax/drivers/net/tulip/de4x5.c
--- linux-2.6.32.60/drivers/net/tulip/de4x5.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tulip/de4x5.c	2012-03-13 13:15:35.216097986 +0100
@@ -5472,7 +5472,7 @@ de4x5_ioctl(struct net_device *dev, stru
 	for (i=0; i<ETH_ALEN; i++) {
 	    tmp.addr[i] = dev->dev_addr[i];
 	}
-	if (copy_to_user(ioc->data, tmp.addr, ioc->len)) return -EFAULT;
+	if (ioc->len > sizeof tmp.addr || copy_to_user(ioc->data, tmp.addr, ioc->len)) return -EFAULT;
 	break;
 
     case DE4X5_SET_HWADDR:           /* Set the hardware address */
@@ -5512,7 +5512,7 @@ de4x5_ioctl(struct net_device *dev, stru
 	spin_lock_irqsave(&lp->lock, flags);
 	memcpy(&statbuf, &lp->pktStats, ioc->len);
 	spin_unlock_irqrestore(&lp->lock, flags);
-	if (copy_to_user(ioc->data, &statbuf, ioc->len))
+	if (ioc->len > sizeof statbuf || copy_to_user(ioc->data, &statbuf, ioc->len))
 		return -EFAULT;
 	break;
     }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tulip/eeprom.c linux-2.6.32.60-pax/drivers/net/tulip/eeprom.c
--- linux-2.6.32.60/drivers/net/tulip/eeprom.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tulip/eeprom.c	2012-03-13 13:15:35.216097986 +0100
@@ -80,7 +80,7 @@ static struct eeprom_fixup eeprom_fixups
   {NULL}};
 
 
-static const char *block_name[] __devinitdata = {
+static const char *block_name[] __devinitconst = {
 	"21140 non-MII",
 	"21140 MII PHY",
 	"21142 Serial PHY",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/tulip/winbond-840.c linux-2.6.32.60-pax/drivers/net/tulip/winbond-840.c
--- linux-2.6.32.60/drivers/net/tulip/winbond-840.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/tulip/winbond-840.c	2012-03-13 13:15:35.220097985 +0100
@@ -235,7 +235,7 @@ struct pci_id_info {
         int drv_flags;		/* Driver use, intended as capability flags. */
 };
 
-static const struct pci_id_info pci_id_tbl[] __devinitdata = {
+static const struct pci_id_info pci_id_tbl[] __devinitconst = {
 	{ 				/* Sometime a Level-One switch card. */
 	  "Winbond W89c840",	CanHaveMII | HasBrokenTx | FDXOnNoMII},
 	{ "Winbond W89c840",	CanHaveMII | HasBrokenTx},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/usb/hso.c linux-2.6.32.60-pax/drivers/net/usb/hso.c
--- linux-2.6.32.60/drivers/net/usb/hso.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/usb/hso.c	2012-03-13 13:15:35.220097985 +0100
@@ -71,7 +71,7 @@
 #include <asm/byteorder.h>
 #include <linux/serial_core.h>
 #include <linux/serial.h>
-
+#include <asm/local.h>
 
 #define DRIVER_VERSION			"1.2"
 #define MOD_AUTHOR			"Option Wireless"
@@ -258,7 +258,7 @@ struct hso_serial {
 
 	/* from usb_serial_port */
 	struct tty_struct *tty;
-	int open_count;
+	local_t open_count;
 	spinlock_t serial_lock;
 
 	int (*write_data) (struct hso_serial *serial);
@@ -1180,7 +1180,7 @@ static void put_rxbuf_data_and_resubmit_
 	struct urb *urb;
 
 	urb = serial->rx_urb[0];
-	if (serial->open_count > 0) {
+	if (local_read(&serial->open_count) > 0) {
 		count = put_rxbuf_data(urb, serial);
 		if (count == -1)
 			return;
@@ -1216,7 +1216,7 @@ static void hso_std_serial_read_bulk_cal
 	DUMP1(urb->transfer_buffer, urb->actual_length);
 
 	/* Anyone listening? */
-	if (serial->open_count == 0)
+	if (local_read(&serial->open_count) == 0)
 		return;
 
 	if (status == 0) {
@@ -1311,8 +1311,7 @@ static int hso_serial_open(struct tty_st
 	spin_unlock_irq(&serial->serial_lock);
 
 	/* check for port already opened, if not set the termios */
-	serial->open_count++;
-	if (serial->open_count == 1) {
+	if (local_inc_return(&serial->open_count) == 1) {
 		tty->low_latency = 1;
 		serial->rx_state = RX_IDLE;
 		/* Force default termio settings */
@@ -1325,7 +1324,7 @@ static int hso_serial_open(struct tty_st
 		result = hso_start_serial_device(serial->parent, GFP_KERNEL);
 		if (result) {
 			hso_stop_serial_device(serial->parent);
-			serial->open_count--;
+			local_dec(&serial->open_count);
 			kref_put(&serial->parent->ref, hso_serial_ref_free);
 		}
 	} else {
@@ -1362,10 +1361,10 @@ static void hso_serial_close(struct tty_
 
 	/* reset the rts and dtr */
 	/* do the actual close */
-	serial->open_count--;
+	local_dec(&serial->open_count);
 
-	if (serial->open_count <= 0) {
-		serial->open_count = 0;
+	if (local_read(&serial->open_count) <= 0) {
+		local_set(&serial->open_count,  0);
 		spin_lock_irq(&serial->serial_lock);
 		if (serial->tty == tty) {
 			serial->tty->driver_data = NULL;
@@ -1447,7 +1446,7 @@ static void hso_serial_set_termios(struc
 
 	/* the actual setup */
 	spin_lock_irqsave(&serial->serial_lock, flags);
-	if (serial->open_count)
+	if (local_read(&serial->open_count))
 		_hso_serial_set_termios(tty, old);
 	else
 		tty->termios = old;
@@ -3097,7 +3096,7 @@ static int hso_resume(struct usb_interfa
 	/* Start all serial ports */
 	for (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {
 		if (serial_table[i] && (serial_table[i]->interface == iface)) {
-			if (dev2ser(serial_table[i])->open_count) {
+			if (local_read(&dev2ser(serial_table[i])->open_count)) {
 				result =
 				    hso_start_serial_device(serial_table[i], GFP_NOIO);
 				hso_kick_transmit(dev2ser(serial_table[i]));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/vxge/vxge-config.c linux-2.6.32.60-pax/drivers/net/vxge/vxge-config.c
--- linux-2.6.32.60/drivers/net/vxge/vxge-config.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/vxge/vxge-config.c	2013-01-23 01:09:57.891096999 +0100
@@ -1467,7 +1467,9 @@ __vxge_hw_ring_create(struct __vxge_hw_v
 	struct vxge_hw_ring_config *config;
 	struct __vxge_hw_device *hldev;
 	u32 vp_id;
-	struct vxge_hw_mempool_cbs ring_mp_callback;
+	static struct vxge_hw_mempool_cbs ring_mp_callback = {
+		.item_func_alloc = __vxge_hw_ring_mempool_item_alloc,
+	};
 
 	if ((vp == NULL) || (attr == NULL)) {
 		status = VXGE_HW_FAIL;
@@ -1521,7 +1523,6 @@ __vxge_hw_ring_create(struct __vxge_hw_v
 
 	/* calculate actual RxD block private size */
 	ring->rxdblock_priv_size = ring->rxd_priv_size * ring->rxds_per_block;
-	ring_mp_callback.item_func_alloc = __vxge_hw_ring_mempool_item_alloc;
 	ring->mempool = __vxge_hw_mempool_create(hldev,
 				VXGE_HW_BLOCK_SIZE,
 				VXGE_HW_BLOCK_SIZE,
@@ -2509,7 +2510,10 @@ __vxge_hw_fifo_create(struct __vxge_hw_v
 	struct __vxge_hw_fifo *fifo;
 	struct vxge_hw_fifo_config *config;
 	u32 txdl_size, txdl_per_memblock;
-	struct vxge_hw_mempool_cbs fifo_mp_callback;
+	static struct vxge_hw_mempool_cbs fifo_mp_callback = {
+		.item_func_alloc = __vxge_hw_fifo_mempool_item_alloc,
+	};
+
 	struct __vxge_hw_virtualpath *vpath;
 
 	if ((vp == NULL) || (attr == NULL)) {
@@ -2590,8 +2594,6 @@ __vxge_hw_fifo_create(struct __vxge_hw_v
 		goto exit;
 	}
 
-	fifo_mp_callback.item_func_alloc = __vxge_hw_fifo_mempool_item_alloc;
-
 	fifo->mempool =
 		__vxge_hw_mempool_create(vpath->hldev,
 			fifo->config->memblock_size,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wan/hdlc_x25.c linux-2.6.32.60-pax/drivers/net/wan/hdlc_x25.c
--- linux-2.6.32.60/drivers/net/wan/hdlc_x25.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wan/hdlc_x25.c	2012-03-13 13:15:35.224097985 +0100
@@ -136,16 +136,16 @@ static netdev_tx_t x25_xmit(struct sk_bu
 
 static int x25_open(struct net_device *dev)
 {
-	struct lapb_register_struct cb;
+	static struct lapb_register_struct cb = {
+		.connect_confirmation = x25_connected,
+		.connect_indication = x25_connected,
+		.disconnect_confirmation = x25_disconnected,
+		.disconnect_indication = x25_disconnected,
+		.data_indication = x25_data_indication,
+		.data_transmit = x25_data_transmit
+	};
 	int result;
 
-	cb.connect_confirmation = x25_connected;
-	cb.connect_indication = x25_connected;
-	cb.disconnect_confirmation = x25_disconnected;
-	cb.disconnect_indication = x25_disconnected;
-	cb.data_indication = x25_data_indication;
-	cb.data_transmit = x25_data_transmit;
-
 	result = lapb_register(dev, &cb);
 	if (result != LAPB_OK)
 		return result;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl3945-base.c linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl3945-base.c
--- linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl3945-base.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl3945-base.c	2012-03-13 13:15:35.228097985 +0100
@@ -3927,7 +3927,9 @@ static int iwl3945_pci_probe(struct pci_
 	 */
 	if (iwl3945_mod_params.disable_hw_scan) {
 		IWL_DEBUG_INFO(priv, "Disabling hw_scan\n");
-		iwl3945_hw_ops.hw_scan = NULL;
+		pax_open_kernel();
+		*(void **)&iwl3945_hw_ops.hw_scan = NULL;
+		pax_close_kernel();
 	}
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-agn.c linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-agn.c
--- linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-agn.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-agn.c	2012-03-13 13:15:35.228097985 +0100
@@ -2911,7 +2911,9 @@ static int iwl_pci_probe(struct pci_dev
 		if (iwl_debug_level & IWL_DL_INFO)
 			dev_printk(KERN_DEBUG, &(pdev->dev),
 				   "Disabling hw_scan\n");
-		iwl_hw_ops.hw_scan = NULL;
+		pax_open_kernel();
+		*(void **)&iwl_hw_ops.hw_scan = NULL;
+		pax_close_kernel();
 	}
 
 	hw = iwl_alloc_all(cfg, &iwl_hw_ops);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-debugfs.c linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-debugfs.c
--- linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-debugfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-debugfs.c	2012-09-20 00:38:15.826660686 +0200
@@ -166,7 +166,7 @@ static ssize_t iwl_dbgfs_tx_statistics_w
 	struct iwl_priv *priv = file->private_data;
 	u32 clear_flag;
 	char buf[8];
-	int buf_size;
+	size_t buf_size;
 
 	memset(buf, 0, sizeof(buf));
 	buf_size = min(count, sizeof(buf) -  1);
@@ -285,7 +285,7 @@ static ssize_t iwl_dbgfs_sram_write(stru
 {
 	struct iwl_priv *priv = file->private_data;
 	char buf[64];
-	int buf_size;
+	size_t buf_size;
 	u32 offset, len;
 
 	memset(buf, 0, sizeof(buf));
@@ -739,7 +739,7 @@ static ssize_t iwl_dbgfs_disable_ht40_wr
 {
 	struct iwl_priv *priv = file->private_data;
 	char buf[8];
-	int buf_size;
+	size_t buf_size;
 	int ht40;
 
 	memset(buf, 0, sizeof(buf));
@@ -782,7 +782,7 @@ static ssize_t iwl_dbgfs_sleep_level_ove
 {
 	struct iwl_priv *priv = file->private_data;
 	char buf[8];
-	int buf_size;
+	size_t buf_size;
 	int value;
 
 	memset(buf, 0, sizeof(buf));
@@ -950,7 +950,7 @@ static ssize_t iwl_dbgfs_traffic_log_wri
 {
 	struct iwl_priv *priv = file->private_data;
 	char buf[8];
-	int buf_size;
+	size_t buf_size;
 	int traffic_log;
 
 	memset(buf, 0, sizeof(buf));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-debug.h linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-debug.h
--- linux-2.6.32.60/drivers/net/wireless/iwlwifi/iwl-debug.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wireless/iwlwifi/iwl-debug.h	2012-03-13 13:15:35.232097985 +0100
@@ -118,8 +118,8 @@ void iwl_dbgfs_unregister(struct iwl_pri
 #endif
 
 #else
-#define IWL_DEBUG(__priv, level, fmt, args...)
-#define IWL_DEBUG_LIMIT(__priv, level, fmt, args...)
+#define IWL_DEBUG(__priv, level, fmt, args...) do {} while (0)
+#define IWL_DEBUG_LIMIT(__priv, level, fmt, args...) do {} while (0)
 static inline void iwl_print_hex_dump(struct iwl_priv *priv, int level,
 				      void *p, u32 len)
 {}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/net/wireless/rndis_wlan.c linux-2.6.32.60-pax/drivers/net/wireless/rndis_wlan.c
--- linux-2.6.32.60/drivers/net/wireless/rndis_wlan.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/net/wireless/rndis_wlan.c	2012-03-13 13:15:35.232097985 +0100
@@ -1176,7 +1176,7 @@ static int set_rts_threshold(struct usbn
 
 	devdbg(usbdev, "set_rts_threshold %i", rts_threshold);
 
-	if (rts_threshold < 0 || rts_threshold > 2347)
+	if (rts_threshold > 2347)
 		rts_threshold = 2347;
 
 	tmp = cpu_to_le32(rts_threshold);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/buffer_sync.c linux-2.6.32.60-pax/drivers/oprofile/buffer_sync.c
--- linux-2.6.32.60/drivers/oprofile/buffer_sync.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/buffer_sync.c	2012-03-13 13:15:35.232097985 +0100
@@ -342,7 +342,7 @@ static void add_data(struct op_entry *en
 		if (cookie == NO_COOKIE)
 			offset = pc;
 		if (cookie == INVALID_COOKIE) {
-			atomic_inc(&oprofile_stats.sample_lost_no_mapping);
+			atomic_inc_unchecked(&oprofile_stats.sample_lost_no_mapping);
 			offset = pc;
 		}
 		if (cookie != last_cookie) {
@@ -386,14 +386,14 @@ add_sample(struct mm_struct *mm, struct
 	/* add userspace sample */
 
 	if (!mm) {
-		atomic_inc(&oprofile_stats.sample_lost_no_mm);
+		atomic_inc_unchecked(&oprofile_stats.sample_lost_no_mm);
 		return 0;
 	}
 
 	cookie = lookup_dcookie(mm, s->eip, &offset);
 
 	if (cookie == INVALID_COOKIE) {
-		atomic_inc(&oprofile_stats.sample_lost_no_mapping);
+		atomic_inc_unchecked(&oprofile_stats.sample_lost_no_mapping);
 		return 0;
 	}
 
@@ -562,7 +562,7 @@ void sync_buffer(int cpu)
 		/* ignore backtraces if failed to add a sample */
 		if (state == sb_bt_start) {
 			state = sb_bt_ignore;
-			atomic_inc(&oprofile_stats.bt_lost_no_mapping);
+			atomic_inc_unchecked(&oprofile_stats.bt_lost_no_mapping);
 		}
 	}
 	release_mm(mm);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/event_buffer.c linux-2.6.32.60-pax/drivers/oprofile/event_buffer.c
--- linux-2.6.32.60/drivers/oprofile/event_buffer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/event_buffer.c	2012-03-13 13:15:35.236097984 +0100
@@ -53,7 +53,7 @@ void add_event_entry(unsigned long value
 	}
 
 	if (buffer_pos == buffer_size) {
-		atomic_inc(&oprofile_stats.event_lost_overflow);
+		atomic_inc_unchecked(&oprofile_stats.event_lost_overflow);
 		return;
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/oprof.c linux-2.6.32.60-pax/drivers/oprofile/oprof.c
--- linux-2.6.32.60/drivers/oprofile/oprof.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/oprof.c	2012-03-13 13:15:35.236097984 +0100
@@ -110,7 +110,7 @@ static void switch_worker(struct work_st
 	if (oprofile_ops.switch_events())
 		return;
 
-	atomic_inc(&oprofile_stats.multiplex_counter);
+	atomic_inc_unchecked(&oprofile_stats.multiplex_counter);
 	start_switch_worker();
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/oprofilefs.c linux-2.6.32.60-pax/drivers/oprofile/oprofilefs.c
--- linux-2.6.32.60/drivers/oprofile/oprofilefs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/oprofilefs.c	2012-05-20 19:21:25.393167281 +0200
@@ -187,7 +187,7 @@ static const struct file_operations atom
 
 
 int oprofilefs_create_ro_atomic(struct super_block *sb, struct dentry *root,
-	char const *name, atomic_t *val)
+	char const *name, atomic_unchecked_t *val)
 {
 	struct dentry *d = __oprofilefs_create_file(sb, root, name,
 						     &atomic_ro_fops, 0444);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/oprofile_stats.c linux-2.6.32.60-pax/drivers/oprofile/oprofile_stats.c
--- linux-2.6.32.60/drivers/oprofile/oprofile_stats.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/oprofile_stats.c	2012-03-13 13:15:35.236097984 +0100
@@ -30,11 +30,11 @@ void oprofile_reset_stats(void)
 		cpu_buf->sample_invalid_eip = 0;
 	}
 
-	atomic_set(&oprofile_stats.sample_lost_no_mm, 0);
-	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
-	atomic_set(&oprofile_stats.event_lost_overflow, 0);
-	atomic_set(&oprofile_stats.bt_lost_no_mapping, 0);
-	atomic_set(&oprofile_stats.multiplex_counter, 0);
+	atomic_set_unchecked(&oprofile_stats.sample_lost_no_mm, 0);
+	atomic_set_unchecked(&oprofile_stats.sample_lost_no_mapping, 0);
+	atomic_set_unchecked(&oprofile_stats.event_lost_overflow, 0);
+	atomic_set_unchecked(&oprofile_stats.bt_lost_no_mapping, 0);
+	atomic_set_unchecked(&oprofile_stats.multiplex_counter, 0);
 }
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/oprofile/oprofile_stats.h linux-2.6.32.60-pax/drivers/oprofile/oprofile_stats.h
--- linux-2.6.32.60/drivers/oprofile/oprofile_stats.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/oprofile/oprofile_stats.h	2012-03-13 13:15:35.236097984 +0100
@@ -13,11 +13,11 @@
 #include <asm/atomic.h>
 
 struct oprofile_stat_struct {
-	atomic_t sample_lost_no_mm;
-	atomic_t sample_lost_no_mapping;
-	atomic_t bt_lost_no_mapping;
-	atomic_t event_lost_overflow;
-	atomic_t multiplex_counter;
+	atomic_unchecked_t sample_lost_no_mm;
+	atomic_unchecked_t sample_lost_no_mapping;
+	atomic_unchecked_t bt_lost_no_mapping;
+	atomic_unchecked_t event_lost_overflow;
+	atomic_unchecked_t multiplex_counter;
 };
 
 extern struct oprofile_stat_struct oprofile_stats;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/parport/procfs.c linux-2.6.32.60-pax/drivers/parport/procfs.c
--- linux-2.6.32.60/drivers/parport/procfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/parport/procfs.c	2012-03-13 13:15:35.236097984 +0100
@@ -64,7 +64,7 @@ static int do_active_device(ctl_table *t
 
 	*ppos += len;
 
-	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
+	return (len > sizeof buffer || copy_to_user(result, buffer, len)) ? -EFAULT : 0;
 }
 
 #ifdef CONFIG_PARPORT_1284
@@ -106,7 +106,7 @@ static int do_autoprobe(ctl_table *table
 
 	*ppos += len;
 
-	return copy_to_user (result, buffer, len) ? -EFAULT : 0;
+	return (len > sizeof buffer || copy_to_user (result, buffer, len)) ? -EFAULT : 0;
 }
 #endif /* IEEE1284.3 support. */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pci/hotplug/cpcihp_generic.c linux-2.6.32.60-pax/drivers/pci/hotplug/cpcihp_generic.c
--- linux-2.6.32.60/drivers/pci/hotplug/cpcihp_generic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pci/hotplug/cpcihp_generic.c	2013-01-22 17:38:23.556543626 +0100
@@ -73,7 +73,6 @@ static u16 port;
 static unsigned int enum_bit;
 static u8 enum_mask;
 
-static struct cpci_hp_controller_ops generic_hpc_ops;
 static struct cpci_hp_controller generic_hpc;
 
 static int __init validate_parameters(void)
@@ -139,6 +138,10 @@ static int query_enum(void)
 	return ((value & enum_mask) == enum_mask);
 }
 
+static struct cpci_hp_controller_ops generic_hpc_ops = {
+	.query_enum = query_enum,
+};
+
 static int __init cpcihp_generic_init(void)
 {
 	int status;
@@ -168,7 +171,6 @@ static int __init cpcihp_generic_init(vo
 	pci_dev_put(dev);
 
 	memset(&generic_hpc, 0, sizeof (struct cpci_hp_controller));
-	generic_hpc_ops.query_enum = query_enum;
 	generic_hpc.ops = &generic_hpc_ops;
 
 	status = cpci_hp_register_controller(&generic_hpc);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pci/hotplug/cpcihp_zt5550.c linux-2.6.32.60-pax/drivers/pci/hotplug/cpcihp_zt5550.c
--- linux-2.6.32.60/drivers/pci/hotplug/cpcihp_zt5550.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pci/hotplug/cpcihp_zt5550.c	2013-01-22 17:38:23.560543626 +0100
@@ -59,7 +59,6 @@
 /* local variables */
 static int debug;
 static int poll;
-static struct cpci_hp_controller_ops zt5550_hpc_ops;
 static struct cpci_hp_controller zt5550_hpc;
 
 /* Primary cPCI bus bridge device */
@@ -205,6 +204,10 @@ static int zt5550_hc_disable_irq(void)
 	return 0;
 }
 
+static struct cpci_hp_controller_ops zt5550_hpc_ops = {
+	.query_enum = zt5550_hc_query_enum,
+};
+
 static int zt5550_hc_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	int status;
@@ -216,16 +219,17 @@ static int zt5550_hc_init_one (struct pc
 	dbg("returned from zt5550_hc_config");
 
 	memset(&zt5550_hpc, 0, sizeof (struct cpci_hp_controller));
-	zt5550_hpc_ops.query_enum = zt5550_hc_query_enum;
 	zt5550_hpc.ops = &zt5550_hpc_ops;
 	if(!poll) {
 		zt5550_hpc.irq = hc_dev->irq;
 		zt5550_hpc.irq_flags = IRQF_SHARED;
 		zt5550_hpc.dev_id = hc_dev;
 
-		zt5550_hpc_ops.enable_irq = zt5550_hc_enable_irq;
-		zt5550_hpc_ops.disable_irq = zt5550_hc_disable_irq;
-		zt5550_hpc_ops.check_irq = zt5550_hc_check_irq;
+		pax_open_kernel();
+		*(void **)&zt5550_hpc_ops.enable_irq = zt5550_hc_enable_irq;
+		*(void **)&zt5550_hpc_ops.disable_irq = zt5550_hc_disable_irq;
+		*(void **)&zt5550_hpc_ops.check_irq = zt5550_hc_check_irq;
+		pax_open_kernel();
 	} else {
 		info("using ENUM# polling mode");
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pci/hotplug/cpqphp_nvram.c linux-2.6.32.60-pax/drivers/pci/hotplug/cpqphp_nvram.c
--- linux-2.6.32.60/drivers/pci/hotplug/cpqphp_nvram.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pci/hotplug/cpqphp_nvram.c	2012-03-13 13:15:35.240097984 +0100
@@ -428,9 +428,13 @@ static u32 store_HRT (void __iomem *rom_
 
 void compaq_nvram_init (void __iomem *rom_start)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	if (rom_start) {
 		compaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);
 	}
+#endif
+
 	dbg("int15 entry  = %p\n", compaq_int15_entry_point);
 
 	/* initialize our int15 lock */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pci/pcie/aspm.c linux-2.6.32.60-pax/drivers/pci/pcie/aspm.c
--- linux-2.6.32.60/drivers/pci/pcie/aspm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pci/pcie/aspm.c	2012-03-13 13:15:35.240097984 +0100
@@ -27,9 +27,9 @@
 #define MODULE_PARAM_PREFIX "pcie_aspm."
 
 /* Note: those are not register definitions */
-#define ASPM_STATE_L0S_UP	(1)	/* Upstream direction L0s state */
-#define ASPM_STATE_L0S_DW	(2)	/* Downstream direction L0s state */
-#define ASPM_STATE_L1		(4)	/* L1 state */
+#define ASPM_STATE_L0S_UP	(1U)	/* Upstream direction L0s state */
+#define ASPM_STATE_L0S_DW	(2U)	/* Downstream direction L0s state */
+#define ASPM_STATE_L1		(4U)	/* L1 state */
 #define ASPM_STATE_L0S		(ASPM_STATE_L0S_UP | ASPM_STATE_L0S_DW)
 #define ASPM_STATE_ALL		(ASPM_STATE_L0S | ASPM_STATE_L1)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pci/probe.c linux-2.6.32.60-pax/drivers/pci/probe.c
--- linux-2.6.32.60/drivers/pci/probe.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pci/probe.c	2012-03-13 13:15:35.244097984 +0100
@@ -62,14 +62,14 @@ static ssize_t pci_bus_show_cpuaffinity(
 	return ret;
 }
 
-static ssize_t inline pci_bus_show_cpumaskaffinity(struct device *dev,
+static inline ssize_t pci_bus_show_cpumaskaffinity(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
 	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
 }
 
-static ssize_t inline pci_bus_show_cpulistaffinity(struct device *dev,
+static inline ssize_t pci_bus_show_cpulistaffinity(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pcmcia/pcmcia_ioctl.c linux-2.6.32.60-pax/drivers/pcmcia/pcmcia_ioctl.c
--- linux-2.6.32.60/drivers/pcmcia/pcmcia_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pcmcia/pcmcia_ioctl.c	2012-03-13 13:15:35.244097984 +0100
@@ -819,7 +819,7 @@ static int ds_ioctl(struct inode * inode
 	    return -EFAULT;
 	}
     }
-    buf = kmalloc(sizeof(ds_ioctl_arg_t), GFP_KERNEL);
+    buf = kzalloc(sizeof(ds_ioctl_arg_t), GFP_KERNEL);
     if (!buf)
 	return -ENOMEM;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/platform/x86/thinkpad_acpi.c linux-2.6.32.60-pax/drivers/platform/x86/thinkpad_acpi.c
--- linux-2.6.32.60/drivers/platform/x86/thinkpad_acpi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/platform/x86/thinkpad_acpi.c	2012-03-13 13:15:35.248097984 +0100
@@ -2139,7 +2139,7 @@ static int hotkey_mask_get(void)
 	return 0;
 }
 
-void static hotkey_mask_warn_incomplete_mask(void)
+static void hotkey_mask_warn_incomplete_mask(void)
 {
 	/* log only what the user can fix... */
 	const u32 wantedmask = hotkey_driver_mask &
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pnp/pnpbios/bioscalls.c linux-2.6.32.60-pax/drivers/pnp/pnpbios/bioscalls.c
--- linux-2.6.32.60/drivers/pnp/pnpbios/bioscalls.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pnp/pnpbios/bioscalls.c	2012-03-13 13:15:35.248097984 +0100
@@ -60,7 +60,7 @@ do { \
 	set_desc_limit(&gdt[(selname) >> 3], (size) - 1); \
 } while(0)
 
-static struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4092,
+static const struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4093,
 			(unsigned long)__va(0x400UL), PAGE_SIZE - 0x400 - 1);
 
 /*
@@ -97,7 +97,10 @@ static inline u16 call_pnp_bios(u16 func
 
 	cpu = get_cpu();
 	save_desc_40 = get_cpu_gdt_table(cpu)[0x40 / 8];
+
+	pax_open_kernel();
 	get_cpu_gdt_table(cpu)[0x40 / 8] = bad_bios_desc;
+	pax_close_kernel();
 
 	/* On some boxes IRQ's during PnP BIOS calls are deadly.  */
 	spin_lock_irqsave(&pnp_bios_lock, flags);
@@ -135,7 +138,10 @@ static inline u16 call_pnp_bios(u16 func
 			     :"memory");
 	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 
+	pax_open_kernel();
 	get_cpu_gdt_table(cpu)[0x40 / 8] = save_desc_40;
+	pax_close_kernel();
+
 	put_cpu();
 
 	/* If we get here and this is set then the PnP BIOS faulted on us. */
@@ -469,7 +475,7 @@ int pnp_bios_read_escd(char *data, u32 n
 	return status;
 }
 
-void pnpbios_calls_init(union pnp_bios_install_struct *header)
+void __init pnpbios_calls_init(union pnp_bios_install_struct *header)
 {
 	int i;
 
@@ -477,6 +483,8 @@ void pnpbios_calls_init(union pnp_bios_i
 	pnp_bios_callpoint.offset = header->fields.pm16offset;
 	pnp_bios_callpoint.segment = PNP_CS16;
 
+	pax_open_kernel();
+
 	for_each_possible_cpu(i) {
 		struct desc_struct *gdt = get_cpu_gdt_table(i);
 		if (!gdt)
@@ -488,4 +496,6 @@ void pnpbios_calls_init(union pnp_bios_i
 		set_desc_base(&gdt[GDT_ENTRY_PNPBIOS_DS],
 			 (unsigned long)__va(header->fields.pm16dseg));
 	}
+
+	pax_close_kernel();
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/pnp/resource.c linux-2.6.32.60-pax/drivers/pnp/resource.c
--- linux-2.6.32.60/drivers/pnp/resource.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/pnp/resource.c	2012-03-13 13:15:35.248097984 +0100
@@ -355,7 +355,7 @@ int pnp_check_irq(struct pnp_dev *dev, s
 		return 1;
 
 	/* check if the resource is valid */
-	if (*irq < 0 || *irq > 15)
+	if (*irq > 15)
 		return 0;
 
 	/* check if the resource is reserved */
@@ -419,7 +419,7 @@ int pnp_check_dma(struct pnp_dev *dev, s
 		return 1;
 
 	/* check if the resource is valid */
-	if (*dma < 0 || *dma == 4 || *dma > 7)
+	if (*dma == 4 || *dma > 7)
 		return 0;
 
 	/* check if the resource is reserved */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/power/bq27x00_battery.c linux-2.6.32.60-pax/drivers/power/bq27x00_battery.c
--- linux-2.6.32.60/drivers/power/bq27x00_battery.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/power/bq27x00_battery.c	2013-01-23 01:05:03.059112741 +0100
@@ -53,7 +53,7 @@ struct bq27x00_device_info {
 	int			current_uA;
 	int			temp_C;
 	int			charge_rsoc;
-	struct bq27x00_access_methods	*bus;
+	struct bq27x00_access_methods	bus;
 	struct power_supply	bat;
 
 	struct i2c_client	*client;
@@ -76,7 +76,7 @@ static int bq27x00_read(u8 reg, int *rt_
 {
 	int ret;
 
-	ret = di->bus->read(reg, rt_value, b_single, di);
+	ret = di->bus.read(reg, rt_value, b_single, di);
 	*rt_value = be16_to_cpu(*rt_value);
 
 	return ret;
@@ -253,7 +253,6 @@ static int bq27200_battery_probe(struct
 {
 	char *name;
 	struct bq27x00_device_info *di;
-	struct bq27x00_access_methods *bus;
 	int num;
 	int retval = 0;
 
@@ -282,19 +281,10 @@ static int bq27200_battery_probe(struct
 	}
 	di->id = num;
 
-	bus = kzalloc(sizeof(*bus), GFP_KERNEL);
-	if (!bus) {
-		dev_err(&client->dev, "failed to allocate access method "
-					"data\n");
-		retval = -ENOMEM;
-		goto batt_failed_3;
-	}
-
 	i2c_set_clientdata(client, di);
 	di->dev = &client->dev;
 	di->bat.name = name;
-	bus->read = &bq27200_read;
-	di->bus = bus;
+	di->bus.read = &bq27200_read;
 	di->client = client;
 
 	bq27x00_powersupply_init(di);
@@ -302,15 +292,13 @@ static int bq27200_battery_probe(struct
 	retval = power_supply_register(&client->dev, &di->bat);
 	if (retval) {
 		dev_err(&client->dev, "failed to register battery\n");
-		goto batt_failed_4;
+		goto batt_failed_3;
 	}
 
 	dev_info(&client->dev, "support ver. %s enabled\n", DRIVER_VERSION);
 
 	return 0;
 
-batt_failed_4:
-	kfree(bus);
 batt_failed_3:
 	kfree(di);
 batt_failed_2:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/s390/cio/qdio_perf.c linux-2.6.32.60-pax/drivers/s390/cio/qdio_perf.c
--- linux-2.6.32.60/drivers/s390/cio/qdio_perf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/s390/cio/qdio_perf.c	2012-03-13 13:15:35.252097984 +0100
@@ -31,51 +31,51 @@ static struct proc_dir_entry *qdio_perf_
 static int qdio_perf_proc_show(struct seq_file *m, void *v)
 {
 	seq_printf(m, "Number of qdio interrupts\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.qdio_int));
+		   (long)atomic_long_read_unchecked(&perf_stats.qdio_int));
 	seq_printf(m, "Number of PCI interrupts\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.pci_int));
+		   (long)atomic_long_read_unchecked(&perf_stats.pci_int));
 	seq_printf(m, "Number of adapter interrupts\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.thin_int));
+		   (long)atomic_long_read_unchecked(&perf_stats.thin_int));
 	seq_printf(m, "\n");
 	seq_printf(m, "Inbound tasklet runs\t\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.tasklet_inbound));
+		   (long)atomic_long_read_unchecked(&perf_stats.tasklet_inbound));
 	seq_printf(m, "Outbound tasklet runs\t\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.tasklet_outbound));
+		   (long)atomic_long_read_unchecked(&perf_stats.tasklet_outbound));
 	seq_printf(m, "Adapter interrupt tasklet runs/loops\t\t: %li/%li\n",
-		   (long)atomic_long_read(&perf_stats.tasklet_thinint),
-		   (long)atomic_long_read(&perf_stats.tasklet_thinint_loop));
+		   (long)atomic_long_read_unchecked(&perf_stats.tasklet_thinint),
+		   (long)atomic_long_read_unchecked(&perf_stats.tasklet_thinint_loop));
 	seq_printf(m, "Adapter interrupt inbound tasklet runs/loops\t: %li/%li\n",
-		   (long)atomic_long_read(&perf_stats.thinint_inbound),
-		   (long)atomic_long_read(&perf_stats.thinint_inbound_loop));
+		   (long)atomic_long_read_unchecked(&perf_stats.thinint_inbound),
+		   (long)atomic_long_read_unchecked(&perf_stats.thinint_inbound_loop));
 	seq_printf(m, "\n");
 	seq_printf(m, "Number of SIGA In issued\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.siga_in));
+		   (long)atomic_long_read_unchecked(&perf_stats.siga_in));
 	seq_printf(m, "Number of SIGA Out issued\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.siga_out));
+		   (long)atomic_long_read_unchecked(&perf_stats.siga_out));
 	seq_printf(m, "Number of SIGA Sync issued\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.siga_sync));
+		   (long)atomic_long_read_unchecked(&perf_stats.siga_sync));
 	seq_printf(m, "\n");
 	seq_printf(m, "Number of inbound transfers\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.inbound_handler));
+		   (long)atomic_long_read_unchecked(&perf_stats.inbound_handler));
 	seq_printf(m, "Number of outbound transfers\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.outbound_handler));
+		   (long)atomic_long_read_unchecked(&perf_stats.outbound_handler));
 	seq_printf(m, "\n");
 	seq_printf(m, "Number of fast requeues (outg. SBAL w/o SIGA)\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.fast_requeue));
+		   (long)atomic_long_read_unchecked(&perf_stats.fast_requeue));
 	seq_printf(m, "Number of outbound target full condition\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.outbound_target_full));
+		   (long)atomic_long_read_unchecked(&perf_stats.outbound_target_full));
 	seq_printf(m, "Number of outbound tasklet mod_timer calls\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.debug_tl_out_timer));
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_tl_out_timer));
 	seq_printf(m, "Number of stop polling calls\t\t\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.debug_stop_polling));
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_stop_polling));
 	seq_printf(m, "AI inbound tasklet loops after stop polling\t: %li\n",
-		   (long)atomic_long_read(&perf_stats.thinint_inbound_loop2));
+		   (long)atomic_long_read_unchecked(&perf_stats.thinint_inbound_loop2));
 	seq_printf(m, "QEBSM EQBS total/incomplete\t\t\t: %li/%li\n",
-		   (long)atomic_long_read(&perf_stats.debug_eqbs_all),
-		   (long)atomic_long_read(&perf_stats.debug_eqbs_incomplete));
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_eqbs_all),
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_eqbs_incomplete));
 	seq_printf(m, "QEBSM SQBS total/incomplete\t\t\t: %li/%li\n",
-		   (long)atomic_long_read(&perf_stats.debug_sqbs_all),
-		   (long)atomic_long_read(&perf_stats.debug_sqbs_incomplete));
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_sqbs_all),
+		   (long)atomic_long_read_unchecked(&perf_stats.debug_sqbs_incomplete));
 	seq_printf(m, "\n");
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/s390/cio/qdio_perf.h linux-2.6.32.60-pax/drivers/s390/cio/qdio_perf.h
--- linux-2.6.32.60/drivers/s390/cio/qdio_perf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/s390/cio/qdio_perf.h	2012-03-13 13:15:35.252097984 +0100
@@ -13,46 +13,46 @@
 
 struct qdio_perf_stats {
 	/* interrupt handler calls */
-	atomic_long_t qdio_int;
-	atomic_long_t pci_int;
-	atomic_long_t thin_int;
+	atomic_long_unchecked_t qdio_int;
+	atomic_long_unchecked_t pci_int;
+	atomic_long_unchecked_t thin_int;
 
 	/* tasklet runs */
-	atomic_long_t tasklet_inbound;
-	atomic_long_t tasklet_outbound;
-	atomic_long_t tasklet_thinint;
-	atomic_long_t tasklet_thinint_loop;
-	atomic_long_t thinint_inbound;
-	atomic_long_t thinint_inbound_loop;
-	atomic_long_t thinint_inbound_loop2;
+	atomic_long_unchecked_t tasklet_inbound;
+	atomic_long_unchecked_t tasklet_outbound;
+	atomic_long_unchecked_t tasklet_thinint;
+	atomic_long_unchecked_t tasklet_thinint_loop;
+	atomic_long_unchecked_t thinint_inbound;
+	atomic_long_unchecked_t thinint_inbound_loop;
+	atomic_long_unchecked_t thinint_inbound_loop2;
 
 	/* signal adapter calls */
-	atomic_long_t siga_out;
-	atomic_long_t siga_in;
-	atomic_long_t siga_sync;
+	atomic_long_unchecked_t siga_out;
+	atomic_long_unchecked_t siga_in;
+	atomic_long_unchecked_t siga_sync;
 
 	/* misc */
-	atomic_long_t inbound_handler;
-	atomic_long_t outbound_handler;
-	atomic_long_t fast_requeue;
-	atomic_long_t outbound_target_full;
+	atomic_long_unchecked_t inbound_handler;
+	atomic_long_unchecked_t outbound_handler;
+	atomic_long_unchecked_t fast_requeue;
+	atomic_long_unchecked_t outbound_target_full;
 
 	/* for debugging */
-	atomic_long_t debug_tl_out_timer;
-	atomic_long_t debug_stop_polling;
-	atomic_long_t debug_eqbs_all;
-	atomic_long_t debug_eqbs_incomplete;
-	atomic_long_t debug_sqbs_all;
-	atomic_long_t debug_sqbs_incomplete;
+	atomic_long_unchecked_t debug_tl_out_timer;
+	atomic_long_unchecked_t debug_stop_polling;
+	atomic_long_unchecked_t debug_eqbs_all;
+	atomic_long_unchecked_t debug_eqbs_incomplete;
+	atomic_long_unchecked_t debug_sqbs_all;
+	atomic_long_unchecked_t debug_sqbs_incomplete;
 };
 
 extern struct qdio_perf_stats perf_stats;
 extern int qdio_performance_stats;
 
-static inline void qdio_perf_stat_inc(atomic_long_t *count)
+static inline void qdio_perf_stat_inc(atomic_long_unchecked_t *count)
 {
 	if (qdio_performance_stats)
-		atomic_long_inc(count);
+		atomic_long_inc_unchecked(count);
 }
 
 int qdio_setup_perf_stats(void);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/aacraid/linit.c linux-2.6.32.60-pax/drivers/scsi/aacraid/linit.c
--- linux-2.6.32.60/drivers/scsi/aacraid/linit.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/aacraid/linit.c	2012-03-13 13:15:35.256097983 +0100
@@ -91,7 +91,7 @@ static DECLARE_PCI_DEVICE_TABLE(aac_pci_
 #elif defined(__devinitconst)
 static const struct pci_device_id aac_pci_tbl[] __devinitconst = {
 #else
-static const struct pci_device_id aac_pci_tbl[] __devinitdata = {
+static const struct pci_device_id aac_pci_tbl[] __devinitconst = {
 #endif
 	{ 0x1028, 0x0001, 0x1028, 0x0001, 0, 0, 0 }, /* PERC 2/Si (Iguana/PERC2Si) */
 	{ 0x1028, 0x0002, 0x1028, 0x0002, 0, 0, 1 }, /* PERC 3/Di (Opal/PERC3Di) */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/aic94xx/aic94xx_init.c linux-2.6.32.60-pax/drivers/scsi/aic94xx/aic94xx_init.c
--- linux-2.6.32.60/drivers/scsi/aic94xx/aic94xx_init.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/aic94xx/aic94xx_init.c	2012-03-13 13:15:35.256097983 +0100
@@ -1011,7 +1011,7 @@ static struct sas_domain_function_templa
 	.lldd_control_phy	= asd_control_phy,
 };
 
-static const struct pci_device_id aic94xx_pci_table[] __devinitdata = {
+static const struct pci_device_id aic94xx_pci_table[] __devinitconst = {
 	{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x410),0, 0, 1},
 	{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x412),0, 0, 1},
 	{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x416),0, 0, 1},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/bfa/bfa_iocfc.h linux-2.6.32.60-pax/drivers/scsi/bfa/bfa_iocfc.h
--- linux-2.6.32.60/drivers/scsi/bfa/bfa_iocfc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/bfa/bfa_iocfc.h	2012-03-13 13:15:35.256097983 +0100
@@ -61,7 +61,7 @@ struct bfa_hwif_s {
 	void (*hw_isr_mode_set)(struct bfa_s *bfa, bfa_boolean_t msix);
 	void (*hw_msix_getvecs)(struct bfa_s *bfa, u32 *vecmap,
 			u32 *nvecs, u32 *maxvec);
-};
+} __no_const;
 typedef void (*bfa_cb_iocfc_t) (void *cbarg, enum bfa_status status);
 
 struct bfa_iocfc_s {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/bfa/bfa_ioc.h linux-2.6.32.60-pax/drivers/scsi/bfa/bfa_ioc.h
--- linux-2.6.32.60/drivers/scsi/bfa/bfa_ioc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/bfa/bfa_ioc.h	2012-03-13 13:15:35.256097983 +0100
@@ -127,7 +127,7 @@ struct bfa_ioc_cbfn_s {
 	bfa_ioc_disable_cbfn_t	disable_cbfn;
 	bfa_ioc_hbfail_cbfn_t	hbfail_cbfn;
 	bfa_ioc_reset_cbfn_t	reset_cbfn;
-};
+} __no_const;
 
 /**
  * Heartbeat failure notification queue element.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/fnic/fnic_main.c linux-2.6.32.60-pax/drivers/scsi/fnic/fnic_main.c
--- linux-2.6.32.60/drivers/scsi/fnic/fnic_main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/fnic/fnic_main.c	2012-03-13 13:15:35.256097983 +0100
@@ -669,7 +669,7 @@ static int __devinit fnic_probe(struct p
 	/* Start local port initiatialization */
 
 	lp->link_up = 0;
-	lp->tt = fnic_transport_template;
+	memcpy((void *)&lp->tt, &fnic_transport_template, sizeof(fnic_transport_template));
 
 	lp->max_retry_count = fnic->config.flogi_retries;
 	lp->max_rport_retry_count = fnic->config.plogi_retries;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/hosts.c linux-2.6.32.60-pax/drivers/scsi/hosts.c
--- linux-2.6.32.60/drivers/scsi/hosts.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/hosts.c	2012-03-13 13:15:35.260097983 +0100
@@ -40,7 +40,7 @@
 #include "scsi_logging.h"
 
 
-static atomic_t scsi_host_next_hn;	/* host_no for next new host */
+static atomic_unchecked_t scsi_host_next_hn;	/* host_no for next new host */
 
 
 static void scsi_host_cls_release(struct device *dev)
@@ -347,7 +347,7 @@ struct Scsi_Host *scsi_host_alloc(struct
 	 * subtract one because we increment first then return, but we need to
 	 * know what the next host number was before increment
 	 */
-	shost->host_no = atomic_inc_return(&scsi_host_next_hn) - 1;
+	shost->host_no = atomic_inc_return_unchecked(&scsi_host_next_hn) - 1;
 	shost->dma_channel = 0xff;
 
 	/* These three are default values which can be overridden */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/libfc/fc_exch.c linux-2.6.32.60-pax/drivers/scsi/libfc/fc_exch.c
--- linux-2.6.32.60/drivers/scsi/libfc/fc_exch.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/libfc/fc_exch.c	2012-03-13 13:15:35.260097983 +0100
@@ -86,12 +86,12 @@ struct fc_exch_mgr {
 	 * all together if not used XXX
 	 */
 	struct {
-		atomic_t no_free_exch;
-		atomic_t no_free_exch_xid;
-		atomic_t xid_not_found;
-		atomic_t xid_busy;
-		atomic_t seq_not_found;
-		atomic_t non_bls_resp;
+		atomic_unchecked_t no_free_exch;
+		atomic_unchecked_t no_free_exch_xid;
+		atomic_unchecked_t xid_not_found;
+		atomic_unchecked_t xid_busy;
+		atomic_unchecked_t seq_not_found;
+		atomic_unchecked_t non_bls_resp;
 	} stats;
 };
 #define	fc_seq_exch(sp) container_of(sp, struct fc_exch, seq)
@@ -510,7 +510,7 @@ static struct fc_exch *fc_exch_em_alloc(
 	/* allocate memory for exchange */
 	ep = mempool_alloc(mp->ep_pool, GFP_ATOMIC);
 	if (!ep) {
-		atomic_inc(&mp->stats.no_free_exch);
+		atomic_inc_unchecked(&mp->stats.no_free_exch);
 		goto out;
 	}
 	memset(ep, 0, sizeof(*ep));
@@ -557,7 +557,7 @@ out:
 	return ep;
 err:
 	spin_unlock_bh(&pool->lock);
-	atomic_inc(&mp->stats.no_free_exch_xid);
+	atomic_inc_unchecked(&mp->stats.no_free_exch_xid);
 	mempool_free(ep, mp->ep_pool);
 	return NULL;
 }
@@ -690,7 +690,7 @@ static enum fc_pf_rjt_reason fc_seq_look
 		xid = ntohs(fh->fh_ox_id);	/* we originated exch */
 		ep = fc_exch_find(mp, xid);
 		if (!ep) {
-			atomic_inc(&mp->stats.xid_not_found);
+			atomic_inc_unchecked(&mp->stats.xid_not_found);
 			reject = FC_RJT_OX_ID;
 			goto out;
 		}
@@ -720,7 +720,7 @@ static enum fc_pf_rjt_reason fc_seq_look
 		ep = fc_exch_find(mp, xid);
 		if ((f_ctl & FC_FC_FIRST_SEQ) && fc_sof_is_init(fr_sof(fp))) {
 			if (ep) {
-				atomic_inc(&mp->stats.xid_busy);
+				atomic_inc_unchecked(&mp->stats.xid_busy);
 				reject = FC_RJT_RX_ID;
 				goto rel;
 			}
@@ -731,7 +731,7 @@ static enum fc_pf_rjt_reason fc_seq_look
 			}
 			xid = ep->xid;	/* get our XID */
 		} else if (!ep) {
-			atomic_inc(&mp->stats.xid_not_found);
+			atomic_inc_unchecked(&mp->stats.xid_not_found);
 			reject = FC_RJT_RX_ID;	/* XID not found */
 			goto out;
 		}
@@ -752,7 +752,7 @@ static enum fc_pf_rjt_reason fc_seq_look
 	} else {
 		sp = &ep->seq;
 		if (sp->id != fh->fh_seq_id) {
-			atomic_inc(&mp->stats.seq_not_found);
+			atomic_inc_unchecked(&mp->stats.seq_not_found);
 			reject = FC_RJT_SEQ_ID;	/* sequence/exch should exist */
 			goto rel;
 		}
@@ -1163,22 +1163,22 @@ static void fc_exch_recv_seq_resp(struct
 
 	ep = fc_exch_find(mp, ntohs(fh->fh_ox_id));
 	if (!ep) {
-		atomic_inc(&mp->stats.xid_not_found);
+		atomic_inc_unchecked(&mp->stats.xid_not_found);
 		goto out;
 	}
 	if (ep->esb_stat & ESB_ST_COMPLETE) {
-		atomic_inc(&mp->stats.xid_not_found);
+		atomic_inc_unchecked(&mp->stats.xid_not_found);
 		goto out;
 	}
 	if (ep->rxid == FC_XID_UNKNOWN)
 		ep->rxid = ntohs(fh->fh_rx_id);
 	if (ep->sid != 0 && ep->sid != ntoh24(fh->fh_d_id)) {
-		atomic_inc(&mp->stats.xid_not_found);
+		atomic_inc_unchecked(&mp->stats.xid_not_found);
 		goto rel;
 	}
 	if (ep->did != ntoh24(fh->fh_s_id) &&
 	    ep->did != FC_FID_FLOGI) {
-		atomic_inc(&mp->stats.xid_not_found);
+		atomic_inc_unchecked(&mp->stats.xid_not_found);
 		goto rel;
 	}
 	sof = fr_sof(fp);
@@ -1189,7 +1189,7 @@ static void fc_exch_recv_seq_resp(struct
 	} else {
 		sp = &ep->seq;
 		if (sp->id != fh->fh_seq_id) {
-			atomic_inc(&mp->stats.seq_not_found);
+			atomic_inc_unchecked(&mp->stats.seq_not_found);
 			goto rel;
 		}
 	}
@@ -1249,9 +1249,9 @@ static void fc_exch_recv_resp(struct fc_
 	sp = fc_seq_lookup_orig(mp, fp);	/* doesn't hold sequence */
 
 	if (!sp)
-		atomic_inc(&mp->stats.xid_not_found);
+		atomic_inc_unchecked(&mp->stats.xid_not_found);
 	else
-		atomic_inc(&mp->stats.non_bls_resp);
+		atomic_inc_unchecked(&mp->stats.non_bls_resp);
 
 	fc_frame_free(fp);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/lpfc/lpfc_debugfs.c linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_debugfs.c
--- linux-2.6.32.60/drivers/scsi/lpfc/lpfc_debugfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_debugfs.c	2012-03-13 13:15:35.264097983 +0100
@@ -124,7 +124,7 @@ struct lpfc_debug {
 	int  len;
 };
 
-static atomic_t lpfc_debugfs_seq_trc_cnt = ATOMIC_INIT(0);
+static atomic_unchecked_t lpfc_debugfs_seq_trc_cnt = ATOMIC_INIT(0);
 static unsigned long lpfc_debugfs_start_time = 0L;
 
 /**
@@ -158,7 +158,7 @@ lpfc_debugfs_disc_trc_data(struct lpfc_v
 	lpfc_debugfs_enable = 0;
 
 	len = 0;
-	index = (atomic_read(&vport->disc_trc_cnt) + 1) &
+	index = (atomic_read_unchecked(&vport->disc_trc_cnt) + 1) &
 		(lpfc_debugfs_max_disc_trc - 1);
 	for (i = index; i < lpfc_debugfs_max_disc_trc; i++) {
 		dtp = vport->disc_trc + i;
@@ -219,7 +219,7 @@ lpfc_debugfs_slow_ring_trc_data(struct l
 	lpfc_debugfs_enable = 0;
 
 	len = 0;
-	index = (atomic_read(&phba->slow_ring_trc_cnt) + 1) &
+	index = (atomic_read_unchecked(&phba->slow_ring_trc_cnt) + 1) &
 		(lpfc_debugfs_max_slow_ring_trc - 1);
 	for (i = index; i < lpfc_debugfs_max_slow_ring_trc; i++) {
 		dtp = phba->slow_ring_trc + i;
@@ -634,14 +634,14 @@ lpfc_debugfs_disc_trc(struct lpfc_vport
 		!vport || !vport->disc_trc)
 		return;
 
-	index = atomic_inc_return(&vport->disc_trc_cnt) &
+	index = atomic_inc_return_unchecked(&vport->disc_trc_cnt) &
 		(lpfc_debugfs_max_disc_trc - 1);
 	dtp = vport->disc_trc + index;
 	dtp->fmt = fmt;
 	dtp->data1 = data1;
 	dtp->data2 = data2;
 	dtp->data3 = data3;
-	dtp->seq_cnt = atomic_inc_return(&lpfc_debugfs_seq_trc_cnt);
+	dtp->seq_cnt = atomic_inc_return_unchecked(&lpfc_debugfs_seq_trc_cnt);
 	dtp->jif = jiffies;
 #endif
 	return;
@@ -672,14 +672,14 @@ lpfc_debugfs_slow_ring_trc(struct lpfc_h
 		!phba || !phba->slow_ring_trc)
 		return;
 
-	index = atomic_inc_return(&phba->slow_ring_trc_cnt) &
+	index = atomic_inc_return_unchecked(&phba->slow_ring_trc_cnt) &
 		(lpfc_debugfs_max_slow_ring_trc - 1);
 	dtp = phba->slow_ring_trc + index;
 	dtp->fmt = fmt;
 	dtp->data1 = data1;
 	dtp->data2 = data2;
 	dtp->data3 = data3;
-	dtp->seq_cnt = atomic_inc_return(&lpfc_debugfs_seq_trc_cnt);
+	dtp->seq_cnt = atomic_inc_return_unchecked(&lpfc_debugfs_seq_trc_cnt);
 	dtp->jif = jiffies;
 #endif
 	return;
@@ -1364,7 +1364,7 @@ lpfc_debugfs_initialize(struct lpfc_vpor
 						 "slow_ring buffer\n");
 				goto debug_failed;
 			}
-			atomic_set(&phba->slow_ring_trc_cnt, 0);
+			atomic_set_unchecked(&phba->slow_ring_trc_cnt, 0);
 			memset(phba->slow_ring_trc, 0,
 				(sizeof(struct lpfc_debugfs_trc) *
 				lpfc_debugfs_max_slow_ring_trc));
@@ -1410,7 +1410,7 @@ lpfc_debugfs_initialize(struct lpfc_vpor
 				 "buffer\n");
 		goto debug_failed;
 	}
-	atomic_set(&vport->disc_trc_cnt, 0);
+	atomic_set_unchecked(&vport->disc_trc_cnt, 0);
 
 	snprintf(name, sizeof(name), "discovery_trace");
 	vport->debug_disc_trc =
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/lpfc/lpfc.h linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc.h
--- linux-2.6.32.60/drivers/scsi/lpfc/lpfc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc.h	2012-03-13 13:15:35.264097983 +0100
@@ -400,7 +400,7 @@ struct lpfc_vport {
 	struct dentry *debug_nodelist;
 	struct dentry *vport_debugfs_root;
 	struct lpfc_debugfs_trc *disc_trc;
-	atomic_t disc_trc_cnt;
+	atomic_unchecked_t disc_trc_cnt;
 #endif
 	uint8_t stat_data_enabled;
 	uint8_t stat_data_blocked;
@@ -725,8 +725,8 @@ struct lpfc_hba {
 	struct timer_list fabric_block_timer;
 	unsigned long bit_flags;
 #define	FABRIC_COMANDS_BLOCKED	0
-	atomic_t num_rsrc_err;
-	atomic_t num_cmd_success;
+	atomic_unchecked_t num_rsrc_err;
+	atomic_unchecked_t num_cmd_success;
 	unsigned long last_rsrc_error_time;
 	unsigned long last_ramp_down_time;
 	unsigned long last_ramp_up_time;
@@ -740,7 +740,7 @@ struct lpfc_hba {
 	struct dentry *debug_dumpDif;    /* BlockGuard BPL*/
 	struct dentry *debug_slow_ring_trc;
 	struct lpfc_debugfs_trc *slow_ring_trc;
-	atomic_t slow_ring_trc_cnt;
+	atomic_unchecked_t slow_ring_trc_cnt;
 #endif
 
 	/* Used for deferred freeing of ELS data buffers */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/lpfc/lpfc_init.c linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_init.c
--- linux-2.6.32.60/drivers/scsi/lpfc/lpfc_init.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_init.c	2012-03-13 13:15:35.268097983 +0100
@@ -8021,8 +8021,10 @@ lpfc_init(void)
 	printk(LPFC_COPYRIGHT "\n");
 
 	if (lpfc_enable_npiv) {
-		lpfc_transport_functions.vport_create = lpfc_vport_create;
-		lpfc_transport_functions.vport_delete = lpfc_vport_delete;
+		pax_open_kernel();
+		*(void **)&lpfc_transport_functions.vport_create = lpfc_vport_create;
+		*(void **)&lpfc_transport_functions.vport_delete = lpfc_vport_delete;
+		pax_close_kernel();
 	}
 	lpfc_transport_template =
 				fc_attach_transport(&lpfc_transport_functions);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/lpfc/lpfc_scsi.c linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_scsi.c
--- linux-2.6.32.60/drivers/scsi/lpfc/lpfc_scsi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/lpfc/lpfc_scsi.c	2012-03-13 13:15:35.272097983 +0100
@@ -259,7 +259,7 @@ lpfc_rampdown_queue_depth(struct lpfc_hb
 	uint32_t evt_posted;
 
 	spin_lock_irqsave(&phba->hbalock, flags);
-	atomic_inc(&phba->num_rsrc_err);
+	atomic_inc_unchecked(&phba->num_rsrc_err);
 	phba->last_rsrc_error_time = jiffies;
 
 	if ((phba->last_ramp_down_time + QUEUE_RAMP_DOWN_INTERVAL) > jiffies) {
@@ -300,7 +300,7 @@ lpfc_rampup_queue_depth(struct lpfc_vpor
 	unsigned long flags;
 	struct lpfc_hba *phba = vport->phba;
 	uint32_t evt_posted;
-	atomic_inc(&phba->num_cmd_success);
+	atomic_inc_unchecked(&phba->num_cmd_success);
 
 	if (vport->cfg_lun_queue_depth <= queue_depth)
 		return;
@@ -343,8 +343,8 @@ lpfc_ramp_down_queue_handler(struct lpfc
 	int i;
 	struct lpfc_rport_data *rdata;
 
-	num_rsrc_err = atomic_read(&phba->num_rsrc_err);
-	num_cmd_success = atomic_read(&phba->num_cmd_success);
+	num_rsrc_err = atomic_read_unchecked(&phba->num_rsrc_err);
+	num_cmd_success = atomic_read_unchecked(&phba->num_cmd_success);
 
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports != NULL)
@@ -378,8 +378,8 @@ lpfc_ramp_down_queue_handler(struct lpfc
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
-	atomic_set(&phba->num_rsrc_err, 0);
-	atomic_set(&phba->num_cmd_success, 0);
+	atomic_set_unchecked(&phba->num_rsrc_err, 0);
+	atomic_set_unchecked(&phba->num_cmd_success, 0);
 }
 
 /**
@@ -427,8 +427,8 @@ lpfc_ramp_up_queue_handler(struct lpfc_h
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
-	atomic_set(&phba->num_rsrc_err, 0);
-	atomic_set(&phba->num_cmd_success, 0);
+	atomic_set_unchecked(&phba->num_rsrc_err, 0);
+	atomic_set_unchecked(&phba->num_cmd_success, 0);
 }
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/pmcraid.c linux-2.6.32.60-pax/drivers/scsi/pmcraid.c
--- linux-2.6.32.60/drivers/scsi/pmcraid.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/pmcraid.c	2012-03-13 13:15:35.272097983 +0100
@@ -189,8 +189,8 @@ static int pmcraid_slave_alloc(struct sc
 		res->scsi_dev = scsi_dev;
 		scsi_dev->hostdata = res;
 		res->change_detected = 0;
-		atomic_set(&res->read_failures, 0);
-		atomic_set(&res->write_failures, 0);
+		atomic_set_unchecked(&res->read_failures, 0);
+		atomic_set_unchecked(&res->write_failures, 0);
 		rc = 0;
 	}
 	spin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);
@@ -2396,9 +2396,9 @@ static int pmcraid_error_handler(struct
 
 	/* If this was a SCSI read/write command keep count of errors */
 	if (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_READ_CMD)
-		atomic_inc(&res->read_failures);
+		atomic_inc_unchecked(&res->read_failures);
 	else if (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_WRITE_CMD)
-		atomic_inc(&res->write_failures);
+		atomic_inc_unchecked(&res->write_failures);
 
 	if (!RES_IS_GSCSI(res->cfg_entry) &&
 		masked_ioasc != PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR) {
@@ -4116,7 +4116,7 @@ static void pmcraid_worker_function(stru
 
 	pinstance = container_of(workp, struct pmcraid_instance, worker_q);
 	/* add resources only after host is added into system */
-	if (!atomic_read(&pinstance->expose_resources))
+	if (!atomic_read_unchecked(&pinstance->expose_resources))
 		return;
 
 	spin_lock_irqsave(&pinstance->resource_lock, lock_flags);
@@ -4850,7 +4850,7 @@ static int __devinit pmcraid_init_instan
 	init_waitqueue_head(&pinstance->reset_wait_q);
 
 	atomic_set(&pinstance->outstanding_cmds, 0);
-	atomic_set(&pinstance->expose_resources, 0);
+	atomic_set_unchecked(&pinstance->expose_resources, 0);
 
 	INIT_LIST_HEAD(&pinstance->free_res_q);
 	INIT_LIST_HEAD(&pinstance->used_res_q);
@@ -5502,7 +5502,7 @@ static int __devinit pmcraid_probe(
 	/* Schedule worker thread to handle CCN and take care of adding and
 	 * removing devices to OS
 	 */
-	atomic_set(&pinstance->expose_resources, 1);
+	atomic_set_unchecked(&pinstance->expose_resources, 1);
 	schedule_work(&pinstance->worker_q);
 	return rc;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/pmcraid.h linux-2.6.32.60-pax/drivers/scsi/pmcraid.h
--- linux-2.6.32.60/drivers/scsi/pmcraid.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/pmcraid.h	2012-03-13 13:15:35.276097982 +0100
@@ -690,7 +690,7 @@ struct pmcraid_instance {
 	atomic_t outstanding_cmds;
 
 	/* should add/delete resources to mid-layer now ?*/
-	atomic_t expose_resources;
+	atomic_unchecked_t expose_resources;
 
 	/* Tasklet to handle deferred processing */
 	struct tasklet_struct isr_tasklet[PMCRAID_NUM_MSIX_VECTORS];
@@ -727,8 +727,8 @@ struct pmcraid_resource_entry {
 	struct list_head queue;	/* link to "to be exposed" resources */
 	struct pmcraid_config_table_entry cfg_entry;
 	struct scsi_device *scsi_dev;	/* Link scsi_device structure */
-	atomic_t read_failures;		/* count of failed READ commands */
-	atomic_t write_failures;	/* count of failed WRITE commands */
+	atomic_unchecked_t read_failures;		/* count of failed READ commands */
+	atomic_unchecked_t write_failures;	/* count of failed WRITE commands */
 
 	/* To indicate add/delete/modify during CCN */
 	u8 change_detected;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/qla2xxx/qla_os.c linux-2.6.32.60-pax/drivers/scsi/qla2xxx/qla_os.c
--- linux-2.6.32.60/drivers/scsi/qla2xxx/qla_os.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/qla2xxx/qla_os.c	2013-01-22 17:38:23.560543626 +0100
@@ -1274,8 +1274,10 @@ qla2x00_config_dma_addressing(struct qla
 		    !pci_set_consistent_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {
 			/* Ok, a 64bit DMA mask is applicable. */
 			ha->flags.enable_64bit_addressing = 1;
-			ha->isp_ops->calc_req_entries = qla2x00_calc_iocbs_64;
-			ha->isp_ops->build_iocbs = qla2x00_build_scsi_iocbs_64;
+			pax_open_kernel();
+			*(void **)&ha->isp_ops->calc_req_entries = qla2x00_calc_iocbs_64;
+			*(void **)&ha->isp_ops->build_iocbs = qla2x00_build_scsi_iocbs_64;
+			pax_close_kernel();
 			return;
 		}
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_def.h linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_def.h
--- linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_def.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_def.h	2012-03-13 13:15:35.280097982 +0100
@@ -240,7 +240,7 @@ struct ddb_entry {
 	atomic_t retry_relogin_timer; /* Min Time between relogins
 				       * (4000 only) */
 	atomic_t relogin_timer;	/* Max Time to wait for relogin to complete */
-	atomic_t relogin_retry_count; /* Num of times relogin has been
+	atomic_unchecked_t relogin_retry_count; /* Num of times relogin has been
 				       * retried */
 
 	uint16_t port;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_init.c linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_init.c
--- linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_init.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_init.c	2012-03-13 13:15:35.280097982 +0100
@@ -482,7 +482,7 @@ static struct ddb_entry * qla4xxx_alloc_
 	atomic_set(&ddb_entry->port_down_timer, ha->port_down_retry_count);
 	atomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);
 	atomic_set(&ddb_entry->relogin_timer, 0);
-	atomic_set(&ddb_entry->relogin_retry_count, 0);
+	atomic_set_unchecked(&ddb_entry->relogin_retry_count, 0);
 	atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
 	list_add_tail(&ddb_entry->list, &ha->ddb_list);
 	ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
@@ -1308,7 +1308,7 @@ int qla4xxx_process_ddb_changed(struct s
 		atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
 		atomic_set(&ddb_entry->port_down_timer,
 			   ha->port_down_retry_count);
-		atomic_set(&ddb_entry->relogin_retry_count, 0);
+		atomic_set_unchecked(&ddb_entry->relogin_retry_count, 0);
 		atomic_set(&ddb_entry->relogin_timer, 0);
 		clear_bit(DF_RELOGIN, &ddb_entry->flags);
 		clear_bit(DF_NO_RELOGIN, &ddb_entry->flags);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_os.c linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_os.c
--- linux-2.6.32.60/drivers/scsi/qla4xxx/ql4_os.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/qla4xxx/ql4_os.c	2012-03-13 13:15:35.280097982 +0100
@@ -641,13 +641,13 @@ static void qla4xxx_timer(struct scsi_ql
 			    ddb_entry->fw_ddb_device_state ==
 			    DDB_DS_SESSION_FAILED) {
 				/* Reset retry relogin timer */
-				atomic_inc(&ddb_entry->relogin_retry_count);
+				atomic_inc_unchecked(&ddb_entry->relogin_retry_count);
 				DEBUG2(printk("scsi%ld: index[%d] relogin"
 					      " timed out-retrying"
 					      " relogin (%d)\n",
 					      ha->host_no,
 					      ddb_entry->fw_ddb_index,
-					      atomic_read(&ddb_entry->
+					      atomic_read_unchecked(&ddb_entry->
 							  relogin_retry_count))
 					);
 				start_dpc++;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi.c linux-2.6.32.60-pax/drivers/scsi/scsi.c
--- linux-2.6.32.60/drivers/scsi/scsi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi.c	2012-03-13 13:15:35.284097982 +0100
@@ -652,7 +652,7 @@ int scsi_dispatch_cmd(struct scsi_cmnd *
 	unsigned long timeout;
 	int rtn = 0;
 
-	atomic_inc(&cmd->device->iorequest_cnt);
+	atomic_inc_unchecked(&cmd->device->iorequest_cnt);
 
 	/* check if the device is still usable */
 	if (unlikely(cmd->device->sdev_state == SDEV_DEL)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_lib.c linux-2.6.32.60-pax/drivers/scsi/scsi_lib.c
--- linux-2.6.32.60/drivers/scsi/scsi_lib.c	2012-10-09 11:00:35.464882471 +0200
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_lib.c	2012-10-09 11:00:39.288883037 +0200
@@ -1400,7 +1400,7 @@ static void scsi_kill_request(struct req
 	shost = sdev->host;
 	scsi_init_cmd_errh(cmd);
 	cmd->result = DID_NO_CONNECT << 16;
-	atomic_inc(&cmd->device->iorequest_cnt);
+	atomic_inc_unchecked(&cmd->device->iorequest_cnt);
 
 	/*
 	 * SCSI request completion path will do scsi_device_unbusy(),
@@ -1431,9 +1431,9 @@ static void scsi_softirq_done(struct req
 	 */
 	cmd->serial_number = 0;
 
-	atomic_inc(&cmd->device->iodone_cnt);
+	atomic_inc_unchecked(&cmd->device->iodone_cnt);
 	if (cmd->result)
-		atomic_inc(&cmd->device->ioerr_cnt);
+		atomic_inc_unchecked(&cmd->device->ioerr_cnt);
 
 	disposition = scsi_decide_disposition(cmd);
 	if (disposition != SUCCESS &&
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_sysfs.c linux-2.6.32.60-pax/drivers/scsi/scsi_sysfs.c
--- linux-2.6.32.60/drivers/scsi/scsi_sysfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_sysfs.c	2012-03-13 13:15:35.284097982 +0100
@@ -662,7 +662,7 @@ show_iostat_##field(struct device *dev,
 		    char *buf)						\
 {									\
 	struct scsi_device *sdev = to_scsi_device(dev);			\
-	unsigned long long count = atomic_read(&sdev->field);		\
+	unsigned long long count = atomic_read_unchecked(&sdev->field);	\
 	return snprintf(buf, 20, "0x%llx\n", count);			\
 }									\
 static DEVICE_ATTR(field, S_IRUGO, show_iostat_##field, NULL)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_tgt_lib.c linux-2.6.32.60-pax/drivers/scsi/scsi_tgt_lib.c
--- linux-2.6.32.60/drivers/scsi/scsi_tgt_lib.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_tgt_lib.c	2012-03-13 13:15:35.288097982 +0100
@@ -362,7 +362,7 @@ static int scsi_map_user_pages(struct sc
 	int err;
 
 	dprintk("%lx %u\n", uaddr, len);
-	err = blk_rq_map_user(q, rq, NULL, (void *)uaddr, len, GFP_KERNEL);
+	err = blk_rq_map_user(q, rq, NULL, (void __user *)uaddr, len, GFP_KERNEL);
 	if (err) {
 		/*
 		 * TODO: need to fixup sg_tablesize, max_segment_size,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_transport_fc.c linux-2.6.32.60-pax/drivers/scsi/scsi_transport_fc.c
--- linux-2.6.32.60/drivers/scsi/scsi_transport_fc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_transport_fc.c	2012-03-13 13:15:35.288097982 +0100
@@ -480,7 +480,7 @@ MODULE_PARM_DESC(dev_loss_tmo,
  * Netlink Infrastructure
  */
 
-static atomic_t fc_event_seq;
+static atomic_unchecked_t fc_event_seq;
 
 /**
  * fc_get_event_number - Obtain the next sequential FC event number
@@ -493,7 +493,7 @@ static atomic_t fc_event_seq;
 u32
 fc_get_event_number(void)
 {
-	return atomic_add_return(1, &fc_event_seq);
+	return atomic_add_return_unchecked(1, &fc_event_seq);
 }
 EXPORT_SYMBOL(fc_get_event_number);
 
@@ -641,7 +641,7 @@ static __init int fc_transport_init(void
 {
 	int error;
 
-	atomic_set(&fc_event_seq, 0);
+	atomic_set_unchecked(&fc_event_seq, 0);
 
 	error = transport_class_register(&fc_host_class);
 	if (error)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_transport_iscsi.c linux-2.6.32.60-pax/drivers/scsi/scsi_transport_iscsi.c
--- linux-2.6.32.60/drivers/scsi/scsi_transport_iscsi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_transport_iscsi.c	2012-03-13 13:15:35.292097981 +0100
@@ -81,7 +81,7 @@ struct iscsi_internal {
 	struct device_attribute *session_attrs[ISCSI_SESSION_ATTRS + 1];
 };
 
-static atomic_t iscsi_session_nr; /* sysfs session id for next new session */
+static atomic_unchecked_t iscsi_session_nr; /* sysfs session id for next new session */
 static struct workqueue_struct *iscsi_eh_timer_workq;
 
 /*
@@ -728,7 +728,7 @@ int iscsi_add_session(struct iscsi_cls_s
 	int err;
 
 	ihost = shost->shost_data;
-	session->sid = atomic_add_return(1, &iscsi_session_nr);
+	session->sid = atomic_add_return_unchecked(1, &iscsi_session_nr);
 
 	if (id == ISCSI_MAX_TARGET) {
 		for (id = 0; id < ISCSI_MAX_TARGET; id++) {
@@ -2060,7 +2060,7 @@ static __init int iscsi_transport_init(v
 	printk(KERN_INFO "Loading iSCSI transport class v%s.\n",
 		ISCSI_TRANSPORT_VERSION);
 
-	atomic_set(&iscsi_session_nr, 0);
+	atomic_set_unchecked(&iscsi_session_nr, 0);
 
 	err = class_register(&iscsi_transport_class);
 	if (err)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/scsi_transport_srp.c linux-2.6.32.60-pax/drivers/scsi/scsi_transport_srp.c
--- linux-2.6.32.60/drivers/scsi/scsi_transport_srp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/scsi_transport_srp.c	2012-03-13 13:15:35.292097981 +0100
@@ -33,7 +33,7 @@
 #include "scsi_transport_srp_internal.h"
 
 struct srp_host_attrs {
-	atomic_t next_port_id;
+	atomic_unchecked_t next_port_id;
 };
 #define to_srp_host_attrs(host)	((struct srp_host_attrs *)(host)->shost_data)
 
@@ -62,7 +62,7 @@ static int srp_host_setup(struct transpo
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct srp_host_attrs *srp_host = to_srp_host_attrs(shost);
 
-	atomic_set(&srp_host->next_port_id, 0);
+	atomic_set_unchecked(&srp_host->next_port_id, 0);
 	return 0;
 }
 
@@ -211,7 +211,7 @@ struct srp_rport *srp_rport_add(struct S
 	memcpy(rport->port_id, ids->port_id, sizeof(rport->port_id));
 	rport->roles = ids->roles;
 
-	id = atomic_inc_return(&to_srp_host_attrs(shost)->next_port_id);
+	id = atomic_inc_return_unchecked(&to_srp_host_attrs(shost)->next_port_id);
 	dev_set_name(&rport->dev, "port-%d:%d", shost->host_no, id);
 
 	transport_setup_device(&rport->dev);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/scsi/sg.c linux-2.6.32.60-pax/drivers/scsi/sg.c
--- linux-2.6.32.60/drivers/scsi/sg.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/scsi/sg.c	2012-03-13 13:15:35.292097981 +0100
@@ -1064,7 +1064,7 @@ sg_ioctl(struct inode *inode, struct fil
 				       sdp->disk->disk_name,
 				       MKDEV(SCSI_GENERIC_MAJOR, sdp->index),
 				       NULL,
-				       (char *)arg);
+				       (char __user *)arg);
 	case BLKTRACESTART:
 		return blk_trace_startstop(sdp->device->request_queue, 1);
 	case BLKTRACESTOP:
@@ -2307,7 +2307,7 @@ sg_proc_init(void)
 {
 	int k, mask;
 	int num_leaves = ARRAY_SIZE(sg_proc_leaf_arr);
-	struct sg_proc_leaf * leaf;
+	const struct sg_proc_leaf * leaf;
 
 	sg_proc_sgp = proc_mkdir(sg_proc_sg_dirname, NULL);
 	if (!sg_proc_sgp)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/serial/kgdboc.c linux-2.6.32.60-pax/drivers/serial/kgdboc.c
--- linux-2.6.32.60/drivers/serial/kgdboc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/serial/kgdboc.c	2012-03-13 13:15:35.296097981 +0100
@@ -18,7 +18,7 @@
 
 #define MAX_CONFIG_LEN		40
 
-static struct kgdb_io		kgdboc_io_ops;
+static struct kgdb_io	kgdboc_io_ops;
 
 /* -1 = init not run yet, 0 = unconfigured, 1 = configured. */
 static int configured		= -1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/spi/spi.c linux-2.6.32.60-pax/drivers/spi/spi.c
--- linux-2.6.32.60/drivers/spi/spi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/spi/spi.c	2012-03-13 13:15:35.300097981 +0100
@@ -774,7 +774,7 @@ int spi_sync(struct spi_device *spi, str
 EXPORT_SYMBOL_GPL(spi_sync);
 
 /* portable code must never pass more than 32 bytes */
-#define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
+#define	SPI_BUFSIZ	max(32U,SMP_CACHE_BYTES)
 
 static u8	*buf;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/dst/dcore.c linux-2.6.32.60-pax/drivers/staging/dst/dcore.c
--- linux-2.6.32.60/drivers/staging/dst/dcore.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/dst/dcore.c	2012-03-13 13:15:35.304097981 +0100
@@ -588,7 +588,7 @@ static struct dst_node *dst_alloc_node(s
 	n->size = ctl->size;
 
 	atomic_set(&n->refcnt, 1);
-	atomic_long_set(&n->gen, 0);
+	atomic_long_set_unchecked(&n->gen, 0);
 	snprintf(n->name, sizeof(n->name), "%s", ctl->name);
 
 	err = dst_node_sysfs_init(n);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/dst/trans.c linux-2.6.32.60-pax/drivers/staging/dst/trans.c
--- linux-2.6.32.60/drivers/staging/dst/trans.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/dst/trans.c	2012-03-13 13:15:35.308097981 +0100
@@ -169,7 +169,7 @@ int dst_process_bio(struct dst_node *n,
 	t->error = 0;
 	t->retries = 0;
 	atomic_set(&t->refcnt, 1);
-	t->gen = atomic_long_inc_return(&n->gen);
+	t->gen = atomic_long_inc_return_unchecked(&n->gen);
 
 	t->enc = bio_data_dir(bio);
 	dst_bio_to_cmd(bio, &t->cmd, DST_IO, t->gen);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/et131x/et1310_tx.c linux-2.6.32.60-pax/drivers/staging/et131x/et1310_tx.c
--- linux-2.6.32.60/drivers/staging/et131x/et1310_tx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/et131x/et1310_tx.c	2012-03-13 13:15:35.312097980 +0100
@@ -710,11 +710,11 @@ inline void et131x_free_send_packet(stru
 	struct net_device_stats *stats = &etdev->net_stats;
 
 	if (pMpTcb->Flags & fMP_DEST_BROAD)
-		atomic_inc(&etdev->Stats.brdcstxmt);
+		atomic_inc_unchecked(&etdev->Stats.brdcstxmt);
 	else if (pMpTcb->Flags & fMP_DEST_MULTI)
-		atomic_inc(&etdev->Stats.multixmt);
+		atomic_inc_unchecked(&etdev->Stats.multixmt);
 	else
-		atomic_inc(&etdev->Stats.unixmt);
+		atomic_inc_unchecked(&etdev->Stats.unixmt);
 
 	if (pMpTcb->Packet) {
 		stats->tx_bytes += pMpTcb->Packet->len;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/et131x/et131x_adapter.h linux-2.6.32.60-pax/drivers/staging/et131x/et131x_adapter.h
--- linux-2.6.32.60/drivers/staging/et131x/et131x_adapter.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/et131x/et131x_adapter.h	2012-03-13 13:15:35.312097980 +0100
@@ -145,11 +145,11 @@ typedef struct _ce_stats_t {
 	 * operations
 	 */
 	u32 unircv;	/* # multicast packets received */
-	atomic_t unixmt;	/* # multicast packets for Tx */
+	atomic_unchecked_t unixmt;	/* # multicast packets for Tx */
 	u32 multircv;	/* # multicast packets received */
-	atomic_t multixmt;	/* # multicast packets for Tx */
+	atomic_unchecked_t multixmt;	/* # multicast packets for Tx */
 	u32 brdcstrcv;	/* # broadcast packets received */
-	atomic_t brdcstxmt;	/* # broadcast packets for Tx */
+	atomic_unchecked_t brdcstxmt;	/* # broadcast packets for Tx */
 	u32 norcvbuf;	/* # Rx packets discarded */
 	u32 noxmtbuf;	/* # Tx packets discarded */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/hv/Channel.c linux-2.6.32.60-pax/drivers/staging/hv/Channel.c
--- linux-2.6.32.60/drivers/staging/hv/Channel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/hv/Channel.c	2012-03-13 13:15:35.312097980 +0100
@@ -464,8 +464,8 @@ int VmbusChannelEstablishGpadl(struct vm
 
 	DPRINT_ENTER(VMBUS);
 
-	nextGpadlHandle = atomic_read(&gVmbusConnection.NextGpadlHandle);
-	atomic_inc(&gVmbusConnection.NextGpadlHandle);
+	nextGpadlHandle = atomic_read_unchecked(&gVmbusConnection.NextGpadlHandle);
+	atomic_inc_unchecked(&gVmbusConnection.NextGpadlHandle);
 
 	VmbusChannelCreateGpadlHeader(Kbuffer, Size, &msgInfo, &msgCount);
 	ASSERT(msgInfo != NULL);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/hv/Hv.c linux-2.6.32.60-pax/drivers/staging/hv/Hv.c
--- linux-2.6.32.60/drivers/staging/hv/Hv.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/hv/Hv.c	2012-03-13 13:15:35.312097980 +0100
@@ -161,7 +161,7 @@ static u64 HvDoHypercall(u64 Control, vo
 	u64 outputAddress = (Output) ? virt_to_phys(Output) : 0;
 	u32 outputAddressHi = outputAddress >> 32;
 	u32 outputAddressLo = outputAddress & 0xFFFFFFFF;
-	volatile void *hypercallPage = gHvContext.HypercallPage;
+	volatile void *hypercallPage = ktva_ktla(gHvContext.HypercallPage);
 
 	DPRINT_DBG(VMBUS, "Hypercall <control %llx input %p output %p>",
 		   Control, Input, Output);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/hv/VmbusApi.h linux-2.6.32.60-pax/drivers/staging/hv/VmbusApi.h
--- linux-2.6.32.60/drivers/staging/hv/VmbusApi.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/hv/VmbusApi.h	2012-03-13 13:15:35.312097980 +0100
@@ -109,7 +109,7 @@ struct vmbus_channel_interface {
 			      u32 *GpadlHandle);
 	int (*TeardownGpadl)(struct hv_device *device, u32 GpadlHandle);
 	void (*GetInfo)(struct hv_device *dev, struct hv_device_info *devinfo);
-};
+} __no_const;
 
 /* Base driver object */
 struct hv_driver {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/hv/vmbus_drv.c linux-2.6.32.60-pax/drivers/staging/hv/vmbus_drv.c
--- linux-2.6.32.60/drivers/staging/hv/vmbus_drv.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/hv/vmbus_drv.c	2012-03-13 13:15:35.316097980 +0100
@@ -532,7 +532,7 @@ static int vmbus_child_device_register(s
 				to_device_context(root_device_obj);
 	struct device_context *child_device_ctx =
 				to_device_context(child_device_obj);
-	static atomic_t device_num = ATOMIC_INIT(0);
+	static atomic_unchecked_t device_num = ATOMIC_INIT(0);
 
 	DPRINT_ENTER(VMBUS_DRV);
 
@@ -541,7 +541,7 @@ static int vmbus_child_device_register(s
 
 	/* Set the device name. Otherwise, device_register() will fail. */
 	dev_set_name(&child_device_ctx->device, "vmbus_0_%d",
-		     atomic_inc_return(&device_num));
+		     atomic_inc_return_unchecked(&device_num));
 
 	/* The new device belongs to this bus */
 	child_device_ctx->device.bus = &g_vmbus_drv.bus; /* device->dev.bus; */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/hv/VmbusPrivate.h linux-2.6.32.60-pax/drivers/staging/hv/VmbusPrivate.h
--- linux-2.6.32.60/drivers/staging/hv/VmbusPrivate.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/hv/VmbusPrivate.h	2012-03-13 13:15:35.316097980 +0100
@@ -59,7 +59,7 @@ enum VMBUS_CONNECT_STATE {
 struct VMBUS_CONNECTION {
 	enum VMBUS_CONNECT_STATE ConnectState;
 
-	atomic_t NextGpadlHandle;
+	atomic_unchecked_t NextGpadlHandle;
 
 	/*
 	 * Represents channel interrupts. Each bit position represents a
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/iio/ring_generic.h linux-2.6.32.60-pax/drivers/staging/iio/ring_generic.h
--- linux-2.6.32.60/drivers/staging/iio/ring_generic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/iio/ring_generic.h	2012-03-13 13:15:35.316097980 +0100
@@ -87,7 +87,7 @@ struct iio_ring_access_funcs {
 
 	int (*is_enabled)(struct iio_ring_buffer *ring);
 	int (*enable)(struct iio_ring_buffer *ring);
-};
+} __no_const;
 
 /**
  * struct iio_ring_buffer - general ring buffer structure
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/octeon/ethernet.c linux-2.6.32.60-pax/drivers/staging/octeon/ethernet.c
--- linux-2.6.32.60/drivers/staging/octeon/ethernet.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/octeon/ethernet.c	2012-03-13 13:15:35.316097980 +0100
@@ -294,11 +294,11 @@ static struct net_device_stats *cvm_oct_
 		 * since the RX tasklet also increments it.
 		 */
 #ifdef CONFIG_64BIT
-		atomic64_add(rx_status.dropped_packets,
-			     (atomic64_t *)&priv->stats.rx_dropped);
+		atomic64_add_unchecked(rx_status.dropped_packets,
+			     (atomic64_unchecked_t *)&priv->stats.rx_dropped);
 #else
-		atomic_add(rx_status.dropped_packets,
-			     (atomic_t *)&priv->stats.rx_dropped);
+		atomic_add_unchecked(rx_status.dropped_packets,
+			     (atomic_unchecked_t *)&priv->stats.rx_dropped);
 #endif
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/octeon/ethernet-rx.c linux-2.6.32.60-pax/drivers/staging/octeon/ethernet-rx.c
--- linux-2.6.32.60/drivers/staging/octeon/ethernet-rx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/octeon/ethernet-rx.c	2012-03-13 13:15:35.320097980 +0100
@@ -406,11 +406,11 @@ void cvm_oct_tasklet_rx(unsigned long un
 				/* Increment RX stats for virtual ports */
 				if (work->ipprt >= CVMX_PIP_NUM_INPUT_PORTS) {
 #ifdef CONFIG_64BIT
-					atomic64_add(1, (atomic64_t *)&priv->stats.rx_packets);
-					atomic64_add(skb->len, (atomic64_t *)&priv->stats.rx_bytes);
+					atomic64_add_unchecked(1, (atomic64_unchecked_t *)&priv->stats.rx_packets);
+					atomic64_add_unchecked(skb->len, (atomic64_unchecked_t *)&priv->stats.rx_bytes);
 #else
-					atomic_add(1, (atomic_t *)&priv->stats.rx_packets);
-					atomic_add(skb->len, (atomic_t *)&priv->stats.rx_bytes);
+					atomic_add_unchecked(1, (atomic_unchecked_t *)&priv->stats.rx_packets);
+					atomic_add_unchecked(skb->len, (atomic_unchecked_t *)&priv->stats.rx_bytes);
 #endif
 				}
 				netif_receive_skb(skb);
@@ -424,9 +424,9 @@ void cvm_oct_tasklet_rx(unsigned long un
 				   dev->name);
 				 */
 #ifdef CONFIG_64BIT
-				atomic64_add(1, (atomic64_t *)&priv->stats.rx_dropped);
+				atomic64_add_unchecked(1, (atomic64_t *)&priv->stats.rx_dropped);
 #else
-				atomic_add(1, (atomic_t *)&priv->stats.rx_dropped);
+				atomic_add_unchecked(1, (atomic_t *)&priv->stats.rx_dropped);
 #endif
 				dev_kfree_skb_irq(skb);
 			}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/otus/80211core/pub_zfi.h linux-2.6.32.60-pax/drivers/staging/otus/80211core/pub_zfi.h
--- linux-2.6.32.60/drivers/staging/otus/80211core/pub_zfi.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/otus/80211core/pub_zfi.h	2012-03-13 13:15:35.320097980 +0100
@@ -531,7 +531,7 @@ struct zsCbFuncTbl
     u8_t (*zfcbClassifyTxPacket)(zdev_t* dev, zbuf_t* buf);
 
     void (*zfcbHwWatchDogNotify)(zdev_t* dev);
-};
+} __no_const;
 
 extern void zfZeroMemory(u8_t* va, u16_t length);
 #define ZM_INIT_CB_FUNC_TABLE(p)        zfZeroMemory((u8_t *)p, sizeof(struct zsCbFuncTbl));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/pohmelfs/inode.c linux-2.6.32.60-pax/drivers/staging/pohmelfs/inode.c
--- linux-2.6.32.60/drivers/staging/pohmelfs/inode.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/pohmelfs/inode.c	2012-03-13 13:15:35.320097980 +0100
@@ -1850,7 +1850,7 @@ static int pohmelfs_fill_super(struct su
 	mutex_init(&psb->mcache_lock);
 	psb->mcache_root = RB_ROOT;
 	psb->mcache_timeout = msecs_to_jiffies(5000);
-	atomic_long_set(&psb->mcache_gen, 0);
+	atomic_long_set_unchecked(&psb->mcache_gen, 0);
 
 	psb->trans_max_pages = 100;
 
@@ -1865,7 +1865,7 @@ static int pohmelfs_fill_super(struct su
 	INIT_LIST_HEAD(&psb->crypto_ready_list);
 	INIT_LIST_HEAD(&psb->crypto_active_list);
 
-	atomic_set(&psb->trans_gen, 1);
+	atomic_set_unchecked(&psb->trans_gen, 1);
 	atomic_long_set(&psb->total_inodes, 0);
 
 	mutex_init(&psb->state_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/pohmelfs/mcache.c linux-2.6.32.60-pax/drivers/staging/pohmelfs/mcache.c
--- linux-2.6.32.60/drivers/staging/pohmelfs/mcache.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/pohmelfs/mcache.c	2012-03-13 13:15:35.324097980 +0100
@@ -121,7 +121,7 @@ struct pohmelfs_mcache *pohmelfs_mcache_
 	m->data = data;
 	m->start = start;
 	m->size = size;
-	m->gen = atomic_long_inc_return(&psb->mcache_gen);
+	m->gen = atomic_long_inc_return_unchecked(&psb->mcache_gen);
 
 	mutex_lock(&psb->mcache_lock);
 	err = pohmelfs_mcache_insert(psb, m);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/pohmelfs/netfs.h linux-2.6.32.60-pax/drivers/staging/pohmelfs/netfs.h
--- linux-2.6.32.60/drivers/staging/pohmelfs/netfs.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/pohmelfs/netfs.h	2012-03-13 13:15:35.324097980 +0100
@@ -570,14 +570,14 @@ struct pohmelfs_config;
 struct pohmelfs_sb {
 	struct rb_root		mcache_root;
 	struct mutex		mcache_lock;
-	atomic_long_t		mcache_gen;
+	atomic_long_unchecked_t	mcache_gen;
 	unsigned long		mcache_timeout;
 
 	unsigned int		idx;
 
 	unsigned int		trans_retries;
 
-	atomic_t		trans_gen;
+	atomic_unchecked_t	trans_gen;
 
 	unsigned int		crypto_attached_size;
 	unsigned int		crypto_align_size;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/pohmelfs/trans.c linux-2.6.32.60-pax/drivers/staging/pohmelfs/trans.c
--- linux-2.6.32.60/drivers/staging/pohmelfs/trans.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/pohmelfs/trans.c	2012-03-13 13:15:35.324097980 +0100
@@ -492,7 +492,7 @@ int netfs_trans_finish(struct netfs_tran
 	int err;
 	struct netfs_cmd *cmd = t->iovec.iov_base;
 
-	t->gen = atomic_inc_return(&psb->trans_gen);
+	t->gen = atomic_inc_return_unchecked(&psb->trans_gen);
 
 	cmd->size = t->iovec.iov_len - sizeof(struct netfs_cmd) +
 		t->attached_size + t->attached_pages * sizeof(struct netfs_cmd);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/usbip/vhci.h linux-2.6.32.60-pax/drivers/staging/usbip/vhci.h
--- linux-2.6.32.60/drivers/staging/usbip/vhci.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/usbip/vhci.h	2012-03-13 13:15:35.324097980 +0100
@@ -92,7 +92,7 @@ struct vhci_hcd {
 	unsigned	resuming:1;
 	unsigned long	re_timeout;
 
-	atomic_t seqnum;
+	atomic_unchecked_t seqnum;
 
 	/*
 	 * NOTE:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/usbip/vhci_hcd.c linux-2.6.32.60-pax/drivers/staging/usbip/vhci_hcd.c
--- linux-2.6.32.60/drivers/staging/usbip/vhci_hcd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/usbip/vhci_hcd.c	2012-03-13 13:15:35.328097980 +0100
@@ -534,7 +534,7 @@ static void vhci_tx_urb(struct urb *urb)
 		return;
 	}
 
-	priv->seqnum = atomic_inc_return(&the_controller->seqnum);
+	priv->seqnum = atomic_inc_return_unchecked(&the_controller->seqnum);
 	if (priv->seqnum == 0xffff)
 		usbip_uinfo("seqnum max\n");
 
@@ -793,7 +793,7 @@ static int vhci_urb_dequeue(struct usb_h
 			return -ENOMEM;
 		}
 
-		unlink->seqnum = atomic_inc_return(&the_controller->seqnum);
+		unlink->seqnum = atomic_inc_return_unchecked(&the_controller->seqnum);
 		if (unlink->seqnum == 0xffff)
 			usbip_uinfo("seqnum max\n");
 
@@ -988,7 +988,7 @@ static int vhci_start(struct usb_hcd *hc
 		vdev->rhport = rhport;
 	}
 
-	atomic_set(&vhci->seqnum, 0);
+	atomic_set_unchecked(&vhci->seqnum, 0);
 	spin_lock_init(&vhci->lock);
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/usbip/vhci_rx.c linux-2.6.32.60-pax/drivers/staging/usbip/vhci_rx.c
--- linux-2.6.32.60/drivers/staging/usbip/vhci_rx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/usbip/vhci_rx.c	2012-03-13 13:15:35.328097980 +0100
@@ -79,7 +79,7 @@ static void vhci_recv_ret_submit(struct
 		usbip_uerr("cannot find a urb of seqnum %u\n",
 							pdu->base.seqnum);
 		usbip_uinfo("max seqnum %d\n",
-					atomic_read(&the_controller->seqnum));
+					atomic_read_unchecked(&the_controller->seqnum));
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 		return;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/vt6655/hostap.c linux-2.6.32.60-pax/drivers/staging/vt6655/hostap.c
--- linux-2.6.32.60/drivers/staging/vt6655/hostap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/vt6655/hostap.c	2012-03-13 13:15:35.328097980 +0100
@@ -84,7 +84,7 @@ static int hostap_enable_hostapd(PSDevic
     PSDevice apdev_priv;
 	struct net_device *dev = pDevice->dev;
 	int ret;
-	const struct net_device_ops apdev_netdev_ops = {
+	net_device_ops_no_const apdev_netdev_ops = {
 		.ndo_start_xmit         = pDevice->tx_80211,
 	};
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/staging/vt6656/hostap.c linux-2.6.32.60-pax/drivers/staging/vt6656/hostap.c
--- linux-2.6.32.60/drivers/staging/vt6656/hostap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/staging/vt6656/hostap.c	2012-03-13 13:15:35.328097980 +0100
@@ -86,7 +86,7 @@ static int hostap_enable_hostapd(PSDevic
     PSDevice apdev_priv;
 	struct net_device *dev = pDevice->dev;
 	int ret;
-	const struct net_device_ops apdev_netdev_ops = {
+	net_device_ops_no_const apdev_netdev_ops = {
 		.ndo_start_xmit         = pDevice->tx_80211,
 	};
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/uio/uio.c linux-2.6.32.60-pax/drivers/uio/uio.c
--- linux-2.6.32.60/drivers/uio/uio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/uio/uio.c	2012-03-13 13:15:35.332097979 +0100
@@ -23,6 +23,7 @@
 #include <linux/string.h>
 #include <linux/kobject.h>
 #include <linux/uio_driver.h>
+#include <asm/local.h>
 
 #define UIO_MAX_DEVICES 255
 
@@ -30,10 +31,10 @@ struct uio_device {
 	struct module		*owner;
 	struct device		*dev;
 	int			minor;
-	atomic_t		event;
+	atomic_unchecked_t	event;
 	struct fasync_struct	*async_queue;
 	wait_queue_head_t	wait;
-	int			vma_count;
+	local_t			vma_count;
 	struct uio_info		*info;
 	struct kobject		*map_dir;
 	struct kobject		*portio_dir;
@@ -255,7 +256,7 @@ static ssize_t show_event(struct device
 	struct uio_device *idev = dev_get_drvdata(dev);
 	if (idev)
 		return sprintf(buf, "%u\n",
-				(unsigned int)atomic_read(&idev->event));
+				(unsigned int)atomic_read_unchecked(&idev->event));
 	else
 		return -ENODEV;
 }
@@ -424,7 +425,7 @@ void uio_event_notify(struct uio_info *i
 {
 	struct uio_device *idev = info->uio_dev;
 
-	atomic_inc(&idev->event);
+	atomic_inc_unchecked(&idev->event);
 	wake_up_interruptible(&idev->wait);
 	kill_fasync(&idev->async_queue, SIGIO, POLL_IN);
 }
@@ -477,7 +478,7 @@ static int uio_open(struct inode *inode,
 	}
 
 	listener->dev = idev;
-	listener->event_count = atomic_read(&idev->event);
+	listener->event_count = atomic_read_unchecked(&idev->event);
 	filep->private_data = listener;
 
 	if (idev->info->open) {
@@ -528,7 +529,7 @@ static unsigned int uio_poll(struct file
 		return -EIO;
 
 	poll_wait(filep, &idev->wait, wait);
-	if (listener->event_count != atomic_read(&idev->event))
+	if (listener->event_count != atomic_read_unchecked(&idev->event))
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
@@ -553,7 +554,7 @@ static ssize_t uio_read(struct file *fil
 	do {
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		event_count = atomic_read(&idev->event);
+		event_count = atomic_read_unchecked(&idev->event);
 		if (event_count != listener->event_count) {
 			if (copy_to_user(buf, &event_count, count))
 				retval = -EFAULT;
@@ -624,13 +625,13 @@ static int uio_find_mem_index(struct vm_
 static void uio_vma_open(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
-	idev->vma_count++;
+	local_inc(&idev->vma_count);
 }
 
 static void uio_vma_close(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
-	idev->vma_count--;
+	local_dec(&idev->vma_count);
 }
 
 static int uio_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
@@ -840,7 +841,7 @@ int __uio_register_device(struct module
 	idev->owner = owner;
 	idev->info = info;
 	init_waitqueue_head(&idev->wait);
-	atomic_set(&idev->event, 0);
+	atomic_set_unchecked(&idev->event, 0);
 
 	ret = uio_get_minor(idev);
 	if (ret)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/atm/usbatm.c linux-2.6.32.60-pax/drivers/usb/atm/usbatm.c
--- linux-2.6.32.60/drivers/usb/atm/usbatm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/atm/usbatm.c	2012-03-13 13:15:35.336097979 +0100
@@ -333,7 +333,7 @@ static void usbatm_extract_one_cell(stru
 		if (printk_ratelimit())
 			atm_warn(instance, "%s: OAM not supported (vpi %d, vci %d)!\n",
 				__func__, vpi, vci);
-		atomic_inc(&vcc->stats->rx_err);
+		atomic_inc_unchecked(&vcc->stats->rx_err);
 		return;
 	}
 
@@ -361,7 +361,7 @@ static void usbatm_extract_one_cell(stru
 		if (length > ATM_MAX_AAL5_PDU) {
 			atm_rldbg(instance, "%s: bogus length %u (vcc: 0x%p)!\n",
 				  __func__, length, vcc);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			goto out;
 		}
 
@@ -370,14 +370,14 @@ static void usbatm_extract_one_cell(stru
 		if (sarb->len < pdu_length) {
 			atm_rldbg(instance, "%s: bogus pdu_length %u (sarb->len: %u, vcc: 0x%p)!\n",
 				  __func__, pdu_length, sarb->len, vcc);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			goto out;
 		}
 
 		if (crc32_be(~0, skb_tail_pointer(sarb) - pdu_length, pdu_length) != 0xc704dd7b) {
 			atm_rldbg(instance, "%s: packet failed crc check (vcc: 0x%p)!\n",
 				  __func__, vcc);
-			atomic_inc(&vcc->stats->rx_err);
+			atomic_inc_unchecked(&vcc->stats->rx_err);
 			goto out;
 		}
 
@@ -387,7 +387,7 @@ static void usbatm_extract_one_cell(stru
 			if (printk_ratelimit())
 				atm_err(instance, "%s: no memory for skb (length: %u)!\n",
 					__func__, length);
-			atomic_inc(&vcc->stats->rx_drop);
+			atomic_inc_unchecked(&vcc->stats->rx_drop);
 			goto out;
 		}
 
@@ -412,7 +412,7 @@ static void usbatm_extract_one_cell(stru
 
 		vcc->push(vcc, skb);
 
-		atomic_inc(&vcc->stats->rx);
+		atomic_inc_unchecked(&vcc->stats->rx);
 	out:
 		skb_trim(sarb, 0);
 	}
@@ -616,7 +616,7 @@ static void usbatm_tx_process(unsigned l
 			struct atm_vcc *vcc = UDSL_SKB(skb)->atm.vcc;
 
 			usbatm_pop(vcc, skb);
-			atomic_inc(&vcc->stats->tx);
+			atomic_inc_unchecked(&vcc->stats->tx);
 
 			skb = skb_dequeue(&instance->sndqueue);
 		}
@@ -775,11 +775,11 @@ static int usbatm_atm_proc_read(struct a
 	if (!left--)
 		return sprintf(page,
 			       "AAL5: tx %d ( %d err ), rx %d ( %d err, %d drop )\n",
-			       atomic_read(&atm_dev->stats.aal5.tx),
-			       atomic_read(&atm_dev->stats.aal5.tx_err),
-			       atomic_read(&atm_dev->stats.aal5.rx),
-			       atomic_read(&atm_dev->stats.aal5.rx_err),
-			       atomic_read(&atm_dev->stats.aal5.rx_drop));
+			       atomic_read_unchecked(&atm_dev->stats.aal5.tx),
+			       atomic_read_unchecked(&atm_dev->stats.aal5.tx_err),
+			       atomic_read_unchecked(&atm_dev->stats.aal5.rx),
+			       atomic_read_unchecked(&atm_dev->stats.aal5.rx_err),
+			       atomic_read_unchecked(&atm_dev->stats.aal5.rx_drop));
 
 	if (!left--) {
 		if (instance->disconnected)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/core/hcd.c linux-2.6.32.60-pax/drivers/usb/core/hcd.c
--- linux-2.6.32.60/drivers/usb/core/hcd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/core/hcd.c	2012-12-03 22:34:34.355767333 +0100
@@ -1373,7 +1373,7 @@ int usb_hcd_submit_urb (struct urb *urb,
 	 */
 	usb_get_urb(urb);
 	atomic_inc(&urb->use_count);
-	atomic_inc(&urb->dev->urbnum);
+	atomic_inc_unchecked(&urb->dev->urbnum);
 	usbmon_urb_submit(&hcd->self, urb);
 
 	/* NOTE requirements on root-hub callers (usbfs and the hub
@@ -1401,7 +1401,7 @@ int usb_hcd_submit_urb (struct urb *urb,
 		urb->hcpriv = NULL;
 		INIT_LIST_HEAD(&urb->urb_list);
 		atomic_dec(&urb->use_count);
-		atomic_dec(&urb->dev->urbnum);
+		atomic_dec_unchecked(&urb->dev->urbnum);
 		if (atomic_read(&urb->reject))
 			wake_up(&usb_kill_urb_queue);
 		usb_put_urb(urb);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/core/sysfs.c linux-2.6.32.60-pax/drivers/usb/core/sysfs.c
--- linux-2.6.32.60/drivers/usb/core/sysfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/core/sysfs.c	2012-12-03 22:34:34.355767333 +0100
@@ -186,7 +186,7 @@ show_urbnum(struct device *dev, struct d
 	struct usb_device *udev;
 
 	udev = to_usb_device(dev);
-	return sprintf(buf, "%d\n", atomic_read(&udev->urbnum));
+	return sprintf(buf, "%d\n", atomic_read_unchecked(&udev->urbnum));
 }
 static DEVICE_ATTR(urbnum, S_IRUGO, show_urbnum, NULL);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/core/usb.c linux-2.6.32.60-pax/drivers/usb/core/usb.c
--- linux-2.6.32.60/drivers/usb/core/usb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/core/usb.c	2012-12-03 22:34:46.239767849 +0100
@@ -377,7 +377,7 @@ struct usb_device *usb_alloc_dev(struct
 	dev->dev.dma_mask = bus->controller->dma_mask;
 	set_dev_node(&dev->dev, dev_to_node(bus->controller));
 	dev->state = USB_STATE_ATTACHED;
-	atomic_set(&dev->urbnum, 0);
+	atomic_set_unchecked(&dev->urbnum, 0);
 
 	INIT_LIST_HEAD(&dev->ep0.urb_list);
 	dev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/wusbcore/wa-hc.h linux-2.6.32.60-pax/drivers/usb/wusbcore/wa-hc.h
--- linux-2.6.32.60/drivers/usb/wusbcore/wa-hc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/wusbcore/wa-hc.h	2012-03-13 13:15:35.336097979 +0100
@@ -192,7 +192,7 @@ struct wahc {
 	struct list_head xfer_delayed_list;
 	spinlock_t xfer_list_lock;
 	struct work_struct xfer_work;
-	atomic_t xfer_id_count;
+	atomic_unchecked_t xfer_id_count;
 };
 
 
@@ -246,7 +246,7 @@ static inline void wa_init(struct wahc *
 	INIT_LIST_HEAD(&wa->xfer_delayed_list);
 	spin_lock_init(&wa->xfer_list_lock);
 	INIT_WORK(&wa->xfer_work, wa_urb_enqueue_run);
-	atomic_set(&wa->xfer_id_count, 1);
+	atomic_set_unchecked(&wa->xfer_id_count, 1);
 }
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/usb/wusbcore/wa-xfer.c linux-2.6.32.60-pax/drivers/usb/wusbcore/wa-xfer.c
--- linux-2.6.32.60/drivers/usb/wusbcore/wa-xfer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/usb/wusbcore/wa-xfer.c	2012-03-13 13:15:35.340097979 +0100
@@ -293,7 +293,7 @@ out:
  */
 static void wa_xfer_id_init(struct wa_xfer *xfer)
 {
-	xfer->id = atomic_add_return(1, &xfer->wa->xfer_id_count);
+	xfer->id = atomic_add_return_unchecked(1, &xfer->wa->xfer_id_count);
 }
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/uwb/wlp/messages.c linux-2.6.32.60-pax/drivers/uwb/wlp/messages.c
--- linux-2.6.32.60/drivers/uwb/wlp/messages.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/uwb/wlp/messages.c	2012-03-13 13:15:35.340097979 +0100
@@ -903,7 +903,7 @@ int wlp_parse_f0(struct wlp *wlp, struct
 	size_t len = skb->len;
 	size_t used;
 	ssize_t result;
-	struct wlp_nonce enonce, rnonce;
+	struct wlp_nonce enonce = {{0}}, rnonce = {{0}};
 	enum wlp_assc_error assc_err;
 	char enonce_buf[WLP_WSS_NONCE_STRSIZE];
 	char rnonce_buf[WLP_WSS_NONCE_STRSIZE];
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/aty/aty128fb.c linux-2.6.32.60-pax/drivers/video/aty/aty128fb.c
--- linux-2.6.32.60/drivers/video/aty/aty128fb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/aty/aty128fb.c	2012-03-13 13:15:35.340097979 +0100
@@ -149,7 +149,7 @@ enum {
 };
 
 /* Must match above enum */
-static const char *r128_family[] __devinitdata = {
+static const char *r128_family[] __devinitconst = {
 	"AGP",
 	"PCI",
 	"PRO AGP",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/fbcmap.c linux-2.6.32.60-pax/drivers/video/fbcmap.c
--- linux-2.6.32.60/drivers/video/fbcmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/fbcmap.c	2012-03-13 13:15:35.344097979 +0100
@@ -266,8 +266,7 @@ int fb_set_user_cmap(struct fb_cmap_user
 		rc = -ENODEV;
 		goto out;
 	}
-	if (cmap->start < 0 || (!info->fbops->fb_setcolreg &&
-				!info->fbops->fb_setcmap)) {
+	if (!info->fbops->fb_setcolreg && !info->fbops->fb_setcmap) {
 		rc = -EINVAL;
 		goto out1;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/fbmem.c linux-2.6.32.60-pax/drivers/video/fbmem.c
--- linux-2.6.32.60/drivers/video/fbmem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/fbmem.c	2012-03-13 13:15:35.344097979 +0100
@@ -403,7 +403,7 @@ static void fb_do_show_logo(struct fb_in
 			image->dx += image->width + 8;
 		}
 	} else if (rotate == FB_ROTATE_UD) {
-		for (x = 0; x < num && image->dx >= 0; x++) {
+		for (x = 0; x < num && (__s32)image->dx >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dx -= image->width + 8;
 		}
@@ -415,7 +415,7 @@ static void fb_do_show_logo(struct fb_in
 			image->dy += image->height + 8;
 		}
 	} else if (rotate == FB_ROTATE_CCW) {
-		for (x = 0; x < num && image->dy >= 0; x++) {
+		for (x = 0; x < num && (__s32)image->dy >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy -= image->height + 8;
 		}
@@ -1119,7 +1119,7 @@ static long do_fb_ioctl(struct fb_info *
 			return -EFAULT;
 		if (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)
 			return -EINVAL;
-		if (con2fb.framebuffer < 0 || con2fb.framebuffer >= FB_MAX)
+		if (con2fb.framebuffer >= FB_MAX)
 			return -EINVAL;
 		if (!registered_fb[con2fb.framebuffer])
 			request_module("fb%d", con2fb.framebuffer);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/geode/gx1fb_core.c linux-2.6.32.60-pax/drivers/video/geode/gx1fb_core.c
--- linux-2.6.32.60/drivers/video/geode/gx1fb_core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/geode/gx1fb_core.c	2012-03-13 13:15:35.344097979 +0100
@@ -30,7 +30,7 @@ static int  crt_option = 1;
 static char panel_option[32] = "";
 
 /* Modes relevant to the GX1 (taken from modedb.c) */
-static const struct fb_videomode __initdata gx1_modedb[] = {
+static const struct fb_videomode __initconst gx1_modedb[] = {
 	/* 640x480-60 VESA */
 	{ NULL, 60, 640, 480, 39682,  48, 16, 33, 10, 96, 2,
 	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/gxt4500.c linux-2.6.32.60-pax/drivers/video/gxt4500.c
--- linux-2.6.32.60/drivers/video/gxt4500.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/gxt4500.c	2012-03-13 13:15:35.344097979 +0100
@@ -156,7 +156,7 @@ struct gxt4500_par {
 static char *mode_option;
 
 /* default mode: 1280x1024 @ 60 Hz, 8 bpp */
-static const struct fb_videomode defaultmode __devinitdata = {
+static const struct fb_videomode defaultmode __devinitconst = {
 	.refresh = 60,
 	.xres = 1280,
 	.yres = 1024,
@@ -581,7 +581,7 @@ static int gxt4500_blank(int blank, stru
 	return 0;
 }
 
-static const struct fb_fix_screeninfo gxt4500_fix __devinitdata = {
+static const struct fb_fix_screeninfo gxt4500_fix __devinitconst = {
 	.id = "IBM GXT4500P",
 	.type = FB_TYPE_PACKED_PIXELS,
 	.visual = FB_VISUAL_PSEUDOCOLOR,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/i810/i810_accel.c linux-2.6.32.60-pax/drivers/video/i810/i810_accel.c
--- linux-2.6.32.60/drivers/video/i810/i810_accel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/i810/i810_accel.c	2012-03-13 13:15:35.348097978 +0100
@@ -73,6 +73,7 @@ static inline int wait_for_space(struct
 		}
 	}
 	printk("ringbuffer lockup!!!\n");
+	printk("head:%u tail:%u iring.size:%u space:%u\n", head, tail, par->iring.size, space);
 	i810_report_error(mmio); 
 	par->dev_flags |= LOCKUP;
 	info->pixmap.scan_align = 1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/i810/i810_main.c linux-2.6.32.60-pax/drivers/video/i810/i810_main.c
--- linux-2.6.32.60/drivers/video/i810/i810_main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/i810/i810_main.c	2012-03-13 13:15:35.348097978 +0100
@@ -97,7 +97,7 @@ static int i810fb_blank      (int blank_
 static void i810fb_release_resource       (struct fb_info *info, struct i810fb_par *par);
 
 /* PCI */
-static const char *i810_pci_list[] __devinitdata = {
+static const char *i810_pci_list[] __devinitconst = {
 	"Intel(R) 810 Framebuffer Device"                                 ,
 	"Intel(R) 810-DC100 Framebuffer Device"                           ,
 	"Intel(R) 810E Framebuffer Device"                                ,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/uvesafb.c linux-2.6.32.60-pax/drivers/video/uvesafb.c
--- linux-2.6.32.60/drivers/video/uvesafb.c	2012-10-09 11:00:35.472882473 +0200
+++ linux-2.6.32.60-pax/drivers/video/uvesafb.c	2012-10-09 11:00:39.328883047 +0200
@@ -18,6 +18,7 @@
 #include <linux/fb.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/moduleloader.h>
 #include <video/edid.h>
 #include <video/uvesafb.h>
 #ifdef CONFIG_X86
@@ -120,7 +121,7 @@ static int uvesafb_helper_start(void)
 		NULL,
 	};
 
-	return call_usermodehelper(v86d_path, argv, envp, 1);
+	return call_usermodehelper(v86d_path, argv, envp, UMH_WAIT_PROC);
 }
 
 /*
@@ -568,10 +569,32 @@ static int __devinit uvesafb_vbe_getpmi(
 	if ((task->t.regs.eax & 0xffff) != 0x4f || task->t.regs.es < 0xc000) {
 		par->pmi_setpal = par->ypan = 0;
 	} else {
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_MODULES
+		par->pmi_code = module_alloc_exec((u16)task->t.regs.ecx);
+#endif
+		if (!par->pmi_code) {
+			par->pmi_setpal = par->ypan = 0;
+			return 0;
+		}
+#endif
+
 		par->pmi_base = (u16 *)phys_to_virt(((u32)task->t.regs.es << 4)
 						+ task->t.regs.edi);
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+		pax_open_kernel();
+		memcpy(par->pmi_code, par->pmi_base, (u16)task->t.regs.ecx);
+		pax_close_kernel();
+
+		par->pmi_start = ktva_ktla(par->pmi_code + par->pmi_base[1]);
+		par->pmi_pal = ktva_ktla(par->pmi_code + par->pmi_base[2]);
+#else
 		par->pmi_start = (u8 *)par->pmi_base + par->pmi_base[1];
 		par->pmi_pal = (u8 *)par->pmi_base + par->pmi_base[2];
+#endif
+
 		printk(KERN_INFO "uvesafb: protected mode interface info at "
 				 "%04x:%04x\n",
 				 (u16)task->t.regs.es, (u16)task->t.regs.edi);
@@ -1806,6 +1829,11 @@ out:
 	if (par->vbe_modes)
 		kfree(par->vbe_modes);
 
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	if (par->pmi_code)
+		module_free_exec(NULL, par->pmi_code);
+#endif
+
 	framebuffer_release(info);
 	return err;
 }
@@ -1832,6 +1860,12 @@ static int uvesafb_remove(struct platfor
 				kfree(par->vbe_state_orig);
 			if (par->vbe_state_saved)
 				kfree(par->vbe_state_saved);
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+			if (par->pmi_code)
+				module_free_exec(NULL, par->pmi_code);
+#endif
+
 		}
 
 		framebuffer_release(info);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/video/vesafb.c linux-2.6.32.60-pax/drivers/video/vesafb.c
--- linux-2.6.32.60/drivers/video/vesafb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/video/vesafb.c	2012-03-13 13:15:35.352097978 +0100
@@ -9,6 +9,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/moduleloader.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/string.h>
@@ -53,8 +54,8 @@ static int   vram_remap __initdata;		/*
 static int   vram_total __initdata;		/* Set total amount of memory */
 static int   pmi_setpal __read_mostly = 1;	/* pmi for palette changes ??? */
 static int   ypan       __read_mostly;		/* 0..nothing, 1..ypan, 2..ywrap */
-static void  (*pmi_start)(void) __read_mostly;
-static void  (*pmi_pal)  (void) __read_mostly;
+static void  (*pmi_start)(void) __read_only;
+static void  (*pmi_pal)  (void) __read_only;
 static int   depth      __read_mostly;
 static int   vga_compat __read_mostly;
 /* --------------------------------------------------------------------- */
@@ -233,6 +234,7 @@ static int __init vesafb_probe(struct pl
 	unsigned int size_vmode;
 	unsigned int size_remap;
 	unsigned int size_total;
+	void *pmi_code = NULL;
 
 	if (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)
 		return -ENODEV;
@@ -275,10 +277,6 @@ static int __init vesafb_probe(struct pl
 		size_remap = size_total;
 	vesafb_fix.smem_len = size_remap;
 
-#ifndef __i386__
-	screen_info.vesapm_seg = 0;
-#endif
-
 	if (!request_mem_region(vesafb_fix.smem_start, size_total, "vesafb")) {
 		printk(KERN_WARNING
 		       "vesafb: cannot reserve video memory at 0x%lx\n",
@@ -315,9 +313,21 @@ static int __init vesafb_probe(struct pl
 	printk(KERN_INFO "vesafb: mode is %dx%dx%d, linelength=%d, pages=%d\n",
 	       vesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel, vesafb_fix.line_length, screen_info.pages);
 
+#ifdef __i386__
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	pmi_code = module_alloc_exec(screen_info.vesapm_size);
+	if (!pmi_code)
+#elif !defined(CONFIG_PAX_KERNEXEC)
+	if (0)
+#endif
+
+#endif
+	screen_info.vesapm_seg = 0;
+
 	if (screen_info.vesapm_seg) {
-		printk(KERN_INFO "vesafb: protected mode interface info at %04x:%04x\n",
-		       screen_info.vesapm_seg,screen_info.vesapm_off);
+		printk(KERN_INFO "vesafb: protected mode interface info at %04x:%04x %04x bytes\n",
+		       screen_info.vesapm_seg,screen_info.vesapm_off,screen_info.vesapm_size);
 	}
 
 	if (screen_info.vesapm_seg < 0xc000)
@@ -325,9 +335,25 @@ static int __init vesafb_probe(struct pl
 
 	if (ypan || pmi_setpal) {
 		unsigned short *pmi_base;
+
 		pmi_base  = (unsigned short*)phys_to_virt(((unsigned long)screen_info.vesapm_seg << 4) + screen_info.vesapm_off);
-		pmi_start = (void*)((char*)pmi_base + pmi_base[1]);
-		pmi_pal   = (void*)((char*)pmi_base + pmi_base[2]);
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+		pax_open_kernel();
+		memcpy(pmi_code, pmi_base, screen_info.vesapm_size);
+#else
+		pmi_code  = pmi_base;
+#endif
+
+		pmi_start = (void*)((char*)pmi_code + pmi_base[1]);
+		pmi_pal   = (void*)((char*)pmi_code + pmi_base[2]);
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+		pmi_start = ktva_ktla(pmi_start);
+		pmi_pal = ktva_ktla(pmi_pal);
+		pax_close_kernel();
+#endif
+
 		printk(KERN_INFO "vesafb: pmi: set display start = %p, set palette = %p\n",pmi_start,pmi_pal);
 		if (pmi_base[3]) {
 			printk(KERN_INFO "vesafb: pmi: ports = ");
@@ -469,6 +495,11 @@ static int __init vesafb_probe(struct pl
 	       info->node, info->fix.id);
 	return 0;
 err:
+
+#if defined(__i386__) && defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	module_free_exec(NULL, pmi_code);
+#endif
+
 	if (info->screen_base)
 		iounmap(info->screen_base);
 	framebuffer_release(info);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/watchdog/hpwdt.c linux-2.6.32.60-pax/drivers/watchdog/hpwdt.c
--- linux-2.6.32.60/drivers/watchdog/hpwdt.c	2012-03-18 17:44:12.476058731 +0100
+++ linux-2.6.32.60-pax/drivers/watchdog/hpwdt.c	2013-01-23 01:23:15.215054428 +0100
@@ -725,8 +725,11 @@ static int __devinit hpwdt_init_one(stru
 	 * die notify list to handle a critical NMI. The default is to
 	 * be last so other users of the NMI signal can function.
 	 */
-	if (priority)
-		die_notifier.priority = 0x7FFFFFFF;
+	if (priority) {
+		pax_open_kernel();
+		*(void **)&die_notifier.priority = 0x7FFFFFFF;
+		pax_close_kernel();
+	}
 
 	retval = register_die_notifier(&die_notifier);
 	if (retval != 0) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/drivers/xen/balloon.c linux-2.6.32.60-pax/drivers/xen/balloon.c
--- linux-2.6.32.60/drivers/xen/balloon.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/drivers/xen/balloon.c	2013-01-23 01:29:21.603034866 +0100
@@ -395,7 +395,9 @@ static int balloon_init_watcher(struct n
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block xenstore_notifier;
+static struct notifier_block xenstore_notifier = {
+	.notifier_call = balloon_init_watcher,
+};
 
 static int __init balloon_init(void)
 {
@@ -427,7 +429,6 @@ static int __init balloon_init(void)
 	}
 
 	target_watch.callback = watch_target;
-	xenstore_notifier.notifier_call = balloon_init_watcher;
 
 	register_xenstore_notifier(&xenstore_notifier);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/9p/vfs_inode.c linux-2.6.32.60-pax/fs/9p/vfs_inode.c
--- linux-2.6.32.60/fs/9p/vfs_inode.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/9p/vfs_inode.c	2012-03-13 13:15:35.352097978 +0100
@@ -1079,7 +1079,7 @@ static void *v9fs_vfs_follow_link(struct
 static void
 v9fs_vfs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
 {
-	char *s = nd_get_link(nd);
+	const char *s = nd_get_link(nd);
 
 	P9_DPRINTK(P9_DEBUG_VFS, " %s %s\n", dentry->d_name.name,
 		IS_ERR(s) ? "<error>" : s);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/aio.c linux-2.6.32.60-pax/fs/aio.c
--- linux-2.6.32.60/fs/aio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/aio.c	2012-03-13 13:15:35.352097978 +0100
@@ -115,7 +115,7 @@ static int aio_setup_ring(struct kioctx
 	size += sizeof(struct io_event) * nr_events;
 	nr_pages = (size + PAGE_SIZE-1) >> PAGE_SHIFT;
 
-	if (nr_pages < 0)
+	if (nr_pages <= 0)
 		return -EINVAL;
 
 	nr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring)) / sizeof(struct io_event);
@@ -1382,13 +1382,18 @@ static ssize_t aio_fsync(struct kiocb *i
 static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb)
 {
 	ssize_t ret;
+	struct iovec iovstack;
 
 	ret = rw_copy_check_uvector(type, (struct iovec __user *)kiocb->ki_buf,
 				    kiocb->ki_nbytes, 1,
-				    &kiocb->ki_inline_vec, &kiocb->ki_iovec);
+				    &iovstack, &kiocb->ki_iovec);
 	if (ret < 0)
 		goto out;
 
+	if (kiocb->ki_iovec == &iovstack) {
+		kiocb->ki_inline_vec = iovstack;
+		kiocb->ki_iovec = &kiocb->ki_inline_vec;
+	}
 	kiocb->ki_nr_segs = kiocb->ki_nbytes;
 	kiocb->ki_cur_seg = 0;
 	/* ki_nbytes/left now reflect bytes instead of segs */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/autofs4/symlink.c linux-2.6.32.60-pax/fs/autofs4/symlink.c
--- linux-2.6.32.60/fs/autofs4/symlink.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/autofs4/symlink.c	2012-03-13 13:15:35.356097978 +0100
@@ -15,7 +15,7 @@
 static void *autofs4_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
-	nd_set_link(nd, (char *)ino->u.symlink);
+	nd_set_link(nd, ino->u.symlink);
 	return NULL;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/autofs4/waitq.c linux-2.6.32.60-pax/fs/autofs4/waitq.c
--- linux-2.6.32.60/fs/autofs4/waitq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/autofs4/waitq.c	2012-03-13 13:15:35.356097978 +0100
@@ -60,7 +60,7 @@ static int autofs4_write(struct file *fi
 {
 	unsigned long sigpipe, flags;
 	mm_segment_t fs;
-	const char *data = (const char *)addr;
+	const char __user *data = (const char __force_user *)addr;
 	ssize_t wr = 0;
 
 	/** WARNING: this is not safe for writing more than PIPE_BUF bytes! **/
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/befs/linuxvfs.c linux-2.6.32.60-pax/fs/befs/linuxvfs.c
--- linux-2.6.32.60/fs/befs/linuxvfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/befs/linuxvfs.c	2012-03-13 13:15:35.356097978 +0100
@@ -498,7 +498,7 @@ static void befs_put_link(struct dentry
 {
 	befs_inode_info *befs_ino = BEFS_I(dentry->d_inode);
 	if (befs_ino->i_flags & BEFS_LONG_SYMLINK) {
-		char *link = nd_get_link(nd);
+		const char *link = nd_get_link(nd);
 		if (!IS_ERR(link))
 			kfree(link);
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/binfmt_aout.c linux-2.6.32.60-pax/fs/binfmt_aout.c
--- linux-2.6.32.60/fs/binfmt_aout.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/binfmt_aout.c	2012-03-13 13:15:35.356097978 +0100
@@ -277,6 +277,27 @@ static int load_aout_binary(struct linux
 	install_exec_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(N_FLAGS(ex) & F_PAX_PAGEEXEC)) {
+		current->mm->pax_flags |= MF_PAX_PAGEEXEC;
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		if (N_FLAGS(ex) & F_PAX_EMUTRAMP)
+			current->mm->pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (!(N_FLAGS(ex) & F_PAX_MPROTECT))
+			current->mm->pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+	}
+#endif
+
 	if (N_MAGIC(ex) == OMAGIC) {
 		unsigned long text_addr, map_size;
 		loff_t pos;
@@ -349,7 +370,7 @@ static int load_aout_binary(struct linux
 
 		down_write(&current->mm->mmap_sem);
  		error = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,
-				PROT_READ | PROT_WRITE | PROT_EXEC,
+				PROT_READ | PROT_WRITE,
 				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
 				fd_offset + ex.a_text);
 		up_write(&current->mm->mmap_sem);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/binfmt_elf.c linux-2.6.32.60-pax/fs/binfmt_elf.c
--- linux-2.6.32.60/fs/binfmt_elf.c	2012-03-18 17:44:12.476058731 +0100
+++ linux-2.6.32.60-pax/fs/binfmt_elf.c	2013-01-28 20:41:20.391975823 +0100
@@ -31,6 +31,7 @@
 #include <linux/random.h>
 #include <linux/elf.h>
 #include <linux/utsname.h>
+#include <linux/xattr.h>
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
@@ -50,6 +51,10 @@ static int elf_core_dump(long signr, str
 #define elf_core_dump	NULL
 #endif
 
+#ifdef CONFIG_PAX_MPROTECT
+static void elf_handle_mprotect(struct vm_area_struct *vma, unsigned long newflags);
+#endif
+
 #if ELF_EXEC_PAGESIZE > PAGE_SIZE
 #define ELF_MIN_ALIGN	ELF_EXEC_PAGESIZE
 #else
@@ -69,6 +74,11 @@ static struct linux_binfmt elf_format =
 		.load_binary	= load_elf_binary,
 		.load_shlib	= load_elf_library,
 		.core_dump	= elf_core_dump,
+
+#ifdef CONFIG_PAX_MPROTECT
+		.handle_mprotect= elf_handle_mprotect,
+#endif
+
 		.min_coredump	= ELF_EXEC_PAGESIZE,
 		.hasvdso	= 1
 };
@@ -77,6 +87,8 @@ static struct linux_binfmt elf_format =
 
 static int set_brk(unsigned long start, unsigned long end)
 {
+	unsigned long e = end;
+
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
 	if (end > start) {
@@ -87,7 +99,7 @@ static int set_brk(unsigned long start,
 		if (BAD_ADDR(addr))
 			return addr;
 	}
-	current->mm->start_brk = current->mm->brk = end;
+	current->mm->start_brk = current->mm->brk = e;
 	return 0;
 }
 
@@ -148,12 +160,13 @@ create_elf_tables(struct linux_binprm *b
 	elf_addr_t __user *u_rand_bytes;
 	const char *k_platform = ELF_PLATFORM;
 	const char *k_base_platform = ELF_BASE_PLATFORM;
-	unsigned char k_rand_bytes[16];
+	u32 k_rand_bytes[4];
 	int items;
 	elf_addr_t *elf_info;
 	int ei_index = 0;
 	const struct cred *cred = current_cred();
 	struct vm_area_struct *vma;
+	unsigned long saved_auxv[AT_VECTOR_SIZE];
 
 	/*
 	 * In some cases (e.g. Hyper-Threading), we want to avoid L1
@@ -195,8 +208,12 @@ create_elf_tables(struct linux_binprm *b
 	 * Generate 16 random bytes for userspace PRNG seeding.
 	 */
 	get_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));
-	u_rand_bytes = (elf_addr_t __user *)
-		       STACK_ALLOC(p, sizeof(k_rand_bytes));
+	srandom32(k_rand_bytes[0] ^ random32());
+	srandom32(k_rand_bytes[1] ^ random32());
+	srandom32(k_rand_bytes[2] ^ random32());
+	srandom32(k_rand_bytes[3] ^ random32());
+	p = STACK_ROUND(p, sizeof(k_rand_bytes));
+	u_rand_bytes = (elf_addr_t __user *) p;
 	if (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))
 		return -EFAULT;
 
@@ -308,9 +325,11 @@ create_elf_tables(struct linux_binprm *b
 		return -EFAULT;
 	current->mm->env_end = p;
 
+	memcpy(saved_auxv, elf_info, ei_index * sizeof(elf_addr_t));
+
 	/* Put the elf_info on the stack in the right place.  */
 	sp = (elf_addr_t __user *)envp + 1;
-	if (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))
+	if (copy_to_user(sp, saved_auxv, ei_index * sizeof(elf_addr_t)))
 		return -EFAULT;
 	return 0;
 }
@@ -380,15 +399,14 @@ static unsigned long total_mapping_size(
    an ELF header */
 
 static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
-		struct file *interpreter, unsigned long *interp_map_addr,
-		unsigned long no_base)
+		struct file *interpreter, unsigned long no_base)
 {
 	struct elf_phdr *elf_phdata;
 	struct elf_phdr *eppnt;
-	unsigned long load_addr = 0;
+	unsigned long load_addr = 0, pax_task_size = TASK_SIZE;
 	int load_addr_set = 0;
 	unsigned long last_bss = 0, elf_bss = 0;
-	unsigned long error = ~0UL;
+	unsigned long error = -EINVAL;
 	unsigned long total_size;
 	int retval, i, size;
 
@@ -434,6 +452,11 @@ static unsigned long load_elf_interp(str
 		goto out_close;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
 	eppnt = elf_phdata;
 	for (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {
 		if (eppnt->p_type == PT_LOAD) {
@@ -457,8 +480,6 @@ static unsigned long load_elf_interp(str
 			map_addr = elf_map(interpreter, load_addr + vaddr,
 					eppnt, elf_prot, elf_type, total_size);
 			total_size = 0;
-			if (!*interp_map_addr)
-				*interp_map_addr = map_addr;
 			error = map_addr;
 			if (BAD_ADDR(map_addr))
 				goto out_close;
@@ -477,8 +498,8 @@ static unsigned long load_elf_interp(str
 			k = load_addr + eppnt->p_vaddr;
 			if (BAD_ADDR(k) ||
 			    eppnt->p_filesz > eppnt->p_memsz ||
-			    eppnt->p_memsz > TASK_SIZE ||
-			    TASK_SIZE - eppnt->p_memsz < k) {
+			    eppnt->p_memsz > pax_task_size ||
+			    pax_task_size - eppnt->p_memsz < k) {
 				error = -ENOMEM;
 				goto out_close;
 			}
@@ -532,6 +553,315 @@ out:
 	return error;
 }
 
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+#ifdef CONFIG_PAX_SOFTMODE
+static unsigned long pax_parse_pt_pax_softmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (elf_phdata->p_flags & PF_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (elf_phdata->p_flags & PF_SEGMEXEC)
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((elf_phdata->p_flags & PF_EMUTRAMP) && (pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (elf_phdata->p_flags & PF_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && (elf_phdata->p_flags & PF_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+static unsigned long pax_parse_pt_pax_hardmode(const struct elf_phdr * const elf_phdata)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_phdata->p_flags & PF_NOPAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_phdata->p_flags & PF_NOSEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(elf_phdata->p_flags & PF_NOEMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(elf_phdata->p_flags & PF_NOMPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && !(elf_phdata->p_flags & PF_NORANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#ifdef CONFIG_PAX_XATTR_PAX_FLAGS
+#ifdef CONFIG_PAX_SOFTMODE
+static unsigned long pax_parse_xattr_pax_softmode(unsigned long pax_flags_softmode)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (pax_flags_softmode & MF_PAX_PAGEEXEC)
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (pax_flags_softmode & MF_PAX_SEGMEXEC)
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (pax_flags_softmode & MF_PAX_EMUTRAMP)
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (pax_flags_softmode & MF_PAX_MPROTECT)
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && (pax_flags_softmode & MF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+static unsigned long pax_parse_xattr_pax_hardmode(unsigned long pax_flags_hardmode)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(pax_flags_hardmode & MF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(pax_flags_hardmode & MF_PAX_SEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if (!(pax_flags_hardmode & MF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (!(pax_flags_hardmode & MF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#if defined(CONFIG_PAX_RANDMMAP) || defined(CONFIG_PAX_RANDUSTACK)
+	if (randomize_va_space && !(pax_flags_hardmode & MF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+	return pax_flags;
+}
+#endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static unsigned long pax_parse_ei_pax(const struct elfhdr * const elf_ex)
+{
+	unsigned long pax_flags = 0UL;
+
+#ifdef CONFIG_PAX_EI_PAX
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_PAGEEXEC))
+		pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (!(elf_ex->e_ident[EI_PAX] & EF_PAX_SEGMEXEC))
+		pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && (elf_ex->e_ident[EI_PAX] & EF_PAX_EMUTRAMP))
+		pax_flags |= MF_PAX_EMUTRAMP;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) && !(elf_ex->e_ident[EI_PAX] & EF_PAX_MPROTECT))
+		pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	if (randomize_va_space && !(elf_ex->e_ident[EI_PAX] & EF_PAX_RANDMMAP))
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+#else
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	pax_flags |= MF_PAX_PAGEEXEC;
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_flags |= MF_PAX_SEGMEXEC;
+#endif
+
+#ifdef CONFIG_PAX_MPROTECT
+	pax_flags |= MF_PAX_MPROTECT;
+#endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (randomize_va_space)
+		pax_flags |= MF_PAX_RANDMMAP;
+#endif
+
+#endif
+
+	return pax_flags;
+}
+
+static unsigned long pax_parse_pt_pax(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata)
+{
+
+#ifdef CONFIG_PAX_PT_PAX_FLAGS
+	unsigned long i;
+
+	for (i = 0UL; i < elf_ex->e_phnum; i++)
+		if (elf_phdata[i].p_type == PT_PAX_FLAGS) {
+			if (((elf_phdata[i].p_flags & PF_PAGEEXEC) && (elf_phdata[i].p_flags & PF_NOPAGEEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_SEGMEXEC) && (elf_phdata[i].p_flags & PF_NOSEGMEXEC)) ||
+			    ((elf_phdata[i].p_flags & PF_EMUTRAMP) && (elf_phdata[i].p_flags & PF_NOEMUTRAMP)) ||
+			    ((elf_phdata[i].p_flags & PF_MPROTECT) && (elf_phdata[i].p_flags & PF_NOMPROTECT)) ||
+			    ((elf_phdata[i].p_flags & PF_RANDMMAP) && (elf_phdata[i].p_flags & PF_NORANDMMAP)))
+				return ~0UL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+			if (pax_softmode)
+				return pax_parse_pt_pax_softmode(&elf_phdata[i]);
+			else
+#endif
+
+				return pax_parse_pt_pax_hardmode(&elf_phdata[i]);
+			break;
+		}
+#endif
+
+	return ~0UL;
+}
+
+static unsigned long pax_parse_xattr_pax(struct file * const file)
+{
+
+#ifdef CONFIG_PAX_XATTR_PAX_FLAGS
+	ssize_t xattr_size, i;
+	unsigned char xattr_value[5];
+	unsigned long pax_flags_hardmode = 0UL, pax_flags_softmode = 0UL;
+
+	xattr_size = vfs_getxattr(file->f_path.dentry, XATTR_NAME_PAX_FLAGS, xattr_value, sizeof xattr_value);
+	if (xattr_size <= 0 || xattr_size > 5)
+		return ~0UL;
+
+	for (i = 0; i < xattr_size; i++)
+		switch (xattr_value[i]) {
+		default:
+			return ~0UL;
+
+#define parse_flag(option1, option2, flag)			\
+		case option1:					\
+			if (pax_flags_hardmode & MF_PAX_##flag)	\
+				return ~0UL;			\
+			pax_flags_hardmode |= MF_PAX_##flag;	\
+			break;					\
+		case option2:					\
+			if (pax_flags_softmode & MF_PAX_##flag)	\
+				return ~0UL;			\
+			pax_flags_softmode |= MF_PAX_##flag;	\
+			break;
+
+		parse_flag('p', 'P', PAGEEXEC);
+		parse_flag('e', 'E', EMUTRAMP);
+		parse_flag('m', 'M', MPROTECT);
+		parse_flag('r', 'R', RANDMMAP);
+		parse_flag('s', 'S', SEGMEXEC);
+
+#undef parse_flag
+		}
+
+	if (pax_flags_hardmode & pax_flags_softmode)
+		return ~0UL;
+
+#ifdef CONFIG_PAX_SOFTMODE
+	if (pax_softmode)
+		return pax_parse_xattr_pax_softmode(pax_flags_softmode);
+	else
+#endif
+
+		return pax_parse_xattr_pax_hardmode(pax_flags_hardmode);
+#else
+	return ~0UL;
+#endif
+
+}
+
+static long pax_parse_pax_flags(const struct elfhdr * const elf_ex, const struct elf_phdr * const elf_phdata, struct file * const file)
+{
+	unsigned long pax_flags, pt_pax_flags, xattr_pax_flags;
+
+	pax_flags = pax_parse_ei_pax(elf_ex);
+	pt_pax_flags = pax_parse_pt_pax(elf_ex, elf_phdata);
+	xattr_pax_flags = pax_parse_xattr_pax(file);
+
+	if (pt_pax_flags == ~0UL)
+		pt_pax_flags = xattr_pax_flags;
+	else if (xattr_pax_flags == ~0UL)
+		xattr_pax_flags = pt_pax_flags;
+	if (pt_pax_flags != xattr_pax_flags)
+		return -EINVAL;
+	if (pt_pax_flags != ~0UL)
+		pax_flags = pt_pax_flags;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_PAX_SEGMEXEC)
+	if ((pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) == (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		if ((__supported_pte_mask & _PAGE_NX))
+			pax_flags &= ~MF_PAX_SEGMEXEC;
+		else
+			pax_flags &= ~MF_PAX_PAGEEXEC;
+	}
+#endif
+
+	if (0 > pax_check_flags(&pax_flags))
+		return -EINVAL;
+
+	current->mm->pax_flags = pax_flags;
+	return 0;
+}
+#endif
+
 /*
  * These are the functions used to load ELF style executables and shared
  * libraries.  There is no binary dependent code anywhere else.
@@ -548,6 +878,11 @@ static unsigned long randomize_stack_top
 {
 	unsigned int random_variable = 0;
 
+#ifdef CONFIG_PAX_RANDUSTACK
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP)
+		return stack_top - current->mm->delta_stack;
+#endif
+
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
 		random_variable = get_random_int() & STACK_RND_MASK;
@@ -566,7 +901,7 @@ static int load_elf_binary(struct linux_
  	unsigned long load_addr = 0, load_bias = 0;
 	int load_addr_set = 0;
 	char * elf_interpreter = NULL;
-	unsigned long error;
+	unsigned long error = 0;
 	struct elf_phdr *elf_ppnt, *elf_phdata;
 	unsigned long elf_bss, elf_brk;
 	int retval, i;
@@ -576,11 +911,11 @@ static int load_elf_binary(struct linux_
 	unsigned long start_code, end_code, start_data, end_data;
 	unsigned long reloc_func_desc = 0;
 	int executable_stack = EXSTACK_DEFAULT;
-	unsigned long def_flags = 0;
 	struct {
 		struct elfhdr elf_ex;
 		struct elfhdr interp_elf_ex;
 	} *loc;
+	unsigned long pax_task_size = TASK_SIZE;
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
@@ -718,11 +1053,80 @@ static int load_elf_binary(struct linux_
 
 	/* OK, This is the point of no return */
 	current->flags &= ~PF_FORKNOEXEC;
-	current->mm->def_flags = def_flags;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	current->mm->pax_flags = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	current->mm->call_dl_resolve = 0UL;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	current->mm->call_syscall = 0UL;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	current->mm->delta_mmap = 0UL;
+	current->mm->delta_stack = 0UL;
+#endif
+
+	current->mm->def_flags = 0;
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	if (0 > pax_parse_pax_flags(&loc->elf_ex, elf_phdata, bprm->file)) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+	pax_set_initial_flags(bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	if (pax_set_initial_flags_func)
+		(pax_set_initial_flags_func)(bprm);
+#endif
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+	if ((current->mm->pax_flags & MF_PAX_PAGEEXEC) && !nx_enabled) {
+		current->mm->context.user_cs_limit = PAGE_SIZE;
+		current->mm->def_flags |= VM_PAGEEXEC;
+	}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		current->mm->context.user_cs_base = SEGMEXEC_TASK_SIZE;
+		current->mm->context.user_cs_limit = TASK_SIZE-SEGMEXEC_TASK_SIZE;
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+	}
+#endif
+
+#if defined(CONFIG_ARCH_TRACK_EXEC_LIMIT) || defined(CONFIG_PAX_SEGMEXEC)
+	if (current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		set_user_cs(current->mm->context.user_cs_base, current->mm->context.user_cs_limit, get_cpu());
+		put_cpu();
+	}
+#endif
 
 	/* Do this immediately, since STACK_TOP as used in setup_arg_pages
 	   may depend on the personality.  */
 	SET_PERSONALITY(loc->elf_ex);
+
+#ifdef CONFIG_PAX_ASLR
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+		current->mm->delta_mmap = (pax_get_random_long() & ((1UL << PAX_DELTA_MMAP_LEN)-1)) << PAGE_SHIFT;
+		current->mm->delta_stack = (pax_get_random_long() & ((1UL << PAX_DELTA_STACK_LEN)-1)) << PAGE_SHIFT;
+	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (current->mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		executable_stack = EXSTACK_DISABLE_X;
+		current->personality &= ~READ_IMPLIES_EXEC;
+	} else
+#endif
+
 	if (elf_read_implies_exec(loc->elf_ex, executable_stack))
 		current->personality |= READ_IMPLIES_EXEC;
 
@@ -804,6 +1208,20 @@ static int load_elf_binary(struct linux_
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+			/* PaX: randomize base address at the default exe base if requested */
+			if ((current->mm->pax_flags & MF_PAX_RANDMMAP) && elf_interpreter) {
+#ifdef CONFIG_SPARC64
+				load_bias = (pax_get_random_long() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << (PAGE_SHIFT+1);
+#else
+				load_bias = (pax_get_random_long() & ((1UL << PAX_DELTA_MMAP_LEN) - 1)) << PAGE_SHIFT;
+#endif
+				load_bias = ELF_PAGESTART(PAX_ELF_ET_DYN_BASE - vaddr + load_bias);
+				elf_flags |= MAP_FIXED;
+			}
+#endif
+
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
@@ -836,9 +1254,9 @@ static int load_elf_binary(struct linux_
 		 * allowed task size. Note that p_filesz must always be
 		 * <= p_memsz so it is only necessary to check p_memsz.
 		 */
-		if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
-		    elf_ppnt->p_memsz > TASK_SIZE ||
-		    TASK_SIZE - elf_ppnt->p_memsz < k) {
+		if (k >= pax_task_size || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
+		    elf_ppnt->p_memsz > pax_task_size ||
+		    pax_task_size - elf_ppnt->p_memsz < k) {
 			/* set_brk can never work. Avoid overflows. */
 			send_sig(SIGKILL, current, 0);
 			retval = -EINVAL;
@@ -877,17 +1295,43 @@ static int load_elf_binary(struct linux_
 		goto out_free_dentry;
 	}
 	if (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {
-		send_sig(SIGSEGV, current, 0);
-		retval = -EFAULT; /* Nobody gets to see this, but.. */
-		goto out_free_dentry;
+		/*
+		 * This bss-zeroing can fail if the ELF
+		 * file specifies odd protections. So
+		 * we don't check the return value
+		 */
 	}
 
-	if (elf_interpreter) {
-		unsigned long uninitialized_var(interp_map_addr);
+#ifdef CONFIG_PAX_RANDMMAP
+	if (current->mm->pax_flags & MF_PAX_RANDMMAP) {
+		unsigned long start, size;
 
+		start = ELF_PAGEALIGN(elf_brk);
+		size = PAGE_SIZE + ((pax_get_random_long() & ((1UL << 22) - 1UL)) << 4);
+		down_write(&current->mm->mmap_sem);
+		retval = -ENOMEM;
+		if (!find_vma_intersection(current->mm, start, start + size + PAGE_SIZE)) {
+			unsigned long prot = PROT_NONE;
+
+			current->mm->brk_gap = PAGE_ALIGN(size) >> PAGE_SHIFT;
+//			if (current->personality & ADDR_NO_RANDOMIZE)
+//				prot = PROT_READ;
+			start = do_mmap(NULL, start, size, prot, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0);
+			retval = IS_ERR_VALUE(start) ? start : 0;
+		}
+		up_write(&current->mm->mmap_sem);
+		if (retval == 0)
+			retval = set_brk(start + size, start + size + PAGE_SIZE);
+		if (retval < 0) {
+			send_sig(SIGKILL, current, 0);
+			goto out_free_dentry;
+		}
+	}
+#endif
+
+	if (elf_interpreter) {
 		elf_entry = load_elf_interp(&loc->interp_elf_ex,
 					    interpreter,
-					    &interp_map_addr,
 					    load_bias);
 		if (!IS_ERR((void *)elf_entry)) {
 			/*
@@ -1112,8 +1556,10 @@ static int dump_seek(struct file *file,
 			unsigned long n = off;
 			if (n > PAGE_SIZE)
 				n = PAGE_SIZE;
-			if (!dump_write(file, buf, n))
+			if (!dump_write(file, buf, n)) {
+				free_page((unsigned long)buf);
 				return 0;
+			}
 			off -= n;
 		}
 		free_page((unsigned long)buf);
@@ -1125,7 +1571,7 @@ static int dump_seek(struct file *file,
  * Decide what to dump of a segment, part, all or none.
  */
 static unsigned long vma_dump_size(struct vm_area_struct *vma,
-				   unsigned long mm_flags)
+				   unsigned long mm_flags, long signr)
 {
 #define FILTER(type)	(mm_flags & (1UL << MMF_DUMP_##type))
 
@@ -1159,7 +1605,7 @@ static unsigned long vma_dump_size(struc
 	if (vma->vm_file == NULL)
 		return 0;
 
-	if (FILTER(MAPPED_PRIVATE))
+	if (signr == SIGKILL || FILTER(MAPPED_PRIVATE))
 		goto whole;
 
 	/*
@@ -1385,9 +1831,9 @@ static void fill_auxv_note(struct memelf
 {
 	elf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;
 	int i = 0;
-	do
+	do {
 		i += 2;
-	while (auxv[i - 2] != AT_NULL);
+	} while (auxv[i - 2] != AT_NULL);
 	fill_note(note, "CORE", NT_AUXV, i * sizeof(elf_addr_t), auxv);
 }
 
@@ -1973,7 +2419,7 @@ static int elf_core_dump(long signr, str
 		phdr.p_offset = offset;
 		phdr.p_vaddr = vma->vm_start;
 		phdr.p_paddr = 0;
-		phdr.p_filesz = vma_dump_size(vma, mm_flags);
+		phdr.p_filesz = vma_dump_size(vma, mm_flags, signr);
 		phdr.p_memsz = vma->vm_end - vma->vm_start;
 		offset += phdr.p_filesz;
 		phdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;
@@ -2006,7 +2452,7 @@ static int elf_core_dump(long signr, str
 		unsigned long addr;
 		unsigned long end;
 
-		end = vma->vm_start + vma_dump_size(vma, mm_flags);
+		end = vma->vm_start + vma_dump_size(vma, mm_flags, signr);
 
 		for (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {
 			struct page *page;
@@ -2042,6 +2488,96 @@ out:
 
 #endif		/* USE_ELF_CORE_DUMP */
 
+#ifdef CONFIG_PAX_MPROTECT
+/* PaX: non-PIC ELF libraries need relocations on their executable segments
+ * therefore we'll grant them VM_MAYWRITE once during their life. Similarly
+ * we'll remove VM_MAYWRITE for good on RELRO segments.
+ *
+ * The checks favour ld-linux.so behaviour which operates on a per ELF segment
+ * basis because we want to allow the common case and not the special ones.
+ */
+static void elf_handle_mprotect(struct vm_area_struct *vma, unsigned long newflags)
+{
+	struct elfhdr elf_h;
+	struct elf_phdr elf_p;
+	unsigned long i;
+	unsigned long oldflags;
+	bool is_textrel_rw, is_textrel_rx, is_relro;
+
+	if (!(vma->vm_mm->pax_flags & MF_PAX_MPROTECT))
+		return;
+
+	oldflags = vma->vm_flags & (VM_MAYEXEC | VM_MAYWRITE | VM_MAYREAD | VM_EXEC | VM_WRITE | VM_READ);
+	newflags &= VM_MAYEXEC | VM_MAYWRITE | VM_MAYREAD | VM_EXEC | VM_WRITE | VM_READ;
+
+#ifdef CONFIG_PAX_ELFRELOCS
+	/* possible TEXTREL */
+	is_textrel_rw = vma->vm_file && !vma->anon_vma && oldflags == (VM_MAYEXEC | VM_MAYREAD | VM_EXEC | VM_READ) && newflags == (VM_WRITE | VM_READ);
+	is_textrel_rx = vma->vm_file && vma->anon_vma && oldflags == (VM_MAYEXEC | VM_MAYWRITE | VM_MAYREAD | VM_WRITE | VM_READ) && newflags == (VM_EXEC | VM_READ);
+#else
+	is_textrel_rw = false;
+	is_textrel_rx = false;
+#endif
+
+	/* possible RELRO */
+	is_relro = vma->vm_file && vma->anon_vma && oldflags == (VM_MAYWRITE | VM_MAYREAD | VM_READ) && newflags == (VM_MAYWRITE | VM_MAYREAD | VM_READ);
+
+	if (!is_textrel_rw && !is_textrel_rx && !is_relro)
+		return;
+
+	if (sizeof(elf_h) != kernel_read(vma->vm_file, 0UL, (char *)&elf_h, sizeof(elf_h)) ||
+	    memcmp(elf_h.e_ident, ELFMAG, SELFMAG) ||
+
+#ifdef CONFIG_PAX_ETEXECRELOCS
+	    ((is_textrel_rw || is_textrel_rx) && (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC)) ||
+#else
+	    ((is_textrel_rw || is_textrel_rx) && elf_h.e_type != ET_DYN) ||
+#endif
+
+	    (is_relro && (elf_h.e_type != ET_DYN && elf_h.e_type != ET_EXEC)) ||
+	    !elf_check_arch(&elf_h) ||
+	    elf_h.e_phentsize != sizeof(struct elf_phdr) ||
+	    elf_h.e_phnum > 65536UL / sizeof(struct elf_phdr))
+		return;
+
+	for (i = 0UL; i < elf_h.e_phnum; i++) {
+		if (sizeof(elf_p) != kernel_read(vma->vm_file, elf_h.e_phoff + i*sizeof(elf_p), (char *)&elf_p, sizeof(elf_p)))
+			return;
+		switch (elf_p.p_type) {
+		case PT_DYNAMIC:
+			if (!is_textrel_rw && !is_textrel_rx)
+				continue;
+			i = 0UL;
+			while ((i+1) * sizeof(elf_dyn) <= elf_p.p_filesz) {
+				elf_dyn dyn;
+
+				if (sizeof(dyn) != kernel_read(vma->vm_file, elf_p.p_offset + i*sizeof(dyn), (char *)&dyn, sizeof(dyn)))
+					return;
+				if (dyn.d_tag == DT_NULL)
+					return;
+				if (dyn.d_tag == DT_TEXTREL || (dyn.d_tag == DT_FLAGS && (dyn.d_un.d_val & DF_TEXTREL))) {
+					if (is_textrel_rw)
+						vma->vm_flags |= VM_MAYWRITE;
+					else
+						/* PaX: disallow write access after relocs are done, hopefully noone else needs it... */
+						vma->vm_flags &= ~VM_MAYWRITE;
+					return;
+				}
+				i++;
+			}
+			return;
+
+		case PT_GNU_RELRO:
+			if (!is_relro)
+				continue;
+			if ((elf_p.p_offset >> PAGE_SHIFT) == vma->vm_pgoff && ELF_PAGEALIGN(elf_p.p_memsz) == vma->vm_end - vma->vm_start)
+				vma->vm_flags &= ~VM_MAYWRITE;
+			return;
+		}
+	}
+}
+#endif
+
 static int __init init_elf_binfmt(void)
 {
 	return register_binfmt(&elf_format);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/binfmt_flat.c linux-2.6.32.60-pax/fs/binfmt_flat.c
--- linux-2.6.32.60/fs/binfmt_flat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/binfmt_flat.c	2012-03-13 13:15:35.360097978 +0100
@@ -564,7 +564,9 @@ static int load_flat_file(struct linux_b
 				realdatastart = (unsigned long) -ENOMEM;
 			printk("Unable to allocate RAM for process data, errno %d\n",
 					(int)-realdatastart);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
+			up_write(&current->mm->mmap_sem);
 			ret = realdatastart;
 			goto err;
 		}
@@ -588,8 +590,10 @@ static int load_flat_file(struct linux_b
 		}
 		if (IS_ERR_VALUE(result)) {
 			printk("Unable to read data+bss, errno %d\n", (int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len);
 			do_munmap(current->mm, realdatastart, data_len + extra);
+			up_write(&current->mm->mmap_sem);
 			ret = result;
 			goto err;
 		}
@@ -658,8 +662,10 @@ static int load_flat_file(struct linux_b
 		}
 		if (IS_ERR_VALUE(result)) {
 			printk("Unable to read code+data+bss, errno %d\n",(int)-result);
+			down_write(&current->mm->mmap_sem);
 			do_munmap(current->mm, textpos, text_len + data_len + extra +
 				MAX_SHARED_LIBS * sizeof(unsigned long));
+			up_write(&current->mm->mmap_sem);
 			ret = result;
 			goto err;
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/bio.c linux-2.6.32.60-pax/fs/bio.c
--- linux-2.6.32.60/fs/bio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/bio.c	2012-07-21 11:20:52.477059538 +0200
@@ -78,7 +78,7 @@ static struct kmem_cache *bio_find_or_cr
 
 	i = 0;
 	while (i < bio_slab_nr) {
-		struct bio_slab *bslab = &bio_slabs[i];
+		bslab = &bio_slabs[i];
 
 		if (!bslab->slab && entry == -1)
 			entry = i;
@@ -841,7 +841,7 @@ struct bio *bio_copy_user_iov(struct req
 		/*
 		 * Overflow, abort
 		 */
-		if (end < start)
+		if (end < start || end - start > INT_MAX - nr_pages)
 			return ERR_PTR(-EINVAL);
 
 		nr_pages += end - start;
@@ -974,7 +974,7 @@ static struct bio *__bio_map_user_iov(st
 		/*
 		 * Overflow, abort
 		 */
-		if (end < start)
+		if (end < start || end - start > INT_MAX - nr_pages)
 			return ERR_PTR(-EINVAL);
 
 		nr_pages += end - start;
@@ -1236,7 +1236,7 @@ static void bio_copy_kern_endio(struct b
 	const int read = bio_data_dir(bio) == READ;
 	struct bio_map_data *bmd = bio->bi_private;
 	int i;
-	char *p = bmd->sgvecs[0].iov_base;
+	char *p = (char __force_kernel *)bmd->sgvecs[0].iov_base;
 
 	__bio_for_each_segment(bvec, bio, i, 0) {
 		char *addr = page_address(bvec->bv_page);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/block_dev.c linux-2.6.32.60-pax/fs/block_dev.c
--- linux-2.6.32.60/fs/block_dev.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/block_dev.c	2012-03-13 13:15:35.364097978 +0100
@@ -664,7 +664,7 @@ int bd_claim(struct block_device *bdev,
 	else if (bdev->bd_contains == bdev)
 		res = 0;  	 /* is a whole device which isn't held */
 
-	else if (bdev->bd_contains->bd_holder == bd_claim)
+	else if (bdev->bd_contains->bd_holder == (void *)bd_claim)
 		res = 0; 	 /* is a partition of a device that is being partitioned */
 	else if (bdev->bd_contains->bd_holder != NULL)
 		res = -EBUSY;	 /* is a partition of a held device */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/btrfs/ctree.c linux-2.6.32.60-pax/fs/btrfs/ctree.c
--- linux-2.6.32.60/fs/btrfs/ctree.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/btrfs/ctree.c	2012-03-13 13:15:35.364097978 +0100
@@ -461,9 +461,12 @@ static noinline int __btrfs_cow_block(st
 		free_extent_buffer(buf);
 		add_root_to_dirty_list(root);
 	} else {
-		if (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)
-			parent_start = parent->start;
-		else
+		if (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {
+			if (parent)
+				parent_start = parent->start;
+			else
+				parent_start = 0;
+		} else
 			parent_start = 0;
 
 		WARN_ON(trans->transid != btrfs_header_generation(parent));
@@ -3645,7 +3648,6 @@ setup_items_for_insert(struct btrfs_tran
 
 	ret = 0;
 	if (slot == 0) {
-		struct btrfs_disk_key disk_key;
 		btrfs_cpu_key_to_disk(&disk_key, cpu_key);
 		ret = fixup_low_keys(trans, root, path, &disk_key, 1);
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/btrfs/free-space-cache.c linux-2.6.32.60-pax/fs/btrfs/free-space-cache.c
--- linux-2.6.32.60/fs/btrfs/free-space-cache.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/btrfs/free-space-cache.c	2012-03-13 13:15:35.368097977 +0100
@@ -1074,8 +1074,6 @@ u64 btrfs_alloc_from_cluster(struct btrf
 
 	while(1) {
 		if (entry->bytes < bytes || entry->offset < min_start) {
-			struct rb_node *node;
-
 			node = rb_next(&entry->offset_index);
 			if (!node)
 				break;
@@ -1226,7 +1224,7 @@ again:
 	 */
 	while (entry->bitmap || found_bitmap ||
 	       (!entry->bitmap && entry->bytes < min_bytes)) {
-		struct rb_node *node = rb_next(&entry->offset_index);
+		node = rb_next(&entry->offset_index);
 
 		if (entry->bitmap && entry->bytes > bytes + empty_size) {
 			ret = btrfs_bitmap_cluster(block_group, entry, cluster,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/btrfs/relocation.c linux-2.6.32.60-pax/fs/btrfs/relocation.c
--- linux-2.6.32.60/fs/btrfs/relocation.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/btrfs/relocation.c	2012-03-13 13:15:35.368097977 +0100
@@ -884,7 +884,7 @@ static int __update_reloc_root(struct bt
 	}
 	spin_unlock(&rc->reloc_root_tree.lock);
 
-	BUG_ON((struct btrfs_root *)node->data != root);
+	BUG_ON(!node || (struct btrfs_root *)node->data != root);
 
 	if (!del) {
 		spin_lock(&rc->reloc_root_tree.lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/bind.c linux-2.6.32.60-pax/fs/cachefiles/bind.c
--- linux-2.6.32.60/fs/cachefiles/bind.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/bind.c	2012-03-13 13:15:35.368097977 +0100
@@ -39,13 +39,11 @@ int cachefiles_daemon_bind(struct cachef
 	       args);
 
 	/* start by checking things over */
-	ASSERT(cache->fstop_percent >= 0 &&
-	       cache->fstop_percent < cache->fcull_percent &&
+	ASSERT(cache->fstop_percent < cache->fcull_percent &&
 	       cache->fcull_percent < cache->frun_percent &&
 	       cache->frun_percent  < 100);
 
-	ASSERT(cache->bstop_percent >= 0 &&
-	       cache->bstop_percent < cache->bcull_percent &&
+	ASSERT(cache->bstop_percent < cache->bcull_percent &&
 	       cache->bcull_percent < cache->brun_percent &&
 	       cache->brun_percent  < 100);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/daemon.c linux-2.6.32.60-pax/fs/cachefiles/daemon.c
--- linux-2.6.32.60/fs/cachefiles/daemon.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/daemon.c	2012-03-13 13:15:35.372097977 +0100
@@ -220,7 +220,7 @@ static ssize_t cachefiles_daemon_write(s
 	if (test_bit(CACHEFILES_DEAD, &cache->flags))
 		return -EIO;
 
-	if (datalen < 0 || datalen > PAGE_SIZE - 1)
+	if (datalen > PAGE_SIZE - 1)
 		return -EOPNOTSUPP;
 
 	/* drag the command string into the kernel so we can parse it */
@@ -385,7 +385,7 @@ static int cachefiles_daemon_fstop(struc
 	if (args[0] != '%' || args[1] != '\0')
 		return -EINVAL;
 
-	if (fstop < 0 || fstop >= cache->fcull_percent)
+	if (fstop >= cache->fcull_percent)
 		return cachefiles_daemon_range_error(cache, args);
 
 	cache->fstop_percent = fstop;
@@ -457,7 +457,7 @@ static int cachefiles_daemon_bstop(struc
 	if (args[0] != '%' || args[1] != '\0')
 		return -EINVAL;
 
-	if (bstop < 0 || bstop >= cache->bcull_percent)
+	if (bstop >= cache->bcull_percent)
 		return cachefiles_daemon_range_error(cache, args);
 
 	cache->bstop_percent = bstop;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/internal.h linux-2.6.32.60-pax/fs/cachefiles/internal.h
--- linux-2.6.32.60/fs/cachefiles/internal.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/internal.h	2012-03-13 13:15:35.372097977 +0100
@@ -56,7 +56,7 @@ struct cachefiles_cache {
 	wait_queue_head_t		daemon_pollwq;	/* poll waitqueue for daemon */
 	struct rb_root			active_nodes;	/* active nodes (can't be culled) */
 	rwlock_t			active_lock;	/* lock for active_nodes */
-	atomic_t			gravecounter;	/* graveyard uniquifier */
+	atomic_unchecked_t		gravecounter;	/* graveyard uniquifier */
 	unsigned			frun_percent;	/* when to stop culling (% files) */
 	unsigned			fcull_percent;	/* when to start culling (% files) */
 	unsigned			fstop_percent;	/* when to stop allocating (% files) */
@@ -168,19 +168,19 @@ extern int cachefiles_check_in_use(struc
  * proc.c
  */
 #ifdef CONFIG_CACHEFILES_HISTOGRAM
-extern atomic_t cachefiles_lookup_histogram[HZ];
-extern atomic_t cachefiles_mkdir_histogram[HZ];
-extern atomic_t cachefiles_create_histogram[HZ];
+extern atomic_unchecked_t cachefiles_lookup_histogram[HZ];
+extern atomic_unchecked_t cachefiles_mkdir_histogram[HZ];
+extern atomic_unchecked_t cachefiles_create_histogram[HZ];
 
 extern int __init cachefiles_proc_init(void);
 extern void cachefiles_proc_cleanup(void);
 static inline
-void cachefiles_hist(atomic_t histogram[], unsigned long start_jif)
+void cachefiles_hist(atomic_unchecked_t histogram[], unsigned long start_jif)
 {
 	unsigned long jif = jiffies - start_jif;
 	if (jif >= HZ)
 		jif = HZ - 1;
-	atomic_inc(&histogram[jif]);
+	atomic_inc_unchecked(&histogram[jif]);
 }
 
 #else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/namei.c linux-2.6.32.60-pax/fs/cachefiles/namei.c
--- linux-2.6.32.60/fs/cachefiles/namei.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/namei.c	2012-03-13 13:15:35.372097977 +0100
@@ -250,7 +250,7 @@ try_again:
 	/* first step is to make up a grave dentry in the graveyard */
 	sprintf(nbuffer, "%08x%08x",
 		(uint32_t) get_seconds(),
-		(uint32_t) atomic_inc_return(&cache->gravecounter));
+		(uint32_t) atomic_inc_return_unchecked(&cache->gravecounter));
 
 	/* do the multiway lock magic */
 	trap = lock_rename(cache->graveyard, dir);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/proc.c linux-2.6.32.60-pax/fs/cachefiles/proc.c
--- linux-2.6.32.60/fs/cachefiles/proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/proc.c	2012-03-13 13:15:35.372097977 +0100
@@ -14,9 +14,9 @@
 #include <linux/seq_file.h>
 #include "internal.h"
 
-atomic_t cachefiles_lookup_histogram[HZ];
-atomic_t cachefiles_mkdir_histogram[HZ];
-atomic_t cachefiles_create_histogram[HZ];
+atomic_unchecked_t cachefiles_lookup_histogram[HZ];
+atomic_unchecked_t cachefiles_mkdir_histogram[HZ];
+atomic_unchecked_t cachefiles_create_histogram[HZ];
 
 /*
  * display the latency histogram
@@ -35,9 +35,9 @@ static int cachefiles_histogram_show(str
 		return 0;
 	default:
 		index = (unsigned long) v - 3;
-		x = atomic_read(&cachefiles_lookup_histogram[index]);
-		y = atomic_read(&cachefiles_mkdir_histogram[index]);
-		z = atomic_read(&cachefiles_create_histogram[index]);
+		x = atomic_read_unchecked(&cachefiles_lookup_histogram[index]);
+		y = atomic_read_unchecked(&cachefiles_mkdir_histogram[index]);
+		z = atomic_read_unchecked(&cachefiles_create_histogram[index]);
 		if (x == 0 && y == 0 && z == 0)
 			return 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cachefiles/rdwr.c linux-2.6.32.60-pax/fs/cachefiles/rdwr.c
--- linux-2.6.32.60/fs/cachefiles/rdwr.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cachefiles/rdwr.c	2012-03-13 13:15:35.376097977 +0100
@@ -946,7 +946,7 @@ int cachefiles_write_page(struct fscache
 			old_fs = get_fs();
 			set_fs(KERNEL_DS);
 			ret = file->f_op->write(
-				file, (const void __user *) data, len, &pos);
+				file, (const void __force_user *) data, len, &pos);
 			set_fs(old_fs);
 			kunmap(page);
 			if (ret != len)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cifs/cifs_debug.c linux-2.6.32.60-pax/fs/cifs/cifs_debug.c
--- linux-2.6.32.60/fs/cifs/cifs_debug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cifs/cifs_debug.c	2012-03-13 13:15:35.376097977 +0100
@@ -242,8 +242,8 @@ static ssize_t cifs_stats_proc_write(str
 
 	if (c == '1' || c == 'y' || c == 'Y' || c == '0') {
 #ifdef CONFIG_CIFS_STATS2
-		atomic_set(&totBufAllocCount, 0);
-		atomic_set(&totSmBufAllocCount, 0);
+		atomic_set_unchecked(&totBufAllocCount, 0);
+		atomic_set_unchecked(&totSmBufAllocCount, 0);
 #endif /* CONFIG_CIFS_STATS2 */
 		read_lock(&cifs_tcp_ses_lock);
 		list_for_each(tmp1, &cifs_tcp_ses_list) {
@@ -256,25 +256,25 @@ static ssize_t cifs_stats_proc_write(str
 					tcon = list_entry(tmp3,
 							  struct cifsTconInfo,
 							  tcon_list);
-					atomic_set(&tcon->num_smbs_sent, 0);
-					atomic_set(&tcon->num_writes, 0);
-					atomic_set(&tcon->num_reads, 0);
-					atomic_set(&tcon->num_oplock_brks, 0);
-					atomic_set(&tcon->num_opens, 0);
-					atomic_set(&tcon->num_posixopens, 0);
-					atomic_set(&tcon->num_posixmkdirs, 0);
-					atomic_set(&tcon->num_closes, 0);
-					atomic_set(&tcon->num_deletes, 0);
-					atomic_set(&tcon->num_mkdirs, 0);
-					atomic_set(&tcon->num_rmdirs, 0);
-					atomic_set(&tcon->num_renames, 0);
-					atomic_set(&tcon->num_t2renames, 0);
-					atomic_set(&tcon->num_ffirst, 0);
-					atomic_set(&tcon->num_fnext, 0);
-					atomic_set(&tcon->num_fclose, 0);
-					atomic_set(&tcon->num_hardlinks, 0);
-					atomic_set(&tcon->num_symlinks, 0);
-					atomic_set(&tcon->num_locks, 0);
+					atomic_set_unchecked(&tcon->num_smbs_sent, 0);
+					atomic_set_unchecked(&tcon->num_writes, 0);
+					atomic_set_unchecked(&tcon->num_reads, 0);
+					atomic_set_unchecked(&tcon->num_oplock_brks, 0);
+					atomic_set_unchecked(&tcon->num_opens, 0);
+					atomic_set_unchecked(&tcon->num_posixopens, 0);
+					atomic_set_unchecked(&tcon->num_posixmkdirs, 0);
+					atomic_set_unchecked(&tcon->num_closes, 0);
+					atomic_set_unchecked(&tcon->num_deletes, 0);
+					atomic_set_unchecked(&tcon->num_mkdirs, 0);
+					atomic_set_unchecked(&tcon->num_rmdirs, 0);
+					atomic_set_unchecked(&tcon->num_renames, 0);
+					atomic_set_unchecked(&tcon->num_t2renames, 0);
+					atomic_set_unchecked(&tcon->num_ffirst, 0);
+					atomic_set_unchecked(&tcon->num_fnext, 0);
+					atomic_set_unchecked(&tcon->num_fclose, 0);
+					atomic_set_unchecked(&tcon->num_hardlinks, 0);
+					atomic_set_unchecked(&tcon->num_symlinks, 0);
+					atomic_set_unchecked(&tcon->num_locks, 0);
 				}
 			}
 		}
@@ -304,8 +304,8 @@ static int cifs_stats_proc_show(struct s
 			smBufAllocCount.counter, cifs_min_small);
 #ifdef CONFIG_CIFS_STATS2
 	seq_printf(m, "Total Large %d Small %d Allocations\n",
-				atomic_read(&totBufAllocCount),
-				atomic_read(&totSmBufAllocCount));
+				atomic_read_unchecked(&totBufAllocCount),
+				atomic_read_unchecked(&totSmBufAllocCount));
 #endif /* CONFIG_CIFS_STATS2 */
 
 	seq_printf(m, "Operations (MIDs): %d\n", midCount.counter);
@@ -334,41 +334,41 @@ static int cifs_stats_proc_show(struct s
 				if (tcon->need_reconnect)
 					seq_puts(m, "\tDISCONNECTED ");
 				seq_printf(m, "\nSMBs: %d Oplock Breaks: %d",
-					atomic_read(&tcon->num_smbs_sent),
-					atomic_read(&tcon->num_oplock_brks));
+					atomic_read_unchecked(&tcon->num_smbs_sent),
+					atomic_read_unchecked(&tcon->num_oplock_brks));
 				seq_printf(m, "\nReads:  %d Bytes: %lld",
-					atomic_read(&tcon->num_reads),
+					atomic_read_unchecked(&tcon->num_reads),
 					(long long)(tcon->bytes_read));
 				seq_printf(m, "\nWrites: %d Bytes: %lld",
-					atomic_read(&tcon->num_writes),
+					atomic_read_unchecked(&tcon->num_writes),
 					(long long)(tcon->bytes_written));
 				seq_printf(m, "\nFlushes: %d",
-					atomic_read(&tcon->num_flushes));
+					atomic_read_unchecked(&tcon->num_flushes));
 				seq_printf(m, "\nLocks: %d HardLinks: %d "
 					      "Symlinks: %d",
-					atomic_read(&tcon->num_locks),
-					atomic_read(&tcon->num_hardlinks),
-					atomic_read(&tcon->num_symlinks));
+					atomic_read_unchecked(&tcon->num_locks),
+					atomic_read_unchecked(&tcon->num_hardlinks),
+					atomic_read_unchecked(&tcon->num_symlinks));
 				seq_printf(m, "\nOpens: %d Closes: %d "
 					      "Deletes: %d",
-					atomic_read(&tcon->num_opens),
-					atomic_read(&tcon->num_closes),
-					atomic_read(&tcon->num_deletes));
+					atomic_read_unchecked(&tcon->num_opens),
+					atomic_read_unchecked(&tcon->num_closes),
+					atomic_read_unchecked(&tcon->num_deletes));
 				seq_printf(m, "\nPosix Opens: %d "
 					      "Posix Mkdirs: %d",
-					atomic_read(&tcon->num_posixopens),
-					atomic_read(&tcon->num_posixmkdirs));
+					atomic_read_unchecked(&tcon->num_posixopens),
+					atomic_read_unchecked(&tcon->num_posixmkdirs));
 				seq_printf(m, "\nMkdirs: %d Rmdirs: %d",
-					atomic_read(&tcon->num_mkdirs),
-					atomic_read(&tcon->num_rmdirs));
+					atomic_read_unchecked(&tcon->num_mkdirs),
+					atomic_read_unchecked(&tcon->num_rmdirs));
 				seq_printf(m, "\nRenames: %d T2 Renames %d",
-					atomic_read(&tcon->num_renames),
-					atomic_read(&tcon->num_t2renames));
+					atomic_read_unchecked(&tcon->num_renames),
+					atomic_read_unchecked(&tcon->num_t2renames));
 				seq_printf(m, "\nFindFirst: %d FNext %d "
 					      "FClose %d",
-					atomic_read(&tcon->num_ffirst),
-					atomic_read(&tcon->num_fnext),
-					atomic_read(&tcon->num_fclose));
+					atomic_read_unchecked(&tcon->num_ffirst),
+					atomic_read_unchecked(&tcon->num_fnext),
+					atomic_read_unchecked(&tcon->num_fclose));
 			}
 		}
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cifs/cifsfs.c linux-2.6.32.60-pax/fs/cifs/cifsfs.c
--- linux-2.6.32.60/fs/cifs/cifsfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cifs/cifsfs.c	2012-03-13 13:15:35.376097977 +0100
@@ -869,7 +869,7 @@ cifs_init_request_bufs(void)
 	cifs_req_cachep = kmem_cache_create("cifs_request",
 					    CIFSMaxBufSize +
 					    MAX_CIFS_HDR_SIZE, 0,
-					    SLAB_HWCACHE_ALIGN, NULL);
+					    SLAB_HWCACHE_ALIGN | SLAB_USERCOPY, NULL);
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
@@ -896,7 +896,7 @@ cifs_init_request_bufs(void)
 	efficient to alloc 1 per page off the slab compared to 17K (5page)
 	alloc of large cifs buffers even when page debugging is on */
 	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
-			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,
+			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN | SLAB_USERCOPY,
 			NULL);
 	if (cifs_sm_req_cachep == NULL) {
 		mempool_destroy(cifs_req_poolp);
@@ -991,8 +991,8 @@ init_cifs(void)
 	atomic_set(&bufAllocCount, 0);
 	atomic_set(&smBufAllocCount, 0);
 #ifdef CONFIG_CIFS_STATS2
-	atomic_set(&totBufAllocCount, 0);
-	atomic_set(&totSmBufAllocCount, 0);
+	atomic_set_unchecked(&totBufAllocCount, 0);
+	atomic_set_unchecked(&totSmBufAllocCount, 0);
 #endif /* CONFIG_CIFS_STATS2 */
 
 	atomic_set(&midCount, 0);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cifs/cifsglob.h linux-2.6.32.60-pax/fs/cifs/cifsglob.h
--- linux-2.6.32.60/fs/cifs/cifsglob.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cifs/cifsglob.h	2012-03-13 13:15:35.376097977 +0100
@@ -252,28 +252,28 @@ struct cifsTconInfo {
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;
 #ifdef CONFIG_CIFS_STATS
-	atomic_t num_smbs_sent;
-	atomic_t num_writes;
-	atomic_t num_reads;
-	atomic_t num_flushes;
-	atomic_t num_oplock_brks;
-	atomic_t num_opens;
-	atomic_t num_closes;
-	atomic_t num_deletes;
-	atomic_t num_mkdirs;
-	atomic_t num_posixopens;
-	atomic_t num_posixmkdirs;
-	atomic_t num_rmdirs;
-	atomic_t num_renames;
-	atomic_t num_t2renames;
-	atomic_t num_ffirst;
-	atomic_t num_fnext;
-	atomic_t num_fclose;
-	atomic_t num_hardlinks;
-	atomic_t num_symlinks;
-	atomic_t num_locks;
-	atomic_t num_acl_get;
-	atomic_t num_acl_set;
+	atomic_unchecked_t num_smbs_sent;
+	atomic_unchecked_t num_writes;
+	atomic_unchecked_t num_reads;
+	atomic_unchecked_t num_flushes;
+	atomic_unchecked_t num_oplock_brks;
+	atomic_unchecked_t num_opens;
+	atomic_unchecked_t num_closes;
+	atomic_unchecked_t num_deletes;
+	atomic_unchecked_t num_mkdirs;
+	atomic_unchecked_t num_posixopens;
+	atomic_unchecked_t num_posixmkdirs;
+	atomic_unchecked_t num_rmdirs;
+	atomic_unchecked_t num_renames;
+	atomic_unchecked_t num_t2renames;
+	atomic_unchecked_t num_ffirst;
+	atomic_unchecked_t num_fnext;
+	atomic_unchecked_t num_fclose;
+	atomic_unchecked_t num_hardlinks;
+	atomic_unchecked_t num_symlinks;
+	atomic_unchecked_t num_locks;
+	atomic_unchecked_t num_acl_get;
+	atomic_unchecked_t num_acl_set;
 #ifdef CONFIG_CIFS_STATS2
 	unsigned long long time_writes;
 	unsigned long long time_reads;
@@ -414,7 +414,7 @@ static inline char CIFS_DIR_SEP(const st
 }
 
 #ifdef CONFIG_CIFS_STATS
-#define cifs_stats_inc atomic_inc
+#define cifs_stats_inc atomic_inc_unchecked
 
 static inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,
 					    unsigned int bytes)
@@ -701,8 +701,8 @@ GLOBAL_EXTERN atomic_t tconInfoReconnect
 /* Various Debug counters */
 GLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */
 #ifdef CONFIG_CIFS_STATS2
-GLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */
-GLOBAL_EXTERN atomic_t totSmBufAllocCount;
+GLOBAL_EXTERN atomic_unchecked_t totBufAllocCount; /* total allocated over all time */
+GLOBAL_EXTERN atomic_unchecked_t totSmBufAllocCount;
 #endif
 GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cifs/link.c linux-2.6.32.60-pax/fs/cifs/link.c
--- linux-2.6.32.60/fs/cifs/link.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cifs/link.c	2012-03-13 13:15:35.380097977 +0100
@@ -215,7 +215,7 @@ cifs_symlink(struct inode *inode, struct
 
 void cifs_put_link(struct dentry *direntry, struct nameidata *nd, void *cookie)
 {
-	char *p = nd_get_link(nd);
+	const char *p = nd_get_link(nd);
 	if (!IS_ERR(p))
 		kfree(p);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/cifs/misc.c linux-2.6.32.60-pax/fs/cifs/misc.c
--- linux-2.6.32.60/fs/cifs/misc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/cifs/misc.c	2012-03-13 13:15:35.380097977 +0100
@@ -155,7 +155,7 @@ cifs_buf_get(void)
 		memset(ret_buf, 0, sizeof(struct smb_hdr) + 3);
 		atomic_inc(&bufAllocCount);
 #ifdef CONFIG_CIFS_STATS2
-		atomic_inc(&totBufAllocCount);
+		atomic_inc_unchecked(&totBufAllocCount);
 #endif /* CONFIG_CIFS_STATS2 */
 	}
 
@@ -190,7 +190,7 @@ cifs_small_buf_get(void)
 	/*	memset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/
 		atomic_inc(&smBufAllocCount);
 #ifdef CONFIG_CIFS_STATS2
-		atomic_inc(&totSmBufAllocCount);
+		atomic_inc_unchecked(&totSmBufAllocCount);
 #endif /* CONFIG_CIFS_STATS2 */
 
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/coda/cache.c linux-2.6.32.60-pax/fs/coda/cache.c
--- linux-2.6.32.60/fs/coda/cache.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/coda/cache.c	2012-03-13 13:15:35.380097977 +0100
@@ -24,14 +24,14 @@
 #include <linux/coda_fs_i.h>
 #include <linux/coda_cache.h>
 
-static atomic_t permission_epoch = ATOMIC_INIT(0);
+static atomic_unchecked_t permission_epoch = ATOMIC_INIT(0);
 
 /* replace or extend an acl cache hit */
 void coda_cache_enter(struct inode *inode, int mask)
 {
 	struct coda_inode_info *cii = ITOC(inode);
 
-	cii->c_cached_epoch = atomic_read(&permission_epoch);
+	cii->c_cached_epoch = atomic_read_unchecked(&permission_epoch);
 	if (cii->c_uid != current_fsuid()) {
 		cii->c_uid = current_fsuid();
                 cii->c_cached_perm = mask;
@@ -43,13 +43,13 @@ void coda_cache_enter(struct inode *inod
 void coda_cache_clear_inode(struct inode *inode)
 {
 	struct coda_inode_info *cii = ITOC(inode);
-	cii->c_cached_epoch = atomic_read(&permission_epoch) - 1;
+	cii->c_cached_epoch = atomic_read_unchecked(&permission_epoch) - 1;
 }
 
 /* remove all acl caches */
 void coda_cache_clear_all(struct super_block *sb)
 {
-	atomic_inc(&permission_epoch);
+	atomic_inc_unchecked(&permission_epoch);
 }
 
 
@@ -61,7 +61,7 @@ int coda_cache_check(struct inode *inode
 	
         hit = (mask & cii->c_cached_perm) == mask &&
 		cii->c_uid == current_fsuid() &&
-		cii->c_cached_epoch == atomic_read(&permission_epoch);
+		cii->c_cached_epoch == atomic_read_unchecked(&permission_epoch);
 
         return hit;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/compat_binfmt_elf.c linux-2.6.32.60-pax/fs/compat_binfmt_elf.c
--- linux-2.6.32.60/fs/compat_binfmt_elf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/compat_binfmt_elf.c	2012-03-13 13:15:35.380097977 +0100
@@ -29,10 +29,12 @@
 #undef	elfhdr
 #undef	elf_phdr
 #undef	elf_note
+#undef	elf_dyn
 #undef	elf_addr_t
 #define elfhdr		elf32_hdr
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
+#define elf_dyn		Elf32_Dyn
 #define elf_addr_t	Elf32_Addr
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/compat.c linux-2.6.32.60-pax/fs/compat.c
--- linux-2.6.32.60/fs/compat.c	2012-10-09 11:00:35.472882473 +0200
+++ linux-2.6.32.60-pax/fs/compat.c	2012-10-09 11:00:39.328883047 +0200
@@ -133,8 +133,8 @@ asmlinkage long compat_sys_utimes(char _
 static int cp_compat_stat(struct kstat *stat, struct compat_stat __user *ubuf)
 {
 	compat_ino_t ino = stat->ino;
-	typeof(ubuf->st_uid) uid = 0;
-	typeof(ubuf->st_gid) gid = 0;
+	typeof(((struct compat_stat *)0)->st_uid) uid = 0;
+	typeof(((struct compat_stat *)0)->st_gid) gid = 0;
 	int err;
 
 	SET_UID(uid, stat->uid);
@@ -533,7 +533,7 @@ compat_sys_io_setup(unsigned nr_reqs, u3
 
 	set_fs(KERNEL_DS);
 	/* The __user pointer cast is valid because of the set_fs() */
-	ret = sys_io_setup(nr_reqs, (aio_context_t __user *) &ctx64);
+	ret = sys_io_setup(nr_reqs, (aio_context_t __force_user *) &ctx64);
 	set_fs(oldfs);
 	/* truncating is ok because it's a user address */
 	if (!ret)
@@ -1060,7 +1060,7 @@ asmlinkage long compat_sys_getdents64(un
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		typeof(lastdirent->d_off) d_off = file->f_pos;
+		typeof(((struct linux_dirent64 *)0)->d_off) d_off = file->f_pos;
 		if (__put_user_unaligned(d_off, &lastdirent->d_off))
 			error = -EFAULT;
 		else
@@ -1098,7 +1098,7 @@ static ssize_t compat_do_readv_writev(in
 	 * verify all the pointers
 	 */
 	ret = -EINVAL;
-	if ((nr_segs > UIO_MAXIOV) || (nr_segs <= 0))
+	if (nr_segs > UIO_MAXIOV)
 		goto out;
 	if (!file->f_op)
 		goto out;
@@ -2157,7 +2157,7 @@ asmlinkage long compat_sys_nfsservctl(in
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	/* The __user pointer casts are valid because of the set_fs() */
-	err = sys_nfsservctl(cmd, (void __user *) karg, (void __user *) kres);
+	err = sys_nfsservctl(cmd, (void __force_user *) karg, (void __force_user *) kres);
 	set_fs(oldfs);
 
 	if (err)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/compat_ioctl.c linux-2.6.32.60-pax/fs/compat_ioctl.c
--- linux-2.6.32.60/fs/compat_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/compat_ioctl.c	2012-03-13 13:15:35.384097977 +0100
@@ -234,6 +234,8 @@ static int do_video_set_spu_palette(unsi
 	up = (struct compat_video_spu_palette __user *) arg;
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
+	if (err)
+		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
@@ -1513,7 +1515,7 @@ static int serial_struct_ioctl(unsigned
 			return -EFAULT;
                 if (__get_user(udata, &ss32->iomem_base))
 			return -EFAULT;
-                ss.iomem_base = compat_ptr(udata);
+                ss.iomem_base = (unsigned char __force_kernel *)compat_ptr(udata);
                 if (__get_user(ss.iomem_reg_shift, &ss32->iomem_reg_shift) ||
 		    __get_user(ss.port_high, &ss32->port_high))
 			return -EFAULT;
@@ -1809,7 +1811,7 @@ static int compat_ioctl_preallocate(stru
 	    copy_in_user(&p->l_len,	&p32->l_len,	sizeof(s64)) ||
 	    copy_in_user(&p->l_sysid,	&p32->l_sysid,	sizeof(s32)) ||
 	    copy_in_user(&p->l_pid,	&p32->l_pid,	sizeof(u32)) ||
-	    copy_in_user(&p->l_pad,	&p32->l_pad,	4*sizeof(u32)))
+	    copy_in_user(p->l_pad,	&p32->l_pad,	4*sizeof(u32)))
 		return -EFAULT;
 
 	return ioctl_preallocate(file, p);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/configfs/dir.c linux-2.6.32.60-pax/fs/configfs/dir.c
--- linux-2.6.32.60/fs/configfs/dir.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/configfs/dir.c	2012-03-13 13:15:35.384097977 +0100
@@ -1572,7 +1572,8 @@ static int configfs_readdir(struct file
 			}
 			for (p=q->next; p!= &parent_sd->s_children; p=p->next) {
 				struct configfs_dirent *next;
-				const char * name;
+				const unsigned char * name;
+				char d_name[sizeof(next->s_dentry->d_iname)];
 				int len;
 
 				next = list_entry(p, struct configfs_dirent,
@@ -1581,7 +1582,12 @@ static int configfs_readdir(struct file
 					continue;
 
 				name = configfs_get_name(next);
-				len = strlen(name);
+				if (next->s_dentry && name == next->s_dentry->d_iname) {
+					len =  next->s_dentry->d_name.len;
+					memcpy(d_name, name, len);
+					name = d_name;
+				} else
+					len = strlen(name);
 				if (next->s_dentry)
 					ino = next->s_dentry->d_inode->i_ino;
 				else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/dcache.c linux-2.6.32.60-pax/fs/dcache.c
--- linux-2.6.32.60/fs/dcache.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/dcache.c	2012-03-13 13:15:35.388097976 +0100
@@ -45,8 +45,6 @@ EXPORT_SYMBOL(dcache_lock);
 
 static struct kmem_cache *dentry_cache __read_mostly;
 
-#define DNAME_INLINE_LEN (sizeof(struct dentry)-offsetof(struct dentry,d_iname))
-
 /*
  * This is the single most critical data structure when it comes
  * to the dcache: the hashtable for lookups. Somebody should try
@@ -2319,7 +2317,7 @@ void __init vfs_caches_init(unsigned lon
 	mempages -= reserve;
 
 	names_cachep = kmem_cache_create("names_cache", PATH_MAX, 0,
-			SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_USERCOPY, NULL);
 
 	dcache_init();
 	inode_init();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ecryptfs/inode.c linux-2.6.32.60-pax/fs/ecryptfs/inode.c
--- linux-2.6.32.60/fs/ecryptfs/inode.c	2012-10-09 11:00:35.472882473 +0200
+++ linux-2.6.32.60-pax/fs/ecryptfs/inode.c	2012-10-09 11:00:39.328883047 +0200
@@ -647,7 +647,7 @@ static int ecryptfs_readlink_lower(struc
 	old_fs = get_fs();
 	set_fs(get_ds());
 	rc = lower_dentry->d_inode->i_op->readlink(lower_dentry,
-						   (char __user *)lower_buf,
+						   (char __force_user *)lower_buf,
 						   lower_bufsiz);
 	set_fs(old_fs);
 	if (rc < 0)
@@ -693,7 +693,7 @@ static void *ecryptfs_follow_link(struct
 	}
 	old_fs = get_fs();
 	set_fs(get_ds());
-	rc = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	rc = dentry->d_inode->i_op->readlink(dentry, (__force char __user *)buf, len);
 	set_fs(old_fs);
 	if (rc < 0)
 		goto out_free;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/exec.c linux-2.6.32.60-pax/fs/exec.c
--- linux-2.6.32.60/fs/exec.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/exec.c	2013-02-17 17:14:31.340173690 +0100
@@ -56,12 +56,32 @@
 #include <linux/fsnotify.h>
 #include <linux/fs_struct.h>
 #include <linux/pipe_fs_i.h>
+#include <linux/random.h>
+#include <linux/seq_file.h>
+#include <linux/mman.h>
+
+#ifdef CONFIG_PAX_REFCOUNT
+#include <linux/kallsyms.h>
+#include <linux/kdebug.h>
+#endif
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
 #include "internal.h"
 
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+void __weak pax_set_initial_flags(struct linux_binprm *bprm)
+{
+	printk_once(KERN_WARNING "PAX: PAX_HAVE_ACL_FLAGS was enabled without providing the pax_set_initial_flags callback, this is probably not what you wanted.\n");
+}
+#endif
+
+#ifdef CONFIG_PAX_HOOK_ACL_FLAGS
+void (*pax_set_initial_flags_func)(struct linux_binprm *bprm);
+EXPORT_SYMBOL(pax_set_initial_flags_func);
+#endif
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 unsigned int core_pipe_limit;
@@ -178,18 +198,10 @@ struct page *get_arg_page(struct linux_b
 		int write)
 {
 	struct page *page;
-	int ret;
 
-#ifdef CONFIG_STACK_GROWSUP
-	if (write) {
-		ret = expand_stack_downwards(bprm->vma, pos);
-		if (ret < 0)
-			return NULL;
-	}
-#endif
-	ret = get_user_pages(current, bprm->mm, pos,
-			1, write, 1, &page, NULL);
-	if (ret <= 0)
+	if (0 > expand_stack_downwards(bprm->vma, pos))
+		return NULL;
+	if (0 >= get_user_pages(current, bprm->mm, pos, 1, write, 1, &page, NULL))
 		return NULL;
 
 	if (write) {
@@ -263,6 +275,11 @@ static int __bprm_mm_init(struct linux_b
 	vma->vm_end = STACK_TOP_MAX;
 	vma->vm_start = vma->vm_end - PAGE_SIZE;
 	vma->vm_flags = VM_STACK_FLAGS;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma->vm_flags &= ~(VM_EXEC | VM_MAYEXEC);
+#endif
+
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 
 	err = security_file_mmap(NULL, 0, 0, 0, vma->vm_start, 1);
@@ -276,6 +293,12 @@ static int __bprm_mm_init(struct linux_b
 	mm->stack_vm = mm->total_vm = 1;
 	up_write(&mm->mmap_sem);
 	bprm->p = vma->vm_end - sizeof(void *);
+
+#ifdef CONFIG_PAX_RANDUSTACK
+	if (randomize_va_space)
+		bprm->p ^= (pax_get_random_long() & ~15) & ~PAGE_MASK;
+#endif
+
 	return 0;
 err:
 	up_write(&mm->mmap_sem);
@@ -510,7 +533,7 @@ int copy_strings_kernel(int argc,char **
 	int r;
 	mm_segment_t oldfs = get_fs();
 	set_fs(KERNEL_DS);
-	r = copy_strings(argc, (char __user * __user *)argv, bprm);
+	r = copy_strings(argc, (__force char __user * __user *)argv, bprm);
 	set_fs(oldfs);
 	return r;
 }
@@ -540,7 +563,8 @@ static int shift_arg_pages(struct vm_are
 	unsigned long new_end = old_end - shift;
 	struct mmu_gather *tlb;
 
-	BUG_ON(new_start > new_end);
+	if (new_start >= new_end || new_start < mmap_min_addr)
+		return -ENOMEM;
 
 	/*
 	 * ensure there are no vmas between where we want to go
@@ -549,6 +573,10 @@ static int shift_arg_pages(struct vm_are
 	if (vma != find_vma(mm, new_start))
 		return -EFAULT;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	BUG_ON(pax_find_mirror_vma(vma));
+#endif
+
 	/*
 	 * cover the whole range: [new_start, old_end)
 	 */
@@ -630,10 +658,6 @@ int setup_arg_pages(struct linux_binprm
 	stack_top = arch_align_stack(stack_top);
 	stack_top = PAGE_ALIGN(stack_top);
 
-	if (unlikely(stack_top < mmap_min_addr) ||
-	    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))
-		return -ENOMEM;
-
 	stack_shift = vma->vm_end - stack_top;
 
 	bprm->p -= stack_shift;
@@ -645,6 +669,14 @@ int setup_arg_pages(struct linux_binprm
 	bprm->exec -= stack_shift;
 
 	down_write(&mm->mmap_sem);
+
+	/* Move stack pages down in memory. */
+	if (stack_shift) {
+		ret = shift_arg_pages(vma, stack_shift);
+		if (ret)
+			goto out_unlock;
+	}
+
 	vm_flags = VM_STACK_FLAGS;
 
 	/*
@@ -658,19 +690,24 @@ int setup_arg_pages(struct linux_binprm
 		vm_flags &= ~VM_EXEC;
 	vm_flags |= mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			vm_flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	ret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,
 			vm_flags);
 	if (ret)
 		goto out_unlock;
 	BUG_ON(prev != vma);
 
-	/* Move stack pages down in memory. */
-	if (stack_shift) {
-		ret = shift_arg_pages(vma, stack_shift);
-		if (ret)
-			goto out_unlock;
-	}
-
 	stack_expand = EXTRA_STACK_VM_PAGES * PAGE_SIZE;
 	stack_size = vma->vm_end - vma->vm_start;
 	/*
@@ -690,6 +727,27 @@ int setup_arg_pages(struct linux_binprm
 		stack_base = vma->vm_start - stack_expand;
 #endif
 	ret = expand_stack(vma, stack_base);
+
+#if !defined(CONFIG_STACK_GROWSUP) && defined(CONFIG_PAX_ASLR)
+	if (!ret && (mm->pax_flags & MF_PAX_RANDMMAP) && STACK_TOP <= 0xFFFFFFFFU && STACK_TOP > vma->vm_end) {
+		unsigned long size, flags, vm_flags;
+
+		size = STACK_TOP - vma->vm_end;
+		flags = MAP_FIXED | MAP_PRIVATE;
+		vm_flags = VM_DONTEXPAND | VM_RESERVED;
+
+		ret = vma->vm_end != mmap_region(NULL, vma->vm_end, size, flags, vm_flags, 0);
+
+#ifdef CONFIG_X86
+		if (!ret) {
+			size = mmap_min_addr + ((mm->delta_mmap ^ mm->delta_stack) & (0xFFUL << PAGE_SHIFT));
+			ret = 0 != mmap_region(NULL, 0, size, flags, vm_flags, 0);
+		}
+#endif
+
+	}
+#endif
+
 	if (ret)
 		ret = -EFAULT;
 
@@ -744,7 +802,7 @@ int kernel_read(struct file *file, loff_
 	old_fs = get_fs();
 	set_fs(get_ds());
 	/* The cast to a user pointer is valid due to the set_fs() */
-	result = vfs_read(file, (void __user *)addr, count, &pos);
+	result = vfs_read(file, (void __force_user *)addr, count, &pos);
 	set_fs(old_fs);
 	return result;
 }
@@ -1152,7 +1210,7 @@ int check_unsafe_exec(struct linux_binpr
 	}
 	rcu_read_unlock();
 
-	if (p->fs->users > n_fs) {
+	if (atomic_read(&p->fs->users) > n_fs) {
 		bprm->unsafe |= LSM_UNSAFE_SHARE;
 	} else {
 		res = -EAGAIN;
@@ -1591,6 +1649,238 @@ out:
 	return ispipe;
 }
 
+int pax_check_flags(unsigned long *flags)
+{
+	int retval = 0;
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_SEGMEXEC)
+	if (*flags & MF_PAX_SEGMEXEC)
+	{
+		*flags &= ~MF_PAX_SEGMEXEC;
+		retval = -EINVAL;
+	}
+#endif
+
+	if ((*flags & MF_PAX_PAGEEXEC)
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	    &&  (*flags & MF_PAX_SEGMEXEC)
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_PAGEEXEC;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_MPROTECT)
+
+#ifdef CONFIG_PAX_MPROTECT
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_MPROTECT;
+		retval = -EINVAL;
+	}
+
+	if ((*flags & MF_PAX_EMUTRAMP)
+
+#ifdef CONFIG_PAX_EMUTRAMP
+	    && !(*flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC))
+#endif
+
+	   )
+	{
+		*flags &= ~MF_PAX_EMUTRAMP;
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(pax_check_flags);
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_fault(struct pt_regs *regs, void *pc, void *sp)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = current->mm;
+	char *buffer_exec = (char *)__get_free_page(GFP_KERNEL);
+	char *buffer_fault = (char *)__get_free_page(GFP_KERNEL);
+	char *path_exec = NULL;
+	char *path_fault = NULL;
+	unsigned long start = 0UL, end = 0UL, offset = 0UL;
+
+	if (buffer_exec && buffer_fault) {
+		struct vm_area_struct *vma, *vma_exec = NULL, *vma_fault = NULL;
+
+		down_read(&mm->mmap_sem);
+		vma = mm->mmap;
+		while (vma && (!vma_exec || !vma_fault)) {
+			if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+				vma_exec = vma;
+			if (vma->vm_start <= (unsigned long)pc && (unsigned long)pc < vma->vm_end)
+				vma_fault = vma;
+			vma = vma->vm_next;
+		}
+		if (vma_exec) {
+			path_exec = d_path(&vma_exec->vm_file->f_path, buffer_exec, PAGE_SIZE);
+			if (IS_ERR(path_exec))
+				path_exec = "<path too long>";
+			else {
+				path_exec = mangle_path(buffer_exec, path_exec, "\t\n\\");
+				if (path_exec) {
+					*path_exec = 0;
+					path_exec = buffer_exec;
+				} else
+					path_exec = "<path too long>";
+			}
+		}
+		if (vma_fault) {
+			start = vma_fault->vm_start;
+			end = vma_fault->vm_end;
+			offset = vma_fault->vm_pgoff << PAGE_SHIFT;
+			if (vma_fault->vm_file) {
+				path_fault = d_path(&vma_fault->vm_file->f_path, buffer_fault, PAGE_SIZE);
+				if (IS_ERR(path_fault))
+					path_fault = "<path too long>";
+				else {
+					path_fault = mangle_path(buffer_fault, path_fault, "\t\n\\");
+					if (path_fault) {
+						*path_fault = 0;
+						path_fault = buffer_fault;
+					} else
+						path_fault = "<path too long>";
+				}
+			} else
+				path_fault = "<anonymous mapping>";
+		}
+		up_read(&mm->mmap_sem);
+	}
+	printk(KERN_ERR "PAX: execution attempt in: %s, %08lx-%08lx %08lx\n", path_fault, start, end, offset);
+	printk(KERN_ERR "PAX: terminating task: %s(%s):%d, uid/euid: %u/%u, "
+			"PC: %p, SP: %p\n", path_exec, tsk->comm, task_pid_nr(tsk),
+			task_uid(tsk), task_euid(tsk), pc, sp);
+	free_page((unsigned long)buffer_exec);
+	free_page((unsigned long)buffer_fault);
+	pax_report_insns(regs, pc, sp);
+	do_coredump(SIGKILL, SIGKILL, regs);
+}
+#endif
+
+#ifdef CONFIG_PAX_REFCOUNT
+void pax_report_refcount_overflow(struct pt_regs *regs)
+{
+	printk(KERN_ERR "PAX: refcount overflow detected in: %s:%d, uid/euid: %u/%u\n",
+			 current->comm, task_pid_nr(current), current_uid(), current_euid());
+	print_symbol(KERN_ERR "PAX: refcount overflow occured at: %s\n", instruction_pointer(regs));
+	show_regs(regs);
+	force_sig_specific(SIGKILL, current);
+}
+#endif
+
+#ifdef CONFIG_PAX_USERCOPY
+/* 0: not at all, 1: fully, 2: fully inside frame, -1: partially (implies an error) */
+static noinline int check_stack_object(const void *obj, unsigned long len)
+{
+	const void * const stack = task_stack_page(current);
+	const void * const stackend = stack + THREAD_SIZE;
+
+#if defined(CONFIG_FRAME_POINTER) && defined(CONFIG_X86)
+	const void *frame = NULL;
+	const void *oldframe;
+#endif
+
+	if (obj + len < obj)
+		return -1;
+
+	if (obj + len <= stack || stackend <= obj)
+		return 0;
+
+	if (obj < stack || stackend < obj + len)
+		return -1;
+
+#if defined(CONFIG_FRAME_POINTER) && defined(CONFIG_X86)
+	oldframe = __builtin_frame_address(1);
+	if (oldframe)
+		frame = __builtin_frame_address(2);
+	/*
+	  low ----------------------------------------------> high
+	  [saved bp][saved ip][args][local vars][saved bp][saved ip]
+			      ^----------------^
+			  allow copies only within here
+	*/
+	while (stack <= frame && frame < stackend) {
+		/* if obj + len extends past the last frame, this
+		   check won't pass and the next frame will be 0,
+		   causing us to bail out and correctly report
+		   the copy as invalid
+		*/
+		if (obj + len <= frame)
+			return obj >= oldframe + 2 * sizeof(void *) ? 2 : -1;
+		oldframe = frame;
+		frame = *(const void * const *)frame;
+	}
+	return -1;
+#else
+	return 1;
+#endif
+}
+
+static __noreturn void pax_report_usercopy(const void *ptr, unsigned long len, bool to, const char *type)
+{
+	printk(KERN_ERR "PAX: kernel memory %s attempt detected %s %p (%s) (%lu bytes)\n",
+		to ? "leak" : "overwrite", to ? "from" : "to", ptr, type ? : "unknown", len);
+	dump_stack();
+	do_group_exit(SIGKILL);
+}
+#endif
+
+void __check_object_size(const void *ptr, unsigned long n, bool to)
+{
+
+#ifdef CONFIG_PAX_USERCOPY
+	const char *type;
+
+	if (!n)
+		return;
+
+	type = check_heap_object(ptr, n);
+	if (!type) {
+		if (check_stack_object(ptr, n) != -1)
+			return;
+		type = "<process stack>";
+	}
+
+	pax_report_usercopy(ptr, n, to, type);
+#endif
+
+}
+EXPORT_SYMBOL(__check_object_size);
+
+#ifdef CONFIG_PAX_MEMORY_STACKLEAK
+void pax_track_stack(void)
+{
+	unsigned long sp = (unsigned long)&sp;
+	if (sp < current_thread_info()->lowest_stack &&
+	    sp > (unsigned long)task_stack_page(current))
+		current_thread_info()->lowest_stack = sp;
+}
+EXPORT_SYMBOL(pax_track_stack);
+#endif
+
+#ifdef CONFIG_PAX_SIZE_OVERFLOW
+void report_size_overflow(const char *file, unsigned int line, const char *func, const char *ssa_name)
+{
+	printk(KERN_ERR "PAX: size overflow detected in function %s %s:%u %s", func, file, line, ssa_name);
+	dump_stack();
+	do_group_exit(SIGKILL);
+}
+EXPORT_SYMBOL(report_size_overflow);
+#endif
+
 static int zap_process(struct task_struct *start)
 {
 	struct task_struct *t;
@@ -1793,17 +2083,17 @@ static void wait_for_dump_helpers(struct
 	pipe = file->f_path.dentry->d_inode->i_pipe;
 
 	pipe_lock(pipe);
-	pipe->readers++;
-	pipe->writers--;
+	atomic_inc(&pipe->readers);
+	atomic_dec(&pipe->writers);
 
-	while ((pipe->readers > 1) && (!signal_pending(current))) {
+	while ((atomic_read(&pipe->readers) > 1) && (!signal_pending(current))) {
 		wake_up_interruptible_sync(&pipe->wait);
 		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
 		pipe_wait(pipe);
 	}
 
-	pipe->readers--;
-	pipe->writers++;
+	atomic_dec(&pipe->readers);
+	atomic_inc(&pipe->writers);
 	pipe_unlock(pipe);
 
 }
@@ -1826,7 +2116,7 @@ void do_coredump(long signr, int exit_co
 	char **helper_argv = NULL;
 	int helper_argc = 0;
 	int dump_count = 0;
-	static atomic_t core_dump_count = ATOMIC_INIT(0);
+	static atomic_unchecked_t core_dump_count = ATOMIC_INIT(0);
 
 	audit_core_dumps(signr);
 
@@ -1908,7 +2198,7 @@ void do_coredump(long signr, int exit_co
 			goto fail_unlock;
 		}
 
-		dump_count = atomic_inc_return(&core_dump_count);
+		dump_count = atomic_inc_return_unchecked(&core_dump_count);
 		if (core_pipe_limit && (core_pipe_limit < dump_count)) {
 			printk(KERN_WARNING "Pid %d(%s) over core_pipe_limit\n",
 			       task_tgid_vnr(current), current->comm);
@@ -1972,7 +2262,7 @@ close_fail:
 	filp_close(file, NULL);
 fail_dropcount:
 	if (dump_count)
-		atomic_dec(&core_dump_count);
+		atomic_dec_unchecked(&core_dump_count);
 fail_unlock:
 	if (helper_argv)
 		argv_free(helper_argv);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ext4/ext4.h linux-2.6.32.60-pax/fs/ext4/ext4.h
--- linux-2.6.32.60/fs/ext4/ext4.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ext4/ext4.h	2012-03-13 13:15:35.392097976 +0100
@@ -1077,19 +1077,19 @@ struct ext4_sb_info {
 
 	/* stats for buddy allocator */
 	spinlock_t s_mb_pa_lock;
-	atomic_t s_bal_reqs;	/* number of reqs with len > 1 */
-	atomic_t s_bal_success;	/* we found long enough chunks */
-	atomic_t s_bal_allocated;	/* in blocks */
-	atomic_t s_bal_ex_scanned;	/* total extents scanned */
-	atomic_t s_bal_goals;	/* goal hits */
-	atomic_t s_bal_breaks;	/* too long searches */
-	atomic_t s_bal_2orders;	/* 2^order hits */
+	atomic_unchecked_t s_bal_reqs;	/* number of reqs with len > 1 */
+	atomic_unchecked_t s_bal_success;	/* we found long enough chunks */
+	atomic_unchecked_t s_bal_allocated;	/* in blocks */
+	atomic_unchecked_t s_bal_ex_scanned;	/* total extents scanned */
+	atomic_unchecked_t s_bal_goals;	/* goal hits */
+	atomic_unchecked_t s_bal_breaks;	/* too long searches */
+	atomic_unchecked_t s_bal_2orders;	/* 2^order hits */
 	spinlock_t s_bal_lock;
 	unsigned long s_mb_buddies_generated;
 	unsigned long long s_mb_generation_time;
-	atomic_t s_mb_lost_chunks;
-	atomic_t s_mb_preallocated;
-	atomic_t s_mb_discarded;
+	atomic_unchecked_t s_mb_lost_chunks;
+	atomic_unchecked_t s_mb_preallocated;
+	atomic_unchecked_t s_mb_discarded;
 	atomic_t s_lock_busy;
 
 	/* locality groups */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ext4/mballoc.c linux-2.6.32.60-pax/fs/ext4/mballoc.c
--- linux-2.6.32.60/fs/ext4/mballoc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ext4/mballoc.c	2012-03-13 13:15:35.396097976 +0100
@@ -1755,7 +1755,7 @@ void ext4_mb_simple_scan_group(struct ex
 		BUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);
 
 		if (EXT4_SB(sb)->s_mb_stats)
-			atomic_inc(&EXT4_SB(sb)->s_bal_2orders);
+			atomic_inc_unchecked(&EXT4_SB(sb)->s_bal_2orders);
 
 		break;
 	}
@@ -2131,7 +2131,7 @@ repeat:
 			ac->ac_status = AC_STATUS_CONTINUE;
 			ac->ac_flags |= EXT4_MB_HINT_FIRST;
 			cr = 3;
-			atomic_inc(&sbi->s_mb_lost_chunks);
+			atomic_inc_unchecked(&sbi->s_mb_lost_chunks);
 			goto repeat;
 		}
 	}
@@ -2534,25 +2534,25 @@ int ext4_mb_release(struct super_block *
 	if (sbi->s_mb_stats) {
 		printk(KERN_INFO
 		       "EXT4-fs: mballoc: %u blocks %u reqs (%u success)\n",
-				atomic_read(&sbi->s_bal_allocated),
-				atomic_read(&sbi->s_bal_reqs),
-				atomic_read(&sbi->s_bal_success));
+				atomic_read_unchecked(&sbi->s_bal_allocated),
+				atomic_read_unchecked(&sbi->s_bal_reqs),
+				atomic_read_unchecked(&sbi->s_bal_success));
 		printk(KERN_INFO
 		      "EXT4-fs: mballoc: %u extents scanned, %u goal hits, "
 				"%u 2^N hits, %u breaks, %u lost\n",
-				atomic_read(&sbi->s_bal_ex_scanned),
-				atomic_read(&sbi->s_bal_goals),
-				atomic_read(&sbi->s_bal_2orders),
-				atomic_read(&sbi->s_bal_breaks),
-				atomic_read(&sbi->s_mb_lost_chunks));
+				atomic_read_unchecked(&sbi->s_bal_ex_scanned),
+				atomic_read_unchecked(&sbi->s_bal_goals),
+				atomic_read_unchecked(&sbi->s_bal_2orders),
+				atomic_read_unchecked(&sbi->s_bal_breaks),
+				atomic_read_unchecked(&sbi->s_mb_lost_chunks));
 		printk(KERN_INFO
 		       "EXT4-fs: mballoc: %lu generated and it took %Lu\n",
 				sbi->s_mb_buddies_generated++,
 				sbi->s_mb_generation_time);
 		printk(KERN_INFO
 		       "EXT4-fs: mballoc: %u preallocated, %u discarded\n",
-				atomic_read(&sbi->s_mb_preallocated),
-				atomic_read(&sbi->s_mb_discarded));
+				atomic_read_unchecked(&sbi->s_mb_preallocated),
+				atomic_read_unchecked(&sbi->s_mb_discarded));
 	}
 
 	free_percpu(sbi->s_locality_groups);
@@ -3034,16 +3034,16 @@ static void ext4_mb_collect_stats(struct
 	struct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);
 
 	if (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {
-		atomic_inc(&sbi->s_bal_reqs);
-		atomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);
+		atomic_inc_unchecked(&sbi->s_bal_reqs);
+		atomic_add_unchecked(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);
 		if (ac->ac_o_ex.fe_len >= ac->ac_g_ex.fe_len)
-			atomic_inc(&sbi->s_bal_success);
-		atomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);
+			atomic_inc_unchecked(&sbi->s_bal_success);
+		atomic_add_unchecked(ac->ac_found, &sbi->s_bal_ex_scanned);
 		if (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&
 				ac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)
-			atomic_inc(&sbi->s_bal_goals);
+			atomic_inc_unchecked(&sbi->s_bal_goals);
 		if (ac->ac_found > sbi->s_mb_max_to_scan)
-			atomic_inc(&sbi->s_bal_breaks);
+			atomic_inc_unchecked(&sbi->s_bal_breaks);
 	}
 
 	if (ac->ac_op == EXT4_MB_HISTORY_ALLOC)
@@ -3443,7 +3443,7 @@ ext4_mb_new_inode_pa(struct ext4_allocat
 	trace_ext4_mb_new_inode_pa(ac, pa);
 
 	ext4_mb_use_inode_pa(ac, pa);
-	atomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);
+	atomic_add_unchecked(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);
 
 	ei = EXT4_I(ac->ac_inode);
 	grp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);
@@ -3503,7 +3503,7 @@ ext4_mb_new_group_pa(struct ext4_allocat
 	trace_ext4_mb_new_group_pa(ac, pa);
 
 	ext4_mb_use_group_pa(ac, pa);
-	atomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);
+	atomic_add_unchecked(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);
 
 	grp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);
 	lg = ac->ac_lg;
@@ -3607,7 +3607,7 @@ ext4_mb_release_inode_pa(struct ext4_bud
 		 * from the bitmap and continue.
 		 */
 	}
-	atomic_add(free, &sbi->s_mb_discarded);
+	atomic_add_unchecked(free, &sbi->s_mb_discarded);
 
 	return err;
 }
@@ -3626,7 +3626,7 @@ ext4_mb_release_group_pa(struct ext4_bud
 	ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);
 	BUG_ON(group != e4b->bd_group && pa->pa_len != 0);
 	mb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);
-	atomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);
+	atomic_add_unchecked(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);
 
 	if (ac) {
 		ac->ac_sb = sb;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fcntl.c linux-2.6.32.60-pax/fs/fcntl.c
--- linux-2.6.32.60/fs/fcntl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fcntl.c	2012-03-13 13:15:35.396097976 +0100
@@ -265,7 +265,7 @@ pid_t f_getown(struct file *filp)
 
 static int f_setown_ex(struct file *filp, unsigned long arg)
 {
-	struct f_owner_ex * __user owner_p = (void * __user)arg;
+	struct f_owner_ex __user *owner_p = (void __user *)arg;
 	struct f_owner_ex owner;
 	struct pid *pid;
 	int type;
@@ -305,7 +305,7 @@ static int f_setown_ex(struct file *filp
 
 static int f_getown_ex(struct file *filp, unsigned long arg)
 {
-	struct f_owner_ex * __user owner_p = (void * __user)arg;
+	struct f_owner_ex __user *owner_p = (void __user *)arg;
 	struct f_owner_ex owner;
 	int ret = 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fifo.c linux-2.6.32.60-pax/fs/fifo.c
--- linux-2.6.32.60/fs/fifo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fifo.c	2012-03-13 13:15:35.396097976 +0100
@@ -59,10 +59,10 @@ static int fifo_open(struct inode *inode
 	 */
 		filp->f_op = &read_pipefifo_fops;
 		pipe->r_counter++;
-		if (pipe->readers++ == 0)
+		if (atomic_inc_return(&pipe->readers) == 1)
 			wake_up_partner(inode);
 
-		if (!pipe->writers) {
+		if (!atomic_read(&pipe->writers)) {
 			if ((filp->f_flags & O_NONBLOCK)) {
 				/* suppress POLLHUP until we have
 				 * seen a writer */
@@ -83,15 +83,15 @@ static int fifo_open(struct inode *inode
 	 *  errno=ENXIO when there is no process reading the FIFO.
 	 */
 		ret = -ENXIO;
-		if ((filp->f_flags & O_NONBLOCK) && !pipe->readers)
+		if ((filp->f_flags & O_NONBLOCK) && !atomic_read(&pipe->readers))
 			goto err;
 
 		filp->f_op = &write_pipefifo_fops;
 		pipe->w_counter++;
-		if (!pipe->writers++)
+		if (atomic_inc_return(&pipe->writers) == 1)
 			wake_up_partner(inode);
 
-		if (!pipe->readers) {
+		if (!atomic_read(&pipe->readers)) {
 			wait_for_partner(inode, &pipe->r_counter);
 			if (signal_pending(current))
 				goto err_wr;
@@ -107,11 +107,11 @@ static int fifo_open(struct inode *inode
 	 */
 		filp->f_op = &rdwr_pipefifo_fops;
 
-		pipe->readers++;
-		pipe->writers++;
+		atomic_inc(&pipe->readers);
+		atomic_inc(&pipe->writers);
 		pipe->r_counter++;
 		pipe->w_counter++;
-		if (pipe->readers == 1 || pipe->writers == 1)
+		if (atomic_read(&pipe->readers) == 1 || atomic_read(&pipe->writers) == 1)
 			wake_up_partner(inode);
 		break;
 
@@ -125,19 +125,19 @@ static int fifo_open(struct inode *inode
 	return 0;
 
 err_rd:
-	if (!--pipe->readers)
+	if (atomic_dec_and_test(&pipe->readers))
 		wake_up_interruptible(&pipe->wait);
 	ret = -ERESTARTSYS;
 	goto err;
 
 err_wr:
-	if (!--pipe->writers)
+	if (atomic_dec_and_test(&pipe->writers))
 		wake_up_interruptible(&pipe->wait);
 	ret = -ERESTARTSYS;
 	goto err;
 
 err:
-	if (!pipe->readers && !pipe->writers)
+	if (!atomic_read(&pipe->readers) && !atomic_read(&pipe->writers))
 		free_pipe_info(inode);
 
 err_nocleanup:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/cookie.c linux-2.6.32.60-pax/fs/fscache/cookie.c
--- linux-2.6.32.60/fs/fscache/cookie.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/cookie.c	2012-03-13 13:15:35.396097976 +0100
@@ -68,11 +68,11 @@ struct fscache_cookie *__fscache_acquire
 	       parent ? (char *) parent->def->name : "<no-parent>",
 	       def->name, netfs_data);
 
-	fscache_stat(&fscache_n_acquires);
+	fscache_stat_unchecked(&fscache_n_acquires);
 
 	/* if there's no parent cookie, then we don't create one here either */
 	if (!parent) {
-		fscache_stat(&fscache_n_acquires_null);
+		fscache_stat_unchecked(&fscache_n_acquires_null);
 		_leave(" [no parent]");
 		return NULL;
 	}
@@ -87,7 +87,7 @@ struct fscache_cookie *__fscache_acquire
 	/* allocate and initialise a cookie */
 	cookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);
 	if (!cookie) {
-		fscache_stat(&fscache_n_acquires_oom);
+		fscache_stat_unchecked(&fscache_n_acquires_oom);
 		_leave(" [ENOMEM]");
 		return NULL;
 	}
@@ -109,13 +109,13 @@ struct fscache_cookie *__fscache_acquire
 
 	switch (cookie->def->type) {
 	case FSCACHE_COOKIE_TYPE_INDEX:
-		fscache_stat(&fscache_n_cookie_index);
+		fscache_stat_unchecked(&fscache_n_cookie_index);
 		break;
 	case FSCACHE_COOKIE_TYPE_DATAFILE:
-		fscache_stat(&fscache_n_cookie_data);
+		fscache_stat_unchecked(&fscache_n_cookie_data);
 		break;
 	default:
-		fscache_stat(&fscache_n_cookie_special);
+		fscache_stat_unchecked(&fscache_n_cookie_special);
 		break;
 	}
 
@@ -126,13 +126,13 @@ struct fscache_cookie *__fscache_acquire
 		if (fscache_acquire_non_index_cookie(cookie) < 0) {
 			atomic_dec(&parent->n_children);
 			__fscache_cookie_put(cookie);
-			fscache_stat(&fscache_n_acquires_nobufs);
+			fscache_stat_unchecked(&fscache_n_acquires_nobufs);
 			_leave(" = NULL");
 			return NULL;
 		}
 	}
 
-	fscache_stat(&fscache_n_acquires_ok);
+	fscache_stat_unchecked(&fscache_n_acquires_ok);
 	_leave(" = %p", cookie);
 	return cookie;
 }
@@ -168,7 +168,7 @@ static int fscache_acquire_non_index_coo
 	cache = fscache_select_cache_for_object(cookie->parent);
 	if (!cache) {
 		up_read(&fscache_addremove_sem);
-		fscache_stat(&fscache_n_acquires_no_cache);
+		fscache_stat_unchecked(&fscache_n_acquires_no_cache);
 		_leave(" = -ENOMEDIUM [no cache]");
 		return -ENOMEDIUM;
 	}
@@ -256,12 +256,12 @@ static int fscache_alloc_object(struct f
 	object = cache->ops->alloc_object(cache, cookie);
 	fscache_stat_d(&fscache_n_cop_alloc_object);
 	if (IS_ERR(object)) {
-		fscache_stat(&fscache_n_object_no_alloc);
+		fscache_stat_unchecked(&fscache_n_object_no_alloc);
 		ret = PTR_ERR(object);
 		goto error;
 	}
 
-	fscache_stat(&fscache_n_object_alloc);
+	fscache_stat_unchecked(&fscache_n_object_alloc);
 
 	object->debug_id = atomic_inc_return(&fscache_object_debug_id);
 
@@ -377,10 +377,10 @@ void __fscache_update_cookie(struct fsca
 	struct fscache_object *object;
 	struct hlist_node *_p;
 
-	fscache_stat(&fscache_n_updates);
+	fscache_stat_unchecked(&fscache_n_updates);
 
 	if (!cookie) {
-		fscache_stat(&fscache_n_updates_null);
+		fscache_stat_unchecked(&fscache_n_updates_null);
 		_leave(" [no cookie]");
 		return;
 	}
@@ -414,12 +414,12 @@ void __fscache_relinquish_cookie(struct
 	struct fscache_object *object;
 	unsigned long event;
 
-	fscache_stat(&fscache_n_relinquishes);
+	fscache_stat_unchecked(&fscache_n_relinquishes);
 	if (retire)
-		fscache_stat(&fscache_n_relinquishes_retire);
+		fscache_stat_unchecked(&fscache_n_relinquishes_retire);
 
 	if (!cookie) {
-		fscache_stat(&fscache_n_relinquishes_null);
+		fscache_stat_unchecked(&fscache_n_relinquishes_null);
 		_leave(" [no cookie]");
 		return;
 	}
@@ -435,7 +435,7 @@ void __fscache_relinquish_cookie(struct
 
 	/* wait for the cookie to finish being instantiated (or to fail) */
 	if (test_bit(FSCACHE_COOKIE_CREATING, &cookie->flags)) {
-		fscache_stat(&fscache_n_relinquishes_waitcrt);
+		fscache_stat_unchecked(&fscache_n_relinquishes_waitcrt);
 		wait_on_bit(&cookie->flags, FSCACHE_COOKIE_CREATING,
 			    fscache_wait_bit, TASK_UNINTERRUPTIBLE);
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/internal.h linux-2.6.32.60-pax/fs/fscache/internal.h
--- linux-2.6.32.60/fs/fscache/internal.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/internal.h	2012-03-13 13:15:35.400097976 +0100
@@ -136,94 +136,94 @@ extern void fscache_proc_cleanup(void);
 extern atomic_t fscache_n_ops_processed[FSCACHE_MAX_THREADS];
 extern atomic_t fscache_n_objs_processed[FSCACHE_MAX_THREADS];
 
-extern atomic_t fscache_n_op_pend;
-extern atomic_t fscache_n_op_run;
-extern atomic_t fscache_n_op_enqueue;
-extern atomic_t fscache_n_op_deferred_release;
-extern atomic_t fscache_n_op_release;
-extern atomic_t fscache_n_op_gc;
-extern atomic_t fscache_n_op_cancelled;
-extern atomic_t fscache_n_op_rejected;
-
-extern atomic_t fscache_n_attr_changed;
-extern atomic_t fscache_n_attr_changed_ok;
-extern atomic_t fscache_n_attr_changed_nobufs;
-extern atomic_t fscache_n_attr_changed_nomem;
-extern atomic_t fscache_n_attr_changed_calls;
-
-extern atomic_t fscache_n_allocs;
-extern atomic_t fscache_n_allocs_ok;
-extern atomic_t fscache_n_allocs_wait;
-extern atomic_t fscache_n_allocs_nobufs;
-extern atomic_t fscache_n_allocs_intr;
-extern atomic_t fscache_n_allocs_object_dead;
-extern atomic_t fscache_n_alloc_ops;
-extern atomic_t fscache_n_alloc_op_waits;
-
-extern atomic_t fscache_n_retrievals;
-extern atomic_t fscache_n_retrievals_ok;
-extern atomic_t fscache_n_retrievals_wait;
-extern atomic_t fscache_n_retrievals_nodata;
-extern atomic_t fscache_n_retrievals_nobufs;
-extern atomic_t fscache_n_retrievals_intr;
-extern atomic_t fscache_n_retrievals_nomem;
-extern atomic_t fscache_n_retrievals_object_dead;
-extern atomic_t fscache_n_retrieval_ops;
-extern atomic_t fscache_n_retrieval_op_waits;
-
-extern atomic_t fscache_n_stores;
-extern atomic_t fscache_n_stores_ok;
-extern atomic_t fscache_n_stores_again;
-extern atomic_t fscache_n_stores_nobufs;
-extern atomic_t fscache_n_stores_oom;
-extern atomic_t fscache_n_store_ops;
-extern atomic_t fscache_n_store_calls;
-extern atomic_t fscache_n_store_pages;
-extern atomic_t fscache_n_store_radix_deletes;
-extern atomic_t fscache_n_store_pages_over_limit;
-
-extern atomic_t fscache_n_store_vmscan_not_storing;
-extern atomic_t fscache_n_store_vmscan_gone;
-extern atomic_t fscache_n_store_vmscan_busy;
-extern atomic_t fscache_n_store_vmscan_cancelled;
-
-extern atomic_t fscache_n_marks;
-extern atomic_t fscache_n_uncaches;
-
-extern atomic_t fscache_n_acquires;
-extern atomic_t fscache_n_acquires_null;
-extern atomic_t fscache_n_acquires_no_cache;
-extern atomic_t fscache_n_acquires_ok;
-extern atomic_t fscache_n_acquires_nobufs;
-extern atomic_t fscache_n_acquires_oom;
-
-extern atomic_t fscache_n_updates;
-extern atomic_t fscache_n_updates_null;
-extern atomic_t fscache_n_updates_run;
-
-extern atomic_t fscache_n_relinquishes;
-extern atomic_t fscache_n_relinquishes_null;
-extern atomic_t fscache_n_relinquishes_waitcrt;
-extern atomic_t fscache_n_relinquishes_retire;
-
-extern atomic_t fscache_n_cookie_index;
-extern atomic_t fscache_n_cookie_data;
-extern atomic_t fscache_n_cookie_special;
-
-extern atomic_t fscache_n_object_alloc;
-extern atomic_t fscache_n_object_no_alloc;
-extern atomic_t fscache_n_object_lookups;
-extern atomic_t fscache_n_object_lookups_negative;
-extern atomic_t fscache_n_object_lookups_positive;
-extern atomic_t fscache_n_object_lookups_timed_out;
-extern atomic_t fscache_n_object_created;
-extern atomic_t fscache_n_object_avail;
-extern atomic_t fscache_n_object_dead;
-
-extern atomic_t fscache_n_checkaux_none;
-extern atomic_t fscache_n_checkaux_okay;
-extern atomic_t fscache_n_checkaux_update;
-extern atomic_t fscache_n_checkaux_obsolete;
+extern atomic_unchecked_t fscache_n_op_pend;
+extern atomic_unchecked_t fscache_n_op_run;
+extern atomic_unchecked_t fscache_n_op_enqueue;
+extern atomic_unchecked_t fscache_n_op_deferred_release;
+extern atomic_unchecked_t fscache_n_op_release;
+extern atomic_unchecked_t fscache_n_op_gc;
+extern atomic_unchecked_t fscache_n_op_cancelled;
+extern atomic_unchecked_t fscache_n_op_rejected;
+
+extern atomic_unchecked_t fscache_n_attr_changed;
+extern atomic_unchecked_t fscache_n_attr_changed_ok;
+extern atomic_unchecked_t fscache_n_attr_changed_nobufs;
+extern atomic_unchecked_t fscache_n_attr_changed_nomem;
+extern atomic_unchecked_t fscache_n_attr_changed_calls;
+
+extern atomic_unchecked_t fscache_n_allocs;
+extern atomic_unchecked_t fscache_n_allocs_ok;
+extern atomic_unchecked_t fscache_n_allocs_wait;
+extern atomic_unchecked_t fscache_n_allocs_nobufs;
+extern atomic_unchecked_t fscache_n_allocs_intr;
+extern atomic_unchecked_t fscache_n_allocs_object_dead;
+extern atomic_unchecked_t fscache_n_alloc_ops;
+extern atomic_unchecked_t fscache_n_alloc_op_waits;
+
+extern atomic_unchecked_t fscache_n_retrievals;
+extern atomic_unchecked_t fscache_n_retrievals_ok;
+extern atomic_unchecked_t fscache_n_retrievals_wait;
+extern atomic_unchecked_t fscache_n_retrievals_nodata;
+extern atomic_unchecked_t fscache_n_retrievals_nobufs;
+extern atomic_unchecked_t fscache_n_retrievals_intr;
+extern atomic_unchecked_t fscache_n_retrievals_nomem;
+extern atomic_unchecked_t fscache_n_retrievals_object_dead;
+extern atomic_unchecked_t fscache_n_retrieval_ops;
+extern atomic_unchecked_t fscache_n_retrieval_op_waits;
+
+extern atomic_unchecked_t fscache_n_stores;
+extern atomic_unchecked_t fscache_n_stores_ok;
+extern atomic_unchecked_t fscache_n_stores_again;
+extern atomic_unchecked_t fscache_n_stores_nobufs;
+extern atomic_unchecked_t fscache_n_stores_oom;
+extern atomic_unchecked_t fscache_n_store_ops;
+extern atomic_unchecked_t fscache_n_store_calls;
+extern atomic_unchecked_t fscache_n_store_pages;
+extern atomic_unchecked_t fscache_n_store_radix_deletes;
+extern atomic_unchecked_t fscache_n_store_pages_over_limit;
+
+extern atomic_unchecked_t fscache_n_store_vmscan_not_storing;
+extern atomic_unchecked_t fscache_n_store_vmscan_gone;
+extern atomic_unchecked_t fscache_n_store_vmscan_busy;
+extern atomic_unchecked_t fscache_n_store_vmscan_cancelled;
+
+extern atomic_unchecked_t fscache_n_marks;
+extern atomic_unchecked_t fscache_n_uncaches;
+
+extern atomic_unchecked_t fscache_n_acquires;
+extern atomic_unchecked_t fscache_n_acquires_null;
+extern atomic_unchecked_t fscache_n_acquires_no_cache;
+extern atomic_unchecked_t fscache_n_acquires_ok;
+extern atomic_unchecked_t fscache_n_acquires_nobufs;
+extern atomic_unchecked_t fscache_n_acquires_oom;
+
+extern atomic_unchecked_t fscache_n_updates;
+extern atomic_unchecked_t fscache_n_updates_null;
+extern atomic_unchecked_t fscache_n_updates_run;
+
+extern atomic_unchecked_t fscache_n_relinquishes;
+extern atomic_unchecked_t fscache_n_relinquishes_null;
+extern atomic_unchecked_t fscache_n_relinquishes_waitcrt;
+extern atomic_unchecked_t fscache_n_relinquishes_retire;
+
+extern atomic_unchecked_t fscache_n_cookie_index;
+extern atomic_unchecked_t fscache_n_cookie_data;
+extern atomic_unchecked_t fscache_n_cookie_special;
+
+extern atomic_unchecked_t fscache_n_object_alloc;
+extern atomic_unchecked_t fscache_n_object_no_alloc;
+extern atomic_unchecked_t fscache_n_object_lookups;
+extern atomic_unchecked_t fscache_n_object_lookups_negative;
+extern atomic_unchecked_t fscache_n_object_lookups_positive;
+extern atomic_unchecked_t fscache_n_object_lookups_timed_out;
+extern atomic_unchecked_t fscache_n_object_created;
+extern atomic_unchecked_t fscache_n_object_avail;
+extern atomic_unchecked_t fscache_n_object_dead;
+
+extern atomic_unchecked_t fscache_n_checkaux_none;
+extern atomic_unchecked_t fscache_n_checkaux_okay;
+extern atomic_unchecked_t fscache_n_checkaux_update;
+extern atomic_unchecked_t fscache_n_checkaux_obsolete;
 
 extern atomic_t fscache_n_cop_alloc_object;
 extern atomic_t fscache_n_cop_lookup_object;
@@ -247,6 +247,11 @@ static inline void fscache_stat(atomic_t
 	atomic_inc(stat);
 }
 
+static inline void fscache_stat_unchecked(atomic_unchecked_t *stat)
+{
+	atomic_inc_unchecked(stat);
+}
+
 static inline void fscache_stat_d(atomic_t *stat)
 {
 	atomic_dec(stat);
@@ -259,6 +264,7 @@ extern const struct file_operations fsca
 
 #define __fscache_stat(stat) (NULL)
 #define fscache_stat(stat) do {} while (0)
+#define fscache_stat_unchecked(stat) do {} while (0)
 #define fscache_stat_d(stat) do {} while (0)
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/object.c linux-2.6.32.60-pax/fs/fscache/object.c
--- linux-2.6.32.60/fs/fscache/object.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/object.c	2012-03-13 13:15:35.400097976 +0100
@@ -144,7 +144,7 @@ static void fscache_object_state_machine
 		/* update the object metadata on disk */
 	case FSCACHE_OBJECT_UPDATING:
 		clear_bit(FSCACHE_OBJECT_EV_UPDATE, &object->events);
-		fscache_stat(&fscache_n_updates_run);
+		fscache_stat_unchecked(&fscache_n_updates_run);
 		fscache_stat(&fscache_n_cop_update_object);
 		object->cache->ops->update_object(object);
 		fscache_stat_d(&fscache_n_cop_update_object);
@@ -233,7 +233,7 @@ static void fscache_object_state_machine
 		spin_lock(&object->lock);
 		object->state = FSCACHE_OBJECT_DEAD;
 		spin_unlock(&object->lock);
-		fscache_stat(&fscache_n_object_dead);
+		fscache_stat_unchecked(&fscache_n_object_dead);
 		goto terminal_transit;
 
 		/* handle the parent cache of this object being withdrawn from
@@ -248,7 +248,7 @@ static void fscache_object_state_machine
 		spin_lock(&object->lock);
 		object->state = FSCACHE_OBJECT_DEAD;
 		spin_unlock(&object->lock);
-		fscache_stat(&fscache_n_object_dead);
+		fscache_stat_unchecked(&fscache_n_object_dead);
 		goto terminal_transit;
 
 		/* complain about the object being woken up once it is
@@ -492,7 +492,7 @@ static void fscache_lookup_object(struct
 	       parent->cookie->def->name, cookie->def->name,
 	       object->cache->tag->name);
 
-	fscache_stat(&fscache_n_object_lookups);
+	fscache_stat_unchecked(&fscache_n_object_lookups);
 	fscache_stat(&fscache_n_cop_lookup_object);
 	ret = object->cache->ops->lookup_object(object);
 	fscache_stat_d(&fscache_n_cop_lookup_object);
@@ -503,7 +503,7 @@ static void fscache_lookup_object(struct
 	if (ret == -ETIMEDOUT) {
 		/* probably stuck behind another object, so move this one to
 		 * the back of the queue */
-		fscache_stat(&fscache_n_object_lookups_timed_out);
+		fscache_stat_unchecked(&fscache_n_object_lookups_timed_out);
 		set_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);
 	}
 
@@ -526,7 +526,7 @@ void fscache_object_lookup_negative(stru
 
 	spin_lock(&object->lock);
 	if (object->state == FSCACHE_OBJECT_LOOKING_UP) {
-		fscache_stat(&fscache_n_object_lookups_negative);
+		fscache_stat_unchecked(&fscache_n_object_lookups_negative);
 
 		/* transit here to allow write requests to begin stacking up
 		 * and read requests to begin returning ENODATA */
@@ -572,7 +572,7 @@ void fscache_obtained_object(struct fsca
 	 * result, in which case there may be data available */
 	spin_lock(&object->lock);
 	if (object->state == FSCACHE_OBJECT_LOOKING_UP) {
-		fscache_stat(&fscache_n_object_lookups_positive);
+		fscache_stat_unchecked(&fscache_n_object_lookups_positive);
 
 		clear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);
 
@@ -586,7 +586,7 @@ void fscache_obtained_object(struct fsca
 		set_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);
 	} else {
 		ASSERTCMP(object->state, ==, FSCACHE_OBJECT_CREATING);
-		fscache_stat(&fscache_n_object_created);
+		fscache_stat_unchecked(&fscache_n_object_created);
 
 		object->state = FSCACHE_OBJECT_AVAILABLE;
 		spin_unlock(&object->lock);
@@ -633,7 +633,7 @@ static void fscache_object_available(str
 	fscache_enqueue_dependents(object);
 
 	fscache_hist(fscache_obj_instantiate_histogram, object->lookup_jif);
-	fscache_stat(&fscache_n_object_avail);
+	fscache_stat_unchecked(&fscache_n_object_avail);
 
 	_leave("");
 }
@@ -861,7 +861,7 @@ enum fscache_checkaux fscache_check_aux(
 	enum fscache_checkaux result;
 
 	if (!object->cookie->def->check_aux) {
-		fscache_stat(&fscache_n_checkaux_none);
+		fscache_stat_unchecked(&fscache_n_checkaux_none);
 		return FSCACHE_CHECKAUX_OKAY;
 	}
 
@@ -870,17 +870,17 @@ enum fscache_checkaux fscache_check_aux(
 	switch (result) {
 		/* entry okay as is */
 	case FSCACHE_CHECKAUX_OKAY:
-		fscache_stat(&fscache_n_checkaux_okay);
+		fscache_stat_unchecked(&fscache_n_checkaux_okay);
 		break;
 
 		/* entry requires update */
 	case FSCACHE_CHECKAUX_NEEDS_UPDATE:
-		fscache_stat(&fscache_n_checkaux_update);
+		fscache_stat_unchecked(&fscache_n_checkaux_update);
 		break;
 
 		/* entry requires deletion */
 	case FSCACHE_CHECKAUX_OBSOLETE:
-		fscache_stat(&fscache_n_checkaux_obsolete);
+		fscache_stat_unchecked(&fscache_n_checkaux_obsolete);
 		break;
 
 	default:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/operation.c linux-2.6.32.60-pax/fs/fscache/operation.c
--- linux-2.6.32.60/fs/fscache/operation.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/operation.c	2012-03-13 13:15:35.400097976 +0100
@@ -16,7 +16,7 @@
 #include <linux/seq_file.h>
 #include "internal.h"
 
-atomic_t fscache_op_debug_id;
+atomic_unchecked_t fscache_op_debug_id;
 EXPORT_SYMBOL(fscache_op_debug_id);
 
 /**
@@ -39,7 +39,7 @@ void fscache_enqueue_operation(struct fs
 	ASSERTCMP(op->object->state, >=, FSCACHE_OBJECT_AVAILABLE);
 	ASSERTCMP(atomic_read(&op->usage), >, 0);
 
-	fscache_stat(&fscache_n_op_enqueue);
+	fscache_stat_unchecked(&fscache_n_op_enqueue);
 	switch (op->flags & FSCACHE_OP_TYPE) {
 	case FSCACHE_OP_FAST:
 		_debug("queue fast");
@@ -76,7 +76,7 @@ static void fscache_run_op(struct fscach
 		wake_up_bit(&op->flags, FSCACHE_OP_WAITING);
 	if (op->processor)
 		fscache_enqueue_operation(op);
-	fscache_stat(&fscache_n_op_run);
+	fscache_stat_unchecked(&fscache_n_op_run);
 }
 
 /*
@@ -107,11 +107,11 @@ int fscache_submit_exclusive_op(struct f
 		if (object->n_ops > 0) {
 			atomic_inc(&op->usage);
 			list_add_tail(&op->pend_link, &object->pending_ops);
-			fscache_stat(&fscache_n_op_pend);
+			fscache_stat_unchecked(&fscache_n_op_pend);
 		} else if (!list_empty(&object->pending_ops)) {
 			atomic_inc(&op->usage);
 			list_add_tail(&op->pend_link, &object->pending_ops);
-			fscache_stat(&fscache_n_op_pend);
+			fscache_stat_unchecked(&fscache_n_op_pend);
 			fscache_start_operations(object);
 		} else {
 			ASSERTCMP(object->n_in_progress, ==, 0);
@@ -127,7 +127,7 @@ int fscache_submit_exclusive_op(struct f
 		object->n_exclusive++;	/* reads and writes must wait */
 		atomic_inc(&op->usage);
 		list_add_tail(&op->pend_link, &object->pending_ops);
-		fscache_stat(&fscache_n_op_pend);
+		fscache_stat_unchecked(&fscache_n_op_pend);
 		ret = 0;
 	} else {
 		/* not allowed to submit ops in any other state */
@@ -214,11 +214,11 @@ int fscache_submit_op(struct fscache_obj
 		if (object->n_exclusive > 0) {
 			atomic_inc(&op->usage);
 			list_add_tail(&op->pend_link, &object->pending_ops);
-			fscache_stat(&fscache_n_op_pend);
+			fscache_stat_unchecked(&fscache_n_op_pend);
 		} else if (!list_empty(&object->pending_ops)) {
 			atomic_inc(&op->usage);
 			list_add_tail(&op->pend_link, &object->pending_ops);
-			fscache_stat(&fscache_n_op_pend);
+			fscache_stat_unchecked(&fscache_n_op_pend);
 			fscache_start_operations(object);
 		} else {
 			ASSERTCMP(object->n_exclusive, ==, 0);
@@ -230,12 +230,12 @@ int fscache_submit_op(struct fscache_obj
 		object->n_ops++;
 		atomic_inc(&op->usage);
 		list_add_tail(&op->pend_link, &object->pending_ops);
-		fscache_stat(&fscache_n_op_pend);
+		fscache_stat_unchecked(&fscache_n_op_pend);
 		ret = 0;
 	} else if (object->state == FSCACHE_OBJECT_DYING ||
 		   object->state == FSCACHE_OBJECT_LC_DYING ||
 		   object->state == FSCACHE_OBJECT_WITHDRAWING) {
-		fscache_stat(&fscache_n_op_rejected);
+		fscache_stat_unchecked(&fscache_n_op_rejected);
 		ret = -ENOBUFS;
 	} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {
 		fscache_report_unexpected_submission(object, op, ostate);
@@ -305,7 +305,7 @@ int fscache_cancel_op(struct fscache_ope
 
 	ret = -EBUSY;
 	if (!list_empty(&op->pend_link)) {
-		fscache_stat(&fscache_n_op_cancelled);
+		fscache_stat_unchecked(&fscache_n_op_cancelled);
 		list_del_init(&op->pend_link);
 		object->n_ops--;
 		if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))
@@ -344,7 +344,7 @@ void fscache_put_operation(struct fscach
 	if (test_and_set_bit(FSCACHE_OP_DEAD, &op->flags))
 		BUG();
 
-	fscache_stat(&fscache_n_op_release);
+	fscache_stat_unchecked(&fscache_n_op_release);
 
 	if (op->release) {
 		op->release(op);
@@ -361,7 +361,7 @@ void fscache_put_operation(struct fscach
 	 * lock, and defer it otherwise */
 	if (!spin_trylock(&object->lock)) {
 		_debug("defer put");
-		fscache_stat(&fscache_n_op_deferred_release);
+		fscache_stat_unchecked(&fscache_n_op_deferred_release);
 
 		cache = object->cache;
 		spin_lock(&cache->op_gc_list_lock);
@@ -423,7 +423,7 @@ void fscache_operation_gc(struct work_st
 
 		_debug("GC DEFERRED REL OBJ%x OP%x",
 		       object->debug_id, op->debug_id);
-		fscache_stat(&fscache_n_op_gc);
+		fscache_stat_unchecked(&fscache_n_op_gc);
 
 		ASSERTCMP(atomic_read(&op->usage), ==, 0);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/page.c linux-2.6.32.60-pax/fs/fscache/page.c
--- linux-2.6.32.60/fs/fscache/page.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/page.c	2012-03-13 13:15:35.404097976 +0100
@@ -59,7 +59,7 @@ bool __fscache_maybe_release_page(struct
 	val = radix_tree_lookup(&cookie->stores, page->index);
 	if (!val) {
 		rcu_read_unlock();
-		fscache_stat(&fscache_n_store_vmscan_not_storing);
+		fscache_stat_unchecked(&fscache_n_store_vmscan_not_storing);
 		__fscache_uncache_page(cookie, page);
 		return true;
 	}
@@ -89,11 +89,11 @@ bool __fscache_maybe_release_page(struct
 	spin_unlock(&cookie->stores_lock);
 
 	if (xpage) {
-		fscache_stat(&fscache_n_store_vmscan_cancelled);
-		fscache_stat(&fscache_n_store_radix_deletes);
+		fscache_stat_unchecked(&fscache_n_store_vmscan_cancelled);
+		fscache_stat_unchecked(&fscache_n_store_radix_deletes);
 		ASSERTCMP(xpage, ==, page);
 	} else {
-		fscache_stat(&fscache_n_store_vmscan_gone);
+		fscache_stat_unchecked(&fscache_n_store_vmscan_gone);
 	}
 
 	wake_up_bit(&cookie->flags, 0);
@@ -106,7 +106,7 @@ page_busy:
 	/* we might want to wait here, but that could deadlock the allocator as
 	 * the slow-work threads writing to the cache may all end up sleeping
 	 * on memory allocation */
-	fscache_stat(&fscache_n_store_vmscan_busy);
+	fscache_stat_unchecked(&fscache_n_store_vmscan_busy);
 	return false;
 }
 EXPORT_SYMBOL(__fscache_maybe_release_page);
@@ -130,7 +130,7 @@ static void fscache_end_page_write(struc
 				     FSCACHE_COOKIE_STORING_TAG);
 		if (!radix_tree_tag_get(&cookie->stores, page->index,
 					FSCACHE_COOKIE_PENDING_TAG)) {
-			fscache_stat(&fscache_n_store_radix_deletes);
+			fscache_stat_unchecked(&fscache_n_store_radix_deletes);
 			xpage = radix_tree_delete(&cookie->stores, page->index);
 		}
 		spin_unlock(&cookie->stores_lock);
@@ -151,7 +151,7 @@ static void fscache_attr_changed_op(stru
 
 	_enter("{OBJ%x OP%x}", object->debug_id, op->debug_id);
 
-	fscache_stat(&fscache_n_attr_changed_calls);
+	fscache_stat_unchecked(&fscache_n_attr_changed_calls);
 
 	if (fscache_object_is_active(object)) {
 		fscache_set_op_state(op, "CallFS");
@@ -178,11 +178,11 @@ int __fscache_attr_changed(struct fscach
 
 	ASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);
 
-	fscache_stat(&fscache_n_attr_changed);
+	fscache_stat_unchecked(&fscache_n_attr_changed);
 
 	op = kzalloc(sizeof(*op), GFP_KERNEL);
 	if (!op) {
-		fscache_stat(&fscache_n_attr_changed_nomem);
+		fscache_stat_unchecked(&fscache_n_attr_changed_nomem);
 		_leave(" = -ENOMEM");
 		return -ENOMEM;
 	}
@@ -202,7 +202,7 @@ int __fscache_attr_changed(struct fscach
 	if (fscache_submit_exclusive_op(object, op) < 0)
 		goto nobufs;
 	spin_unlock(&cookie->lock);
-	fscache_stat(&fscache_n_attr_changed_ok);
+	fscache_stat_unchecked(&fscache_n_attr_changed_ok);
 	fscache_put_operation(op);
 	_leave(" = 0");
 	return 0;
@@ -210,7 +210,7 @@ int __fscache_attr_changed(struct fscach
 nobufs:
 	spin_unlock(&cookie->lock);
 	kfree(op);
-	fscache_stat(&fscache_n_attr_changed_nobufs);
+	fscache_stat_unchecked(&fscache_n_attr_changed_nobufs);
 	_leave(" = %d", -ENOBUFS);
 	return -ENOBUFS;
 }
@@ -264,7 +264,7 @@ static struct fscache_retrieval *fscache
 	/* allocate a retrieval operation and attempt to submit it */
 	op = kzalloc(sizeof(*op), GFP_NOIO);
 	if (!op) {
-		fscache_stat(&fscache_n_retrievals_nomem);
+		fscache_stat_unchecked(&fscache_n_retrievals_nomem);
 		return NULL;
 	}
 
@@ -294,13 +294,13 @@ static int fscache_wait_for_deferred_loo
 		return 0;
 	}
 
-	fscache_stat(&fscache_n_retrievals_wait);
+	fscache_stat_unchecked(&fscache_n_retrievals_wait);
 
 	jif = jiffies;
 	if (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,
 			fscache_wait_bit_interruptible,
 			TASK_INTERRUPTIBLE) != 0) {
-		fscache_stat(&fscache_n_retrievals_intr);
+		fscache_stat_unchecked(&fscache_n_retrievals_intr);
 		_leave(" = -ERESTARTSYS");
 		return -ERESTARTSYS;
 	}
@@ -318,8 +318,8 @@ static int fscache_wait_for_deferred_loo
  */
 static int fscache_wait_for_retrieval_activation(struct fscache_object *object,
 						 struct fscache_retrieval *op,
-						 atomic_t *stat_op_waits,
-						 atomic_t *stat_object_dead)
+						 atomic_unchecked_t *stat_op_waits,
+						 atomic_unchecked_t *stat_object_dead)
 {
 	int ret;
 
@@ -327,7 +327,7 @@ static int fscache_wait_for_retrieval_ac
 		goto check_if_dead;
 
 	_debug(">>> WT");
-	fscache_stat(stat_op_waits);
+	fscache_stat_unchecked(stat_op_waits);
 	if (wait_on_bit(&op->op.flags, FSCACHE_OP_WAITING,
 			fscache_wait_bit_interruptible,
 			TASK_INTERRUPTIBLE) < 0) {
@@ -344,7 +344,7 @@ static int fscache_wait_for_retrieval_ac
 
 check_if_dead:
 	if (unlikely(fscache_object_is_dead(object))) {
-		fscache_stat(stat_object_dead);
+		fscache_stat_unchecked(stat_object_dead);
 		return -ENOBUFS;
 	}
 	return 0;
@@ -371,7 +371,7 @@ int __fscache_read_or_alloc_page(struct
 
 	_enter("%p,%p,,,", cookie, page);
 
-	fscache_stat(&fscache_n_retrievals);
+	fscache_stat_unchecked(&fscache_n_retrievals);
 
 	if (hlist_empty(&cookie->backing_objects))
 		goto nobufs;
@@ -405,7 +405,7 @@ int __fscache_read_or_alloc_page(struct
 		goto nobufs_unlock;
 	spin_unlock(&cookie->lock);
 
-	fscache_stat(&fscache_n_retrieval_ops);
+	fscache_stat_unchecked(&fscache_n_retrieval_ops);
 
 	/* pin the netfs read context in case we need to do the actual netfs
 	 * read because we've encountered a cache read failure */
@@ -435,15 +435,15 @@ int __fscache_read_or_alloc_page(struct
 
 error:
 	if (ret == -ENOMEM)
-		fscache_stat(&fscache_n_retrievals_nomem);
+		fscache_stat_unchecked(&fscache_n_retrievals_nomem);
 	else if (ret == -ERESTARTSYS)
-		fscache_stat(&fscache_n_retrievals_intr);
+		fscache_stat_unchecked(&fscache_n_retrievals_intr);
 	else if (ret == -ENODATA)
-		fscache_stat(&fscache_n_retrievals_nodata);
+		fscache_stat_unchecked(&fscache_n_retrievals_nodata);
 	else if (ret < 0)
-		fscache_stat(&fscache_n_retrievals_nobufs);
+		fscache_stat_unchecked(&fscache_n_retrievals_nobufs);
 	else
-		fscache_stat(&fscache_n_retrievals_ok);
+		fscache_stat_unchecked(&fscache_n_retrievals_ok);
 
 	fscache_put_retrieval(op);
 	_leave(" = %d", ret);
@@ -453,7 +453,7 @@ nobufs_unlock:
 	spin_unlock(&cookie->lock);
 	kfree(op);
 nobufs:
-	fscache_stat(&fscache_n_retrievals_nobufs);
+	fscache_stat_unchecked(&fscache_n_retrievals_nobufs);
 	_leave(" = -ENOBUFS");
 	return -ENOBUFS;
 }
@@ -491,7 +491,7 @@ int __fscache_read_or_alloc_pages(struct
 
 	_enter("%p,,%d,,,", cookie, *nr_pages);
 
-	fscache_stat(&fscache_n_retrievals);
+	fscache_stat_unchecked(&fscache_n_retrievals);
 
 	if (hlist_empty(&cookie->backing_objects))
 		goto nobufs;
@@ -522,7 +522,7 @@ int __fscache_read_or_alloc_pages(struct
 		goto nobufs_unlock;
 	spin_unlock(&cookie->lock);
 
-	fscache_stat(&fscache_n_retrieval_ops);
+	fscache_stat_unchecked(&fscache_n_retrieval_ops);
 
 	/* pin the netfs read context in case we need to do the actual netfs
 	 * read because we've encountered a cache read failure */
@@ -552,15 +552,15 @@ int __fscache_read_or_alloc_pages(struct
 
 error:
 	if (ret == -ENOMEM)
-		fscache_stat(&fscache_n_retrievals_nomem);
+		fscache_stat_unchecked(&fscache_n_retrievals_nomem);
 	else if (ret == -ERESTARTSYS)
-		fscache_stat(&fscache_n_retrievals_intr);
+		fscache_stat_unchecked(&fscache_n_retrievals_intr);
 	else if (ret == -ENODATA)
-		fscache_stat(&fscache_n_retrievals_nodata);
+		fscache_stat_unchecked(&fscache_n_retrievals_nodata);
 	else if (ret < 0)
-		fscache_stat(&fscache_n_retrievals_nobufs);
+		fscache_stat_unchecked(&fscache_n_retrievals_nobufs);
 	else
-		fscache_stat(&fscache_n_retrievals_ok);
+		fscache_stat_unchecked(&fscache_n_retrievals_ok);
 
 	fscache_put_retrieval(op);
 	_leave(" = %d", ret);
@@ -570,7 +570,7 @@ nobufs_unlock:
 	spin_unlock(&cookie->lock);
 	kfree(op);
 nobufs:
-	fscache_stat(&fscache_n_retrievals_nobufs);
+	fscache_stat_unchecked(&fscache_n_retrievals_nobufs);
 	_leave(" = -ENOBUFS");
 	return -ENOBUFS;
 }
@@ -594,7 +594,7 @@ int __fscache_alloc_page(struct fscache_
 
 	_enter("%p,%p,,,", cookie, page);
 
-	fscache_stat(&fscache_n_allocs);
+	fscache_stat_unchecked(&fscache_n_allocs);
 
 	if (hlist_empty(&cookie->backing_objects))
 		goto nobufs;
@@ -621,7 +621,7 @@ int __fscache_alloc_page(struct fscache_
 		goto nobufs_unlock;
 	spin_unlock(&cookie->lock);
 
-	fscache_stat(&fscache_n_alloc_ops);
+	fscache_stat_unchecked(&fscache_n_alloc_ops);
 
 	ret = fscache_wait_for_retrieval_activation(
 		object, op,
@@ -637,11 +637,11 @@ int __fscache_alloc_page(struct fscache_
 
 error:
 	if (ret == -ERESTARTSYS)
-		fscache_stat(&fscache_n_allocs_intr);
+		fscache_stat_unchecked(&fscache_n_allocs_intr);
 	else if (ret < 0)
-		fscache_stat(&fscache_n_allocs_nobufs);
+		fscache_stat_unchecked(&fscache_n_allocs_nobufs);
 	else
-		fscache_stat(&fscache_n_allocs_ok);
+		fscache_stat_unchecked(&fscache_n_allocs_ok);
 
 	fscache_put_retrieval(op);
 	_leave(" = %d", ret);
@@ -651,7 +651,7 @@ nobufs_unlock:
 	spin_unlock(&cookie->lock);
 	kfree(op);
 nobufs:
-	fscache_stat(&fscache_n_allocs_nobufs);
+	fscache_stat_unchecked(&fscache_n_allocs_nobufs);
 	_leave(" = -ENOBUFS");
 	return -ENOBUFS;
 }
@@ -694,7 +694,7 @@ static void fscache_write_op(struct fsca
 
 	spin_lock(&cookie->stores_lock);
 
-	fscache_stat(&fscache_n_store_calls);
+	fscache_stat_unchecked(&fscache_n_store_calls);
 
 	/* find a page to store */
 	page = NULL;
@@ -705,7 +705,7 @@ static void fscache_write_op(struct fsca
 	page = results[0];
 	_debug("gang %d [%lx]", n, page->index);
 	if (page->index > op->store_limit) {
-		fscache_stat(&fscache_n_store_pages_over_limit);
+		fscache_stat_unchecked(&fscache_n_store_pages_over_limit);
 		goto superseded;
 	}
 
@@ -721,7 +721,7 @@ static void fscache_write_op(struct fsca
 
 	if (page) {
 		fscache_set_op_state(&op->op, "Store");
-		fscache_stat(&fscache_n_store_pages);
+		fscache_stat_unchecked(&fscache_n_store_pages);
 		fscache_stat(&fscache_n_cop_write_page);
 		ret = object->cache->ops->write_page(op, page);
 		fscache_stat_d(&fscache_n_cop_write_page);
@@ -792,7 +792,7 @@ int __fscache_write_page(struct fscache_
 	ASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);
 	ASSERT(PageFsCache(page));
 
-	fscache_stat(&fscache_n_stores);
+	fscache_stat_unchecked(&fscache_n_stores);
 
 	op = kzalloc(sizeof(*op), GFP_NOIO);
 	if (!op)
@@ -844,7 +844,7 @@ int __fscache_write_page(struct fscache_
 	spin_unlock(&cookie->stores_lock);
 	spin_unlock(&object->lock);
 
-	op->op.debug_id	= atomic_inc_return(&fscache_op_debug_id);
+	op->op.debug_id	= atomic_inc_return_unchecked(&fscache_op_debug_id);
 	op->store_limit = object->store_limit;
 
 	if (fscache_submit_op(object, &op->op) < 0)
@@ -852,8 +852,8 @@ int __fscache_write_page(struct fscache_
 
 	spin_unlock(&cookie->lock);
 	radix_tree_preload_end();
-	fscache_stat(&fscache_n_store_ops);
-	fscache_stat(&fscache_n_stores_ok);
+	fscache_stat_unchecked(&fscache_n_store_ops);
+	fscache_stat_unchecked(&fscache_n_stores_ok);
 
 	/* the slow work queue now carries its own ref on the object */
 	fscache_put_operation(&op->op);
@@ -861,14 +861,14 @@ int __fscache_write_page(struct fscache_
 	return 0;
 
 already_queued:
-	fscache_stat(&fscache_n_stores_again);
+	fscache_stat_unchecked(&fscache_n_stores_again);
 already_pending:
 	spin_unlock(&cookie->stores_lock);
 	spin_unlock(&object->lock);
 	spin_unlock(&cookie->lock);
 	radix_tree_preload_end();
 	kfree(op);
-	fscache_stat(&fscache_n_stores_ok);
+	fscache_stat_unchecked(&fscache_n_stores_ok);
 	_leave(" = 0");
 	return 0;
 
@@ -886,14 +886,14 @@ nobufs:
 	spin_unlock(&cookie->lock);
 	radix_tree_preload_end();
 	kfree(op);
-	fscache_stat(&fscache_n_stores_nobufs);
+	fscache_stat_unchecked(&fscache_n_stores_nobufs);
 	_leave(" = -ENOBUFS");
 	return -ENOBUFS;
 
 nomem_free:
 	kfree(op);
 nomem:
-	fscache_stat(&fscache_n_stores_oom);
+	fscache_stat_unchecked(&fscache_n_stores_oom);
 	_leave(" = -ENOMEM");
 	return -ENOMEM;
 }
@@ -911,7 +911,7 @@ void __fscache_uncache_page(struct fscac
 	ASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);
 	ASSERTCMP(page, !=, NULL);
 
-	fscache_stat(&fscache_n_uncaches);
+	fscache_stat_unchecked(&fscache_n_uncaches);
 
 	/* cache withdrawal may beat us to it */
 	if (!PageFsCache(page))
@@ -964,7 +964,7 @@ void fscache_mark_pages_cached(struct fs
 	unsigned long loop;
 
 #ifdef CONFIG_FSCACHE_STATS
-	atomic_add(pagevec->nr, &fscache_n_marks);
+	atomic_add_unchecked(pagevec->nr, &fscache_n_marks);
 #endif
 
 	for (loop = 0; loop < pagevec->nr; loop++) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fscache/stats.c linux-2.6.32.60-pax/fs/fscache/stats.c
--- linux-2.6.32.60/fs/fscache/stats.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fscache/stats.c	2012-03-13 13:15:35.404097976 +0100
@@ -18,95 +18,95 @@
 /*
  * operation counters
  */
-atomic_t fscache_n_op_pend;
-atomic_t fscache_n_op_run;
-atomic_t fscache_n_op_enqueue;
-atomic_t fscache_n_op_requeue;
-atomic_t fscache_n_op_deferred_release;
-atomic_t fscache_n_op_release;
-atomic_t fscache_n_op_gc;
-atomic_t fscache_n_op_cancelled;
-atomic_t fscache_n_op_rejected;
-
-atomic_t fscache_n_attr_changed;
-atomic_t fscache_n_attr_changed_ok;
-atomic_t fscache_n_attr_changed_nobufs;
-atomic_t fscache_n_attr_changed_nomem;
-atomic_t fscache_n_attr_changed_calls;
-
-atomic_t fscache_n_allocs;
-atomic_t fscache_n_allocs_ok;
-atomic_t fscache_n_allocs_wait;
-atomic_t fscache_n_allocs_nobufs;
-atomic_t fscache_n_allocs_intr;
-atomic_t fscache_n_allocs_object_dead;
-atomic_t fscache_n_alloc_ops;
-atomic_t fscache_n_alloc_op_waits;
-
-atomic_t fscache_n_retrievals;
-atomic_t fscache_n_retrievals_ok;
-atomic_t fscache_n_retrievals_wait;
-atomic_t fscache_n_retrievals_nodata;
-atomic_t fscache_n_retrievals_nobufs;
-atomic_t fscache_n_retrievals_intr;
-atomic_t fscache_n_retrievals_nomem;
-atomic_t fscache_n_retrievals_object_dead;
-atomic_t fscache_n_retrieval_ops;
-atomic_t fscache_n_retrieval_op_waits;
-
-atomic_t fscache_n_stores;
-atomic_t fscache_n_stores_ok;
-atomic_t fscache_n_stores_again;
-atomic_t fscache_n_stores_nobufs;
-atomic_t fscache_n_stores_oom;
-atomic_t fscache_n_store_ops;
-atomic_t fscache_n_store_calls;
-atomic_t fscache_n_store_pages;
-atomic_t fscache_n_store_radix_deletes;
-atomic_t fscache_n_store_pages_over_limit;
-
-atomic_t fscache_n_store_vmscan_not_storing;
-atomic_t fscache_n_store_vmscan_gone;
-atomic_t fscache_n_store_vmscan_busy;
-atomic_t fscache_n_store_vmscan_cancelled;
-
-atomic_t fscache_n_marks;
-atomic_t fscache_n_uncaches;
-
-atomic_t fscache_n_acquires;
-atomic_t fscache_n_acquires_null;
-atomic_t fscache_n_acquires_no_cache;
-atomic_t fscache_n_acquires_ok;
-atomic_t fscache_n_acquires_nobufs;
-atomic_t fscache_n_acquires_oom;
-
-atomic_t fscache_n_updates;
-atomic_t fscache_n_updates_null;
-atomic_t fscache_n_updates_run;
-
-atomic_t fscache_n_relinquishes;
-atomic_t fscache_n_relinquishes_null;
-atomic_t fscache_n_relinquishes_waitcrt;
-atomic_t fscache_n_relinquishes_retire;
-
-atomic_t fscache_n_cookie_index;
-atomic_t fscache_n_cookie_data;
-atomic_t fscache_n_cookie_special;
-
-atomic_t fscache_n_object_alloc;
-atomic_t fscache_n_object_no_alloc;
-atomic_t fscache_n_object_lookups;
-atomic_t fscache_n_object_lookups_negative;
-atomic_t fscache_n_object_lookups_positive;
-atomic_t fscache_n_object_lookups_timed_out;
-atomic_t fscache_n_object_created;
-atomic_t fscache_n_object_avail;
-atomic_t fscache_n_object_dead;
-
-atomic_t fscache_n_checkaux_none;
-atomic_t fscache_n_checkaux_okay;
-atomic_t fscache_n_checkaux_update;
-atomic_t fscache_n_checkaux_obsolete;
+atomic_unchecked_t fscache_n_op_pend;
+atomic_unchecked_t fscache_n_op_run;
+atomic_unchecked_t fscache_n_op_enqueue;
+atomic_unchecked_t fscache_n_op_requeue;
+atomic_unchecked_t fscache_n_op_deferred_release;
+atomic_unchecked_t fscache_n_op_release;
+atomic_unchecked_t fscache_n_op_gc;
+atomic_unchecked_t fscache_n_op_cancelled;
+atomic_unchecked_t fscache_n_op_rejected;
+
+atomic_unchecked_t fscache_n_attr_changed;
+atomic_unchecked_t fscache_n_attr_changed_ok;
+atomic_unchecked_t fscache_n_attr_changed_nobufs;
+atomic_unchecked_t fscache_n_attr_changed_nomem;
+atomic_unchecked_t fscache_n_attr_changed_calls;
+
+atomic_unchecked_t fscache_n_allocs;
+atomic_unchecked_t fscache_n_allocs_ok;
+atomic_unchecked_t fscache_n_allocs_wait;
+atomic_unchecked_t fscache_n_allocs_nobufs;
+atomic_unchecked_t fscache_n_allocs_intr;
+atomic_unchecked_t fscache_n_allocs_object_dead;
+atomic_unchecked_t fscache_n_alloc_ops;
+atomic_unchecked_t fscache_n_alloc_op_waits;
+
+atomic_unchecked_t fscache_n_retrievals;
+atomic_unchecked_t fscache_n_retrievals_ok;
+atomic_unchecked_t fscache_n_retrievals_wait;
+atomic_unchecked_t fscache_n_retrievals_nodata;
+atomic_unchecked_t fscache_n_retrievals_nobufs;
+atomic_unchecked_t fscache_n_retrievals_intr;
+atomic_unchecked_t fscache_n_retrievals_nomem;
+atomic_unchecked_t fscache_n_retrievals_object_dead;
+atomic_unchecked_t fscache_n_retrieval_ops;
+atomic_unchecked_t fscache_n_retrieval_op_waits;
+
+atomic_unchecked_t fscache_n_stores;
+atomic_unchecked_t fscache_n_stores_ok;
+atomic_unchecked_t fscache_n_stores_again;
+atomic_unchecked_t fscache_n_stores_nobufs;
+atomic_unchecked_t fscache_n_stores_oom;
+atomic_unchecked_t fscache_n_store_ops;
+atomic_unchecked_t fscache_n_store_calls;
+atomic_unchecked_t fscache_n_store_pages;
+atomic_unchecked_t fscache_n_store_radix_deletes;
+atomic_unchecked_t fscache_n_store_pages_over_limit;
+
+atomic_unchecked_t fscache_n_store_vmscan_not_storing;
+atomic_unchecked_t fscache_n_store_vmscan_gone;
+atomic_unchecked_t fscache_n_store_vmscan_busy;
+atomic_unchecked_t fscache_n_store_vmscan_cancelled;
+
+atomic_unchecked_t fscache_n_marks;
+atomic_unchecked_t fscache_n_uncaches;
+
+atomic_unchecked_t fscache_n_acquires;
+atomic_unchecked_t fscache_n_acquires_null;
+atomic_unchecked_t fscache_n_acquires_no_cache;
+atomic_unchecked_t fscache_n_acquires_ok;
+atomic_unchecked_t fscache_n_acquires_nobufs;
+atomic_unchecked_t fscache_n_acquires_oom;
+
+atomic_unchecked_t fscache_n_updates;
+atomic_unchecked_t fscache_n_updates_null;
+atomic_unchecked_t fscache_n_updates_run;
+
+atomic_unchecked_t fscache_n_relinquishes;
+atomic_unchecked_t fscache_n_relinquishes_null;
+atomic_unchecked_t fscache_n_relinquishes_waitcrt;
+atomic_unchecked_t fscache_n_relinquishes_retire;
+
+atomic_unchecked_t fscache_n_cookie_index;
+atomic_unchecked_t fscache_n_cookie_data;
+atomic_unchecked_t fscache_n_cookie_special;
+
+atomic_unchecked_t fscache_n_object_alloc;
+atomic_unchecked_t fscache_n_object_no_alloc;
+atomic_unchecked_t fscache_n_object_lookups;
+atomic_unchecked_t fscache_n_object_lookups_negative;
+atomic_unchecked_t fscache_n_object_lookups_positive;
+atomic_unchecked_t fscache_n_object_lookups_timed_out;
+atomic_unchecked_t fscache_n_object_created;
+atomic_unchecked_t fscache_n_object_avail;
+atomic_unchecked_t fscache_n_object_dead;
+
+atomic_unchecked_t fscache_n_checkaux_none;
+atomic_unchecked_t fscache_n_checkaux_okay;
+atomic_unchecked_t fscache_n_checkaux_update;
+atomic_unchecked_t fscache_n_checkaux_obsolete;
 
 atomic_t fscache_n_cop_alloc_object;
 atomic_t fscache_n_cop_lookup_object;
@@ -133,113 +133,113 @@ static int fscache_stats_show(struct seq
 	seq_puts(m, "FS-Cache statistics\n");
 
 	seq_printf(m, "Cookies: idx=%u dat=%u spc=%u\n",
-		   atomic_read(&fscache_n_cookie_index),
-		   atomic_read(&fscache_n_cookie_data),
-		   atomic_read(&fscache_n_cookie_special));
+		   atomic_read_unchecked(&fscache_n_cookie_index),
+		   atomic_read_unchecked(&fscache_n_cookie_data),
+		   atomic_read_unchecked(&fscache_n_cookie_special));
 
 	seq_printf(m, "Objects: alc=%u nal=%u avl=%u ded=%u\n",
-		   atomic_read(&fscache_n_object_alloc),
-		   atomic_read(&fscache_n_object_no_alloc),
-		   atomic_read(&fscache_n_object_avail),
-		   atomic_read(&fscache_n_object_dead));
+		   atomic_read_unchecked(&fscache_n_object_alloc),
+		   atomic_read_unchecked(&fscache_n_object_no_alloc),
+		   atomic_read_unchecked(&fscache_n_object_avail),
+		   atomic_read_unchecked(&fscache_n_object_dead));
 	seq_printf(m, "ChkAux : non=%u ok=%u upd=%u obs=%u\n",
-		   atomic_read(&fscache_n_checkaux_none),
-		   atomic_read(&fscache_n_checkaux_okay),
-		   atomic_read(&fscache_n_checkaux_update),
-		   atomic_read(&fscache_n_checkaux_obsolete));
+		   atomic_read_unchecked(&fscache_n_checkaux_none),
+		   atomic_read_unchecked(&fscache_n_checkaux_okay),
+		   atomic_read_unchecked(&fscache_n_checkaux_update),
+		   atomic_read_unchecked(&fscache_n_checkaux_obsolete));
 
 	seq_printf(m, "Pages  : mrk=%u unc=%u\n",
-		   atomic_read(&fscache_n_marks),
-		   atomic_read(&fscache_n_uncaches));
+		   atomic_read_unchecked(&fscache_n_marks),
+		   atomic_read_unchecked(&fscache_n_uncaches));
 
 	seq_printf(m, "Acquire: n=%u nul=%u noc=%u ok=%u nbf=%u"
 		   " oom=%u\n",
-		   atomic_read(&fscache_n_acquires),
-		   atomic_read(&fscache_n_acquires_null),
-		   atomic_read(&fscache_n_acquires_no_cache),
-		   atomic_read(&fscache_n_acquires_ok),
-		   atomic_read(&fscache_n_acquires_nobufs),
-		   atomic_read(&fscache_n_acquires_oom));
+		   atomic_read_unchecked(&fscache_n_acquires),
+		   atomic_read_unchecked(&fscache_n_acquires_null),
+		   atomic_read_unchecked(&fscache_n_acquires_no_cache),
+		   atomic_read_unchecked(&fscache_n_acquires_ok),
+		   atomic_read_unchecked(&fscache_n_acquires_nobufs),
+		   atomic_read_unchecked(&fscache_n_acquires_oom));
 
 	seq_printf(m, "Lookups: n=%u neg=%u pos=%u crt=%u tmo=%u\n",
-		   atomic_read(&fscache_n_object_lookups),
-		   atomic_read(&fscache_n_object_lookups_negative),
-		   atomic_read(&fscache_n_object_lookups_positive),
-		   atomic_read(&fscache_n_object_lookups_timed_out),
-		   atomic_read(&fscache_n_object_created));
+		   atomic_read_unchecked(&fscache_n_object_lookups),
+		   atomic_read_unchecked(&fscache_n_object_lookups_negative),
+		   atomic_read_unchecked(&fscache_n_object_lookups_positive),
+		   atomic_read_unchecked(&fscache_n_object_lookups_timed_out),
+		   atomic_read_unchecked(&fscache_n_object_created));
 
 	seq_printf(m, "Updates: n=%u nul=%u run=%u\n",
-		   atomic_read(&fscache_n_updates),
-		   atomic_read(&fscache_n_updates_null),
-		   atomic_read(&fscache_n_updates_run));
+		   atomic_read_unchecked(&fscache_n_updates),
+		   atomic_read_unchecked(&fscache_n_updates_null),
+		   atomic_read_unchecked(&fscache_n_updates_run));
 
 	seq_printf(m, "Relinqs: n=%u nul=%u wcr=%u rtr=%u\n",
-		   atomic_read(&fscache_n_relinquishes),
-		   atomic_read(&fscache_n_relinquishes_null),
-		   atomic_read(&fscache_n_relinquishes_waitcrt),
-		   atomic_read(&fscache_n_relinquishes_retire));
+		   atomic_read_unchecked(&fscache_n_relinquishes),
+		   atomic_read_unchecked(&fscache_n_relinquishes_null),
+		   atomic_read_unchecked(&fscache_n_relinquishes_waitcrt),
+		   atomic_read_unchecked(&fscache_n_relinquishes_retire));
 
 	seq_printf(m, "AttrChg: n=%u ok=%u nbf=%u oom=%u run=%u\n",
-		   atomic_read(&fscache_n_attr_changed),
-		   atomic_read(&fscache_n_attr_changed_ok),
-		   atomic_read(&fscache_n_attr_changed_nobufs),
-		   atomic_read(&fscache_n_attr_changed_nomem),
-		   atomic_read(&fscache_n_attr_changed_calls));
+		   atomic_read_unchecked(&fscache_n_attr_changed),
+		   atomic_read_unchecked(&fscache_n_attr_changed_ok),
+		   atomic_read_unchecked(&fscache_n_attr_changed_nobufs),
+		   atomic_read_unchecked(&fscache_n_attr_changed_nomem),
+		   atomic_read_unchecked(&fscache_n_attr_changed_calls));
 
 	seq_printf(m, "Allocs : n=%u ok=%u wt=%u nbf=%u int=%u\n",
-		   atomic_read(&fscache_n_allocs),
-		   atomic_read(&fscache_n_allocs_ok),
-		   atomic_read(&fscache_n_allocs_wait),
-		   atomic_read(&fscache_n_allocs_nobufs),
-		   atomic_read(&fscache_n_allocs_intr));
+		   atomic_read_unchecked(&fscache_n_allocs),
+		   atomic_read_unchecked(&fscache_n_allocs_ok),
+		   atomic_read_unchecked(&fscache_n_allocs_wait),
+		   atomic_read_unchecked(&fscache_n_allocs_nobufs),
+		   atomic_read_unchecked(&fscache_n_allocs_intr));
 	seq_printf(m, "Allocs : ops=%u owt=%u abt=%u\n",
-		   atomic_read(&fscache_n_alloc_ops),
-		   atomic_read(&fscache_n_alloc_op_waits),
-		   atomic_read(&fscache_n_allocs_object_dead));
+		   atomic_read_unchecked(&fscache_n_alloc_ops),
+		   atomic_read_unchecked(&fscache_n_alloc_op_waits),
+		   atomic_read_unchecked(&fscache_n_allocs_object_dead));
 
 	seq_printf(m, "Retrvls: n=%u ok=%u wt=%u nod=%u nbf=%u"
 		   " int=%u oom=%u\n",
-		   atomic_read(&fscache_n_retrievals),
-		   atomic_read(&fscache_n_retrievals_ok),
-		   atomic_read(&fscache_n_retrievals_wait),
-		   atomic_read(&fscache_n_retrievals_nodata),
-		   atomic_read(&fscache_n_retrievals_nobufs),
-		   atomic_read(&fscache_n_retrievals_intr),
-		   atomic_read(&fscache_n_retrievals_nomem));
+		   atomic_read_unchecked(&fscache_n_retrievals),
+		   atomic_read_unchecked(&fscache_n_retrievals_ok),
+		   atomic_read_unchecked(&fscache_n_retrievals_wait),
+		   atomic_read_unchecked(&fscache_n_retrievals_nodata),
+		   atomic_read_unchecked(&fscache_n_retrievals_nobufs),
+		   atomic_read_unchecked(&fscache_n_retrievals_intr),
+		   atomic_read_unchecked(&fscache_n_retrievals_nomem));
 	seq_printf(m, "Retrvls: ops=%u owt=%u abt=%u\n",
-		   atomic_read(&fscache_n_retrieval_ops),
-		   atomic_read(&fscache_n_retrieval_op_waits),
-		   atomic_read(&fscache_n_retrievals_object_dead));
+		   atomic_read_unchecked(&fscache_n_retrieval_ops),
+		   atomic_read_unchecked(&fscache_n_retrieval_op_waits),
+		   atomic_read_unchecked(&fscache_n_retrievals_object_dead));
 
 	seq_printf(m, "Stores : n=%u ok=%u agn=%u nbf=%u oom=%u\n",
-		   atomic_read(&fscache_n_stores),
-		   atomic_read(&fscache_n_stores_ok),
-		   atomic_read(&fscache_n_stores_again),
-		   atomic_read(&fscache_n_stores_nobufs),
-		   atomic_read(&fscache_n_stores_oom));
+		   atomic_read_unchecked(&fscache_n_stores),
+		   atomic_read_unchecked(&fscache_n_stores_ok),
+		   atomic_read_unchecked(&fscache_n_stores_again),
+		   atomic_read_unchecked(&fscache_n_stores_nobufs),
+		   atomic_read_unchecked(&fscache_n_stores_oom));
 	seq_printf(m, "Stores : ops=%u run=%u pgs=%u rxd=%u olm=%u\n",
-		   atomic_read(&fscache_n_store_ops),
-		   atomic_read(&fscache_n_store_calls),
-		   atomic_read(&fscache_n_store_pages),
-		   atomic_read(&fscache_n_store_radix_deletes),
-		   atomic_read(&fscache_n_store_pages_over_limit));
+		   atomic_read_unchecked(&fscache_n_store_ops),
+		   atomic_read_unchecked(&fscache_n_store_calls),
+		   atomic_read_unchecked(&fscache_n_store_pages),
+		   atomic_read_unchecked(&fscache_n_store_radix_deletes),
+		   atomic_read_unchecked(&fscache_n_store_pages_over_limit));
 
 	seq_printf(m, "VmScan : nos=%u gon=%u bsy=%u can=%u\n",
-		   atomic_read(&fscache_n_store_vmscan_not_storing),
-		   atomic_read(&fscache_n_store_vmscan_gone),
-		   atomic_read(&fscache_n_store_vmscan_busy),
-		   atomic_read(&fscache_n_store_vmscan_cancelled));
+		   atomic_read_unchecked(&fscache_n_store_vmscan_not_storing),
+		   atomic_read_unchecked(&fscache_n_store_vmscan_gone),
+		   atomic_read_unchecked(&fscache_n_store_vmscan_busy),
+		   atomic_read_unchecked(&fscache_n_store_vmscan_cancelled));
 
 	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u rej=%u\n",
-		   atomic_read(&fscache_n_op_pend),
-		   atomic_read(&fscache_n_op_run),
-		   atomic_read(&fscache_n_op_enqueue),
-		   atomic_read(&fscache_n_op_cancelled),
-		   atomic_read(&fscache_n_op_rejected));
+		   atomic_read_unchecked(&fscache_n_op_pend),
+		   atomic_read_unchecked(&fscache_n_op_run),
+		   atomic_read_unchecked(&fscache_n_op_enqueue),
+		   atomic_read_unchecked(&fscache_n_op_cancelled),
+		   atomic_read_unchecked(&fscache_n_op_rejected));
 	seq_printf(m, "Ops    : dfr=%u rel=%u gc=%u\n",
-		   atomic_read(&fscache_n_op_deferred_release),
-		   atomic_read(&fscache_n_op_release),
-		   atomic_read(&fscache_n_op_gc));
+		   atomic_read_unchecked(&fscache_n_op_deferred_release),
+		   atomic_read_unchecked(&fscache_n_op_release),
+		   atomic_read_unchecked(&fscache_n_op_gc));
 
 	seq_printf(m, "CacheOp: alo=%d luo=%d luc=%d gro=%d\n",
 		   atomic_read(&fscache_n_cop_alloc_object),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fs_struct.c linux-2.6.32.60-pax/fs/fs_struct.c
--- linux-2.6.32.60/fs/fs_struct.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fs_struct.c	2012-03-13 13:15:35.404097976 +0100
@@ -89,7 +89,7 @@ void exit_fs(struct task_struct *tsk)
 		task_lock(tsk);
 		write_lock(&fs->lock);
 		tsk->fs = NULL;
-		kill = !--fs->users;
+		kill = !atomic_dec_return(&fs->users);
 		write_unlock(&fs->lock);
 		task_unlock(tsk);
 		if (kill)
@@ -102,7 +102,7 @@ struct fs_struct *copy_fs_struct(struct
 	struct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);
 	/* We don't need to lock fs - think why ;-) */
 	if (fs) {
-		fs->users = 1;
+		atomic_set(&fs->users, 1);
 		fs->in_exec = 0;
 		rwlock_init(&fs->lock);
 		fs->umask = old->umask;
@@ -127,7 +127,7 @@ int unshare_fs_struct(void)
 
 	task_lock(current);
 	write_lock(&fs->lock);
-	kill = !--fs->users;
+	kill = !atomic_dec_return(&fs->users);
 	current->fs = new_fs;
 	write_unlock(&fs->lock);
 	task_unlock(current);
@@ -147,7 +147,7 @@ EXPORT_SYMBOL(current_umask);
 
 /* to be mentioned only in INIT_TASK */
 struct fs_struct init_fs = {
-	.users		= 1,
+	.users		= ATOMIC_INIT(1),
 	.lock		= __RW_LOCK_UNLOCKED(init_fs.lock),
 	.umask		= 0022,
 };
@@ -162,12 +162,12 @@ void daemonize_fs_struct(void)
 		task_lock(current);
 
 		write_lock(&init_fs.lock);
-		init_fs.users++;
+		atomic_inc(&init_fs.users);
 		write_unlock(&init_fs.lock);
 
 		write_lock(&fs->lock);
 		current->fs = &init_fs;
-		kill = !--fs->users;
+		kill = !atomic_dec_return(&fs->users);
 		write_unlock(&fs->lock);
 
 		task_unlock(current);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fuse/cuse.c linux-2.6.32.60-pax/fs/fuse/cuse.c
--- linux-2.6.32.60/fs/fuse/cuse.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fuse/cuse.c	2012-03-13 13:15:35.404097976 +0100
@@ -576,10 +576,12 @@ static int __init cuse_init(void)
 		INIT_LIST_HEAD(&cuse_conntbl[i]);
 
 	/* inherit and extend fuse_dev_operations */
-	cuse_channel_fops		= fuse_dev_operations;
-	cuse_channel_fops.owner		= THIS_MODULE;
-	cuse_channel_fops.open		= cuse_channel_open;
-	cuse_channel_fops.release	= cuse_channel_release;
+	pax_open_kernel();
+	memcpy((void *)&cuse_channel_fops, &fuse_dev_operations, sizeof(fuse_dev_operations));
+	*(void **)&cuse_channel_fops.owner	= THIS_MODULE;
+	*(void **)&cuse_channel_fops.open	= cuse_channel_open;
+	*(void **)&cuse_channel_fops.release	= cuse_channel_release;
+	pax_close_kernel();
 
 	cuse_class = class_create(THIS_MODULE, "cuse");
 	if (IS_ERR(cuse_class))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fuse/dev.c linux-2.6.32.60-pax/fs/fuse/dev.c
--- linux-2.6.32.60/fs/fuse/dev.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/fuse/dev.c	2012-03-13 13:15:35.408097975 +0100
@@ -885,7 +885,7 @@ static int fuse_notify_inval_entry(struc
 {
 	struct fuse_notify_inval_entry_out outarg;
 	int err = -EINVAL;
-	char buf[FUSE_NAME_MAX+1];
+	char *buf = NULL;
 	struct qstr name;
 
 	if (size < sizeof(outarg))
@@ -899,6 +899,11 @@ static int fuse_notify_inval_entry(struc
 	if (outarg.namelen > FUSE_NAME_MAX)
 		goto err;
 
+	err = -ENOMEM;
+	buf = kmalloc(FUSE_NAME_MAX+1, GFP_KERNEL);
+	if (!buf)
+		goto err;
+
 	err = -EINVAL;
 	if (size != sizeof(outarg) + outarg.namelen + 1)
 		goto err;
@@ -914,17 +919,15 @@ static int fuse_notify_inval_entry(struc
 
 	down_read(&fc->killsb);
 	err = -ENOENT;
-	if (!fc->sb)
-		goto err_unlock;
-
-	err = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);
-
-err_unlock:
+	if (fc->sb)
+		err = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);
 	up_read(&fc->killsb);
+	kfree(buf);
 	return err;
 
 err:
 	fuse_copy_finish(cs);
+	kfree(buf);
 	return err;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/fuse/dir.c linux-2.6.32.60-pax/fs/fuse/dir.c
--- linux-2.6.32.60/fs/fuse/dir.c	2012-10-09 11:00:35.480882475 +0200
+++ linux-2.6.32.60-pax/fs/fuse/dir.c	2012-10-09 11:00:39.336883049 +0200
@@ -1128,7 +1128,7 @@ static char *read_link(struct dentry *de
 	return link;
 }
 
-static void free_link(char *link)
+static void free_link(const char *link)
 {
 	if (!IS_ERR(link))
 		free_page((unsigned long) link);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/gfs2/dir.c linux-2.6.32.60-pax/fs/gfs2/dir.c
--- linux-2.6.32.60/fs/gfs2/dir.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/gfs2/dir.c	2013-02-17 17:53:17.892049470 +0100
@@ -1095,7 +1095,7 @@ static int dir_double_exhash(struct gfs2
 
 	/*  Allocate both the "from" and "to" buffers in one big chunk  */
 
-	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS | __GFP_NOFAIL);
+	buf = kcalloc(sdp->sd_hash_bsize, 3, GFP_NOFS | __GFP_NOFAIL);
 
 	for (block = dip->i_disksize >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/hugetlbfs/inode.c linux-2.6.32.60-pax/fs/hugetlbfs/inode.c
--- linux-2.6.32.60/fs/hugetlbfs/inode.c	2012-10-09 11:00:35.480882475 +0200
+++ linux-2.6.32.60-pax/fs/hugetlbfs/inode.c	2013-02-17 17:19:43.700157012 +0100
@@ -146,6 +146,10 @@ hugetlb_get_unmapped_area(struct file *f
 		return addr;
 	}
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
@@ -157,7 +161,7 @@ hugetlb_get_unmapped_area(struct file *f
 	start_addr = mm->free_area_cache;
 
 	if (len <= mm->cached_hole_size)
-		start_addr = TASK_UNMAPPED_BASE;
+		start_addr = mm->mmap_base;
 
 full_search:
 	addr = ALIGN(start_addr, huge_page_size(h));
@@ -169,14 +173,14 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = mm->mmap_base;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
 
-		if (!vma || addr + len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			return addr;
 		addr = ALIGN(vma->vm_end, huge_page_size(h));
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ioctl.c linux-2.6.32.60-pax/fs/ioctl.c
--- linux-2.6.32.60/fs/ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ioctl.c	2012-03-13 13:15:35.408097975 +0100
@@ -97,7 +97,7 @@ int fiemap_fill_next_extent(struct fiema
 			    u64 phys, u64 len, u32 flags)
 {
 	struct fiemap_extent extent;
-	struct fiemap_extent *dest = fieinfo->fi_extents_start;
+	struct fiemap_extent __user *dest = fieinfo->fi_extents_start;
 
 	/* only count the extents */
 	if (fieinfo->fi_extents_max == 0) {
@@ -207,7 +207,7 @@ static int ioctl_fiemap(struct file *fil
 
 	fieinfo.fi_flags = fiemap.fm_flags;
 	fieinfo.fi_extents_max = fiemap.fm_extent_count;
-	fieinfo.fi_extents_start = (struct fiemap_extent *)(arg + sizeof(fiemap));
+	fieinfo.fi_extents_start = (struct fiemap_extent __user *)(arg + sizeof(fiemap));
 
 	if (fiemap.fm_extent_count != 0 &&
 	    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,
@@ -220,7 +220,7 @@ static int ioctl_fiemap(struct file *fil
 	error = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);
 	fiemap.fm_flags = fieinfo.fi_flags;
 	fiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;
-	if (copy_to_user((char *)arg, &fiemap, sizeof(fiemap)))
+	if (copy_to_user((__force char __user *)arg, &fiemap, sizeof(fiemap)))
 		error = -EFAULT;
 
 	return error;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/jffs2/erase.c linux-2.6.32.60-pax/fs/jffs2/erase.c
--- linux-2.6.32.60/fs/jffs2/erase.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/jffs2/erase.c	2012-03-13 13:15:35.408097975 +0100
@@ -434,7 +434,8 @@ static void jffs2_mark_erased_block(stru
 		struct jffs2_unknown_node marker = {
 			.magic =	cpu_to_je16(JFFS2_MAGIC_BITMASK),
 			.nodetype =	cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),
-			.totlen =	cpu_to_je32(c->cleanmarker_size)
+			.totlen =	cpu_to_je32(c->cleanmarker_size),
+			.hdr_crc =	cpu_to_je32(0)
 		};
 
 		jffs2_prealloc_raw_node_refs(c, jeb, 1);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/jffs2/wbuf.c linux-2.6.32.60-pax/fs/jffs2/wbuf.c
--- linux-2.6.32.60/fs/jffs2/wbuf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/jffs2/wbuf.c	2012-03-13 13:15:35.412097975 +0100
@@ -1012,7 +1012,8 @@ static const struct jffs2_unknown_node o
 {
 	.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),
 	.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),
-	.totlen = constant_cpu_to_je32(8)
+	.totlen = constant_cpu_to_je32(8),
+	.hdr_crc = constant_cpu_to_je32(0)
 };
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/jfs/super.c linux-2.6.32.60-pax/fs/jfs/super.c
--- linux-2.6.32.60/fs/jfs/super.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/jfs/super.c	2012-03-13 13:15:35.412097975 +0100
@@ -793,7 +793,7 @@ static int __init init_jfs_fs(void)
 
 	jfs_inode_cachep =
 	    kmem_cache_create("jfs_ip", sizeof(struct jfs_inode_info), 0,
-			    SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,
+			    SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|SLAB_USERCOPY,
 			    init_once);
 	if (jfs_inode_cachep == NULL)
 		return -ENOMEM;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/Kconfig.binfmt linux-2.6.32.60-pax/fs/Kconfig.binfmt
--- linux-2.6.32.60/fs/Kconfig.binfmt	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/Kconfig.binfmt	2012-03-13 13:15:35.412097975 +0100
@@ -86,7 +86,7 @@ config HAVE_AOUT
 
 config BINFMT_AOUT
 	tristate "Kernel support for a.out and ECOFF binaries"
-	depends on HAVE_AOUT
+	depends on HAVE_AOUT && BROKEN
 	---help---
 	  A.out (Assembler.OUTput) is a set of formats for libraries and
 	  executables used in the earliest versions of UNIX.  Linux used
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/libfs.c linux-2.6.32.60-pax/fs/libfs.c
--- linux-2.6.32.60/fs/libfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/libfs.c	2012-03-13 13:15:35.412097975 +0100
@@ -157,12 +157,20 @@ int dcache_readdir(struct file * filp, v
 
 			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
 				struct dentry *next;
+				char d_name[sizeof(next->d_iname)];
+				const unsigned char *name;
+
 				next = list_entry(p, struct dentry, d_u.d_child);
 				if (d_unhashed(next) || !next->d_inode)
 					continue;
 
 				spin_unlock(&dcache_lock);
-				if (filldir(dirent, next->d_name.name, 
+				name = next->d_name.name;
+				if (name == next->d_iname) {
+					memcpy(d_name, name, next->d_name.len);
+					name = d_name;
+				}
+				if (filldir(dirent, name, 
 					    next->d_name.len, filp->f_pos, 
 					    next->d_inode->i_ino, 
 					    dt_type(next->d_inode)) < 0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/lockd/clntproc.c linux-2.6.32.60-pax/fs/lockd/clntproc.c
--- linux-2.6.32.60/fs/lockd/clntproc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/lockd/clntproc.c	2012-03-13 13:15:35.416097975 +0100
@@ -36,11 +36,11 @@ static const struct rpc_call_ops nlmclnt
 /*
  * Cookie counter for NLM requests
  */
-static atomic_t	nlm_cookie = ATOMIC_INIT(0x1234);
+static atomic_unchecked_t	nlm_cookie = ATOMIC_INIT(0x1234);
 
 void nlmclnt_next_cookie(struct nlm_cookie *c)
 {
-	u32	cookie = atomic_inc_return(&nlm_cookie);
+	u32	cookie = atomic_inc_return_unchecked(&nlm_cookie);
 
 	memcpy(c->data, &cookie, 4);
 	c->len=4;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/locks.c linux-2.6.32.60-pax/fs/locks.c
--- linux-2.6.32.60/fs/locks.c	2012-10-09 11:00:35.480882475 +0200
+++ linux-2.6.32.60-pax/fs/locks.c	2012-10-09 11:00:39.340883050 +0200
@@ -2007,16 +2007,16 @@ void locks_remove_flock(struct file *fil
 		return;
 
 	if (filp->f_op && filp->f_op->flock) {
-		struct file_lock fl = {
+		struct file_lock flock = {
 			.fl_pid = current->tgid,
 			.fl_file = filp,
 			.fl_flags = FL_FLOCK,
 			.fl_type = F_UNLCK,
 			.fl_end = OFFSET_MAX,
 		};
-		filp->f_op->flock(filp, F_SETLKW, &fl);
-		if (fl.fl_ops && fl.fl_ops->fl_release_private)
-			fl.fl_ops->fl_release_private(&fl);
+		filp->f_op->flock(filp, F_SETLKW, &flock);
+		if (flock.fl_ops && flock.fl_ops->fl_release_private)
+			flock.fl_ops->fl_release_private(&flock);
 	}
 
 	lock_kernel();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/namei.c linux-2.6.32.60-pax/fs/namei.c
--- linux-2.6.32.60/fs/namei.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/namei.c	2012-03-13 13:15:35.420097975 +0100
@@ -638,7 +638,7 @@ static __always_inline int __do_follow_l
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
-		char *s = nd_get_link(nd);
+		const char *s = nd_get_link(nd);
 		error = 0;
 		if (s)
 			error = __vfs_follow_link(nd, s);
@@ -2798,6 +2798,8 @@ SYSCALL_DEFINE2(rename, const char __use
 
 int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
 {
+	char tmpbuf[64];
+	const char *newlink;
 	int len;
 
 	len = PTR_ERR(link);
@@ -2807,7 +2809,14 @@ int vfs_readlink(struct dentry *dentry,
 	len = strlen(link);
 	if (len > (unsigned) buflen)
 		len = buflen;
-	if (copy_to_user(buffer, link, len))
+
+	if (len < sizeof(tmpbuf)) {
+		memcpy(tmpbuf, link, len);
+		newlink = tmpbuf;
+	} else
+		newlink = link;
+
+	if (copy_to_user(buffer, newlink, len))
 		len = -EFAULT;
 out:
 	return len;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/nfs/inode.c linux-2.6.32.60-pax/fs/nfs/inode.c
--- linux-2.6.32.60/fs/nfs/inode.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/nfs/inode.c	2012-03-13 13:15:35.420097975 +0100
@@ -156,7 +156,7 @@ static void nfs_zap_caches_locked(struct
 	nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
 	nfsi->attrtimeo_timestamp = jiffies;
 
-	memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
+	memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_I(inode)->cookieverf));
 	if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
 	else
@@ -973,16 +973,16 @@ static int nfs_size_need_update(const st
 	return nfs_size_to_loff_t(fattr->size) > i_size_read(inode);
 }
 
-static atomic_long_t nfs_attr_generation_counter;
+static atomic_long_unchecked_t nfs_attr_generation_counter;
 
 static unsigned long nfs_read_attr_generation_counter(void)
 {
-	return atomic_long_read(&nfs_attr_generation_counter);
+	return atomic_long_read_unchecked(&nfs_attr_generation_counter);
 }
 
 unsigned long nfs_inc_attr_generation_counter(void)
 {
-	return atomic_long_inc_return(&nfs_attr_generation_counter);
+	return atomic_long_inc_return_unchecked(&nfs_attr_generation_counter);
 }
 
 void nfs_fattr_init(struct nfs_fattr *fattr)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/nfsd/vfs.c linux-2.6.32.60-pax/fs/nfsd/vfs.c
--- linux-2.6.32.60/fs/nfsd/vfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/nfsd/vfs.c	2012-03-13 13:15:35.424097974 +0100
@@ -937,7 +937,7 @@ nfsd_vfs_read(struct svc_rqst *rqstp, st
 	} else {
 		oldfs = get_fs();
 		set_fs(KERNEL_DS);
-		host_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset);
+		host_err = vfs_readv(file, (struct iovec __force_user *)vec, vlen, &offset);
 		set_fs(oldfs);
 	}
 
@@ -1060,7 +1060,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, s
 
 	/* Write the data. */
 	oldfs = get_fs(); set_fs(KERNEL_DS);
-	host_err = vfs_writev(file, (struct iovec __user *)vec, vlen, &offset);
+	host_err = vfs_writev(file, (struct iovec __force_user *)vec, vlen, &offset);
 	set_fs(oldfs);
 	if (host_err < 0)
 		goto out_nfserr;
@@ -1542,7 +1542,7 @@ nfsd_readlink(struct svc_rqst *rqstp, st
 	 */
 
 	oldfs = get_fs(); set_fs(KERNEL_DS);
-	host_err = inode->i_op->readlink(dentry, buf, *lenp);
+	host_err = inode->i_op->readlink(dentry, (char __force_user *)buf, *lenp);
 	set_fs(oldfs);
 
 	if (host_err < 0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/nilfs2/ioctl.c linux-2.6.32.60-pax/fs/nilfs2/ioctl.c
--- linux-2.6.32.60/fs/nilfs2/ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/nilfs2/ioctl.c	2012-03-13 13:15:35.424097974 +0100
@@ -480,7 +480,7 @@ static int nilfs_ioctl_clean_segments(st
 				      unsigned int cmd, void __user *argp)
 {
 	struct nilfs_argv argv[5];
-	const static size_t argsz[5] = {
+	static const size_t argsz[5] = {
 		sizeof(struct nilfs_vdesc),
 		sizeof(struct nilfs_period),
 		sizeof(__u64),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/notify/notification.c linux-2.6.32.60-pax/fs/notify/notification.c
--- linux-2.6.32.60/fs/notify/notification.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/notify/notification.c	2012-03-13 13:15:35.424097974 +0100
@@ -57,7 +57,7 @@ static struct kmem_cache *fsnotify_event
  * get set to 0 so it will never get 'freed'
  */
 static struct fsnotify_event q_overflow_event;
-static atomic_t fsnotify_sync_cookie = ATOMIC_INIT(0);
+static atomic_unchecked_t fsnotify_sync_cookie = ATOMIC_INIT(0);
 
 /**
  * fsnotify_get_cookie - return a unique cookie for use in synchronizing events.
@@ -65,7 +65,7 @@ static atomic_t fsnotify_sync_cookie = A
  */
 u32 fsnotify_get_cookie(void)
 {
-	return atomic_inc_return(&fsnotify_sync_cookie);
+	return atomic_inc_return_unchecked(&fsnotify_sync_cookie);
 }
 EXPORT_SYMBOL_GPL(fsnotify_get_cookie);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ntfs/dir.c linux-2.6.32.60-pax/fs/ntfs/dir.c
--- linux-2.6.32.60/fs/ntfs/dir.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ntfs/dir.c	2012-03-13 13:15:35.424097974 +0100
@@ -1328,7 +1328,7 @@ find_next_index_buffer:
 	ia = (INDEX_ALLOCATION*)(kaddr + (ia_pos & ~PAGE_CACHE_MASK &
 			~(s64)(ndir->itype.index.block_size - 1)));
 	/* Bounds checks. */
-	if (unlikely((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE)) {
+	if (unlikely(!kaddr || (u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE)) {
 		ntfs_error(sb, "Out of bounds check failed. Corrupt directory "
 				"inode 0x%lx or driver bug.", vdir->i_ino);
 		goto err_out;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ntfs/file.c linux-2.6.32.60-pax/fs/ntfs/file.c
--- linux-2.6.32.60/fs/ntfs/file.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ntfs/file.c	2012-03-13 13:15:35.428097974 +0100
@@ -2243,6 +2243,6 @@ const struct inode_operations ntfs_file_
 #endif /* NTFS_RW */
 };
 
-const struct file_operations ntfs_empty_file_ops = {};
+const struct file_operations ntfs_empty_file_ops __read_only;
 
-const struct inode_operations ntfs_empty_inode_ops = {};
+const struct inode_operations ntfs_empty_inode_ops __read_only;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ocfs2/localalloc.c linux-2.6.32.60-pax/fs/ocfs2/localalloc.c
--- linux-2.6.32.60/fs/ocfs2/localalloc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ocfs2/localalloc.c	2012-03-13 13:15:35.428097974 +0100
@@ -1188,7 +1188,7 @@ static int ocfs2_local_alloc_slide_windo
 		goto bail;
 	}
 
-	atomic_inc(&osb->alloc_stats.moves);
+	atomic_inc_unchecked(&osb->alloc_stats.moves);
 
 	status = 0;
 bail:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ocfs2/ocfs2.h linux-2.6.32.60-pax/fs/ocfs2/ocfs2.h
--- linux-2.6.32.60/fs/ocfs2/ocfs2.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ocfs2/ocfs2.h	2012-03-13 13:15:35.428097974 +0100
@@ -217,11 +217,11 @@ enum ocfs2_vol_state
 
 struct ocfs2_alloc_stats
 {
-	atomic_t moves;
-	atomic_t local_data;
-	atomic_t bitmap_data;
-	atomic_t bg_allocs;
-	atomic_t bg_extends;
+	atomic_unchecked_t moves;
+	atomic_unchecked_t local_data;
+	atomic_unchecked_t bitmap_data;
+	atomic_unchecked_t bg_allocs;
+	atomic_unchecked_t bg_extends;
 };
 
 enum ocfs2_local_alloc_state
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ocfs2/suballoc.c linux-2.6.32.60-pax/fs/ocfs2/suballoc.c
--- linux-2.6.32.60/fs/ocfs2/suballoc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ocfs2/suballoc.c	2012-03-13 13:15:35.432097974 +0100
@@ -623,7 +623,7 @@ static int ocfs2_reserve_suballoc_bits(s
 				mlog_errno(status);
 			goto bail;
 		}
-		atomic_inc(&osb->alloc_stats.bg_extends);
+		atomic_inc_unchecked(&osb->alloc_stats.bg_extends);
 
 		/* You should never ask for this much metadata */
 		BUG_ON(bits_wanted >
@@ -1654,7 +1654,7 @@ int ocfs2_claim_metadata(struct ocfs2_su
 		mlog_errno(status);
 		goto bail;
 	}
-	atomic_inc(&osb->alloc_stats.bg_allocs);
+	atomic_inc_unchecked(&osb->alloc_stats.bg_allocs);
 
 	*blkno_start = bg_blkno + (u64) *suballoc_bit_start;
 	ac->ac_bits_given += (*num_bits);
@@ -1728,7 +1728,7 @@ int ocfs2_claim_new_inode(struct ocfs2_s
 		mlog_errno(status);
 		goto bail;
 	}
-	atomic_inc(&osb->alloc_stats.bg_allocs);
+	atomic_inc_unchecked(&osb->alloc_stats.bg_allocs);
 
 	BUG_ON(num_bits != 1);
 
@@ -1830,7 +1830,7 @@ int __ocfs2_claim_clusters(struct ocfs2_
 						      cluster_start,
 						      num_clusters);
 		if (!status)
-			atomic_inc(&osb->alloc_stats.local_data);
+			atomic_inc_unchecked(&osb->alloc_stats.local_data);
 	} else {
 		if (min_clusters > (osb->bitmap_cpg - 1)) {
 			/* The only paths asking for contiguousness
@@ -1858,7 +1858,7 @@ int __ocfs2_claim_clusters(struct ocfs2_
 				ocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,
 								 bg_blkno,
 								 bg_bit_off);
-			atomic_inc(&osb->alloc_stats.bitmap_data);
+			atomic_inc_unchecked(&osb->alloc_stats.bitmap_data);
 		}
 	}
 	if (status < 0) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/ocfs2/super.c linux-2.6.32.60-pax/fs/ocfs2/super.c
--- linux-2.6.32.60/fs/ocfs2/super.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/ocfs2/super.c	2012-03-13 13:15:35.432097974 +0100
@@ -284,11 +284,11 @@ static int ocfs2_osb_dump(struct ocfs2_s
 			"%10s => GlobalAllocs: %d  LocalAllocs: %d  "
 			"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\n",
 			"Stats",
-			atomic_read(&osb->alloc_stats.bitmap_data),
-			atomic_read(&osb->alloc_stats.local_data),
-			atomic_read(&osb->alloc_stats.bg_allocs),
-			atomic_read(&osb->alloc_stats.moves),
-			atomic_read(&osb->alloc_stats.bg_extends));
+			atomic_read_unchecked(&osb->alloc_stats.bitmap_data),
+			atomic_read_unchecked(&osb->alloc_stats.local_data),
+			atomic_read_unchecked(&osb->alloc_stats.bg_allocs),
+			atomic_read_unchecked(&osb->alloc_stats.moves),
+			atomic_read_unchecked(&osb->alloc_stats.bg_extends));
 
 	out += snprintf(buf + out, len - out,
 			"%10s => State: %u  Descriptor: %llu  Size: %u bits  "
@@ -2002,11 +2002,11 @@ static int ocfs2_initialize_super(struct
 	spin_lock_init(&osb->osb_xattr_lock);
 	ocfs2_init_inode_steal_slot(osb);
 
-	atomic_set(&osb->alloc_stats.moves, 0);
-	atomic_set(&osb->alloc_stats.local_data, 0);
-	atomic_set(&osb->alloc_stats.bitmap_data, 0);
-	atomic_set(&osb->alloc_stats.bg_allocs, 0);
-	atomic_set(&osb->alloc_stats.bg_extends, 0);
+	atomic_set_unchecked(&osb->alloc_stats.moves, 0);
+	atomic_set_unchecked(&osb->alloc_stats.local_data, 0);
+	atomic_set_unchecked(&osb->alloc_stats.bitmap_data, 0);
+	atomic_set_unchecked(&osb->alloc_stats.bg_allocs, 0);
+	atomic_set_unchecked(&osb->alloc_stats.bg_extends, 0);
 
 	/* Copy the blockcheck stats from the superblock probe */
 	osb->osb_ecc_stats = *stats;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/partitions/efi.c linux-2.6.32.60-pax/fs/partitions/efi.c
--- linux-2.6.32.60/fs/partitions/efi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/partitions/efi.c	2012-03-13 13:15:35.436097974 +0100
@@ -231,14 +231,14 @@ alloc_read_gpt_entries(struct block_devi
 	if (!bdev || !gpt)
 		return NULL;
 
-	count = le32_to_cpu(gpt->num_partition_entries) *
-                le32_to_cpu(gpt->sizeof_partition_entry);
-	if (!count)
+	if (!le32_to_cpu(gpt->num_partition_entries))
 		return NULL;
-	pte = kzalloc(count, GFP_KERNEL);
+	pte = kcalloc(le32_to_cpu(gpt->num_partition_entries), le32_to_cpu(gpt->sizeof_partition_entry), GFP_KERNEL);
 	if (!pte)
 		return NULL;
 
+	count = le32_to_cpu(gpt->num_partition_entries) *
+                le32_to_cpu(gpt->sizeof_partition_entry);
 	if (read_lba(bdev, le64_to_cpu(gpt->partition_entry_lba),
                      (u8 *) pte,
 		     count) < count) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/pipe.c linux-2.6.32.60-pax/fs/pipe.c
--- linux-2.6.32.60/fs/pipe.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/pipe.c	2012-03-13 13:15:35.436097974 +0100
@@ -401,9 +401,9 @@ redo:
 		}
 		if (bufs)	/* More to do? */
 			continue;
-		if (!pipe->writers)
+		if (!atomic_read(&pipe->writers))
 			break;
-		if (!pipe->waiting_writers) {
+		if (!atomic_read(&pipe->waiting_writers)) {
 			/* syscall merging: Usually we must not sleep
 			 * if O_NONBLOCK is set, or if we got some data.
 			 * But if a writer sleeps in kernel space, then
@@ -462,7 +462,7 @@ pipe_write(struct kiocb *iocb, const str
 	mutex_lock(&inode->i_mutex);
 	pipe = inode->i_pipe;
 
-	if (!pipe->readers) {
+	if (!atomic_read(&pipe->readers)) {
 		send_sig(SIGPIPE, current, 0);
 		ret = -EPIPE;
 		goto out;
@@ -511,7 +511,7 @@ redo1:
 	for (;;) {
 		int bufs;
 
-		if (!pipe->readers) {
+		if (!atomic_read(&pipe->readers)) {
 			send_sig(SIGPIPE, current, 0);
 			if (!ret)
 				ret = -EPIPE;
@@ -597,9 +597,9 @@ redo2:
 			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
 			do_wakeup = 0;
 		}
-		pipe->waiting_writers++;
+		atomic_inc(&pipe->waiting_writers);
 		pipe_wait(pipe);
-		pipe->waiting_writers--;
+		atomic_dec(&pipe->waiting_writers);
 	}
 out:
 	mutex_unlock(&inode->i_mutex);
@@ -666,7 +666,7 @@ pipe_poll(struct file *filp, poll_table
 	mask = 0;
 	if (filp->f_mode & FMODE_READ) {
 		mask = (nrbufs > 0) ? POLLIN | POLLRDNORM : 0;
-		if (!pipe->writers && filp->f_version != pipe->w_counter)
+		if (!atomic_read(&pipe->writers) && filp->f_version != pipe->w_counter)
 			mask |= POLLHUP;
 	}
 
@@ -676,7 +676,7 @@ pipe_poll(struct file *filp, poll_table
 		 * Most Unices do not set POLLERR for FIFOs but on Linux they
 		 * behave exactly like pipes for poll().
 		 */
-		if (!pipe->readers)
+		if (!atomic_read(&pipe->readers))
 			mask |= POLLERR;
 	}
 
@@ -690,10 +690,10 @@ pipe_release(struct inode *inode, int de
 
 	mutex_lock(&inode->i_mutex);
 	pipe = inode->i_pipe;
-	pipe->readers -= decr;
-	pipe->writers -= decw;
+	atomic_sub(decr, &pipe->readers);
+	atomic_sub(decw, &pipe->writers);
 
-	if (!pipe->readers && !pipe->writers) {
+	if (!atomic_read(&pipe->readers) && !atomic_read(&pipe->writers)) {
 		free_pipe_info(inode);
 	} else {
 		wake_up_interruptible_sync(&pipe->wait);
@@ -783,7 +783,7 @@ pipe_read_open(struct inode *inode, stru
 
 	if (inode->i_pipe) {
 		ret = 0;
-		inode->i_pipe->readers++;
+		atomic_inc(&inode->i_pipe->readers);
 	}
 
 	mutex_unlock(&inode->i_mutex);
@@ -800,7 +800,7 @@ pipe_write_open(struct inode *inode, str
 
 	if (inode->i_pipe) {
 		ret = 0;
-		inode->i_pipe->writers++;
+		atomic_inc(&inode->i_pipe->writers);
 	}
 
 	mutex_unlock(&inode->i_mutex);
@@ -818,9 +818,9 @@ pipe_rdwr_open(struct inode *inode, stru
 	if (inode->i_pipe) {
 		ret = 0;
 		if (filp->f_mode & FMODE_READ)
-			inode->i_pipe->readers++;
+			atomic_inc(&inode->i_pipe->readers);
 		if (filp->f_mode & FMODE_WRITE)
-			inode->i_pipe->writers++;
+			atomic_inc(&inode->i_pipe->writers);
 	}
 
 	mutex_unlock(&inode->i_mutex);
@@ -945,7 +945,8 @@ static struct inode * get_pipe_inode(voi
 		goto fail_iput;
 	inode->i_pipe = pipe;
 
-	pipe->readers = pipe->writers = 1;
+	atomic_set(&pipe->readers, 1);
+	atomic_set(&pipe->writers, 1);
 	inode->i_fop = &rdwr_pipefifo_fops;
 
 	/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/array.c linux-2.6.32.60-pax/fs/proc/array.c
--- linux-2.6.32.60/fs/proc/array.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/array.c	2012-03-13 13:15:35.436097974 +0100
@@ -321,6 +321,21 @@ static inline void task_context_switch_c
 			p->nivcsw);
 }
 
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline void task_pax(struct seq_file *m, struct task_struct *p)
+{
+	if (p->mm)
+		seq_printf(m, "PaX:\t%c%c%c%c%c\n",
+			   p->mm->pax_flags & MF_PAX_PAGEEXEC ? 'P' : 'p',
+			   p->mm->pax_flags & MF_PAX_EMUTRAMP ? 'E' : 'e',
+			   p->mm->pax_flags & MF_PAX_MPROTECT ? 'M' : 'm',
+			   p->mm->pax_flags & MF_PAX_RANDMMAP ? 'R' : 'r',
+			   p->mm->pax_flags & MF_PAX_SEGMEXEC ? 'S' : 's');
+	else
+		seq_printf(m, "PaX:\t-----\n");
+}
+#endif
+
 int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
 			struct pid *pid, struct task_struct *task)
 {
@@ -337,6 +352,11 @@ int proc_pid_status(struct seq_file *m,
 	task_cap(m, task);
 	cpuset_task_status_allowed(m, task);
 	task_context_switch_counts(m, task);
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	task_pax(m, task);
+#endif
+
 	return 0;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/base.c linux-2.6.32.60-pax/fs/proc/base.c
--- linux-2.6.32.60/fs/proc/base.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/base.c	2012-03-13 13:15:35.440097974 +0100
@@ -2347,7 +2347,7 @@ static void *proc_self_follow_link(struc
 static void proc_self_put_link(struct dentry *dentry, struct nameidata *nd,
 				void *cookie)
 {
-	char *s = nd_get_link(nd);
+	const char *s = nd_get_link(nd);
 	if (!IS_ERR(s))
 		__putname(s);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/kcore.c linux-2.6.32.60-pax/fs/proc/kcore.c
--- linux-2.6.32.60/fs/proc/kcore.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/kcore.c	2012-03-13 13:15:35.440097974 +0100
@@ -477,9 +477,10 @@ read_kcore(struct file *file, char __use
 	 * the addresses in the elf_phdr on our list.
 	 */
 	start = kc_offset_to_vaddr(*fpos - elf_buflen);
-	if ((tsz = (PAGE_SIZE - (start & ~PAGE_MASK))) > buflen)
+	tsz = PAGE_SIZE - (start & ~PAGE_MASK);
+	if (tsz > buflen)
 		tsz = buflen;
-		
+
 	while (buflen) {
 		struct kcore_list *m;
 
@@ -508,20 +509,23 @@ read_kcore(struct file *file, char __use
 			kfree(elf_buf);
 		} else {
 			if (kern_addr_valid(start)) {
-				unsigned long n;
+				char *elf_buf;
+				mm_segment_t oldfs;
 
-				n = copy_to_user(buffer, (char *)start, tsz);
-				/*
-				 * We cannot distingush between fault on source
-				 * and fault on destination. When this happens
-				 * we clear too and hope it will trigger the
-				 * EFAULT again.
-				 */
-				if (n) { 
-					if (clear_user(buffer + tsz - n,
-								n))
+				elf_buf = kmalloc(tsz, GFP_KERNEL);
+				if (!elf_buf)
+					return -ENOMEM;
+				oldfs = get_fs();
+				set_fs(KERNEL_DS);
+				if (!__copy_from_user(elf_buf, (const void __user *)start, tsz)) {
+					set_fs(oldfs);
+					if (copy_to_user(buffer, elf_buf, tsz)) {
+						kfree(elf_buf);
 						return -EFAULT;
+					}
 				}
+				set_fs(oldfs);
+				kfree(elf_buf);
 			} else {
 				if (clear_user(buffer, tsz))
 					return -EFAULT;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/meminfo.c linux-2.6.32.60-pax/fs/proc/meminfo.c
--- linux-2.6.32.60/fs/proc/meminfo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/meminfo.c	2012-03-13 13:15:35.440097974 +0100
@@ -149,7 +149,7 @@ static int meminfo_proc_show(struct seq_
 		vmi.used >> 10,
 		vmi.largest_chunk >> 10
 #ifdef CONFIG_MEMORY_FAILURE
-		,atomic_long_read(&mce_bad_pages) << (PAGE_SHIFT - 10)
+		,atomic_long_read_unchecked(&mce_bad_pages) << (PAGE_SHIFT - 10)
 #endif
 		);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/nommu.c linux-2.6.32.60-pax/fs/proc/nommu.c
--- linux-2.6.32.60/fs/proc/nommu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/nommu.c	2012-03-13 13:15:35.440097974 +0100
@@ -67,7 +67,7 @@ static int nommu_region_show(struct seq_
 		if (len < 1)
 			len = 1;
 		seq_printf(m, "%*c", len, ' ');
-		seq_path(m, &file->f_path, "");
+		seq_path(m, &file->f_path, "\n\\");
 	}
 
 	seq_putc(m, '\n');
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/task_mmu.c linux-2.6.32.60-pax/fs/proc/task_mmu.c
--- linux-2.6.32.60/fs/proc/task_mmu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/task_mmu.c	2012-03-13 13:15:35.444097973 +0100
@@ -46,15 +46,26 @@ void task_mem(struct seq_file *m, struct
 		"VmStk:\t%8lu kB\n"
 		"VmExe:\t%8lu kB\n"
 		"VmLib:\t%8lu kB\n"
-		"VmPTE:\t%8lu kB\n",
-		hiwater_vm << (PAGE_SHIFT-10),
+		"VmPTE:\t%8lu kB\n"
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		"CsBase:\t%8lx\nCsLim:\t%8lx\n"
+#endif
+
+		,hiwater_vm << (PAGE_SHIFT-10),
 		(total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
 		mm->locked_vm << (PAGE_SHIFT-10),
 		hiwater_rss << (PAGE_SHIFT-10),
 		total_rss << (PAGE_SHIFT-10),
 		data << (PAGE_SHIFT-10),
 		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
-		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10);
+		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		, mm->context.user_cs_base, mm->context.user_cs_limit
+#endif
+
+	);
 }
 
 unsigned long task_vsize(struct mm_struct *mm)
@@ -206,7 +217,6 @@ static void show_map_vma(struct seq_file
 	int flags = vma->vm_flags;
 	unsigned long ino = 0;
 	unsigned long long pgoff = 0;
-	unsigned long start;
 	dev_t dev = 0;
 	int len;
 
@@ -217,18 +227,20 @@ static void show_map_vma(struct seq_file
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
 	}
 
-	/* We don't show the stack guard page in /proc/maps */
-	start = vma->vm_start;
-	if (vma->vm_flags & VM_GROWSDOWN)
-		if (!vma_stack_continue(vma->vm_prev, vma->vm_start))
-			start += PAGE_SIZE;
-
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
-			start,
+			vma->vm_start,
 			vma->vm_end,
+
+#if 0
+			flags & VM_MAYREAD ? flags & VM_READ ? 'R' : '+' : flags & VM_READ ? 'r' : '-',
+			flags & VM_MAYWRITE ? flags & VM_WRITE ? 'W' : '+' : flags & VM_WRITE ? 'w' : '-',
+			flags & VM_MAYEXEC ? flags & VM_EXEC ? 'X' : '+' : flags & VM_EXEC ? 'x' : '-',
+#else
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
 			flags & VM_EXEC ? 'x' : '-',
+#endif
+
 			flags & VM_MAYSHARE ? 's' : 'p',
 			pgoff,
 			MAJOR(dev), MINOR(dev), ino, &len);
@@ -239,7 +251,7 @@ static void show_map_vma(struct seq_file
 	 */
 	if (file) {
 		pad_len_spaces(m, len);
-		seq_path(m, &file->f_path, "\n");
+		seq_path(m, &file->f_path, "\n\\");
 	} else {
 		const char *name = arch_vma_name(vma);
 		if (!name) {
@@ -247,8 +259,9 @@ static void show_map_vma(struct seq_file
 				if (vma->vm_start <= mm->brk &&
 						vma->vm_end >= mm->start_brk) {
 					name = "[heap]";
-				} else if (vma->vm_start <= mm->start_stack &&
-					   vma->vm_end >= mm->start_stack) {
+				} else if ((vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP)) ||
+					   (vma->vm_start <= mm->start_stack &&
+					    vma->vm_end >= mm->start_stack)) {
 					name = "[stack]";
 				}
 			} else {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/proc/task_nommu.c linux-2.6.32.60-pax/fs/proc/task_nommu.c
--- linux-2.6.32.60/fs/proc/task_nommu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/proc/task_nommu.c	2012-03-13 13:15:35.444097973 +0100
@@ -50,7 +50,7 @@ void task_mem(struct seq_file *m, struct
 	else
 		bytes += kobjsize(mm);
 	
-	if (current->fs && current->fs->users > 1)
+	if (current->fs && atomic_read(&current->fs->users) > 1)
 		sbytes += kobjsize(current->fs);
 	else
 		bytes += kobjsize(current->fs);
@@ -154,7 +154,7 @@ static int nommu_vma_show(struct seq_fil
 		if (len < 1)
 			len = 1;
 		seq_printf(m, "%*c", len, ' ');
-		seq_path(m, &file->f_path, "");
+		seq_path(m, &file->f_path, "\n\\");
 	}
 
 	seq_putc(m, '\n');
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/readdir.c linux-2.6.32.60-pax/fs/readdir.c
--- linux-2.6.32.60/fs/readdir.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/readdir.c	2012-03-13 13:15:35.444097973 +0100
@@ -297,7 +297,7 @@ SYSCALL_DEFINE3(getdents64, unsigned int
 		error = buf.error;
 	lastdirent = buf.previous;
 	if (lastdirent) {
-		typeof(lastdirent->d_off) d_off = file->f_pos;
+		typeof(((struct linux_dirent64 *)0)->d_off) d_off = file->f_pos;
 		if (__put_user(d_off, &lastdirent->d_off))
 			error = -EFAULT;
 		else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/reiserfs/do_balan.c linux-2.6.32.60-pax/fs/reiserfs/do_balan.c
--- linux-2.6.32.60/fs/reiserfs/do_balan.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/reiserfs/do_balan.c	2012-03-13 13:15:35.444097973 +0100
@@ -2058,7 +2058,7 @@ void do_balance(struct tree_balance *tb,
 		return;
 	}
 
-	atomic_inc(&(fs_generation(tb->tb_sb)));
+	atomic_inc_unchecked(&(fs_generation(tb->tb_sb)));
 	do_balance_starts(tb);
 
 	/* balance leaf returns 0 except if combining L R and S into
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/reiserfs/procfs.c linux-2.6.32.60-pax/fs/reiserfs/procfs.c
--- linux-2.6.32.60/fs/reiserfs/procfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/reiserfs/procfs.c	2012-03-13 13:15:35.444097973 +0100
@@ -123,7 +123,7 @@ static int show_super(struct seq_file *m
 		   "SMALL_TAILS " : "NO_TAILS ",
 		   replay_only(sb) ? "REPLAY_ONLY " : "",
 		   convert_reiserfs(sb) ? "CONV " : "",
-		   atomic_read(&r->s_generation_counter),
+		   atomic_read_unchecked(&r->s_generation_counter),
 		   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),
 		   SF(s_do_balance), SF(s_unneeded_left_neighbor),
 		   SF(s_good_search_by_key_reada), SF(s_bmaps),
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/seq_file.c linux-2.6.32.60-pax/fs/seq_file.c
--- linux-2.6.32.60/fs/seq_file.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/seq_file.c	2013-01-22 17:38:23.416543634 +0100
@@ -551,7 +551,7 @@ static void single_stop(struct seq_file
 int single_open(struct file *file, int (*show)(struct seq_file *, void *),
 		void *data)
 {
-	struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);
+	seq_operations_no_const *op = kzalloc(sizeof(*op), GFP_KERNEL);
 	int res = -ENOMEM;
 
 	if (op) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/smbfs/proc.c linux-2.6.32.60-pax/fs/smbfs/proc.c
--- linux-2.6.32.60/fs/smbfs/proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/smbfs/proc.c	2013-02-17 20:00:19.527642533 +0100
@@ -266,9 +266,9 @@ int smb_setcodepage(struct smb_sb_info *
 
 out:
 	if (server->local_nls != NULL && server->remote_nls != NULL)
-		server->ops->convert = convert_cp;
+		*(void **)&server->ops->convert = convert_cp;
 	else
-		server->ops->convert = convert_memcpy;
+		*(void **)&server->ops->convert = convert_memcpy;
 
 	smb_unlock_server(server);
 	return n;
@@ -933,9 +933,9 @@ smb_newconn(struct smb_sb_info *server,
 
 	/* FIXME: the win9x code wants to modify these ... (seek/trunc bug) */
 	if (server->mnt->flags & SMB_MOUNT_OLDATTR) {
-		server->ops->getattr = smb_proc_getattr_core;
+		*(void **)&server->ops->getattr = smb_proc_getattr_core;
 	} else if (server->mnt->flags & SMB_MOUNT_DIRATTR) {
-		server->ops->getattr = smb_proc_getattr_ff;
+		*(void **)&server->ops->getattr = smb_proc_getattr_ff;
 	}
 
 	/* Decode server capabilities */
@@ -3439,7 +3439,7 @@ out:
 static void
 install_ops(struct smb_ops *dst, struct smb_ops *src)
 {
-	memcpy(dst, src, sizeof(void *) * SMB_OPS_NUM_STATIC);
+	memcpy((void *)dst, src, sizeof(void *) * SMB_OPS_NUM_STATIC);
 }
 
 /* < LANMAN2 */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/smbfs/symlink.c linux-2.6.32.60-pax/fs/smbfs/symlink.c
--- linux-2.6.32.60/fs/smbfs/symlink.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/smbfs/symlink.c	2012-03-13 13:15:35.448097973 +0100
@@ -55,7 +55,7 @@ static void *smb_follow_link(struct dent
 
 static void smb_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
 {
-	char *s = nd_get_link(nd);
+	const char *s = nd_get_link(nd);
 	if (!IS_ERR(s))
 		__putname(s);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/splice.c linux-2.6.32.60-pax/fs/splice.c
--- linux-2.6.32.60/fs/splice.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/splice.c	2012-03-13 13:15:35.452097973 +0100
@@ -185,7 +185,7 @@ ssize_t splice_to_pipe(struct pipe_inode
 	pipe_lock(pipe);
 
 	for (;;) {
-		if (!pipe->readers) {
+		if (!atomic_read(&pipe->readers)) {
 			send_sig(SIGPIPE, current, 0);
 			if (!ret)
 				ret = -EPIPE;
@@ -239,9 +239,9 @@ ssize_t splice_to_pipe(struct pipe_inode
 			do_wakeup = 0;
 		}
 
-		pipe->waiting_writers++;
+		atomic_inc(&pipe->waiting_writers);
 		pipe_wait(pipe);
-		pipe->waiting_writers--;
+		atomic_dec(&pipe->waiting_writers);
 	}
 
 	pipe_unlock(pipe);
@@ -521,7 +521,7 @@ static ssize_t kernel_readv(struct file
 	old_fs = get_fs();
 	set_fs(get_ds());
 	/* The cast to a user pointer is valid due to the set_fs() */
-	res = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);
+	res = vfs_readv(file, (const struct iovec __force_user *)vec, vlen, &pos);
 	set_fs(old_fs);
 
 	return res;
@@ -536,7 +536,7 @@ static ssize_t kernel_write(struct file
 	old_fs = get_fs();
 	set_fs(get_ds());
 	/* The cast to a user pointer is valid due to the set_fs() */
-	res = vfs_write(file, (const char __user *)buf, count, &pos);
+	res = vfs_write(file, (const char __force_user *)buf, count, &pos);
 	set_fs(old_fs);
 
 	return res;
@@ -578,7 +578,7 @@ ssize_t default_file_splice_read(struct
 			goto err;
 
 		this_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);
-		vec[i].iov_base = (void __user *) page_address(page);
+		vec[i].iov_base = (__force void __user *) page_address(page);
 		vec[i].iov_len = this_len;
 		pages[i] = page;
 		spd.nr_pages++;
@@ -800,10 +800,10 @@ EXPORT_SYMBOL(splice_from_pipe_feed);
 int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
 {
 	while (!pipe->nrbufs) {
-		if (!pipe->writers)
+		if (!atomic_read(&pipe->writers))
 			return 0;
 
-		if (!pipe->waiting_writers && sd->num_spliced)
+		if (!atomic_read(&pipe->waiting_writers) && sd->num_spliced)
 			return 0;
 
 		if (sd->flags & SPLICE_F_NONBLOCK)
@@ -1140,7 +1140,7 @@ ssize_t splice_direct_to_actor(struct fi
 		 * out of the pipe right after the splice_to_pipe(). So set
 		 * PIPE_READERS appropriately.
 		 */
-		pipe->readers = 1;
+		atomic_set(&pipe->readers, 1);
 
 		current->splice_pipe = pipe;
 	}
@@ -1701,9 +1701,9 @@ static int ipipe_prep(struct pipe_inode_
 			ret = -ERESTARTSYS;
 			break;
 		}
-		if (!pipe->writers)
+		if (!atomic_read(&pipe->writers))
 			break;
-		if (!pipe->waiting_writers) {
+		if (!atomic_read(&pipe->waiting_writers)) {
 			if (flags & SPLICE_F_NONBLOCK) {
 				ret = -EAGAIN;
 				break;
@@ -1735,7 +1735,7 @@ static int opipe_prep(struct pipe_inode_
 	pipe_lock(pipe);
 
 	while (pipe->nrbufs >= PIPE_BUFFERS) {
-		if (!pipe->readers) {
+		if (!atomic_read(&pipe->readers)) {
 			send_sig(SIGPIPE, current, 0);
 			ret = -EPIPE;
 			break;
@@ -1748,9 +1748,9 @@ static int opipe_prep(struct pipe_inode_
 			ret = -ERESTARTSYS;
 			break;
 		}
-		pipe->waiting_writers++;
+		atomic_inc(&pipe->waiting_writers);
 		pipe_wait(pipe);
-		pipe->waiting_writers--;
+		atomic_dec(&pipe->waiting_writers);
 	}
 
 	pipe_unlock(pipe);
@@ -1786,14 +1786,14 @@ retry:
 	pipe_double_lock(ipipe, opipe);
 
 	do {
-		if (!opipe->readers) {
+		if (!atomic_read(&opipe->readers)) {
 			send_sig(SIGPIPE, current, 0);
 			if (!ret)
 				ret = -EPIPE;
 			break;
 		}
 
-		if (!ipipe->nrbufs && !ipipe->writers)
+		if (!ipipe->nrbufs && !atomic_read(&ipipe->writers))
 			break;
 
 		/*
@@ -1893,7 +1893,7 @@ static int link_pipe(struct pipe_inode_i
 	pipe_double_lock(ipipe, opipe);
 
 	do {
-		if (!opipe->readers) {
+		if (!atomic_read(&opipe->readers)) {
 			send_sig(SIGPIPE, current, 0);
 			if (!ret)
 				ret = -EPIPE;
@@ -1938,7 +1938,7 @@ static int link_pipe(struct pipe_inode_i
 	 * return EAGAIN if we have the potential of some data in the
 	 * future, otherwise just return 0
 	 */
-	if (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))
+	if (!ret && atomic_read(&ipipe->waiting_writers) && (flags & SPLICE_F_NONBLOCK))
 		ret = -EAGAIN;
 
 	pipe_unlock(ipipe);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/sysfs/file.c linux-2.6.32.60-pax/fs/sysfs/file.c
--- linux-2.6.32.60/fs/sysfs/file.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/sysfs/file.c	2012-05-20 19:21:25.409167282 +0200
@@ -44,7 +44,7 @@ static DEFINE_SPINLOCK(sysfs_open_dirent
 
 struct sysfs_open_dirent {
 	atomic_t		refcnt;
-	atomic_t		event;
+	atomic_unchecked_t	event;
 	wait_queue_head_t	poll;
 	struct list_head	buffers; /* goes through sysfs_buffer.list */
 };
@@ -88,7 +88,7 @@ static int fill_read_buffer(struct dentr
 	if (!sysfs_get_active_two(attr_sd))
 		return -ENODEV;
 
-	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
+	buffer->event = atomic_read_unchecked(&attr_sd->s_attr.open->event);
 	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
 
 	sysfs_put_active_two(attr_sd);
@@ -294,7 +294,7 @@ static int sysfs_get_open_dirent(struct
 		return -ENOMEM;
 
 	atomic_set(&new_od->refcnt, 0);
-	atomic_set(&new_od->event, 1);
+	atomic_set_unchecked(&new_od->event, 1);
 	init_waitqueue_head(&new_od->poll);
 	INIT_LIST_HEAD(&new_od->buffers);
 	goto retry;
@@ -444,7 +444,7 @@ static unsigned int sysfs_poll(struct fi
 
 	sysfs_put_active_two(attr_sd);
 
-	if (buffer->event != atomic_read(&od->event))
+	if (buffer->event != atomic_read_unchecked(&od->event))
 		goto trigger;
 
 	return DEFAULT_POLLMASK;
@@ -463,7 +463,7 @@ void sysfs_notify_dirent(struct sysfs_di
 
 	od = sd->s_attr.open;
 	if (od) {
-		atomic_inc(&od->event);
+		atomic_inc_unchecked(&od->event);
 		wake_up_interruptible(&od->poll);
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/sysfs/symlink.c linux-2.6.32.60-pax/fs/sysfs/symlink.c
--- linux-2.6.32.60/fs/sysfs/symlink.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/sysfs/symlink.c	2012-03-13 13:15:35.452097973 +0100
@@ -204,7 +204,7 @@ static void *sysfs_follow_link(struct de
 
 static void sysfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
 {
-	char *page = nd_get_link(nd);
+	const char *page = nd_get_link(nd);
 	if (!IS_ERR(page))
 		free_page((unsigned long)page);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/udf/balloc.c linux-2.6.32.60-pax/fs/udf/balloc.c
--- linux-2.6.32.60/fs/udf/balloc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/udf/balloc.c	2012-03-13 13:15:35.452097973 +0100
@@ -172,9 +172,7 @@ static void udf_bitmap_free_blocks(struc
 
 	mutex_lock(&sbi->s_alloc_mutex);
 	partmap = &sbi->s_partmaps[bloc->partitionReferenceNum];
-	if (bloc->logicalBlockNum < 0 ||
-	    (bloc->logicalBlockNum + count) >
-		partmap->s_partition_len) {
+	if ((bloc->logicalBlockNum + count) > partmap->s_partition_len) {
 		udf_debug("%d < %d || %d + %d > %d\n",
 			  bloc->logicalBlockNum, 0, bloc->logicalBlockNum,
 			  count, partmap->s_partition_len);
@@ -436,9 +434,7 @@ static void udf_table_free_blocks(struct
 
 	mutex_lock(&sbi->s_alloc_mutex);
 	partmap = &sbi->s_partmaps[bloc->partitionReferenceNum];
-	if (bloc->logicalBlockNum < 0 ||
-	    (bloc->logicalBlockNum + count) >
-		partmap->s_partition_len) {
+	if ((bloc->logicalBlockNum + count) > partmap->s_partition_len) {
 		udf_debug("%d < %d || %d + %d > %d\n",
 			  bloc.logicalBlockNum, 0, bloc.logicalBlockNum, count,
 			  partmap->s_partition_len);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/udf/misc.c linux-2.6.32.60-pax/fs/udf/misc.c
--- linux-2.6.32.60/fs/udf/misc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/udf/misc.c	2012-03-13 13:15:35.456097973 +0100
@@ -286,7 +286,7 @@ void udf_new_tag(char *data, uint16_t id
 
 u8 udf_tag_checksum(const struct tag *t)
 {
-	u8 *data = (u8 *)t;
+	const u8 *data = (const u8 *)t;
 	u8 checksum = 0;
 	int i;
 	for (i = 0; i < sizeof(struct tag); ++i)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/xattr_acl.c linux-2.6.32.60-pax/fs/xattr_acl.c
--- linux-2.6.32.60/fs/xattr_acl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/xattr_acl.c	2012-03-13 13:15:35.456097973 +0100
@@ -17,8 +17,8 @@
 struct posix_acl *
 posix_acl_from_xattr(const void *value, size_t size)
 {
-	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
-	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+	const posix_acl_xattr_header *header = (const posix_acl_xattr_header *)value;
+	const posix_acl_xattr_entry *entry = (const posix_acl_xattr_entry *)(header+1), *end;
 	int count;
 	struct posix_acl *acl;
 	struct posix_acl_entry *acl_e;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/xfs/linux-2.6/xfs_ioctl.c linux-2.6.32.60-pax/fs/xfs/linux-2.6/xfs_ioctl.c
--- linux-2.6.32.60/fs/xfs/linux-2.6/xfs_ioctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/xfs/linux-2.6/xfs_ioctl.c	2012-03-13 13:15:35.456097973 +0100
@@ -134,7 +134,7 @@ xfs_find_handle(
 	}
 
 	error = -EFAULT;
-	if (copy_to_user(hreq->ohandle, &handle, hsize) ||
+	if (hsize > sizeof handle || copy_to_user(hreq->ohandle, &handle, hsize) ||
 	    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))
 		goto out_put;
 
@@ -423,7 +423,7 @@ xfs_attrlist_by_handle(
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	kbuf = kmalloc(al_hreq.buflen, GFP_KERNEL);
+	kbuf = kzalloc(al_hreq.buflen, GFP_KERNEL);
 	if (!kbuf)
 		goto out_dput;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/xfs/linux-2.6/xfs_iops.c linux-2.6.32.60-pax/fs/xfs/linux-2.6/xfs_iops.c
--- linux-2.6.32.60/fs/xfs/linux-2.6/xfs_iops.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/xfs/linux-2.6/xfs_iops.c	2012-03-13 13:15:35.456097973 +0100
@@ -468,7 +468,7 @@ xfs_vn_put_link(
 	struct nameidata *nd,
 	void		*p)
 {
-	char		*s = nd_get_link(nd);
+	const char	*s = nd_get_link(nd);
 
 	if (!IS_ERR(s))
 		kfree(s);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/xfs/xfs_bmap.c linux-2.6.32.60-pax/fs/xfs/xfs_bmap.c
--- linux-2.6.32.60/fs/xfs/xfs_bmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/xfs/xfs_bmap.c	2012-03-13 13:15:35.460097973 +0100
@@ -360,7 +360,7 @@ xfs_bmap_validate_ret(
 	int			nmap,
 	int			ret_nmap);
 #else
-#define	xfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap)
+#define	xfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap) do {} while (0)
 #endif /* DEBUG */
 
 #if defined(XFS_RW_TRACE)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/fs/xfs/xfs_dir2_sf.c linux-2.6.32.60-pax/fs/xfs/xfs_dir2_sf.c
--- linux-2.6.32.60/fs/xfs/xfs_dir2_sf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/fs/xfs/xfs_dir2_sf.c	2012-03-13 13:15:35.460097973 +0100
@@ -779,7 +779,15 @@ xfs_dir2_sf_getdents(
 		}
 
 		ino = xfs_dir2_sf_get_inumber(sfp, xfs_dir2_sf_inumberp(sfep));
-		if (filldir(dirent, sfep->name, sfep->namelen,
+		if (dp->i_df.if_u1.if_data == dp->i_df.if_u2.if_inline_data) {
+			char name[sfep->namelen];
+			memcpy(name, sfep->name, sfep->namelen);
+			if (filldir(dirent, name, sfep->namelen,
+			    off & 0x7fffffff, ino, DT_UNKNOWN)) {
+				*offset = off & 0x7fffffff;
+				return 0;
+			}
+		} else if (filldir(dirent, sfep->name, sfep->namelen,
 			    off & 0x7fffffff, ino, DT_UNKNOWN)) {
 			*offset = off & 0x7fffffff;
 			return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/4level-fixup.h linux-2.6.32.60-pax/include/asm-generic/4level-fixup.h
--- linux-2.6.32.60/include/asm-generic/4level-fixup.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/4level-fixup.h	2012-09-04 14:07:43.394752297 +0200
@@ -13,8 +13,10 @@
 #define pmd_alloc(mm, pud, address) \
 	((unlikely(pgd_none(*(pud))) && __pmd_alloc(mm, pud, address))? \
  		NULL: pmd_offset(pud, address))
+#define pmd_alloc_kernel(mm, pud, address) pmd_alloc((mm), (pud), (address))
 
 #define pud_alloc(mm, pgd, address)	(pgd)
+#define pud_alloc_kernel(mm, pgd, address)	pud_alloc((mm), (pgd), (address))
 #define pud_offset(pgd, start)		(pgd)
 #define pud_none(pud)			0
 #define pud_bad(pud)			0
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/atomic64.h linux-2.6.32.60-pax/include/asm-generic/atomic64.h
--- linux-2.6.32.60/include/asm-generic/atomic64.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/atomic64.h	2012-03-13 13:15:35.464097972 +0100
@@ -16,6 +16,8 @@ typedef struct {
 	long long counter;
 } atomic64_t;
 
+typedef atomic64_t atomic64_unchecked_t;
+
 #define ATOMIC64_INIT(i)	{ (i) }
 
 extern long long atomic64_read(const atomic64_t *v);
@@ -39,4 +41,14 @@ extern int	 atomic64_add_unless(atomic64
 #define atomic64_dec_and_test(v)	(atomic64_dec_return((v)) == 0)
 #define atomic64_inc_not_zero(v) 	atomic64_add_unless((v), 1LL, 0LL)
 
+#define atomic64_read_unchecked(v) atomic64_read(v)
+#define atomic64_set_unchecked(v, i) atomic64_set((v), (i))
+#define atomic64_add_unchecked(a, v) atomic64_add((a), (v))
+#define atomic64_add_return_unchecked(a, v) atomic64_add_return((a), (v))
+#define atomic64_sub_unchecked(a, v) atomic64_sub((a), (v))
+#define atomic64_inc_unchecked(v) atomic64_inc(v)
+#define atomic64_inc_return_unchecked(v) atomic64_inc_return(v)
+#define atomic64_dec_unchecked(v) atomic64_dec(v)
+#define atomic64_cmpxchg_unchecked(v, o, n) atomic64_cmpxchg((v), (o), (n))
+
 #endif  /*  _ASM_GENERIC_ATOMIC64_H  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/atomic.h linux-2.6.32.60-pax/include/asm-generic/atomic.h
--- linux-2.6.32.60/include/asm-generic/atomic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/atomic.h	2012-07-21 11:36:14.865086549 +0200
@@ -134,7 +134,7 @@ static inline void atomic_dec(atomic_t *
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
-static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
+static inline void atomic_clear_mask(unsigned int mask, atomic_t *v)
 {
 	unsigned long flags;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/atomic-long.h linux-2.6.32.60-pax/include/asm-generic/atomic-long.h
--- linux-2.6.32.60/include/asm-generic/atomic-long.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/atomic-long.h	2012-12-14 21:00:03.141796436 +0100
@@ -22,6 +22,12 @@
 
 typedef atomic64_t atomic_long_t;
 
+#ifdef CONFIG_PAX_REFCOUNT
+typedef atomic64_unchecked_t atomic_long_unchecked_t;
+#else
+typedef atomic64_t atomic_long_unchecked_t;
+#endif
+
 #define ATOMIC_LONG_INIT(i)	ATOMIC64_INIT(i)
 
 static inline long atomic_long_read(atomic_long_t *l)
@@ -31,6 +37,15 @@ static inline long atomic_long_read(atom
 	return (long)atomic64_read(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_read_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	return (long)atomic64_read_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_set(atomic_long_t *l, long i)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -38,6 +53,15 @@ static inline void atomic_long_set(atomi
 	atomic64_set(v, i);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_set_unchecked(atomic_long_unchecked_t *l, long i)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	atomic64_set_unchecked(v, i);
+}
+#endif
+
 static inline void atomic_long_inc(atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -45,6 +69,15 @@ static inline void atomic_long_inc(atomi
 	atomic64_inc(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_inc_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	atomic64_inc_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_dec(atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -52,6 +85,15 @@ static inline void atomic_long_dec(atomi
 	atomic64_dec(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_dec_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	atomic64_dec_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_add(long i, atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -59,6 +101,15 @@ static inline void atomic_long_add(long
 	atomic64_add(i, v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_add_unchecked(long i, atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	atomic64_add_unchecked(i, v);
+}
+#endif
+
 static inline void atomic_long_sub(long i, atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -101,6 +152,15 @@ static inline long atomic_long_add_retur
 	return (long)atomic64_add_return(i, v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_add_return_unchecked(long i, atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	return (long)atomic64_add_return_unchecked(i, v);
+}
+#endif
+
 static inline long atomic_long_sub_return(long i, atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -115,6 +175,15 @@ static inline long atomic_long_inc_retur
 	return (long)atomic64_inc_return(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_inc_return_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic64_unchecked_t *v = (atomic64_unchecked_t *)l;
+
+	return (long)atomic64_inc_return_unchecked(v);
+}
+#endif
+
 static inline long atomic_long_dec_return(atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -140,6 +209,12 @@ static inline long atomic_long_add_unles
 
 typedef atomic_t atomic_long_t;
 
+#ifdef CONFIG_PAX_REFCOUNT
+typedef atomic_unchecked_t atomic_long_unchecked_t;
+#else
+typedef atomic_t atomic_long_unchecked_t;
+#endif
+
 #define ATOMIC_LONG_INIT(i)	ATOMIC_INIT(i)
 static inline long atomic_long_read(atomic_long_t *l)
 {
@@ -148,6 +223,15 @@ static inline long atomic_long_read(atom
 	return (long)atomic_read(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_read_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	return (long)atomic_read_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_set(atomic_long_t *l, long i)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -155,6 +239,15 @@ static inline void atomic_long_set(atomi
 	atomic_set(v, i);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_set_unchecked(atomic_long_unchecked_t *l, long i)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	atomic_set_unchecked(v, i);
+}
+#endif
+
 static inline void atomic_long_inc(atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -162,6 +255,15 @@ static inline void atomic_long_inc(atomi
 	atomic_inc(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_inc_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	atomic_inc_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_dec(atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -169,6 +271,15 @@ static inline void atomic_long_dec(atomi
 	atomic_dec(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_dec_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	atomic_dec_unchecked(v);
+}
+#endif
+
 static inline void atomic_long_add(long i, atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -176,6 +287,15 @@ static inline void atomic_long_add(long
 	atomic_add(i, v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void atomic_long_add_unchecked(long i, atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	atomic_add_unchecked(i, v);
+}
+#endif
+
 static inline void atomic_long_sub(long i, atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -218,6 +338,16 @@ static inline long atomic_long_add_retur
 	return (long)atomic_add_return(i, v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_add_return_unchecked(long i, atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	return (long)atomic_add_return_unchecked(i, v);
+}
+
+#endif
+
 static inline long atomic_long_sub_return(long i, atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -232,6 +362,15 @@ static inline long atomic_long_inc_retur
 	return (long)atomic_inc_return(v);
 }
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline long atomic_long_inc_return_unchecked(atomic_long_unchecked_t *l)
+{
+	atomic_unchecked_t *v = (atomic_unchecked_t *)l;
+
+	return (long)atomic_inc_return_unchecked(v);
+}
+#endif
+
 static inline long atomic_long_dec_return(atomic_long_t *l)
 {
 	atomic_t *v = (atomic_t *)l;
@@ -255,4 +394,55 @@ static inline long atomic_long_add_unles
 
 #endif  /*  BITS_PER_LONG == 64  */
 
+#ifdef CONFIG_PAX_REFCOUNT
+static inline void pax_refcount_needs_these_functions(void)
+{
+	atomic_read_unchecked((atomic_unchecked_t *)NULL);
+	atomic_set_unchecked((atomic_unchecked_t *)NULL, 0);
+	atomic_add_unchecked(0, (atomic_unchecked_t *)NULL);
+	atomic_sub_unchecked(0, (atomic_unchecked_t *)NULL);
+	atomic_inc_unchecked((atomic_unchecked_t *)NULL);
+	(void)atomic_inc_and_test_unchecked((atomic_unchecked_t *)NULL);
+	atomic_inc_return_unchecked((atomic_unchecked_t *)NULL);
+	atomic_add_return_unchecked(0, (atomic_unchecked_t *)NULL);
+	atomic_dec_unchecked((atomic_unchecked_t *)NULL);
+	atomic_cmpxchg_unchecked((atomic_unchecked_t *)NULL, 0, 0);
+	(void)atomic_xchg_unchecked((atomic_unchecked_t *)NULL, 0);
+#ifdef CONFIG_X86
+	atomic_clear_mask_unchecked(0, NULL);
+	atomic_set_mask_unchecked(0, NULL);
+#endif
+
+	atomic_long_read_unchecked((atomic_long_unchecked_t *)NULL);
+	atomic_long_set_unchecked((atomic_long_unchecked_t *)NULL, 0);
+	atomic_long_add_unchecked(0, (atomic_long_unchecked_t *)NULL);
+	atomic_long_inc_unchecked((atomic_long_unchecked_t *)NULL);
+	atomic_long_add_return_unchecked(0, (atomic_long_unchecked_t *)NULL);
+	atomic_long_inc_return_unchecked((atomic_long_unchecked_t *)NULL);
+	atomic_long_dec_unchecked((atomic_long_unchecked_t *)NULL);
+}
+#else
+#define atomic_read_unchecked(v) atomic_read(v)
+#define atomic_set_unchecked(v, i) atomic_set((v), (i))
+#define atomic_add_unchecked(i, v) atomic_add((i), (v))
+#define atomic_sub_unchecked(i, v) atomic_sub((i), (v))
+#define atomic_inc_unchecked(v) atomic_inc(v)
+#define atomic_inc_and_test_unchecked(v) atomic_inc_and_test(v)
+#define atomic_inc_return_unchecked(v) atomic_inc_return(v)
+#define atomic_add_return_unchecked(i, v) atomic_add_return((i), (v))
+#define atomic_dec_unchecked(v) atomic_dec(v)
+#define atomic_cmpxchg_unchecked(v, o, n) atomic_cmpxchg((v), (o), (n))
+#define atomic_xchg_unchecked(v, i) atomic_xchg((v), (i))
+#define atomic_clear_mask_unchecked(mask, v) atomic_clear_mask((mask), (v))
+#define atomic_set_mask_unchecked(mask, v) atomic_set_mask((mask), (v))
+
+#define atomic_long_read_unchecked(v) atomic_long_read(v)
+#define atomic_long_set_unchecked(v, i) atomic_long_set((v), (i))
+#define atomic_long_add_unchecked(i, v) atomic_long_add((i), (v))
+#define atomic_long_inc_unchecked(v) atomic_long_inc(v)
+#define atomic_long_add_return_unchecked(i, v) atomic_long_add_return((i), (v))
+#define atomic_long_inc_return_unchecked(v) atomic_long_inc_return(v)
+#define atomic_long_dec_unchecked(v) atomic_long_dec(v)
+#endif
+
 #endif  /*  _ASM_GENERIC_ATOMIC_LONG_H  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/cache.h linux-2.6.32.60-pax/include/asm-generic/cache.h
--- linux-2.6.32.60/include/asm-generic/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/cache.h	2012-03-13 13:15:35.464097972 +0100
@@ -6,7 +6,7 @@
  * cache lines need to provide their own cache.h.
  */
 
-#define L1_CACHE_SHIFT		5
-#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+#define L1_CACHE_SHIFT		5UL
+#define L1_CACHE_BYTES		(1UL << L1_CACHE_SHIFT)
 
 #endif /* __ASM_GENERIC_CACHE_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/emergency-restart.h linux-2.6.32.60-pax/include/asm-generic/emergency-restart.h
--- linux-2.6.32.60/include/asm-generic/emergency-restart.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/emergency-restart.h	2012-03-13 13:15:35.464097972 +0100
@@ -1,7 +1,7 @@
 #ifndef _ASM_GENERIC_EMERGENCY_RESTART_H
 #define _ASM_GENERIC_EMERGENCY_RESTART_H
 
-static inline void machine_emergency_restart(void)
+static inline __noreturn void machine_emergency_restart(void)
 {
 	machine_restart(NULL);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/futex.h linux-2.6.32.60-pax/include/asm-generic/futex.h
--- linux-2.6.32.60/include/asm-generic/futex.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/futex.h	2012-03-13 13:15:35.468097972 +0100
@@ -6,7 +6,7 @@
 #include <asm/errno.h>
 
 static inline int
-futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
+futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
 {
 	int op = (encoded_op >> 28) & 7;
 	int cmp = (encoded_op >> 24) & 15;
@@ -48,7 +48,7 @@ futex_atomic_op_inuser (int encoded_op,
 }
 
 static inline int
-futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
+futex_atomic_cmpxchg_inatomic(u32 __user *uaddr, int oldval, int newval)
 {
 	return -ENOSYS;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/kmap_types.h linux-2.6.32.60-pax/include/asm-generic/kmap_types.h
--- linux-2.6.32.60/include/asm-generic/kmap_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/kmap_types.h	2012-03-13 13:15:35.472097972 +0100
@@ -28,7 +28,8 @@ KMAP_D(15)	KM_UML_USERCOPY,
 KMAP_D(16)	KM_IRQ_PTE,
 KMAP_D(17)	KM_NMI,
 KMAP_D(18)	KM_NMI_PTE,
-KMAP_D(19)	KM_TYPE_NR
+KMAP_D(19)	KM_CLEARPAGE,
+KMAP_D(20)	KM_TYPE_NR
 };
 
 #undef KMAP_D
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/local.h linux-2.6.32.60-pax/include/asm-generic/local.h
--- linux-2.6.32.60/include/asm-generic/local.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/local.h	2012-12-14 20:55:58.517779158 +0100
@@ -23,24 +23,37 @@ typedef struct
 	atomic_long_t a;
 } local_t;
 
+typedef struct {
+	atomic_long_unchecked_t a;
+} local_unchecked_t;
+
 #define LOCAL_INIT(i)	{ ATOMIC_LONG_INIT(i) }
 
 #define local_read(l)	atomic_long_read(&(l)->a)
+#define local_read_unchecked(l)	atomic_long_read_unchecked(&(l)->a)
 #define local_set(l,i)	atomic_long_set((&(l)->a),(i))
+#define local_set_unchecked(l,i)	atomic_long_set_unchecked((&(l)->a),(i))
 #define local_inc(l)	atomic_long_inc(&(l)->a)
+#define local_inc_unchecked(l)	atomic_long_inc_unchecked(&(l)->a)
 #define local_dec(l)	atomic_long_dec(&(l)->a)
+#define local_dec_unchecked(l)	atomic_long_dec_unchecked(&(l)->a)
 #define local_add(i,l)	atomic_long_add((i),(&(l)->a))
+#define local_add_unchecked(i,l)	atomic_long_add_unchecked((i),(&(l)->a))
 #define local_sub(i,l)	atomic_long_sub((i),(&(l)->a))
+#define local_sub_unchecked(i,l)	atomic_long_sub_unchecked((i),(&(l)->a))
 
 #define local_sub_and_test(i, l) atomic_long_sub_and_test((i), (&(l)->a))
 #define local_dec_and_test(l) atomic_long_dec_and_test(&(l)->a)
 #define local_inc_and_test(l) atomic_long_inc_and_test(&(l)->a)
 #define local_add_negative(i, l) atomic_long_add_negative((i), (&(l)->a))
 #define local_add_return(i, l) atomic_long_add_return((i), (&(l)->a))
+#define local_add_return_unchecked(i, l) atomic_long_add_return_unchecked((i), (&(l)->a))
 #define local_sub_return(i, l) atomic_long_sub_return((i), (&(l)->a))
 #define local_inc_return(l) atomic_long_inc_return(&(l)->a)
+#define local_dec_return(l) atomic_long_dec_return(&(l)->a)
 
 #define local_cmpxchg(l, o, n) atomic_long_cmpxchg((&(l)->a), (o), (n))
+#define local_cmpxchg_unchecked(l, o, n) atomic_long_cmpxchg((&(l)->a), (o), (n))
 #define local_xchg(l, n) atomic_long_xchg((&(l)->a), (n))
 #define local_add_unless(l, _a, u) atomic_long_add_unless((&(l)->a), (_a), (u))
 #define local_inc_not_zero(l) atomic_long_inc_not_zero(&(l)->a)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/pgtable.h linux-2.6.32.60-pax/include/asm-generic/pgtable.h
--- linux-2.6.32.60/include/asm-generic/pgtable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/pgtable.h	2012-03-13 13:15:35.472097972 +0100
@@ -344,6 +344,14 @@ extern void untrack_pfn_vma(struct vm_ar
 				unsigned long size);
 #endif
 
+#ifndef __HAVE_ARCH_PAX_OPEN_KERNEL
+static inline unsigned long pax_open_kernel(void) { return 0; }
+#endif
+
+#ifndef __HAVE_ARCH_PAX_CLOSE_KERNEL
+static inline unsigned long pax_close_kernel(void) { return 0; }
+#endif
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* _ASM_GENERIC_PGTABLE_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/pgtable-nopmd.h linux-2.6.32.60-pax/include/asm-generic/pgtable-nopmd.h
--- linux-2.6.32.60/include/asm-generic/pgtable-nopmd.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/pgtable-nopmd.h	2012-03-13 13:15:35.472097972 +0100
@@ -1,14 +1,19 @@
 #ifndef _PGTABLE_NOPMD_H
 #define _PGTABLE_NOPMD_H
 
-#ifndef __ASSEMBLY__
-
 #include <asm-generic/pgtable-nopud.h>
 
-struct mm_struct;
-
 #define __PAGETABLE_PMD_FOLDED
 
+#define PMD_SHIFT	PUD_SHIFT
+#define PTRS_PER_PMD	1
+#define PMD_SIZE  	(_AC(1,UL) << PMD_SHIFT)
+#define PMD_MASK  	(~(PMD_SIZE-1))
+
+#ifndef __ASSEMBLY__
+
+struct mm_struct;
+
 /*
  * Having the pmd type consist of a pud gets the size right, and allows
  * us to conceptually access the pud entry that this pmd is folded into
@@ -16,11 +21,6 @@ struct mm_struct;
  */
 typedef struct { pud_t pud; } pmd_t;
 
-#define PMD_SHIFT	PUD_SHIFT
-#define PTRS_PER_PMD	1
-#define PMD_SIZE  	(1UL << PMD_SHIFT)
-#define PMD_MASK  	(~(PMD_SIZE-1))
-
 /*
  * The "pud_xxx()" functions here are trivial for a folded two-level
  * setup: the pmd is never bad, and a pmd always exists (as it's folded
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/pgtable-nopud.h linux-2.6.32.60-pax/include/asm-generic/pgtable-nopud.h
--- linux-2.6.32.60/include/asm-generic/pgtable-nopud.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/pgtable-nopud.h	2012-05-25 08:51:22.342766556 +0200
@@ -1,10 +1,15 @@
 #ifndef _PGTABLE_NOPUD_H
 #define _PGTABLE_NOPUD_H
 
-#ifndef __ASSEMBLY__
-
 #define __PAGETABLE_PUD_FOLDED
 
+#define PUD_SHIFT	PGDIR_SHIFT
+#define PTRS_PER_PUD	1
+#define PUD_SIZE  	(_AC(1,UL) << PUD_SHIFT)
+#define PUD_MASK  	(~(PUD_SIZE-1))
+
+#ifndef __ASSEMBLY__
+
 /*
  * Having the pud type consist of a pgd gets the size right, and allows
  * us to conceptually access the pgd entry that this pud is folded into
@@ -12,11 +17,6 @@
  */
 typedef struct { pgd_t pgd; } pud_t;
 
-#define PUD_SHIFT	PGDIR_SHIFT
-#define PTRS_PER_PUD	1
-#define PUD_SIZE  	(1UL << PUD_SHIFT)
-#define PUD_MASK  	(~(PUD_SIZE-1))
-
 /*
  * The "pgd_xxx()" functions here are trivial for a folded two-level
  * setup: the pud is never bad, and a pud always exists (as it's folded
@@ -29,6 +29,7 @@ static inline void pgd_clear(pgd_t *pgd)
 #define pud_ERROR(pud)				(pgd_ERROR((pud).pgd))
 
 #define pgd_populate(mm, pgd, pud)		do { } while (0)
+#define pgd_populate_kernel(mm, pgd, pud)	do { } while (0)
 /*
  * (puds are folded into pgds so this doesn't get actually called,
  * but the define is needed for a generic inline function.)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/asm-generic/vmlinux.lds.h linux-2.6.32.60-pax/include/asm-generic/vmlinux.lds.h
--- linux-2.6.32.60/include/asm-generic/vmlinux.lds.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/asm-generic/vmlinux.lds.h	2012-03-13 13:15:35.476097972 +0100
@@ -199,6 +199,7 @@
 	.rodata           : AT(ADDR(.rodata) - LOAD_OFFSET) {		\
 		VMLINUX_SYMBOL(__start_rodata) = .;			\
 		*(.rodata) *(.rodata.*)					\
+		*(.data.read_only)					\
 		*(__vermagic)		/* Kernel version magic */	\
 		*(__markers_strings)	/* Markers: strings */		\
 		*(__tracepoints_strings)/* Tracepoints: strings */	\
@@ -656,22 +657,24 @@
  * section in the linker script will go there too.  @phdr should have
  * a leading colon.
  *
- * Note that this macros defines __per_cpu_load as an absolute symbol.
+ * Note that this macros defines per_cpu_load as an absolute symbol.
  * If there is no need to put the percpu section at a predetermined
  * address, use PERCPU().
  */
 #define PERCPU_VADDR(vaddr, phdr)					\
-	VMLINUX_SYMBOL(__per_cpu_load) = .;				\
-	.data.percpu vaddr : AT(VMLINUX_SYMBOL(__per_cpu_load)		\
+	per_cpu_load = .;						\
+	.data.percpu vaddr : AT(VMLINUX_SYMBOL(per_cpu_load)		\
 				- LOAD_OFFSET) {			\
+		VMLINUX_SYMBOL(__per_cpu_load) = . + per_cpu_load;	\
 		VMLINUX_SYMBOL(__per_cpu_start) = .;			\
 		*(.data.percpu.first)					\
-		*(.data.percpu.page_aligned)				\
 		*(.data.percpu)						\
+		. = ALIGN(PAGE_SIZE);					\
+		*(.data.percpu.page_aligned)				\
 		*(.data.percpu.shared_aligned)				\
 		VMLINUX_SYMBOL(__per_cpu_end) = .;			\
 	} phdr								\
-	. = VMLINUX_SYMBOL(__per_cpu_load) + SIZEOF(.data.percpu);
+	. = VMLINUX_SYMBOL(per_cpu_load) + SIZEOF(.data.percpu);
 
 /**
  * PERCPU - define output section for percpu area, simple version
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/crypto/algapi.h linux-2.6.32.60-pax/include/crypto/algapi.h
--- linux-2.6.32.60/include/crypto/algapi.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/crypto/algapi.h	2013-01-22 17:38:23.560543626 +0100
@@ -32,7 +32,7 @@ struct crypto_type {
 	unsigned int maskclear;
 	unsigned int maskset;
 	unsigned int tfmsize;
-};
+} __do_const;
 
 struct crypto_instance {
 	struct crypto_alg alg;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/drm/drm_crtc_helper.h linux-2.6.32.60-pax/include/drm/drm_crtc_helper.h
--- linux-2.6.32.60/include/drm/drm_crtc_helper.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/drm/drm_crtc_helper.h	2013-01-22 20:58:05.439903887 +0100
@@ -85,7 +85,7 @@ struct drm_encoder_helper_funcs {
 					    struct drm_connector *connector);
 	/* disable encoder when not in use - more explicit than dpms off */
 	void (*disable)(struct drm_encoder *encoder);
-};
+} __no_const;
 
 struct drm_connector_helper_funcs {
 	int (*get_modes)(struct drm_connector *connector);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/drm/drmP.h linux-2.6.32.60-pax/include/drm/drmP.h
--- linux-2.6.32.60/include/drm/drmP.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/drm/drmP.h	2013-02-17 17:53:57.252047368 +0100
@@ -71,6 +71,7 @@
 #include <linux/workqueue.h>
 #include <linux/poll.h>
 #include <asm/pgalloc.h>
+#include <asm/local.h>
 #include "drm.h"
 
 #include <linux/idr.h>
@@ -917,7 +918,7 @@ struct drm_device {
 
 	/** \name Usage Counters */
 	/*@{ */
-	int open_count;			/**< Outstanding files open */
+	local_t open_count;		/**< Outstanding files open */
 	atomic_t ioctl_count;		/**< Outstanding IOCTLs pending */
 	atomic_t vma_count;		/**< Outstanding vma areas open */
 	int buf_use;			/**< Buffers in use -- cannot alloc */
@@ -928,7 +929,7 @@ struct drm_device {
 	/*@{ */
 	unsigned long counters;
 	enum drm_stat_type types[15];
-	atomic_t counts[15];
+	atomic_unchecked_t counts[15];
 	/*@} */
 
 	struct list_head filelist;
@@ -1042,11 +1043,11 @@ struct drm_device {
 	spinlock_t object_name_lock;
 	struct idr object_name_idr;
 	atomic_t object_count;
-	atomic_t object_memory;
+	atomic_unchecked_t object_memory;
 	atomic_t pin_count;
-	atomic_t pin_memory;
+	atomic_unchecked_t pin_memory;
 	atomic_t gtt_count;
-	atomic_t gtt_memory;
+	atomic_unchecked_t gtt_memory;
 	uint32_t gtt_total;
 	uint32_t invalidate_domains;    /* domains pending invalidation */
 	uint32_t flush_domains;         /* domains pending flush */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/drm/ttm/ttm_memory.h linux-2.6.32.60-pax/include/drm/ttm/ttm_memory.h
--- linux-2.6.32.60/include/drm/ttm/ttm_memory.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/drm/ttm/ttm_memory.h	2012-03-13 13:15:35.476097972 +0100
@@ -47,7 +47,7 @@
 
 struct ttm_mem_shrink {
 	int (*do_shrink) (struct ttm_mem_shrink *);
-};
+} __no_const;
 
 /**
  * struct ttm_mem_global - Global memory accounting structure.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/a.out.h linux-2.6.32.60-pax/include/linux/a.out.h
--- linux-2.6.32.60/include/linux/a.out.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/a.out.h	2012-03-13 13:15:35.476097972 +0100
@@ -39,6 +39,14 @@ enum machine_type {
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_PAX_PAGEEXEC	1	/* Paging based non-executable pages */
+#define F_PAX_EMUTRAMP	2	/* Emulate trampolines */
+#define F_PAX_MPROTECT	4	/* Restrict mprotect() */
+#define F_PAX_RANDMMAP	8	/* Randomize mmap() base */
+/*#define F_PAX_RANDEXEC	16*/	/* Randomize ET_EXEC base */
+#define F_PAX_SEGMEXEC	32	/* Segmentation based non-executable pages */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/atmdev.h linux-2.6.32.60-pax/include/linux/atmdev.h
--- linux-2.6.32.60/include/linux/atmdev.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/atmdev.h	2012-03-13 13:15:35.480097971 +0100
@@ -237,7 +237,7 @@ struct compat_atm_iobuf {
 #endif
 
 struct k_atm_aal_stats {
-#define __HANDLE_ITEM(i) atomic_t i
+#define __HANDLE_ITEM(i) atomic_unchecked_t i
 	__AAL_STAT_ITEMS
 #undef __HANDLE_ITEM
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/binfmts.h linux-2.6.32.60-pax/include/linux/binfmts.h
--- linux-2.6.32.60/include/linux/binfmts.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/binfmts.h	2012-03-13 13:15:35.480097971 +0100
@@ -83,6 +83,7 @@ struct linux_binfmt {
 	int (*load_binary)(struct linux_binprm *, struct  pt_regs * regs);
 	int (*load_shlib)(struct file *);
 	int (*core_dump)(long signr, struct pt_regs *regs, struct file *file, unsigned long limit);
+	void (*handle_mprotect)(struct vm_area_struct *vma, unsigned long newflags);
 	unsigned long min_coredump;	/* minimal dump size */
 	int hasvdso;
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/blkdev.h linux-2.6.32.60-pax/include/linux/blkdev.h
--- linux-2.6.32.60/include/linux/blkdev.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/blkdev.h	2012-03-13 13:15:35.480097971 +0100
@@ -1281,7 +1281,7 @@ struct block_device_operations {
 	int (*revalidate_disk) (struct gendisk *);
 	int (*getgeo)(struct block_device *, struct hd_geometry *);
 	struct module *owner;
-};
+} __do_const;
 
 extern int __blkdev_driver_ioctl(struct block_device *, fmode_t, unsigned int,
 				 unsigned long);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/blktrace_api.h linux-2.6.32.60-pax/include/linux/blktrace_api.h
--- linux-2.6.32.60/include/linux/blktrace_api.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/blktrace_api.h	2012-03-13 13:15:35.480097971 +0100
@@ -160,7 +160,7 @@ struct blk_trace {
 	struct dentry *dir;
 	struct dentry *dropped_file;
 	struct dentry *msg_file;
-	atomic_t dropped;
+	atomic_unchecked_t dropped;
 };
 
 extern int blk_trace_ioctl(struct block_device *, unsigned, char __user *);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/byteorder/little_endian.h linux-2.6.32.60-pax/include/linux/byteorder/little_endian.h
--- linux-2.6.32.60/include/linux/byteorder/little_endian.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/byteorder/little_endian.h	2012-03-13 13:15:35.484097971 +0100
@@ -42,51 +42,51 @@
 
 static inline __le64 __cpu_to_le64p(const __u64 *p)
 {
-	return (__force __le64)*p;
+	return (__force const __le64)*p;
 }
 static inline __u64 __le64_to_cpup(const __le64 *p)
 {
-	return (__force __u64)*p;
+	return (__force const __u64)*p;
 }
 static inline __le32 __cpu_to_le32p(const __u32 *p)
 {
-	return (__force __le32)*p;
+	return (__force const __le32)*p;
 }
 static inline __u32 __le32_to_cpup(const __le32 *p)
 {
-	return (__force __u32)*p;
+	return (__force const __u32)*p;
 }
 static inline __le16 __cpu_to_le16p(const __u16 *p)
 {
-	return (__force __le16)*p;
+	return (__force const __le16)*p;
 }
 static inline __u16 __le16_to_cpup(const __le16 *p)
 {
-	return (__force __u16)*p;
+	return (__force const __u16)*p;
 }
 static inline __be64 __cpu_to_be64p(const __u64 *p)
 {
-	return (__force __be64)__swab64p(p);
+	return (__force const __be64)__swab64p(p);
 }
 static inline __u64 __be64_to_cpup(const __be64 *p)
 {
-	return __swab64p((__u64 *)p);
+	return __swab64p((const __u64 *)p);
 }
 static inline __be32 __cpu_to_be32p(const __u32 *p)
 {
-	return (__force __be32)__swab32p(p);
+	return (__force const __be32)__swab32p(p);
 }
 static inline __u32 __be32_to_cpup(const __be32 *p)
 {
-	return __swab32p((__u32 *)p);
+	return __swab32p((const __u32 *)p);
 }
 static inline __be16 __cpu_to_be16p(const __u16 *p)
 {
-	return (__force __be16)__swab16p(p);
+	return (__force const __be16)__swab16p(p);
 }
 static inline __u16 __be16_to_cpup(const __be16 *p)
 {
-	return __swab16p((__u16 *)p);
+	return __swab16p((const __u16 *)p);
 }
 #define __cpu_to_le64s(x) do { (void)(x); } while (0)
 #define __le64_to_cpus(x) do { (void)(x); } while (0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/cache.h linux-2.6.32.60-pax/include/linux/cache.h
--- linux-2.6.32.60/include/linux/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/cache.h	2012-03-13 13:15:35.484097971 +0100
@@ -16,6 +16,10 @@
 #define __read_mostly
 #endif
 
+#ifndef __read_only
+#define __read_only __read_mostly
+#endif
+
 #ifndef ____cacheline_aligned
 #define ____cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES)))
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/cdrom.h linux-2.6.32.60-pax/include/linux/cdrom.h
--- linux-2.6.32.60/include/linux/cdrom.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/cdrom.h	2013-01-22 17:38:23.560543626 +0100
@@ -981,7 +981,6 @@ struct cdrom_device_ops {
 
 /* driver specifications */
 	const int capability;   /* capability flags */
-	int n_minors;           /* number of active minor devices */
 	/* handle uniform packets for scsi type devices (scsi,atapi) */
 	int (*generic_packet) (struct cdrom_device_info *,
 			       struct packet_command *);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/compiler-gcc4.h linux-2.6.32.60-pax/include/linux/compiler-gcc4.h
--- linux-2.6.32.60/include/linux/compiler-gcc4.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/compiler-gcc4.h	2012-09-11 21:13:32.852026118 +0200
@@ -14,6 +14,15 @@
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 #define __always_inline		inline __attribute__((always_inline))
 
+#ifdef SIZE_OVERFLOW_PLUGIN
+#define __size_overflow(...) __attribute__((size_overflow(__VA_ARGS__)))
+#define __intentional_overflow(...) __attribute__((intentional_overflow(__VA_ARGS__)))
+#endif
+
+#ifdef LATENT_ENTROPY_PLUGIN
+#define __latent_entropy __attribute__((latent_entropy))
+#endif
+
 /*
  * A trick to suppress uninitialized variable warning without generating any
  * code
@@ -36,4 +45,23 @@
    the kernel context */
 #define __cold			__attribute__((__cold__))
 
+#define __alloc_size(...)	__attribute((alloc_size(__VA_ARGS__)))
+#define __bos(ptr, arg)		__builtin_object_size((ptr), (arg))
+#define __bos0(ptr)		__bos((ptr), 0)
+#define __bos1(ptr)		__bos((ptr), 1)
+#endif
+
+#if __GNUC_MINOR__ >= 5
+#ifdef CONSTIFY_PLUGIN
+#define __no_const __attribute__((no_const))
+#define __do_const __attribute__((do_const))
+#endif
+#endif
+
+#if __GNUC_MINOR__ > 0
+#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+#endif
+#if __GNUC_MINOR__ >= 4 && !defined(__CHECKER__)
+#define __compiletime_warning(message) __attribute__((warning(message)))
+#define __compiletime_error(message) __attribute__((error(message)))
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/compiler.h linux-2.6.32.60-pax/include/linux/compiler.h
--- linux-2.6.32.60/include/linux/compiler.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/compiler.h	2012-09-11 21:06:16.476024746 +0200
@@ -5,11 +5,14 @@
 
 #ifdef __CHECKER__
 # define __user		__attribute__((noderef, address_space(1)))
+# define __force_user	__force __user
 # define __kernel	/* default address space */
+# define __force_kernel	__force __kernel
 # define __safe		__attribute__((safe))
 # define __force	__attribute__((force))
 # define __nocast	__attribute__((nocast))
 # define __iomem	__attribute__((noderef, address_space(2)))
+# define __force_iomem	__force __iomem
 # define __acquires(x)	__attribute__((context(x,0,1)))
 # define __releases(x)	__attribute__((context(x,1,0)))
 # define __acquire(x)	__context__(x,1)
@@ -17,13 +20,34 @@
 # define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
+#elif defined(CHECKER_PLUGIN)
+//# define __user
+//# define __force_user
+//# define __kernel
+//# define __force_kernel
+# define __safe
+# define __force
+# define __nocast
+# define __iomem
+# define __force_iomem
+# define __chk_user_ptr(x) (void)0
+# define __chk_io_ptr(x) (void)0
+# define __builtin_warning(x, y...) (1)
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+# define __cond_lock(x,c) (c)
 #else
 # define __user
+# define __force_user
 # define __kernel
+# define __force_kernel
 # define __safe
 # define __force
 # define __nocast
 # define __iomem
+# define __force_iomem
 # define __chk_user_ptr(x) (void)0
 # define __chk_io_ptr(x) (void)0
 # define __builtin_warning(x, y...) (1)
@@ -247,6 +271,26 @@ void ftrace_likely_update(struct ftrace_
 # define __attribute_const__	/* unimplemented */
 #endif
 
+#ifndef __no_const
+# define __no_const
+#endif
+
+#ifndef __do_const
+# define __do_const
+#endif
+
+#ifndef __size_overflow
+# define __size_overflow(...)
+#endif
+
+#ifndef __intentional_overflow
+# define __intentional_overflow(...)
+#endif
+
+#ifndef __latent_entropy
+# define __latent_entropy
+#endif
+
 /*
  * Tell gcc if a function is cold. The compiler will assume any path
  * directly leading to the call is unlikely.
@@ -256,6 +300,22 @@ void ftrace_likely_update(struct ftrace_
 #define __cold
 #endif
 
+#ifndef __alloc_size
+#define __alloc_size(...)
+#endif
+
+#ifndef __bos
+#define __bos(ptr, arg)
+#endif
+
+#ifndef __bos0
+#define __bos0(ptr)
+#endif
+
+#ifndef __bos1
+#define __bos1(ptr)
+#endif
+
 /* Simple shorthand for a section definition */
 #ifndef __section
 # define __section(S) __attribute__ ((__section__(#S)))
@@ -266,6 +326,19 @@ void ftrace_likely_update(struct ftrace_
 # define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
 #endif
 
+/* Compile time object size, -1 for unknown */
+#ifndef __compiletime_object_size
+# define __compiletime_object_size(obj) -1
+#endif
+#ifndef __compiletime_warning
+# define __compiletime_warning(message)
+#endif
+#ifndef __compiletime_error
+# define __compiletime_error(message)
+#endif
+#ifndef __linktime_error
+# define __linktime_error(message)
+#endif
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
@@ -278,6 +351,7 @@ void ftrace_likely_update(struct ftrace_
  * use is to mediate communication between process-level code and irq/NMI
  * handlers, all running on the same CPU.
  */
-#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
+#define ACCESS_ONCE(x) (*(volatile const typeof(x) *)&(x))
+#define ACCESS_ONCE_RW(x) (*(volatile typeof(x) *)&(x))
 
 #endif /* __LINUX_COMPILER_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/crypto.h linux-2.6.32.60-pax/include/linux/crypto.h
--- linux-2.6.32.60/include/linux/crypto.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/crypto.h	2012-03-13 13:15:35.484097971 +0100
@@ -394,7 +394,7 @@ struct cipher_tfm {
 	                  const u8 *key, unsigned int keylen);
 	void (*cit_encrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	void (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
-};
+} __no_const;
 
 struct hash_tfm {
 	int (*init)(struct hash_desc *desc);
@@ -415,13 +415,13 @@ struct compress_tfm {
 	int (*cot_decompress)(struct crypto_tfm *tfm,
 	                      const u8 *src, unsigned int slen,
 	                      u8 *dst, unsigned int *dlen);
-};
+} __no_const;
 
 struct rng_tfm {
 	int (*rng_gen_random)(struct crypto_rng *tfm, u8 *rdata,
 			      unsigned int dlen);
 	int (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);
-};
+} __no_const;
 
 #define crt_ablkcipher	crt_u.ablkcipher
 #define crt_aead	crt_u.aead
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/dcache.h linux-2.6.32.60-pax/include/linux/dcache.h
--- linux-2.6.32.60/include/linux/dcache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/dcache.h	2012-03-13 13:15:35.488097971 +0100
@@ -119,6 +119,8 @@ struct dentry {
 	unsigned char d_iname[DNAME_INLINE_LEN_MIN];	/* small names */
 };
 
+#define DNAME_INLINE_LEN (sizeof(struct dentry)-offsetof(struct dentry,d_iname))
+
 /*
  * dentry->d_lock spinlock nesting subclasses:
  *
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/decompress/mm.h linux-2.6.32.60-pax/include/linux/decompress/mm.h
--- linux-2.6.32.60/include/linux/decompress/mm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/decompress/mm.h	2012-03-13 13:15:35.488097971 +0100
@@ -78,7 +78,7 @@ static void free(void *where)
  * warnings when not needed (indeed large_malloc / large_free are not
  * needed by inflate */
 
-#define malloc(a) kmalloc(a, GFP_KERNEL)
+#define malloc(a) kmalloc((a), GFP_KERNEL)
 #define free(a) kfree(a)
 
 #define large_malloc(a) vmalloc(a)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/dmaengine.h linux-2.6.32.60-pax/include/linux/dmaengine.h
--- linux-2.6.32.60/include/linux/dmaengine.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/dmaengine.h	2012-09-11 20:58:31.536023288 +0200
@@ -625,9 +625,9 @@ struct dma_pinned_list {
 struct dma_pinned_list *dma_pin_iovec_pages(struct iovec *iov, size_t len);
 void dma_unpin_iovec_pages(struct dma_pinned_list* pinned_list);
 
-dma_cookie_t dma_memcpy_to_iovec(struct dma_chan *chan, struct iovec *iov,
+dma_cookie_t __intentional_overflow(0) dma_memcpy_to_iovec(struct dma_chan *chan, struct iovec *iov,
 	struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
-dma_cookie_t dma_memcpy_pg_to_iovec(struct dma_chan *chan, struct iovec *iov,
+dma_cookie_t __intentional_overflow(0) dma_memcpy_pg_to_iovec(struct dma_chan *chan, struct iovec *iov,
 	struct dma_pinned_list *pinned_list, struct page *page,
 	unsigned int offset, size_t len);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/dma-mapping.h linux-2.6.32.60-pax/include/linux/dma-mapping.h
--- linux-2.6.32.60/include/linux/dma-mapping.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/dma-mapping.h	2012-03-13 13:15:35.488097971 +0100
@@ -60,7 +60,7 @@ struct dma_map_ops {
 	int (*dma_supported)(struct device *dev, u64 mask);
 	int (*set_dma_mask)(struct device *dev, u64 mask);
 	int is_phys;
-};
+} __do_const;
 
 #define DMA_BIT_MASK(n)	(((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/dst.h linux-2.6.32.60-pax/include/linux/dst.h
--- linux-2.6.32.60/include/linux/dst.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/dst.h	2012-03-13 13:15:35.488097971 +0100
@@ -380,7 +380,7 @@ struct dst_node
 	struct thread_pool	*pool;
 
 	/* Transaction IDs live here */
-	atomic_long_t		gen;
+	atomic_long_unchecked_t	gen;
 
 	/*
 	 * How frequently and how many times transaction
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/elf.h linux-2.6.32.60-pax/include/linux/elf.h
--- linux-2.6.32.60/include/linux/elf.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/elf.h	2012-03-13 13:15:35.488097971 +0100
@@ -49,6 +49,17 @@ typedef __s64	Elf64_Sxword;
 #define PT_GNU_EH_FRAME		0x6474e550
 
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+#define PT_GNU_RELRO	(PT_LOOS + 0x474e552)
+
+#define PT_PAX_FLAGS	(PT_LOOS + 0x5041580)
+
+/* Constants for the e_flags field */
+#define EF_PAX_PAGEEXEC		1	/* Paging based non-executable pages */
+#define EF_PAX_EMUTRAMP		2	/* Emulate trampolines */
+#define EF_PAX_MPROTECT		4	/* Restrict mprotect() */
+#define EF_PAX_RANDMMAP		8	/* Randomize mmap() base */
+/*#define EF_PAX_RANDEXEC		16*/	/* Randomize ET_EXEC base */
+#define EF_PAX_SEGMEXEC		32	/* Segmentation based non-executable pages */
 
 /* These constants define the different elf file types */
 #define ET_NONE   0
@@ -84,6 +95,8 @@ typedef __s64	Elf64_Sxword;
 #define DT_DEBUG	21
 #define DT_TEXTREL	22
 #define DT_JMPREL	23
+#define DT_FLAGS	30
+  #define DF_TEXTREL  0x00000004
 #define DT_ENCODING	32
 #define OLD_DT_LOOS	0x60000000
 #define DT_LOOS		0x6000000d
@@ -230,6 +243,19 @@ typedef struct elf64_hdr {
 #define PF_W		0x2
 #define PF_X		0x1
 
+#define PF_PAGEEXEC	(1U << 4)	/* Enable  PAGEEXEC */
+#define PF_NOPAGEEXEC	(1U << 5)	/* Disable PAGEEXEC */
+#define PF_SEGMEXEC	(1U << 6)	/* Enable  SEGMEXEC */
+#define PF_NOSEGMEXEC	(1U << 7)	/* Disable SEGMEXEC */
+#define PF_MPROTECT	(1U << 8)	/* Enable  MPROTECT */
+#define PF_NOMPROTECT	(1U << 9)	/* Disable MPROTECT */
+/*#define PF_RANDEXEC	(1U << 10)*/	/* Enable  RANDEXEC */
+/*#define PF_NORANDEXEC	(1U << 11)*/	/* Disable RANDEXEC */
+#define PF_EMUTRAMP	(1U << 12)	/* Enable  EMUTRAMP */
+#define PF_NOEMUTRAMP	(1U << 13)	/* Disable EMUTRAMP */
+#define PF_RANDMMAP	(1U << 14)	/* Enable  RANDMMAP */
+#define PF_NORANDMMAP	(1U << 15)	/* Disable RANDMMAP */
+
 typedef struct elf32_phdr{
   Elf32_Word	p_type;
   Elf32_Off	p_offset;
@@ -322,6 +348,8 @@ typedef struct elf64_shdr {
 #define	EI_OSABI	7
 #define	EI_PAD		8
 
+#define	EI_PAX		14
+
 #define	ELFMAG0		0x7f		/* EI_MAG */
 #define	ELFMAG1		'E'
 #define	ELFMAG2		'L'
@@ -386,6 +414,7 @@ extern Elf32_Dyn _DYNAMIC [];
 #define elf_phdr	elf32_phdr
 #define elf_note	elf32_note
 #define elf_addr_t	Elf32_Off
+#define elf_dyn		Elf32_Dyn
 
 #else
 
@@ -394,6 +423,7 @@ extern Elf64_Dyn _DYNAMIC [];
 #define elf_phdr	elf64_phdr
 #define elf_note	elf64_note
 #define elf_addr_t	Elf64_Off
+#define elf_dyn		Elf64_Dyn
 
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/fscache-cache.h linux-2.6.32.60-pax/include/linux/fscache-cache.h
--- linux-2.6.32.60/include/linux/fscache-cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/fscache-cache.h	2012-03-13 13:15:35.492097971 +0100
@@ -116,7 +116,7 @@ struct fscache_operation {
 #endif
 };
 
-extern atomic_t fscache_op_debug_id;
+extern atomic_unchecked_t fscache_op_debug_id;
 extern const struct slow_work_ops fscache_op_slow_work_ops;
 
 extern void fscache_enqueue_operation(struct fscache_operation *);
@@ -134,7 +134,7 @@ static inline void fscache_operation_ini
 					  fscache_operation_release_t release)
 {
 	atomic_set(&op->usage, 1);
-	op->debug_id = atomic_inc_return(&fscache_op_debug_id);
+	op->debug_id = atomic_inc_return_unchecked(&fscache_op_debug_id);
 	op->release = release;
 	INIT_LIST_HEAD(&op->pend_link);
 	fscache_set_op_state(op, "Init");
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/fs.h linux-2.6.32.60-pax/include/linux/fs.h
--- linux-2.6.32.60/include/linux/fs.h	2012-10-09 11:00:35.488882477 +0200
+++ linux-2.6.32.60-pax/include/linux/fs.h	2012-10-09 11:00:39.344883051 +0200
@@ -1443,7 +1443,7 @@ struct fiemap_extent_info {
 	unsigned int fi_flags;		/* Flags as passed from user */
 	unsigned int fi_extents_mapped;	/* Number of mapped extents */
 	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
-	struct fiemap_extent *fi_extents_start; /* Start of fiemap_extent
+	struct fiemap_extent __user *fi_extents_start; /* Start of fiemap_extent
 						 * array */
 };
 int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
@@ -1513,7 +1513,8 @@ struct file_operations {
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 	int (*setlease)(struct file *, long, struct file_lock **);
-};
+} __do_const;
+typedef struct file_operations __no_const file_operations_no_const;
 
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/fs_struct.h linux-2.6.32.60-pax/include/linux/fs_struct.h
--- linux-2.6.32.60/include/linux/fs_struct.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/fs_struct.h	2012-03-13 13:15:35.492097971 +0100
@@ -4,7 +4,7 @@
 #include <linux/path.h>
 
 struct fs_struct {
-	int users;
+	atomic_t users;
 	rwlock_t lock;
 	int umask;
 	int in_exec;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/ftrace_event.h linux-2.6.32.60-pax/include/linux/ftrace_event.h
--- linux-2.6.32.60/include/linux/ftrace_event.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/ftrace_event.h	2012-03-13 13:15:35.496097971 +0100
@@ -163,7 +163,7 @@ extern int trace_define_field(struct ftr
 			      int filter_type);
 extern int trace_define_common_fields(struct ftrace_event_call *call);
 
-#define is_signed_type(type)	(((type)(-1)) < 0)
+#define is_signed_type(type)	(((type)(-1)) < (type)1)
 
 int trace_set_clr_event(const char *system, const char *event, int set);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/genhd.h linux-2.6.32.60-pax/include/linux/genhd.h
--- linux-2.6.32.60/include/linux/genhd.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/genhd.h	2012-03-13 13:15:35.496097971 +0100
@@ -161,7 +161,7 @@ struct gendisk {
 
 	struct timer_rand_state *random;
 
-	atomic_t sync_io;		/* RAID */
+	atomic_unchecked_t sync_io;	/* RAID */
 	struct work_struct async_notify;
 #ifdef  CONFIG_BLK_DEV_INTEGRITY
 	struct blk_integrity *integrity;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/gfp.h linux-2.6.32.60-pax/include/linux/gfp.h
--- linux-2.6.32.60/include/linux/gfp.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/gfp.h	2012-07-27 21:58:45.738355395 +0200
@@ -53,6 +53,12 @@ struct vm_area_struct;
 #define __GFP_THISNODE	((__force gfp_t)0x40000u)/* No fallback, no policies */
 #define __GFP_RECLAIMABLE ((__force gfp_t)0x80000u) /* Page is reclaimable */
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+#define __GFP_USERCOPY	((__force gfp_t)0x1000000u)
+#else
+#define __GFP_USERCOPY	((__force gfp_t)0)
+#endif
+
 #ifdef CONFIG_KMEMCHECK
 #define __GFP_NOTRACK	((__force gfp_t)0x200000u)  /* Don't track with kmemcheck */
 #else
@@ -65,7 +71,7 @@ struct vm_area_struct;
  */
 #define __GFP_NOTRACK_FALSE_POSITIVE (__GFP_NOTRACK)
 
-#define __GFP_BITS_SHIFT 22	/* Room for 22 __GFP_FOO bits */
+#define __GFP_BITS_SHIFT 26	/* Room for 26 __GFP_FOO bits */
 #define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
 
 /* This equals 0, but use constants in case they ever change */
@@ -115,6 +121,8 @@ struct vm_area_struct;
 /* 4GB DMA on some platforms */
 #define GFP_DMA32	__GFP_DMA32
 
+#define GFP_USERCOPY	__GFP_USERCOPY
+
 /* Convert GFP flags to their corresponding migrate type */
 static inline int allocflags_to_migratetype(gfp_t gfp_flags)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/hdpu_features.h linux-2.6.32.60-pax/include/linux/hdpu_features.h
--- linux-2.6.32.60/include/linux/hdpu_features.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/hdpu_features.h	2012-03-13 13:15:35.496097971 +0100
@@ -3,7 +3,7 @@
 struct cpustate_t {
 	spinlock_t lock;
 	int excl;
-        int open_count;
+	atomic_t open_count;
 	unsigned char cached_val;
 	int inited;
 	unsigned long *set_addr;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/highmem.h linux-2.6.32.60-pax/include/linux/highmem.h
--- linux-2.6.32.60/include/linux/highmem.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/highmem.h	2012-03-13 13:15:35.496097971 +0100
@@ -137,6 +137,18 @@ static inline void clear_highpage(struct
 	kunmap_atomic(kaddr, KM_USER0);
 }
 
+static inline void sanitize_highpage(struct page *page)
+{
+	void *kaddr;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	kaddr = kmap_atomic(page, KM_CLEARPAGE);
+	clear_page(kaddr);
+	kunmap_atomic(kaddr, KM_CLEARPAGE);
+	local_irq_restore(flags);
+}
+
 static inline void zero_user_segments(struct page *page,
 	unsigned start1, unsigned end1,
 	unsigned start2, unsigned end2)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/i2c.h linux-2.6.32.60-pax/include/linux/i2c.h
--- linux-2.6.32.60/include/linux/i2c.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/i2c.h	2012-03-13 13:15:35.500097970 +0100
@@ -325,6 +325,7 @@ struct i2c_algorithm {
 	/* To determine what the adapter supports */
 	u32 (*functionality) (struct i2c_adapter *);
 };
+typedef struct i2c_algorithm __no_const i2c_algorithm_no_const;
 
 /*
  * i2c_adapter is the structure used to identify a physical i2c bus along
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/i2o.h linux-2.6.32.60-pax/include/linux/i2o.h
--- linux-2.6.32.60/include/linux/i2o.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/i2o.h	2012-03-13 13:15:35.500097970 +0100
@@ -564,7 +564,7 @@ struct i2o_controller {
 	struct i2o_device *exec;	/* Executive */
 #if BITS_PER_LONG == 64
 	spinlock_t context_list_lock;	/* lock for context_list */
-	atomic_t context_list_counter;	/* needed for unique contexts */
+	atomic_unchecked_t context_list_counter;	/* needed for unique contexts */
 	struct list_head context_list;	/* list of context id's
 					   and pointers */
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/if_pppox.h linux-2.6.32.60-pax/include/linux/if_pppox.h
--- linux-2.6.32.60/include/linux/if_pppox.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/if_pppox.h	2013-01-22 17:35:22.792553278 +0100
@@ -175,7 +175,7 @@ struct pppox_proto {
 	int		(*ioctl)(struct socket *sock, unsigned int cmd,
 				 unsigned long arg);
 	struct module	*owner;
-};
+} __do_const;
 
 extern int register_pppox_proto(int proto_num, struct pppox_proto *pp);
 extern void unregister_pppox_proto(int proto_num);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/init.h linux-2.6.32.60-pax/include/linux/init.h
--- linux-2.6.32.60/include/linux/init.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/init.h	2012-11-27 15:00:39.163946536 +0100
@@ -38,9 +38,36 @@
  * Also note, that this data cannot be "const".
  */
 
+#ifdef MODULE
+#define add_init_latent_entropy
+#define add_devinit_latent_entropy
+#define add_cpuinit_latent_entropy
+#define add_meminit_latent_entropy
+#else
+#define add_init_latent_entropy __latent_entropy
+
+#ifdef CONFIG_HOTPLUG
+#define add_devinit_latent_entropy
+#else
+#define add_devinit_latent_entropy __latent_entropy
+#endif
+
+#ifdef CONFIG_HOTPLUG_CPU
+#define add_cpuinit_latent_entropy
+#else
+#define add_cpuinit_latent_entropy __latent_entropy
+#endif
+
+#ifdef CONFIG_MEMORY_HOTPLUG
+#define add_meminit_latent_entropy
+#else
+#define add_meminit_latent_entropy __latent_entropy
+#endif
+#endif
+
 /* These are for everybody (although not all archs will actually
    discard it in modules) */
-#define __init		__section(.init.text) __cold notrace
+#define __init		__section(.init.text) __cold notrace add_init_latent_entropy
 #define __initdata	__section(.init.data)
 #define __initconst	__section(.init.rodata)
 #define __exitdata	__section(.exit.data)
@@ -75,7 +102,7 @@
 #define __exit          __section(.exit.text) __exitused __cold
 
 /* Used for HOTPLUG */
-#define __devinit        __section(.devinit.text) __cold
+#define __devinit        __section(.devinit.text) __cold add_devinit_latent_entropy
 #define __devinitdata    __section(.devinit.data)
 #define __devinitconst   __section(.devinit.rodata)
 #define __devexit        __section(.devexit.text) __exitused __cold
@@ -83,7 +110,7 @@
 #define __devexitconst   __section(.devexit.rodata)
 
 /* Used for HOTPLUG_CPU */
-#define __cpuinit        __section(.cpuinit.text) __cold
+#define __cpuinit        __section(.cpuinit.text) __cold add_cpuinit_latent_entropy
 #define __cpuinitdata    __section(.cpuinit.data)
 #define __cpuinitconst   __section(.cpuinit.rodata)
 #define __cpuexit        __section(.cpuexit.text) __exitused __cold
@@ -91,7 +118,7 @@
 #define __cpuexitconst   __section(.cpuexit.rodata)
 
 /* Used for MEMORY_HOTPLUG */
-#define __meminit        __section(.meminit.text) __cold
+#define __meminit        __section(.meminit.text) __cold add_meminit_latent_entropy
 #define __meminitdata    __section(.meminit.data)
 #define __meminitconst   __section(.meminit.rodata)
 #define __memexit        __section(.memexit.text) __exitused __cold
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/init_task.h linux-2.6.32.60-pax/include/linux/init_task.h
--- linux-2.6.32.60/include/linux/init_task.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/init_task.h	2012-03-13 13:15:35.500097970 +0100
@@ -83,6 +83,12 @@ extern struct group_info init_groups;
 #define INIT_IDS
 #endif
 
+#ifdef CONFIG_X86
+#define INIT_TASK_THREAD_INFO .tinfo = INIT_THREAD_INFO,
+#else
+#define INIT_TASK_THREAD_INFO
+#endif
+
 #ifdef CONFIG_SECURITY_FILE_CAPABILITIES
 /*
  * Because of the reduced scope of CAP_SETPCAP when filesystem
@@ -156,6 +162,7 @@ extern struct cred init_cred;
 		 __MUTEX_INITIALIZER(tsk.cred_guard_mutex),		\
 	.comm		= "swapper",					\
 	.thread		= INIT_THREAD,					\
+	INIT_TASK_THREAD_INFO						\
 	.fs		= &init_fs,					\
 	.files		= &init_files,					\
 	.signal		= &init_signals,				\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/interrupt.h linux-2.6.32.60-pax/include/linux/interrupt.h
--- linux-2.6.32.60/include/linux/interrupt.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/interrupt.h	2013-02-17 19:42:31.739699545 +0100
@@ -369,7 +369,7 @@ enum
 /* map softirq index to softirq name. update 'softirq_to_name' in
  * kernel/softirq.c when adding a new softirq.
  */
-extern char *softirq_to_name[NR_SOFTIRQS];
+extern const char * const softirq_to_name[NR_SOFTIRQS];
 
 /* softirq mask and active fields moved to irq_cpustat_t in
  * asm/hardirq.h to get better cache usage.  KAO
@@ -377,12 +377,12 @@ extern char *softirq_to_name[NR_SOFTIRQS
 
 struct softirq_action
 {
-	void	(*action)(struct softirq_action *);
-};
+	void	(*action)(void);
+} __no_const;
 
 asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
-extern void open_softirq(int nr, void (*action)(struct softirq_action *));
+extern void open_softirq(int nr, void (*action)(void));
 extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
 extern void raise_softirq_irqoff(unsigned int nr);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/irq.h linux-2.6.32.60-pax/include/linux/irq.h
--- linux-2.6.32.60/include/linux/irq.h	2012-10-09 11:00:35.492882478 +0200
+++ linux-2.6.32.60-pax/include/linux/irq.h	2012-10-09 11:00:39.348883053 +0200
@@ -437,12 +437,12 @@ extern int set_irq_msi(unsigned int irq,
 static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
 							bool boot)
 {
+#ifdef CONFIG_CPUMASK_OFFSTACK
 	gfp_t gfp = GFP_ATOMIC;
 
 	if (boot)
 		gfp = GFP_NOWAIT;
 
-#ifdef CONFIG_CPUMASK_OFFSTACK
 	if (!alloc_cpumask_var_node(&desc->affinity, gfp, node))
 		return false;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/kgdb.h linux-2.6.32.60-pax/include/linux/kgdb.h
--- linux-2.6.32.60/include/linux/kgdb.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/kgdb.h	2012-03-13 13:15:35.504097970 +0100
@@ -74,8 +74,8 @@ void kgdb_breakpoint(void);
 
 extern int kgdb_connected;
 
-extern atomic_t			kgdb_setting_breakpoint;
-extern atomic_t			kgdb_cpu_doing_single_step;
+extern atomic_unchecked_t	kgdb_setting_breakpoint;
+extern atomic_unchecked_t	kgdb_cpu_doing_single_step;
 
 extern struct task_struct	*kgdb_usethread;
 extern struct task_struct	*kgdb_contthread;
@@ -235,7 +235,7 @@ struct kgdb_arch {
 	int	(*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
 	void	(*remove_all_hw_break)(void);
 	void	(*correct_hw_break)(void);
-};
+} __do_const;
 
 /**
  * struct kgdb_io - Describe the interface for an I/O driver to talk with KGDB.
@@ -257,7 +257,7 @@ struct kgdb_io {
 	int			(*init) (void);
 	void			(*pre_exception) (void);
 	void			(*post_exception) (void);
-};
+} __do_const;
 
 extern struct kgdb_arch		arch_kgdb_ops;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/kobject.h linux-2.6.32.60-pax/include/linux/kobject.h
--- linux-2.6.32.60/include/linux/kobject.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/kobject.h	2013-01-22 17:43:29.912527269 +0100
@@ -108,7 +108,7 @@ struct kobj_type {
 	void (*release)(struct kobject *kobj);
 	struct sysfs_ops *sysfs_ops;
 	struct attribute **default_attrs;
-};
+} __do_const;
 
 struct kobj_uevent_env {
 	char *envp[UEVENT_NUM_ENVP];
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/kvm_host.h linux-2.6.32.60-pax/include/linux/kvm_host.h
--- linux-2.6.32.60/include/linux/kvm_host.h	2012-10-09 11:00:35.492882478 +0200
+++ linux-2.6.32.60-pax/include/linux/kvm_host.h	2012-10-09 11:00:39.348883053 +0200
@@ -210,7 +210,7 @@ void kvm_vcpu_uninit(struct kvm_vcpu *vc
 void vcpu_load(struct kvm_vcpu *vcpu);
 void vcpu_put(struct kvm_vcpu *vcpu);
 
-int kvm_init(void *opaque, unsigned int vcpu_size,
+int kvm_init(const void *opaque, unsigned int vcpu_size,
 		  struct module *module);
 void kvm_exit(void);
 
@@ -316,7 +316,7 @@ int kvm_arch_vcpu_ioctl_set_guest_debug(
 					struct kvm_guest_debug *dbg);
 int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run);
 
-int kvm_arch_init(void *opaque);
+int kvm_arch_init(const void *opaque);
 void kvm_arch_exit(void);
 
 int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/libata.h linux-2.6.32.60-pax/include/linux/libata.h
--- linux-2.6.32.60/include/linux/libata.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/libata.h	2012-03-13 13:15:35.508097970 +0100
@@ -884,7 +884,7 @@ struct ata_port_operations {
 	 * fields must be pointers.
 	 */
 	const struct ata_port_operations	*inherits;
-};
+} __do_const;
 
 struct ata_port_info {
 	unsigned long		flags;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/list.h linux-2.6.32.60-pax/include/linux/list.h
--- linux-2.6.32.60/include/linux/list.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/list.h	2013-01-22 17:38:23.572543625 +0100
@@ -110,6 +110,9 @@ static inline void list_del(struct list_
 extern void list_del(struct list_head *entry);
 #endif
 
+extern void pax_list_add_tail(struct list_head *new, struct list_head *head);
+extern void pax_list_del(struct list_head *entry);
+
 /**
  * list_replace - replace old entry by new one
  * @old : the element to be replaced
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mca.h linux-2.6.32.60-pax/include/linux/mca.h
--- linux-2.6.32.60/include/linux/mca.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mca.h	2012-03-13 13:15:35.508097970 +0100
@@ -80,7 +80,7 @@ struct mca_bus_accessor_functions {
 						  int region);
 	void *		(*mca_transform_memory)(struct mca_device *,
 						void *memory);
-};
+} __no_const;
 
 struct mca_bus {
 	u64			default_dma_mask;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mm.h linux-2.6.32.60-pax/include/linux/mm.h
--- linux-2.6.32.60/include/linux/mm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mm.h	2012-05-07 17:52:29.584104073 +0200
@@ -106,7 +106,14 @@ extern unsigned int kobjsize(const void
 
 #define VM_CAN_NONLINEAR 0x08000000	/* Has ->fault & does nonlinear pages */
 #define VM_MIXEDMAP	0x10000000	/* Can contain "struct page" and pure PFN pages */
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+#define VM_SAO		0x00000000	/* Strong Access Ordering (powerpc) */
+#define VM_PAGEEXEC	0x20000000	/* vma->vm_page_prot needs special handling */
+#else
 #define VM_SAO		0x20000000	/* Strong Access Ordering (powerpc) */
+#endif
+
 #define VM_PFN_AT_MMAP	0x40000000	/* PFNMAP vma that is fully mapped at mmap time */
 #define VM_MERGEABLE	0x80000000	/* KSM may merge identical pages */
 
@@ -841,12 +848,6 @@ int set_page_dirty(struct page *page);
 int set_page_dirty_lock(struct page *page);
 int clear_page_dirty_for_io(struct page *page);
 
-/* Is the vma a continuation of the stack vma above it? */
-static inline int vma_stack_continue(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);
-}
-
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
 		unsigned long old_addr, struct vm_area_struct *new_vma,
 		unsigned long new_addr, unsigned long len);
@@ -890,6 +891,8 @@ struct shrinker {
 extern void register_shrinker(struct shrinker *);
 extern void unregister_shrinker(struct shrinker *);
 
+pgprot_t vm_get_page_prot(unsigned long vm_flags);
+
 int vma_wants_writenotify(struct vm_area_struct *vma);
 
 extern pte_t *get_locked_pte(struct mm_struct *mm, unsigned long addr, spinlock_t **ptl);
@@ -900,8 +903,15 @@ static inline int __pud_alloc(struct mm_
 {
 	return 0;
 }
+
+static inline int __pud_alloc_kernel(struct mm_struct *mm, pgd_t *pgd,
+						unsigned long address)
+{
+	return 0;
+}
 #else
 int __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address);
+int __pud_alloc_kernel(struct mm_struct *mm, pgd_t *pgd, unsigned long address);
 #endif
 
 #ifdef __PAGETABLE_PMD_FOLDED
@@ -910,8 +920,15 @@ static inline int __pmd_alloc(struct mm_
 {
 	return 0;
 }
+
+static inline int __pmd_alloc_kernel(struct mm_struct *mm, pud_t *pud,
+						unsigned long address)
+{
+	return 0;
+}
 #else
 int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address);
+int __pmd_alloc_kernel(struct mm_struct *mm, pud_t *pud, unsigned long address);
 #endif
 
 int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address);
@@ -928,11 +945,23 @@ static inline pud_t *pud_alloc(struct mm
 		NULL: pud_offset(pgd, address);
 }
 
+static inline pud_t *pud_alloc_kernel(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
+{
+	return (unlikely(pgd_none(*pgd)) && __pud_alloc_kernel(mm, pgd, address))?
+		NULL: pud_offset(pgd, address);
+}
+
 static inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
 {
 	return (unlikely(pud_none(*pud)) && __pmd_alloc(mm, pud, address))?
 		NULL: pmd_offset(pud, address);
 }
+
+static inline pmd_t *pmd_alloc_kernel(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+	return (unlikely(pud_none(*pud)) && __pmd_alloc_kernel(mm, pud, address))?
+		NULL: pmd_offset(pud, address);
+}
 #endif /* CONFIG_MMU && !__ARCH_HAS_4LEVEL_HACK */
 
 #if USE_SPLIT_PTLOCKS
@@ -1162,6 +1191,7 @@ out:
 }
 
 extern int do_munmap(struct mm_struct *, unsigned long, size_t);
+extern int __do_munmap(struct mm_struct *, unsigned long, size_t);
 
 extern unsigned long do_brk(unsigned long, unsigned long);
 
@@ -1218,6 +1248,10 @@ extern struct vm_area_struct * find_vma(
 extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
 					     struct vm_area_struct **pprev);
 
+extern struct vm_area_struct *pax_find_mirror_vma(struct vm_area_struct *vma);
+extern void pax_mirror_vma(struct vm_area_struct *vma_m, struct vm_area_struct *vma);
+extern void pax_mirror_file_pte(struct vm_area_struct *vma, unsigned long address, struct page *page_m, spinlock_t *ptl);
+
 /* Look up the first VMA which intersects the interval start_addr..end_addr-1,
    NULL if none.  Assume start_addr < end_addr. */
 static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
@@ -1234,7 +1268,6 @@ static inline unsigned long vma_pages(st
 	return (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 }
 
-pgprot_t vm_get_page_prot(unsigned long vm_flags);
 struct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);
 int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
 			unsigned long pfn, unsigned long size, pgprot_t);
@@ -1332,7 +1365,13 @@ extern void memory_failure(unsigned long
 extern int __memory_failure(unsigned long pfn, int trapno, int ref);
 extern int sysctl_memory_failure_early_kill;
 extern int sysctl_memory_failure_recovery;
-extern atomic_long_t mce_bad_pages;
+extern atomic_long_unchecked_t mce_bad_pages;
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+extern void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot);
+#else
+static inline void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot) {}
+#endif
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mmiotrace.h linux-2.6.32.60-pax/include/linux/mmiotrace.h
--- linux-2.6.32.60/include/linux/mmiotrace.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mmiotrace.h	2013-01-22 17:38:23.576543625 +0100
@@ -46,7 +46,7 @@ extern int kmmio_handler(struct pt_regs
 /* Called from ioremap.c */
 extern void mmiotrace_ioremap(resource_size_t offset, unsigned long size,
 							void __iomem *addr);
-extern void mmiotrace_iounmap(volatile void __iomem *addr);
+extern void mmiotrace_iounmap(const volatile void __iomem *addr);
 
 /* For anyone to insert markers. Remember trailing newline. */
 extern int mmiotrace_printk(const char *fmt, ...)
@@ -67,7 +67,7 @@ static inline void mmiotrace_ioremap(res
 {
 }
 
-static inline void mmiotrace_iounmap(volatile void __iomem *addr)
+static inline void mmiotrace_iounmap(const volatile void __iomem *addr)
 {
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mm_types.h linux-2.6.32.60-pax/include/linux/mm_types.h
--- linux-2.6.32.60/include/linux/mm_types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mm_types.h	2012-08-07 02:04:15.784572711 +0200
@@ -186,6 +186,8 @@ struct vm_area_struct {
 #ifdef CONFIG_NUMA
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
+
+	struct vm_area_struct *vm_mirror;/* PaX: mirror vma or NULL */
 };
 
 struct core_thread {
@@ -235,7 +237,7 @@ struct mm_struct {
 	unsigned long total_vm, locked_vm, shared_vm, exec_vm;
 	unsigned long stack_vm, reserved_vm, def_flags, nr_ptes;
 	unsigned long start_code, end_code, start_data, end_data;
-	unsigned long start_brk, brk, start_stack;
+	unsigned long brk_gap, start_brk, brk, start_stack;
 	unsigned long arg_start, arg_end, env_start, env_end;
 
 	unsigned long saved_auxv[AT_VECTOR_SIZE]; /* for /proc/PID/auxv */
@@ -287,6 +289,24 @@ struct mm_struct {
 #ifdef CONFIG_MMU_NOTIFIER
 	struct mmu_notifier_mm *mmu_notifier_mm;
 #endif
+
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+	unsigned long pax_flags;
+#endif
+
+#ifdef CONFIG_PAX_DLRESOLVE
+	unsigned long call_dl_resolve;
+#endif
+
+#if defined(CONFIG_PPC32) && defined(CONFIG_PAX_EMUSIGRT)
+	unsigned long call_syscall;
+#endif
+
+#ifdef CONFIG_PAX_ASLR
+	unsigned long delta_mmap;		/* randomized offset */
+	unsigned long delta_stack;		/* randomized offset */
+#endif
+
 };
 
 /* Future-safe accessor for struct mm_struct's cpu_vm_mask. */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mmu_notifier.h linux-2.6.32.60-pax/include/linux/mmu_notifier.h
--- linux-2.6.32.60/include/linux/mmu_notifier.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mmu_notifier.h	2012-03-13 13:15:35.512097970 +0100
@@ -235,12 +235,12 @@ static inline void mmu_notifier_mm_destr
  */
 #define ptep_clear_flush_notify(__vma, __address, __ptep)		\
 ({									\
-	pte_t __pte;							\
+	pte_t ___pte;							\
 	struct vm_area_struct *___vma = __vma;				\
 	unsigned long ___address = __address;				\
-	__pte = ptep_clear_flush(___vma, ___address, __ptep);		\
+	___pte = ptep_clear_flush(___vma, ___address, __ptep);		\
 	mmu_notifier_invalidate_page(___vma->vm_mm, ___address);	\
-	__pte;								\
+	___pte;								\
 })
 
 #define ptep_clear_flush_young_notify(__vma, __address, __ptep)		\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mmzone.h linux-2.6.32.60-pax/include/linux/mmzone.h
--- linux-2.6.32.60/include/linux/mmzone.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mmzone.h	2012-03-13 13:15:35.512097970 +0100
@@ -350,7 +350,7 @@ struct zone {
 	unsigned long		flags;		   /* zone flags, see below */
 
 	/* Zone statistics */
-	atomic_long_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
+	atomic_long_unchecked_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
 
 	/*
 	 * prev_priority holds the scanning priority for this zone.  It is
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mod_devicetable.h linux-2.6.32.60-pax/include/linux/mod_devicetable.h
--- linux-2.6.32.60/include/linux/mod_devicetable.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mod_devicetable.h	2012-03-13 13:15:35.512097970 +0100
@@ -12,7 +12,7 @@
 typedef unsigned long kernel_ulong_t;
 #endif
 
-#define PCI_ANY_ID (~0)
+#define PCI_ANY_ID ((__u16)~0)
 
 struct pci_device_id {
 	__u32 vendor, device;		/* Vendor and device ID or PCI_ANY_ID*/
@@ -131,7 +131,7 @@ struct usb_device_id {
 #define USB_DEVICE_ID_MATCH_INT_SUBCLASS	0x0100
 #define USB_DEVICE_ID_MATCH_INT_PROTOCOL	0x0200
 
-#define HID_ANY_ID				(~0)
+#define HID_ANY_ID				(~0U)
 
 struct hid_device_id {
 	__u16 bus;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/module.h linux-2.6.32.60-pax/include/linux/module.h
--- linux-2.6.32.60/include/linux/module.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/module.h	2013-01-22 17:31:45.544564877 +0100
@@ -16,9 +16,11 @@
 #include <linux/kobject.h>
 #include <linux/moduleparam.h>
 #include <linux/tracepoint.h>
+#include <linux/fs.h>
 
 #include <asm/local.h>
 #include <asm/module.h>
+#include <asm/pgtable.h>
 
 #include <trace/events/module.h>
 
@@ -287,16 +289,16 @@ struct module
 	int (*init)(void);
 
 	/* If this is non-NULL, vfree after init() returns */
-	void *module_init;
+	void *module_init_rx, *module_init_rw;
 
 	/* Here is the actual code + data, vfree'd on unload. */
-	void *module_core;
+	void *module_core_rx, *module_core_rw;
 
 	/* Here are the sizes of the init and core sections */
-	unsigned int init_size, core_size;
+	unsigned int init_size_rw, core_size_rw;
 
 	/* The size of the executable code in each section.  */
-	unsigned int init_text_size, core_text_size;
+	unsigned int init_size_rx, core_size_rx;
 
 	/* Arch-specific module values */
 	struct mod_arch_specific arch;
@@ -345,6 +347,10 @@ struct module
 #ifdef CONFIG_EVENT_TRACING
 	struct ftrace_event_call *trace_events;
 	unsigned int num_trace_events;
+	struct file_operations trace_id;
+	struct file_operations trace_enable;
+	struct file_operations trace_format;
+	struct file_operations trace_filter;
 #endif
 #ifdef CONFIG_FTRACE_MCOUNT_RECORD
 	unsigned long *ftrace_callsites;
@@ -393,16 +399,46 @@ struct module *__module_address(unsigned
 bool is_module_address(unsigned long addr);
 bool is_module_text_address(unsigned long addr);
 
+static inline int within_module_range(unsigned long addr, void *start, unsigned long size)
+{
+
+#ifdef CONFIG_PAX_KERNEXEC
+	if (ktla_ktva(addr) >= (unsigned long)start &&
+	    ktla_ktva(addr) < (unsigned long)start + size)
+		return 1;
+#endif
+
+	return ((void *)addr >= start && (void *)addr < start + size);
+}
+
+static inline int within_module_core_rx(unsigned long addr, struct module *mod)
+{
+	return within_module_range(addr, mod->module_core_rx, mod->core_size_rx);
+}
+
+static inline int within_module_core_rw(unsigned long addr, struct module *mod)
+{
+	return within_module_range(addr, mod->module_core_rw, mod->core_size_rw);
+}
+
+static inline int within_module_init_rx(unsigned long addr, struct module *mod)
+{
+	return within_module_range(addr, mod->module_init_rx, mod->init_size_rx);
+}
+
+static inline int within_module_init_rw(unsigned long addr, struct module *mod)
+{
+	return within_module_range(addr, mod->module_init_rw, mod->init_size_rw);
+}
+
 static inline int within_module_core(unsigned long addr, struct module *mod)
 {
-	return (unsigned long)mod->module_core <= addr &&
-	       addr < (unsigned long)mod->module_core + mod->core_size;
+	return within_module_core_rx(addr, mod) || within_module_core_rw(addr, mod);
 }
 
 static inline int within_module_init(unsigned long addr, struct module *mod)
 {
-	return (unsigned long)mod->module_init <= addr &&
-	       addr < (unsigned long)mod->module_init + mod->init_size;
+	return within_module_init_rx(addr, mod) || within_module_init_rw(addr, mod);
 }
 
 /* Search for module by name: must hold module_mutex. */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/moduleloader.h linux-2.6.32.60-pax/include/linux/moduleloader.h
--- linux-2.6.32.60/include/linux/moduleloader.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/moduleloader.h	2012-05-20 19:23:24.201173776 +0200
@@ -20,9 +20,21 @@ unsigned int arch_mod_section_prepend(st
    sections.  Returns NULL on failure. */
 void *module_alloc(unsigned long size);
 
+#ifdef CONFIG_PAX_KERNEXEC
+void *module_alloc_exec(unsigned long size) __size_overflow(1);
+#else
+#define module_alloc_exec(x) module_alloc(x)
+#endif
+
 /* Free memory returned from module_alloc. */
 void module_free(struct module *mod, void *module_region);
 
+#ifdef CONFIG_PAX_KERNEXEC
+void module_free_exec(struct module *mod, void *module_region);
+#else
+#define module_free_exec(x, y) module_free((x), (y))
+#endif
+
 /* Apply the given relocation to the (simplified) ELF.  Return -error
    or 0. */
 int apply_relocate(Elf_Shdr *sechdrs,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/moduleparam.h linux-2.6.32.60-pax/include/linux/moduleparam.h
--- linux-2.6.32.60/include/linux/moduleparam.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/moduleparam.h	2012-03-13 13:15:35.516097970 +0100
@@ -132,7 +132,7 @@ struct kparam_array
 
 /* Actually copy string: maxlen param is usually sizeof(string). */
 #define module_param_string(name, string, len, perm)			\
-	static const struct kparam_string __param_string_##name		\
+	static const struct kparam_string __param_string_##name __used	\
 		= { len, string };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
 			    param_set_copystring, param_get_string,	\
@@ -211,7 +211,7 @@ extern int param_get_invbool(char *buffe
 
 /* Comma-separated array: *nump is set to number they actually specified. */
 #define module_param_array_named(name, array, type, nump, perm)		\
-	static const struct kparam_array __param_arr_##name		\
+	static const struct kparam_array __param_arr_##name __used	\
 	= { ARRAY_SIZE(array), nump, param_set_##type, param_get_##type,\
 	    sizeof(array[0]), array };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/mutex.h linux-2.6.32.60-pax/include/linux/mutex.h
--- linux-2.6.32.60/include/linux/mutex.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/mutex.h	2012-03-13 13:15:35.516097970 +0100
@@ -51,7 +51,7 @@ struct mutex {
 	spinlock_t		wait_lock;
 	struct list_head	wait_list;
 #if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
-	struct thread_info	*owner;
+	struct task_struct	*owner;
 #endif
 #ifdef CONFIG_DEBUG_MUTEXES
 	const char 		*name;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/namei.h linux-2.6.32.60-pax/include/linux/namei.h
--- linux-2.6.32.60/include/linux/namei.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/namei.h	2012-03-13 13:15:35.516097970 +0100
@@ -22,7 +22,7 @@ struct nameidata {
 	unsigned int	flags;
 	int		last_type;
 	unsigned	depth;
-	char *saved_names[MAX_NESTED_LINKS + 1];
+	const char *saved_names[MAX_NESTED_LINKS + 1];
 
 	/* Intent data */
 	union {
@@ -84,12 +84,12 @@ extern int follow_up(struct path *);
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
-static inline void nd_set_link(struct nameidata *nd, char *path)
+static inline void nd_set_link(struct nameidata *nd, const char *path)
 {
 	nd->saved_names[nd->depth] = path;
 }
 
-static inline char *nd_get_link(struct nameidata *nd)
+static inline const char *nd_get_link(const struct nameidata *nd)
 {
 	return nd->saved_names[nd->depth];
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/netdevice.h linux-2.6.32.60-pax/include/linux/netdevice.h
--- linux-2.6.32.60/include/linux/netdevice.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/netdevice.h	2012-03-13 13:15:35.520097969 +0100
@@ -637,6 +637,7 @@ struct net_device_ops {
 						     u16 xid);
 #endif
 };
+typedef struct net_device_ops __no_const net_device_ops_no_const;
 
 /*
  *	The DEVICE structure.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/netfilter/nfnetlink.h linux-2.6.32.60-pax/include/linux/netfilter/nfnetlink.h
--- linux-2.6.32.60/include/linux/netfilter/nfnetlink.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/netfilter/nfnetlink.h	2013-01-22 17:34:41.416555487 +0100
@@ -62,7 +62,7 @@ struct nfnl_callback
 		    const struct nlattr * const cda[]);
 	const struct nla_policy *policy;	/* netlink attribute policy */
 	const u_int16_t attr_count;		/* number of nlattr's */
-};
+} __do_const;
 
 struct nfnetlink_subsystem
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/nodemask.h linux-2.6.32.60-pax/include/linux/nodemask.h
--- linux-2.6.32.60/include/linux/nodemask.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/nodemask.h	2012-03-13 13:15:35.520097969 +0100
@@ -464,11 +464,11 @@ static inline int num_node_state(enum no
 
 #define any_online_node(mask)			\
 ({						\
-	int node;				\
-	for_each_node_mask(node, (mask))	\
-		if (node_online(node))		\
+	int __node;				\
+	for_each_node_mask(__node, (mask))	\
+		if (node_online(__node))	\
 			break;			\
-	node;					\
+	__node;					\
 })
 
 #define num_online_nodes()	num_node_state(N_ONLINE)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/notifier.h linux-2.6.32.60-pax/include/linux/notifier.h
--- linux-2.6.32.60/include/linux/notifier.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/notifier.h	2013-01-22 17:34:06.500557351 +0100
@@ -51,7 +51,8 @@ struct notifier_block {
 	int (*notifier_call)(struct notifier_block *, unsigned long, void *);
 	struct notifier_block *next;
 	int priority;
-};
+} __do_const;
+typedef struct notifier_block __no_const notifier_block_no_const;
 
 struct atomic_notifier_head {
 	spinlock_t lock;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/oprofile.h linux-2.6.32.60-pax/include/linux/oprofile.h
--- linux-2.6.32.60/include/linux/oprofile.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/oprofile.h	2012-05-20 19:21:25.465167284 +0200
@@ -129,9 +129,9 @@ int oprofilefs_create_ulong(struct super
 int oprofilefs_create_ro_ulong(struct super_block * sb, struct dentry * root,
 	char const * name, ulong * val);
  
-/** Create a file for read-only access to an atomic_t. */
+/** Create a file for read-only access to an atomic_unchecked_t. */
 int oprofilefs_create_ro_atomic(struct super_block * sb, struct dentry * root,
-	char const * name, atomic_t * val);
+	char const * name, atomic_unchecked_t * val);
  
 /** create a directory */
 struct dentry * oprofilefs_mkdir(struct super_block * sb, struct dentry * root,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/pagemap.h linux-2.6.32.60-pax/include/linux/pagemap.h
--- linux-2.6.32.60/include/linux/pagemap.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/pagemap.h	2012-03-13 13:15:35.520097969 +0100
@@ -426,6 +426,7 @@ static inline int fault_in_pages_readabl
 				((unsigned long)end & PAGE_MASK))
 		 	ret = __get_user(c, end);
 	}
+	(void)c;
 	return ret;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/perf_event.h linux-2.6.32.60-pax/include/linux/perf_event.h
--- linux-2.6.32.60/include/linux/perf_event.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/perf_event.h	2012-03-13 13:15:35.524097969 +0100
@@ -476,7 +476,7 @@ struct hw_perf_event {
 			struct hrtimer	hrtimer;
 		};
 	};
-	atomic64_t			prev_count;
+	atomic64_unchecked_t		prev_count;
 	u64				sample_period;
 	u64				last_period;
 	atomic64_t			period_left;
@@ -557,7 +557,7 @@ struct perf_event {
 	const struct pmu		*pmu;
 
 	enum perf_event_active_state	state;
-	atomic64_t			count;
+	atomic64_unchecked_t		count;
 
 	/*
 	 * These are the total time in nanoseconds that the event
@@ -595,8 +595,8 @@ struct perf_event {
 	 * These accumulate total time (in nanoseconds) that children
 	 * events have been enabled and running, respectively.
 	 */
-	atomic64_t			child_total_time_enabled;
-	atomic64_t			child_total_time_running;
+	atomic64_unchecked_t		child_total_time_enabled;
+	atomic64_unchecked_t		child_total_time_running;
 
 	/*
 	 * Protect attach/detach and child_list:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/pipe_fs_i.h linux-2.6.32.60-pax/include/linux/pipe_fs_i.h
--- linux-2.6.32.60/include/linux/pipe_fs_i.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/pipe_fs_i.h	2012-03-13 13:15:35.524097969 +0100
@@ -46,9 +46,9 @@ struct pipe_inode_info {
 	wait_queue_head_t wait;
 	unsigned int nrbufs, curbuf;
 	struct page *tmp_page;
-	unsigned int readers;
-	unsigned int writers;
-	unsigned int waiting_writers;
+	atomic_t readers;
+	atomic_t writers;
+	atomic_t waiting_writers;
 	unsigned int r_counter;
 	unsigned int w_counter;
 	struct fasync_struct *fasync_readers;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/poison.h linux-2.6.32.60-pax/include/linux/poison.h
--- linux-2.6.32.60/include/linux/poison.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/poison.h	2012-03-13 13:15:35.524097969 +0100
@@ -19,8 +19,8 @@
  * under normal circumstances, used to verify that nobody uses
  * non-initialized list entries.
  */
-#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
-#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
+#define LIST_POISON1  ((void *) (long)0xFFFFFF01)
+#define LIST_POISON2  ((void *) (long)0xFFFFFF02)
 
 /********** include/linux/timer.h **********/
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/posix-timers.h linux-2.6.32.60-pax/include/linux/posix-timers.h
--- linux-2.6.32.60/include/linux/posix-timers.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/posix-timers.h	2012-03-13 13:15:35.524097969 +0100
@@ -82,7 +82,8 @@ struct k_clock {
 #define TIMER_RETRY 1
 	void (*timer_get) (struct k_itimer * timr,
 			   struct itimerspec * cur_setting);
-};
+} __do_const;
+typedef struct k_clock __no_const k_clock_no_const;
 
 void register_posix_clock(const clockid_t clock_id, struct k_clock *new_clock);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/prefetch.h linux-2.6.32.60-pax/include/linux/prefetch.h
--- linux-2.6.32.60/include/linux/prefetch.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/prefetch.h	2012-03-13 13:15:35.528097969 +0100
@@ -11,6 +11,7 @@
 #define _LINUX_PREFETCH_H
 
 #include <linux/types.h>
+#include <linux/const.h>
 #include <asm/processor.h>
 #include <asm/cache.h>
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/random.h linux-2.6.32.60-pax/include/linux/random.h
--- linux-2.6.32.60/include/linux/random.h	2012-10-09 11:00:35.492882478 +0200
+++ linux-2.6.32.60-pax/include/linux/random.h	2013-01-22 17:38:23.452543632 +0100
@@ -76,6 +76,11 @@ static inline int arch_get_random_int(un
 }
 #endif
 
+static inline unsigned long pax_get_random_long(void)
+{
+	return random32() + (sizeof(long) > 4 ? (unsigned long)random32() << 32 : 0);
+}
+
 #endif /* __KERNEL___ */
 
 #endif /* _LINUX_RANDOM_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/reboot.h linux-2.6.32.60-pax/include/linux/reboot.h
--- linux-2.6.32.60/include/linux/reboot.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/reboot.h	2012-03-13 13:15:35.528097969 +0100
@@ -47,9 +47,9 @@ extern int unregister_reboot_notifier(st
  * Architecture-specific implementations of sys_reboot commands.
  */
 
-extern void machine_restart(char *cmd);
-extern void machine_halt(void);
-extern void machine_power_off(void);
+extern void machine_restart(char *cmd) __noreturn;
+extern void machine_halt(void) __noreturn;
+extern void machine_power_off(void) __noreturn;
 
 extern void machine_shutdown(void);
 struct pt_regs;
@@ -60,9 +60,9 @@ extern void machine_crash_shutdown(struc
  */
 
 extern void kernel_restart_prepare(char *cmd);
-extern void kernel_restart(char *cmd);
-extern void kernel_halt(void);
-extern void kernel_power_off(void);
+extern void kernel_restart(char *cmd) __noreturn;
+extern void kernel_halt(void) __noreturn;
+extern void kernel_power_off(void) __noreturn;
 
 void ctrl_alt_del(void);
 
@@ -75,7 +75,7 @@ extern int orderly_poweroff(bool force);
  * Emergency restart, callable from an interrupt handler.
  */
 
-extern void emergency_restart(void);
+extern void emergency_restart(void) __noreturn;
 #include <asm/emergency-restart.h>
 
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/regset.h linux-2.6.32.60-pax/include/linux/regset.h
--- linux-2.6.32.60/include/linux/regset.h	2012-03-18 17:44:12.492057971 +0100
+++ linux-2.6.32.60-pax/include/linux/regset.h	2013-01-22 17:38:23.580543625 +0100
@@ -160,7 +160,7 @@ struct user_regset {
 	unsigned int 			align;
 	unsigned int 			bias;
 	unsigned int 			core_note_type;
-};
+} __do_const;
 
 /**
  * struct user_regset_view - available regsets
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/reiserfs_fs.h linux-2.6.32.60-pax/include/linux/reiserfs_fs.h
--- linux-2.6.32.60/include/linux/reiserfs_fs.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/reiserfs_fs.h	2012-03-13 13:15:35.528097969 +0100
@@ -1326,7 +1326,7 @@ static inline loff_t max_reiserfs_offset
 #define REISERFS_USER_MEM		1	/* reiserfs user memory mode            */
 
 #define fs_generation(s) (REISERFS_SB(s)->s_generation_counter)
-#define get_generation(s) atomic_read (&fs_generation(s))
+#define get_generation(s) atomic_read_unchecked (&fs_generation(s))
 #define FILESYSTEM_CHANGED_TB(tb)  (get_generation((tb)->tb_sb) != (tb)->fs_gen)
 #define __fs_changed(gen,s) (gen != get_generation (s))
 #define fs_changed(gen,s) ({cond_resched(); __fs_changed(gen, s);})
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/reiserfs_fs_sb.h linux-2.6.32.60-pax/include/linux/reiserfs_fs_sb.h
--- linux-2.6.32.60/include/linux/reiserfs_fs_sb.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/reiserfs_fs_sb.h	2012-03-13 13:15:35.532097969 +0100
@@ -377,7 +377,7 @@ struct reiserfs_sb_info {
 	/* Comment? -Hans */
 	wait_queue_head_t s_wait;
 	/* To be obsoleted soon by per buffer seals.. -Hans */
-	atomic_t s_generation_counter;	// increased by one every time the
+	atomic_unchecked_t s_generation_counter;	// increased by one every time the
 	// tree gets re-balanced
 	unsigned long s_properties;	/* File system properties. Currently holds
 					   on-disk FS format */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/relay.h linux-2.6.32.60-pax/include/linux/relay.h
--- linux-2.6.32.60/include/linux/relay.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/relay.h	2012-03-13 13:15:35.532097969 +0100
@@ -159,7 +159,7 @@ struct rchan_callbacks
 	 * The callback should return 0 if successful, negative if not.
 	 */
 	int (*remove_buf_file)(struct dentry *dentry);
-};
+} __no_const;
 
 /*
  * CONFIG_RELAY kernel API, kernel/relay.c
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sched.h linux-2.6.32.60-pax/include/linux/sched.h
--- linux-2.6.32.60/include/linux/sched.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sched.h	2013-02-17 17:14:41.988173121 +0100
@@ -101,6 +101,7 @@ struct bio;
 struct fs_struct;
 struct bts_context;
 struct perf_event_context;
+struct linux_binprm;
 
 /*
  * List of flags we want to share for kernel threads,
@@ -350,7 +351,7 @@ extern signed long schedule_timeout_kill
 extern signed long schedule_timeout_uninterruptible(signed long timeout);
 asmlinkage void __schedule(void);
 asmlinkage void schedule(void);
-extern int mutex_spin_on_owner(struct mutex *lock, struct thread_info *owner);
+extern int mutex_spin_on_owner(struct mutex *lock, struct task_struct *owner);
 
 struct nsproxy;
 struct user_namespace;
@@ -371,9 +372,12 @@ struct user_namespace;
 #define DEFAULT_MAX_MAP_COUNT	(USHORT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
 
 extern int sysctl_max_map_count;
+extern unsigned long sysctl_heap_stack_gap;
 
 #include <linux/aio.h>
 
+extern bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len);
+extern unsigned long skip_heap_stack_gap(const struct vm_area_struct *vma, unsigned long len);
 extern unsigned long
 arch_get_unmapped_area(struct file *, unsigned long, unsigned long,
 		       unsigned long, unsigned long);
@@ -1328,8 +1332,8 @@ struct task_struct {
 	struct list_head thread_group;
 
 	struct completion *vfork_done;		/* for vfork() */
-	int __user *set_child_tid;		/* CLONE_CHILD_SETTID */
-	int __user *clear_child_tid;		/* CLONE_CHILD_CLEARTID */
+	pid_t __user *set_child_tid;		/* CLONE_CHILD_SETTID */
+	pid_t __user *clear_child_tid;		/* CLONE_CHILD_CLEARTID */
 
 	cputime_t utime, stime, utimescaled, stimescaled;
 	cputime_t gtime;
@@ -1369,6 +1373,10 @@ struct task_struct {
 #endif
 /* CPU-specific state of this task */
 	struct thread_struct thread;
+/* thread_info moved to task_struct */
+#ifdef CONFIG_X86
+	struct thread_info tinfo;
+#endif
 /* filesystem information */
 	struct fs_struct *fs;
 /* open file information */
@@ -1542,6 +1550,50 @@ struct task_struct {
 #endif /* CONFIG_TRACING */
 };
 
+#define MF_PAX_PAGEEXEC		0x01000000	/* Paging based non-executable pages */
+#define MF_PAX_EMUTRAMP		0x02000000	/* Emulate trampolines */
+#define MF_PAX_MPROTECT		0x04000000	/* Restrict mprotect() */
+#define MF_PAX_RANDMMAP		0x08000000	/* Randomize mmap() base */
+/*#define MF_PAX_RANDEXEC		0x10000000*/	/* Randomize ET_EXEC base */
+#define MF_PAX_SEGMEXEC		0x20000000	/* Segmentation based non-executable pages */
+
+#ifdef CONFIG_PAX_SOFTMODE
+extern int pax_softmode;
+#endif
+
+extern int pax_check_flags(unsigned long *);
+
+/* if tsk != current then task_lock must be held on it */
+#if defined(CONFIG_PAX_NOEXEC) || defined(CONFIG_PAX_ASLR)
+static inline unsigned long pax_get_flags(struct task_struct *tsk)
+{
+	if (likely(tsk->mm))
+		return tsk->mm->pax_flags;
+	else
+		return 0UL;
+}
+
+/* if tsk != current then task_lock must be held on it */
+static inline long pax_set_flags(struct task_struct *tsk, unsigned long flags)
+{
+	if (likely(tsk->mm)) {
+		tsk->mm->pax_flags = flags;
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_PAX_HAVE_ACL_FLAGS
+extern void pax_set_initial_flags(struct linux_binprm *bprm);
+#elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+extern void (*pax_set_initial_flags_func)(struct linux_binprm *bprm);
+#endif
+
+extern void pax_report_fault(struct pt_regs *regs, void *pc, void *sp);
+extern void pax_report_insns(struct pt_regs *regs, void *pc, void *sp);
+extern void pax_report_refcount_overflow(struct pt_regs *regs);
+
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
 #define tsk_cpumask(tsk) (&(tsk)->cpus_allowed)
 
@@ -1978,7 +2030,9 @@ void yield(void);
 extern struct exec_domain	default_exec_domain;
 
 union thread_union {
+#ifndef CONFIG_X86
 	struct thread_info thread_info;
+#endif
 	unsigned long stack[THREAD_SIZE/sizeof(long)];
 };
 
@@ -2155,7 +2209,7 @@ extern void __cleanup_sighand(struct sig
 extern void exit_itimers(struct signal_struct *);
 extern void flush_itimer_signals(void);
 
-extern NORET_TYPE void do_group_exit(int);
+extern __noreturn void do_group_exit(int);
 
 extern void daemonize(const char *, ...);
 extern int allow_signal(int);
@@ -2284,9 +2338,9 @@ static inline unsigned long *end_of_stac
 
 #endif
 
-static inline int object_is_on_stack(void *obj)
+static inline int object_starts_on_stack(void *obj)
 {
-	void *stack = task_stack_page(current);
+	const void *stack = task_stack_page(current);
 
 	return (obj >= stack) && (obj < (stack + THREAD_SIZE));
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/screen_info.h linux-2.6.32.60-pax/include/linux/screen_info.h
--- linux-2.6.32.60/include/linux/screen_info.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/screen_info.h	2012-03-13 13:15:35.536097968 +0100
@@ -42,7 +42,8 @@ struct screen_info {
 	__u16 pages;		/* 0x32 */
 	__u16 vesa_attributes;	/* 0x34 */
 	__u32 capabilities;     /* 0x36 */
-	__u8  _reserved[6];	/* 0x3a */
+	__u16 vesapm_size;	/* 0x3a */
+	__u8  _reserved[4];	/* 0x3c */
 } __attribute__((packed));
 
 #define VIDEO_TYPE_MDA		0x10	/* Monochrome Text Display	*/
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/seq_file.h linux-2.6.32.60-pax/include/linux/seq_file.h
--- linux-2.6.32.60/include/linux/seq_file.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/seq_file.h	2012-03-13 13:15:35.536097968 +0100
@@ -32,6 +32,7 @@ struct seq_operations {
 	void * (*next) (struct seq_file *m, void *v, loff_t *pos);
 	int (*show) (struct seq_file *m, void *v);
 };
+typedef struct seq_operations __no_const seq_operations_no_const;
 
 #define SEQ_SKIP 1
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/skbuff.h linux-2.6.32.60-pax/include/linux/skbuff.h
--- linux-2.6.32.60/include/linux/skbuff.h	2012-10-09 11:00:35.492882478 +0200
+++ linux-2.6.32.60-pax/include/linux/skbuff.h	2012-10-09 11:00:39.348883053 +0200
@@ -442,7 +442,7 @@ extern void consume_skb(struct sk_buff *
 extern void	       __kfree_skb(struct sk_buff *skb);
 extern struct sk_buff *__alloc_skb(unsigned int size,
 				   gfp_t priority, int fclone, int node);
-static inline struct sk_buff *alloc_skb(unsigned int size,
+static inline struct sk_buff * __intentional_overflow(0) alloc_skb(unsigned int size,
 					gfp_t priority)
 {
 	return __alloc_skb(size, priority, 0, -1);
@@ -544,7 +544,7 @@ static inline union skb_shared_tx *skb_t
  */
 static inline int skb_queue_empty(const struct sk_buff_head *list)
 {
-	return list->next == (struct sk_buff *)list;
+	return list->next == (const struct sk_buff *)list;
 }
 
 /**
@@ -557,7 +557,7 @@ static inline int skb_queue_empty(const
 static inline bool skb_queue_is_last(const struct sk_buff_head *list,
 				     const struct sk_buff *skb)
 {
-	return (skb->next == (struct sk_buff *) list);
+	return (skb->next == (const struct sk_buff *) list);
 }
 
 /**
@@ -570,7 +570,7 @@ static inline bool skb_queue_is_last(con
 static inline bool skb_queue_is_first(const struct sk_buff_head *list,
 				      const struct sk_buff *skb)
 {
-	return (skb->prev == (struct sk_buff *) list);
+	return (skb->prev == (const struct sk_buff *) list);
 }
 
 /**
@@ -1377,7 +1377,7 @@ static inline int skb_network_offset(con
  * headroom, you should not reduce this.
  */
 #ifndef NET_SKB_PAD
-#define NET_SKB_PAD	32
+#define NET_SKB_PAD	(_AC(32,UL))
 #endif
 
 extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
@@ -1750,7 +1750,7 @@ extern struct sk_buff *skb_recv_datagram
 					 int noblock, int *err);
 extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 				     struct poll_table_struct *wait);
-extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
+extern int	       __intentional_overflow(0) skb_copy_datagram_iovec(const struct sk_buff *from,
 					       int offset, struct iovec *to,
 					       int size);
 extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/slab_def.h linux-2.6.32.60-pax/include/linux/slab_def.h
--- linux-2.6.32.60/include/linux/slab_def.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/slab_def.h	2012-07-27 21:50:49.198341384 +0200
@@ -69,10 +69,10 @@ struct kmem_cache {
 	unsigned long node_allocs;
 	unsigned long node_frees;
 	unsigned long node_overflow;
-	atomic_t allochit;
-	atomic_t allocmiss;
-	atomic_t freehit;
-	atomic_t freemiss;
+	atomic_unchecked_t allochit;
+	atomic_unchecked_t allocmiss;
+	atomic_unchecked_t freehit;
+	atomic_unchecked_t freemiss;
 
 	/*
 	 * If debugging is enabled, then the allocator can add additional
@@ -104,11 +104,16 @@ struct cache_sizes {
 #ifdef CONFIG_ZONE_DMA
 	struct kmem_cache	*cs_dmacachep;
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	struct kmem_cache	*cs_usercopycachep;
+#endif
+
 };
 extern struct cache_sizes malloc_sizes[];
 
 void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
-void *__kmalloc(size_t size, gfp_t flags);
+void *__kmalloc(size_t size, gfp_t flags) __size_overflow(1);
 
 #ifdef CONFIG_KMEMTRACE
 extern void *kmem_cache_alloc_notrace(struct kmem_cache *cachep, gfp_t flags);
@@ -150,6 +155,13 @@ found:
 			cachep = malloc_sizes[i].cs_dmacachep;
 		else
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+		if (flags & GFP_USERCOPY)
+			cachep = malloc_sizes[i].cs_usercopycachep;
+		else
+#endif
+
 			cachep = malloc_sizes[i].cs_cachep;
 
 		ret = kmem_cache_alloc_notrace(cachep, flags);
@@ -163,7 +175,7 @@ found:
 }
 
 #ifdef CONFIG_NUMA
-extern void *__kmalloc_node(size_t size, gfp_t flags, int node);
+extern void *__kmalloc_node(size_t size, gfp_t flags, int node) __size_overflow(1);
 extern void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node);
 
 #ifdef CONFIG_KMEMTRACE
@@ -205,6 +217,13 @@ found:
 			cachep = malloc_sizes[i].cs_dmacachep;
 		else
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+		if (flags & GFP_USERCOPY)
+			cachep = malloc_sizes[i].cs_usercopycachep;
+		else
+#endif
+
 			cachep = malloc_sizes[i].cs_cachep;
 
 		ret = kmem_cache_alloc_node_notrace(cachep, flags, node);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/slab.h linux-2.6.32.60-pax/include/linux/slab.h
--- linux-2.6.32.60/include/linux/slab.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/slab.h	2013-02-17 17:15:32.280170436 +0100
@@ -11,12 +11,20 @@
 
 #include <linux/gfp.h>
 #include <linux/types.h>
+#include <linux/err.h>
 
 /*
  * Flags to pass to kmem_cache_create().
  * The ones marked DEBUG are only valid if CONFIG_SLAB_DEBUG is set.
  */
 #define SLAB_DEBUG_FREE		0x00000100UL	/* DEBUG: Perform (expensive) checks on free */
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+#define SLAB_USERCOPY		0x00000200UL	/* PaX: Allow copying objs to/from userland */
+#else
+#define SLAB_USERCOPY		0x00000000UL
+#endif
+
 #define SLAB_RED_ZONE		0x00000400UL	/* DEBUG: Red zone objs in a cache */
 #define SLAB_POISON		0x00000800UL	/* DEBUG: Poison objects */
 #define SLAB_HWCACHE_ALIGN	0x00002000UL	/* Align objs on cache lines */
@@ -82,10 +90,13 @@
  * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.
  * Both make kfree a no-op.
  */
-#define ZERO_SIZE_PTR ((void *)16)
+#define ZERO_SIZE_PTR				\
+({						\
+	BUILD_BUG_ON(!(MAX_ERRNO & ~PAGE_MASK));\
+	(void *)(-MAX_ERRNO-1L);		\
+})
 
-#define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \
-				(unsigned long)ZERO_SIZE_PTR)
+#define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) - 1 >= (unsigned long)ZERO_SIZE_PTR - 1)
 
 /*
  * struct kmem_cache related prototypes
@@ -138,6 +149,8 @@ void * __must_check krealloc(const void
 void kfree(const void *);
 void kzfree(const void *);
 size_t ksize(const void *);
+const char *check_heap_object(const void *ptr, unsigned long n);
+bool is_usercopy_object(const void *ptr);
 
 /*
  * Allocator specific definitions. These are mainly used to establish optimized
@@ -217,8 +230,18 @@ size_t ksize(const void *);
  * for general use, and so are not documented here. For a full list of
  * potential flags, always refer to linux/gfp.h.
  */
+
+extern void kcalloc_error(void)
+#if defined(CONFIG_GCOV_KERNEL) && defined(CONFIG_PAX_SIZE_OVERFLOW)
+__compiletime_warning("kcalloc called with swapped arguments?");
+#else
+__compiletime_error("kcalloc called with swapped arguments?");
+#endif
+
 static inline void *kcalloc(size_t n, size_t size, gfp_t flags)
 {
+	if (__builtin_constant_p(n) && !__builtin_constant_p(size))
+		kcalloc_error();
 	if (size != 0 && n > ULONG_MAX / size)
 		return NULL;
 	return __kmalloc(n * size, flags | __GFP_ZERO);
@@ -263,7 +286,7 @@ static inline void *kmem_cache_alloc_nod
  * request comes from.
  */
 #if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_SLUB)
-extern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);
+extern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long) __size_overflow(1);
 #define kmalloc_track_caller(size, flags) \
 	__kmalloc_track_caller(size, flags, _RET_IP_)
 #else
@@ -281,7 +304,7 @@ extern void *__kmalloc_track_caller(size
  * allocation request comes from.
  */
 #if defined(CONFIG_DEBUG_SLAB) || defined(CONFIG_SLUB)
-extern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);
+extern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long) __size_overflow(1);
 #define kmalloc_node_track_caller(size, flags, node) \
 	__kmalloc_node_track_caller(size, flags, node, \
 			_RET_IP_)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/slob_def.h linux-2.6.32.60-pax/include/linux/slob_def.h
--- linux-2.6.32.60/include/linux/slob_def.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/slob_def.h	2012-08-12 13:34:47.857244615 +0200
@@ -9,7 +9,7 @@ static __always_inline void *kmem_cache_
 	return kmem_cache_alloc_node(cachep, flags, -1);
 }
 
-void *__kmalloc_node(size_t size, gfp_t flags, int node);
+void *__kmalloc_node(size_t size, gfp_t flags, int node) __size_overflow(1);
 
 static __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node)
 {
@@ -29,7 +29,7 @@ static __always_inline void *kmalloc(siz
 	return __kmalloc_node(size, flags, -1);
 }
 
-static __always_inline void *__kmalloc(size_t size, gfp_t flags)
+static __always_inline __size_overflow(1) void *__kmalloc(size_t size, gfp_t flags)
 {
 	return kmalloc(size, flags);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/slub_def.h linux-2.6.32.60-pax/include/linux/slub_def.h
--- linux-2.6.32.60/include/linux/slub_def.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/slub_def.h	2012-08-12 13:35:17.461244026 +0200
@@ -86,7 +86,7 @@ struct kmem_cache {
 	struct kmem_cache_order_objects max;
 	struct kmem_cache_order_objects min;
 	gfp_t allocflags;	/* gfp flags to use on each alloc */
-	int refcount;		/* Refcount for slab cache destroy */
+	atomic_t refcount;	/* Refcount for slab cache destroy */
 	void (*ctor)(void *);
 	int inuse;		/* Offset to metadata */
 	int align;		/* Alignment */
@@ -145,7 +145,7 @@ extern struct kmem_cache kmalloc_caches[
  * Sorry that the following has to be that ugly but some versions of GCC
  * have trouble with constant propagation and loops.
  */
-static __always_inline int kmalloc_index(size_t size)
+static __always_inline __size_overflow(1) int kmalloc_index(size_t size)
 {
 	if (!size)
 		return 0;
@@ -215,7 +215,7 @@ static __always_inline struct kmem_cache
 #endif
 
 void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
-void *__kmalloc(size_t size, gfp_t flags);
+void *__kmalloc(size_t size, gfp_t flags) __alloc_size(1);
 
 #ifdef CONFIG_KMEMTRACE
 extern void *kmem_cache_alloc_notrace(struct kmem_cache *s, gfp_t gfpflags);
@@ -227,7 +227,7 @@ kmem_cache_alloc_notrace(struct kmem_cac
 }
 #endif
 
-static __always_inline void *kmalloc_large(size_t size, gfp_t flags)
+static __always_inline __size_overflow(1) void *kmalloc_large(size_t size, gfp_t flags)
 {
 	unsigned int order = get_order(size);
 	void *ret = (void *) __get_free_pages(flags | __GFP_COMP, order);
@@ -263,7 +263,7 @@ static __always_inline void *kmalloc(siz
 }
 
 #ifdef CONFIG_NUMA
-void *__kmalloc_node(size_t size, gfp_t flags, int node);
+void *__kmalloc_node(size_t size, gfp_t flags, int node) __size_overflow(1);
 void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node);
 
 #ifdef CONFIG_KMEMTRACE
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sonet.h linux-2.6.32.60-pax/include/linux/sonet.h
--- linux-2.6.32.60/include/linux/sonet.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sonet.h	2012-03-13 13:15:35.540097968 +0100
@@ -61,7 +61,7 @@ struct sonet_stats {
 #include <asm/atomic.h>
 
 struct k_sonet_stats {
-#define __HANDLE_ITEM(i) atomic_t i
+#define __HANDLE_ITEM(i) atomic_unchecked_t i
 	__SONET_ITEMS
 #undef __HANDLE_ITEM
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sunrpc/cache.h linux-2.6.32.60-pax/include/linux/sunrpc/cache.h
--- linux-2.6.32.60/include/linux/sunrpc/cache.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sunrpc/cache.h	2012-03-13 13:15:35.544097968 +0100
@@ -125,7 +125,7 @@ struct cache_detail {
  */
 struct cache_req {
 	struct cache_deferred_req *(*defer)(struct cache_req *req);
-};
+} __no_const;
 /* this must be embedded in a deferred_request that is being
  * delayed awaiting cache-fill
  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sunrpc/clnt.h linux-2.6.32.60-pax/include/linux/sunrpc/clnt.h
--- linux-2.6.32.60/include/linux/sunrpc/clnt.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sunrpc/clnt.h	2012-03-13 13:15:35.544097968 +0100
@@ -167,9 +167,9 @@ static inline unsigned short rpc_get_por
 {
 	switch (sap->sa_family) {
 	case AF_INET:
-		return ntohs(((struct sockaddr_in *)sap)->sin_port);
+		return ntohs(((const struct sockaddr_in *)sap)->sin_port);
 	case AF_INET6:
-		return ntohs(((struct sockaddr_in6 *)sap)->sin6_port);
+		return ntohs(((const struct sockaddr_in6 *)sap)->sin6_port);
 	}
 	return 0;
 }
@@ -202,7 +202,7 @@ static inline bool __rpc_cmp_addr4(const
 static inline bool __rpc_copy_addr4(struct sockaddr *dst,
 				    const struct sockaddr *src)
 {
-	const struct sockaddr_in *ssin = (struct sockaddr_in *) src;
+	const struct sockaddr_in *ssin = (const struct sockaddr_in *) src;
 	struct sockaddr_in *dsin = (struct sockaddr_in *) dst;
 
 	dsin->sin_family = ssin->sin_family;
@@ -299,7 +299,7 @@ static inline u32 rpc_get_scope_id(const
 	if (sa->sa_family != AF_INET6)
 		return 0;
 
-	return ((struct sockaddr_in6 *) sa)->sin6_scope_id;
+	return ((const struct sockaddr_in6 *) sa)->sin6_scope_id;
 }
 
 #endif /* __KERNEL__ */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sunrpc/svc_rdma.h linux-2.6.32.60-pax/include/linux/sunrpc/svc_rdma.h
--- linux-2.6.32.60/include/linux/sunrpc/svc_rdma.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sunrpc/svc_rdma.h	2012-03-13 13:15:35.544097968 +0100
@@ -53,15 +53,15 @@ extern unsigned int svcrdma_ord;
 extern unsigned int svcrdma_max_requests;
 extern unsigned int svcrdma_max_req_size;
 
-extern atomic_t rdma_stat_recv;
-extern atomic_t rdma_stat_read;
-extern atomic_t rdma_stat_write;
-extern atomic_t rdma_stat_sq_starve;
-extern atomic_t rdma_stat_rq_starve;
-extern atomic_t rdma_stat_rq_poll;
-extern atomic_t rdma_stat_rq_prod;
-extern atomic_t rdma_stat_sq_poll;
-extern atomic_t rdma_stat_sq_prod;
+extern atomic_unchecked_t rdma_stat_recv;
+extern atomic_unchecked_t rdma_stat_read;
+extern atomic_unchecked_t rdma_stat_write;
+extern atomic_unchecked_t rdma_stat_sq_starve;
+extern atomic_unchecked_t rdma_stat_rq_starve;
+extern atomic_unchecked_t rdma_stat_rq_poll;
+extern atomic_unchecked_t rdma_stat_rq_prod;
+extern atomic_unchecked_t rdma_stat_sq_poll;
+extern atomic_unchecked_t rdma_stat_sq_prod;
 
 #define RPCRDMA_VERSION 1
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sysctl.h linux-2.6.32.60-pax/include/linux/sysctl.h
--- linux-2.6.32.60/include/linux/sysctl.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sysctl.h	2012-03-13 13:15:35.544097968 +0100
@@ -164,7 +164,11 @@ enum
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
 };
 
-
+#ifdef CONFIG_PAX_SOFTMODE
+enum {
+	PAX_SOFTMODE=1		/* PaX: disable/enable soft mode */
+};
+#endif
 
 /* CTL_VM names: */
 enum
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/sysrq.h linux-2.6.32.60-pax/include/linux/sysrq.h
--- linux-2.6.32.60/include/linux/sysrq.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/sysrq.h	2013-01-22 17:38:23.580543625 +0100
@@ -35,7 +35,7 @@ struct sysrq_key_op {
 	char *help_msg;
 	char *action_msg;
 	int enable_mask;
-};
+} __do_const;
 
 #ifdef CONFIG_MAGIC_SYSRQ
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/thread_info.h linux-2.6.32.60-pax/include/linux/thread_info.h
--- linux-2.6.32.60/include/linux/thread_info.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/thread_info.h	2013-02-17 17:20:03.728155943 +0100
@@ -23,7 +23,7 @@ struct restart_block {
 		};
 		/* For futex_wait and futex_wait_requeue_pi */
 		struct {
-			u32 *uaddr;
+			u32 __user *uaddr;
 			u32 val;
 			u32 flags;
 			u32 bitset;
@@ -126,6 +126,13 @@ static inline void set_restore_sigmask(v
 }
 #endif	/* TIF_RESTORE_SIGMASK && !HAVE_SET_RESTORE_SIGMASK */
 
+extern void __check_object_size(const void *ptr, unsigned long n, bool to);
+static inline void check_object_size(const void *ptr, unsigned long n, bool to)
+{
+	if (!__builtin_constant_p(n))
+		__check_object_size(ptr, n, to);
+}
+
 #endif	/* __KERNEL__ */
 
 #endif /* _LINUX_THREAD_INFO_H */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/tty_driver.h linux-2.6.32.60-pax/include/linux/tty_driver.h
--- linux-2.6.32.60/include/linux/tty_driver.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/tty_driver.h	2013-01-22 17:38:23.588543625 +0100
@@ -283,7 +283,7 @@ struct tty_operations {
 	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
 #endif
 	const struct file_operations *proc_fops;
-};
+} __do_const;
 
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/tty_ldisc.h linux-2.6.32.60-pax/include/linux/tty_ldisc.h
--- linux-2.6.32.60/include/linux/tty_ldisc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/tty_ldisc.h	2012-03-13 13:15:35.548097968 +0100
@@ -139,7 +139,7 @@ struct tty_ldisc_ops {
 
 	struct  module *owner;
 	
-	int refcount;
+	atomic_t refcount;
 };
 
 struct tty_ldisc {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/types.h linux-2.6.32.60-pax/include/linux/types.h
--- linux-2.6.32.60/include/linux/types.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/types.h	2012-03-13 13:15:35.548097968 +0100
@@ -191,10 +191,26 @@ typedef struct {
 	volatile int counter;
 } atomic_t;
 
+#ifdef CONFIG_PAX_REFCOUNT
+typedef struct {
+	volatile int counter;
+} atomic_unchecked_t;
+#else
+typedef atomic_t atomic_unchecked_t;
+#endif
+
 #ifdef CONFIG_64BIT
 typedef struct {
 	volatile long counter;
 } atomic64_t;
+
+#ifdef CONFIG_PAX_REFCOUNT
+typedef struct {
+	volatile long counter;
+} atomic64_unchecked_t;
+#else
+typedef atomic64_t atomic64_unchecked_t;
+#endif
 #endif
 
 struct ustat {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/uaccess.h linux-2.6.32.60-pax/include/linux/uaccess.h
--- linux-2.6.32.60/include/linux/uaccess.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/uaccess.h	2012-03-16 19:21:46.039707783 +0100
@@ -76,11 +76,11 @@ static inline unsigned long __copy_from_
 		long ret;				\
 		mm_segment_t old_fs = get_fs();		\
 							\
-		set_fs(KERNEL_DS);			\
 		pagefault_disable();			\
-		ret = __copy_from_user_inatomic(&(retval), (__force typeof(retval) __user *)(addr), sizeof(retval));		\
-		pagefault_enable();			\
+		set_fs(KERNEL_DS);			\
+		ret = __copy_from_user_inatomic(&(retval), (typeof(retval) __force_user *)(addr), sizeof(retval));		\
 		set_fs(old_fs);				\
+		pagefault_enable();			\
 		ret;					\
 	})
 
@@ -93,7 +93,7 @@ static inline unsigned long __copy_from_
  * Safely read from address @src to the buffer at @dst.  If a kernel fault
  * happens, handle that and return -EFAULT.
  */
-extern long probe_kernel_read(void *dst, void *src, size_t size);
+extern long probe_kernel_read(void *dst, const void *src, size_t size);
 
 /*
  * probe_kernel_write(): safely attempt to write to a location
@@ -104,6 +104,6 @@ extern long probe_kernel_read(void *dst,
  * Safely write to address @dst from the buffer at @src.  If a kernel fault
  * happens, handle that and return -EFAULT.
  */
-extern long probe_kernel_write(void *dst, void *src, size_t size);
+extern long probe_kernel_write(void *dst, const void *src, size_t size) __size_overflow(3);
 
 #endif		/* __LINUX_UACCESS_H__ */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/unaligned/access_ok.h linux-2.6.32.60-pax/include/linux/unaligned/access_ok.h
--- linux-2.6.32.60/include/linux/unaligned/access_ok.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/unaligned/access_ok.h	2012-03-13 13:15:35.548097968 +0100
@@ -6,32 +6,32 @@
 
 static inline u16 get_unaligned_le16(const void *p)
 {
-	return le16_to_cpup((__le16 *)p);
+	return le16_to_cpup((const __le16 *)p);
 }
 
 static inline u32 get_unaligned_le32(const void *p)
 {
-	return le32_to_cpup((__le32 *)p);
+	return le32_to_cpup((const __le32 *)p);
 }
 
 static inline u64 get_unaligned_le64(const void *p)
 {
-	return le64_to_cpup((__le64 *)p);
+	return le64_to_cpup((const __le64 *)p);
 }
 
 static inline u16 get_unaligned_be16(const void *p)
 {
-	return be16_to_cpup((__be16 *)p);
+	return be16_to_cpup((const __be16 *)p);
 }
 
 static inline u32 get_unaligned_be32(const void *p)
 {
-	return be32_to_cpup((__be32 *)p);
+	return be32_to_cpup((const __be32 *)p);
 }
 
 static inline u64 get_unaligned_be64(const void *p)
 {
-	return be64_to_cpup((__be64 *)p);
+	return be64_to_cpup((const __be64 *)p);
 }
 
 static inline void put_unaligned_le16(u16 val, void *p)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/usb.h linux-2.6.32.60-pax/include/linux/usb.h
--- linux-2.6.32.60/include/linux/usb.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/usb.h	2012-12-03 22:35:07.467768880 +0100
@@ -500,7 +500,7 @@ struct usb_device {
 
 	int pm_usage_cnt;
 	u32 quirks;
-	atomic_t urbnum;
+	atomic_unchecked_t urbnum;
 
 	unsigned long active_duration;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/vermagic.h linux-2.6.32.60-pax/include/linux/vermagic.h
--- linux-2.6.32.60/include/linux/vermagic.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/vermagic.h	2012-03-13 13:15:35.548097968 +0100
@@ -26,9 +26,28 @@
 #define MODULE_ARCH_VERMAGIC ""
 #endif
 
+#ifdef CONFIG_PAX_REFCOUNT
+#define MODULE_PAX_REFCOUNT "REFCOUNT "
+#else
+#define MODULE_PAX_REFCOUNT ""
+#endif
+
+#ifdef CONSTIFY_PLUGIN
+#define MODULE_CONSTIFY_PLUGIN "CONSTIFY_PLUGIN "
+#else
+#define MODULE_CONSTIFY_PLUGIN ""
+#endif
+
+#ifdef STACKLEAK_PLUGIN
+#define MODULE_STACKLEAK_PLUGIN "STACKLEAK_PLUGIN "
+#else
+#define MODULE_STACKLEAK_PLUGIN ""
+#endif
+
 #define VERMAGIC_STRING 						\
 	UTS_RELEASE " "							\
 	MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT 			\
 	MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS	\
-	MODULE_ARCH_VERMAGIC
+	MODULE_ARCH_VERMAGIC						\
+	MODULE_PAX_REFCOUNT MODULE_CONSTIFY_PLUGIN MODULE_STACKLEAK_PLUGIN
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/vmalloc.h linux-2.6.32.60-pax/include/linux/vmalloc.h
--- linux-2.6.32.60/include/linux/vmalloc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/vmalloc.h	2012-05-20 19:21:25.497167287 +0200
@@ -14,6 +14,11 @@ struct vm_area_struct;		/* vma defining
 #define VM_USERMAP	0x00000008	/* suitable for remap_vmalloc_range */
 #define VM_VPAGES	0x00000010	/* buffer for pages was vmalloc'ed */
 #define VM_UNLIST	0x00000020	/* vm_struct is not listed in vmlist */
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
+#define VM_KERNEXEC	0x00000040	/* allocate from executable kernel memory range */
+#endif
+
 /* bits [20..32] reserved for arch specific ioremap internals */
 
 /*
@@ -106,8 +111,8 @@ extern struct vm_struct *alloc_vm_area(s
 extern void free_vm_area(struct vm_struct *area);
 
 /* for /dev/kmem */
-extern long vread(char *buf, char *addr, unsigned long count);
-extern long vwrite(char *buf, char *addr, unsigned long count);
+extern long vread(char *buf, char *addr, unsigned long count) __size_overflow(3);
+extern long vwrite(char *buf, char *addr, unsigned long count) __size_overflow(3);
 
 /*
  *	Internals.  Dont't use..
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/vmstat.h linux-2.6.32.60-pax/include/linux/vmstat.h
--- linux-2.6.32.60/include/linux/vmstat.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/vmstat.h	2012-03-13 13:15:35.552097968 +0100
@@ -136,18 +136,18 @@ static inline void vm_events_fold_cpu(in
 /*
  * Zone based page accounting with per cpu differentials.
  */
-extern atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
+extern atomic_long_unchecked_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
 
 static inline void zone_page_state_add(long x, struct zone *zone,
 				 enum zone_stat_item item)
 {
-	atomic_long_add(x, &zone->vm_stat[item]);
-	atomic_long_add(x, &vm_stat[item]);
+	atomic_long_add_unchecked(x, &zone->vm_stat[item]);
+	atomic_long_add_unchecked(x, &vm_stat[item]);
 }
 
 static inline unsigned long global_page_state(enum zone_stat_item item)
 {
-	long x = atomic_long_read(&vm_stat[item]);
+	long x = atomic_long_read_unchecked(&vm_stat[item]);
 #ifdef CONFIG_SMP
 	if (x < 0)
 		x = 0;
@@ -158,7 +158,7 @@ static inline unsigned long global_page_
 static inline unsigned long zone_page_state(struct zone *zone,
 					enum zone_stat_item item)
 {
-	long x = atomic_long_read(&zone->vm_stat[item]);
+	long x = atomic_long_read_unchecked(&zone->vm_stat[item]);
 #ifdef CONFIG_SMP
 	if (x < 0)
 		x = 0;
@@ -175,7 +175,7 @@ static inline unsigned long zone_page_st
 static inline unsigned long zone_page_state_snapshot(struct zone *zone,
 					enum zone_stat_item item)
 {
-	long x = atomic_long_read(&zone->vm_stat[item]);
+	long x = atomic_long_read_unchecked(&zone->vm_stat[item]);
 
 #ifdef CONFIG_SMP
 	int cpu;
@@ -264,8 +264,8 @@ static inline void __mod_zone_page_state
 
 static inline void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
 {
-	atomic_long_inc(&zone->vm_stat[item]);
-	atomic_long_inc(&vm_stat[item]);
+	atomic_long_inc_unchecked(&zone->vm_stat[item]);
+	atomic_long_inc_unchecked(&vm_stat[item]);
 }
 
 static inline void __inc_zone_page_state(struct page *page,
@@ -276,8 +276,8 @@ static inline void __inc_zone_page_state
 
 static inline void __dec_zone_state(struct zone *zone, enum zone_stat_item item)
 {
-	atomic_long_dec(&zone->vm_stat[item]);
-	atomic_long_dec(&vm_stat[item]);
+	atomic_long_dec_unchecked(&zone->vm_stat[item]);
+	atomic_long_dec_unchecked(&vm_stat[item]);
 }
 
 static inline void __dec_zone_page_state(struct page *page,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/linux/xattr.h linux-2.6.32.60-pax/include/linux/xattr.h
--- linux-2.6.32.60/include/linux/xattr.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/linux/xattr.h	2012-03-13 13:15:35.552097968 +0100
@@ -33,6 +33,11 @@
 #define XATTR_USER_PREFIX "user."
 #define XATTR_USER_PREFIX_LEN (sizeof (XATTR_USER_PREFIX) - 1)
 
+/* User namespace */
+#define XATTR_PAX_PREFIX XATTR_USER_PREFIX "pax."
+#define XATTR_PAX_FLAGS_SUFFIX "flags"
+#define XATTR_NAME_PAX_FLAGS XATTR_PAX_PREFIX XATTR_PAX_FLAGS_SUFFIX
+
 struct inode;
 struct dentry;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/media/v4l2-dev.h linux-2.6.32.60-pax/include/media/v4l2-dev.h
--- linux-2.6.32.60/include/media/v4l2-dev.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/media/v4l2-dev.h	2013-01-22 17:38:23.468543631 +0100
@@ -34,7 +34,7 @@ struct v4l2_device;
 #define V4L2_FL_UNREGISTERED	(0)
 
 struct v4l2_file_operations {
-	struct module *owner;
+	struct module * const owner;
 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/media/v4l2-device.h linux-2.6.32.60-pax/include/media/v4l2-device.h
--- linux-2.6.32.60/include/media/v4l2-device.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/media/v4l2-device.h	2012-03-13 13:15:35.556097967 +0100
@@ -71,7 +71,7 @@ int __must_check v4l2_device_register(st
    this function returns 0. If the name ends with a digit (e.g. cx18),
    then the name will be set to cx18-0 since cx180 looks really odd. */
 int v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,
-						atomic_t *instance);
+						atomic_unchecked_t *instance);
 
 /* Set v4l2_dev->dev to NULL. Call when the USB parent disconnects.
    Since the parent disappears this ensures that v4l2_dev doesn't have an
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/flow.h linux-2.6.32.60-pax/include/net/flow.h
--- linux-2.6.32.60/include/net/flow.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/flow.h	2012-03-13 13:15:35.556097967 +0100
@@ -92,7 +92,7 @@ typedef int (*flow_resolve_t)(struct net
 extern void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family,
 			       u8 dir, flow_resolve_t resolver);
 extern void flow_cache_flush(void);
-extern atomic_t flow_cache_genid;
+extern atomic_unchecked_t flow_cache_genid;
 
 static inline int flow_cache_uli_match(struct flowi *fl1, struct flowi *fl2)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/inet_connection_sock.h linux-2.6.32.60-pax/include/net/inet_connection_sock.h
--- linux-2.6.32.60/include/net/inet_connection_sock.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/inet_connection_sock.h	2013-01-22 17:38:23.592543624 +0100
@@ -62,7 +62,7 @@ struct inet_connection_sock_af_ops {
 	void	    (*addr2sockaddr)(struct sock *sk, struct sockaddr *);
 	int	    (*bind_conflict)(const struct sock *sk,
 				     const struct inet_bind_bucket *tb);
-};
+} __do_const;
 
 /** inet_connection_sock - INET connection oriented sock
  *
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/inetpeer.h linux-2.6.32.60-pax/include/net/inetpeer.h
--- linux-2.6.32.60/include/net/inetpeer.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/inetpeer.h	2012-03-13 13:15:35.556097967 +0100
@@ -24,7 +24,7 @@ struct inet_peer
 	__u32			dtime;		/* the time of last use of not
 						 * referenced entries */
 	atomic_t		refcnt;
-	atomic_t		rid;		/* Frag reception counter */
+	atomic_unchecked_t	rid;		/* Frag reception counter */
 	__u32			tcp_ts;
 	unsigned long		tcp_ts_stamp;
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/ip_vs.h linux-2.6.32.60-pax/include/net/ip_vs.h
--- linux-2.6.32.60/include/net/ip_vs.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/ip_vs.h	2012-03-13 13:15:35.556097967 +0100
@@ -365,7 +365,7 @@ struct ip_vs_conn {
 	struct ip_vs_conn       *control;       /* Master control connection */
 	atomic_t                n_control;      /* Number of controlled ones */
 	struct ip_vs_dest       *dest;          /* real server */
-	atomic_t                in_pkts;        /* incoming packet counter */
+	atomic_unchecked_t      in_pkts;        /* incoming packet counter */
 
 	/* packet transmitter for different forwarding methods.  If it
 	   mangles the packet, it must return NF_DROP or better NF_STOLEN,
@@ -466,7 +466,7 @@ struct ip_vs_dest {
 	union nf_inet_addr	addr;		/* IP address of the server */
 	__be16			port;		/* port number of the server */
 	volatile unsigned	flags;		/* dest status flags */
-	atomic_t		conn_flags;	/* flags to copy to conn */
+	atomic_unchecked_t	conn_flags;	/* flags to copy to conn */
 	atomic_t		weight;		/* server weight */
 
 	atomic_t		refcnt;		/* reference counter */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/irda/ircomm_tty.h linux-2.6.32.60-pax/include/net/irda/ircomm_tty.h
--- linux-2.6.32.60/include/net/irda/ircomm_tty.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/irda/ircomm_tty.h	2012-03-13 13:15:35.560097967 +0100
@@ -35,6 +35,7 @@
 #include <linux/termios.h>
 #include <linux/timer.h>
 #include <linux/tty.h>		/* struct tty_struct */
+#include <asm/local.h>
 
 #include <net/irda/irias_object.h>
 #include <net/irda/ircomm_core.h>
@@ -105,8 +106,8 @@ struct ircomm_tty_cb {
         unsigned short    close_delay;
         unsigned short    closing_wait; /* time to wait before closing */
 
-	int  open_count;
-	int  blocked_open;	/* # of blocked opens */
+	local_t open_count;
+	local_t blocked_open;	/* # of blocked opens */
 
 	/* Protect concurent access to :
 	 *	o self->open_count
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/iucv/af_iucv.h linux-2.6.32.60-pax/include/net/iucv/af_iucv.h
--- linux-2.6.32.60/include/net/iucv/af_iucv.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/iucv/af_iucv.h	2012-03-13 13:15:35.560097967 +0100
@@ -87,7 +87,7 @@ struct iucv_sock {
 struct iucv_sock_list {
 	struct hlist_head head;
 	rwlock_t	  lock;
-	atomic_t	  autobind_name;
+	atomic_unchecked_t autobind_name;
 };
 
 unsigned int iucv_sock_poll(struct file *file, struct socket *sock,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/lapb.h linux-2.6.32.60-pax/include/net/lapb.h
--- linux-2.6.32.60/include/net/lapb.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/lapb.h	2012-03-13 13:15:35.560097967 +0100
@@ -95,7 +95,7 @@ struct lapb_cb {
 	struct sk_buff_head	write_queue;
 	struct sk_buff_head	ack_queue;
 	unsigned char		window;
-	struct lapb_register_struct callbacks;
+	struct lapb_register_struct *callbacks;
 
 	/* FRMR control information */
 	struct lapb_frame	frmr_data;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/neighbour.h linux-2.6.32.60-pax/include/net/neighbour.h
--- linux-2.6.32.60/include/net/neighbour.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/neighbour.h	2012-03-13 13:15:35.560097967 +0100
@@ -131,7 +131,7 @@ struct neigh_ops
 	int			(*connected_output)(struct sk_buff*);
 	int			(*hh_output)(struct sk_buff*);
 	int			(*queue_xmit)(struct sk_buff*);
-};
+} __do_const;
 
 struct pneigh_entry
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/netdma.h linux-2.6.32.60-pax/include/net/netdma.h
--- linux-2.6.32.60/include/net/netdma.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/netdma.h	2012-09-11 20:58:31.540023288 +0200
@@ -24,7 +24,7 @@
 #include <linux/dmaengine.h>
 #include <linux/skbuff.h>
 
-int dma_skb_copy_datagram_iovec(struct dma_chan* chan,
+int __intentional_overflow(3,5) dma_skb_copy_datagram_iovec(struct dma_chan* chan,
 		struct sk_buff *skb, int offset, struct iovec *to,
 		size_t len, struct dma_pinned_list *pinned_list);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/netfilter/nf_queue.h linux-2.6.32.60-pax/include/net/netfilter/nf_queue.h
--- linux-2.6.32.60/include/net/netfilter/nf_queue.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/netfilter/nf_queue.h	2013-01-22 17:38:23.592543624 +0100
@@ -22,7 +22,7 @@ struct nf_queue_handler {
 	int			(*outfn)(struct nf_queue_entry *entry,
 					 unsigned int queuenum);
 	char			*name;
-};
+} __do_const;
 
 extern int nf_register_queue_handler(u_int8_t pf,
 				     const struct nf_queue_handler *qh);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/netlink.h linux-2.6.32.60-pax/include/net/netlink.h
--- linux-2.6.32.60/include/net/netlink.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/netlink.h	2012-03-13 13:15:35.564097967 +0100
@@ -558,7 +558,7 @@ static inline void *nlmsg_get_pos(struct
 static inline void nlmsg_trim(struct sk_buff *skb, const void *mark)
 {
 	if (mark)
-		skb_trim(skb, (unsigned char *) mark - skb->data);
+		skb_trim(skb, (const unsigned char *) mark - skb->data);
 }
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/netns/ipv4.h linux-2.6.32.60-pax/include/net/netns/ipv4.h
--- linux-2.6.32.60/include/net/netns/ipv4.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/netns/ipv4.h	2012-03-13 13:15:35.564097967 +0100
@@ -54,7 +54,7 @@ struct netns_ipv4 {
 	int current_rt_cache_rebuild_count;
 
 	struct timer_list rt_secret_timer;
-	atomic_t rt_genid;
+	atomic_unchecked_t rt_genid;
 
 #ifdef CONFIG_IP_MROUTE
 	struct sock		*mroute_sk;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/protocol.h linux-2.6.32.60-pax/include/net/protocol.h
--- linux-2.6.32.60/include/net/protocol.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/protocol.h	2013-01-22 17:38:23.592543624 +0100
@@ -44,7 +44,7 @@ struct net_protocol {
 	int			(*gro_complete)(struct sk_buff *skb);
 	unsigned int		no_policy:1,
 				netns_ok:1;
-};
+} __do_const;
 
 #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
 struct inet6_protocol 
@@ -64,7 +64,7 @@ struct inet6_protocol
 	int	(*gro_complete)(struct sk_buff *skb);
 
 	unsigned int	flags;	/* INET6_PROTO_xxx */
-};
+} __do_const;
 
 #define INET6_PROTO_NOPOLICY	0x1
 #define INET6_PROTO_FINAL	0x2
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/sctp/sctp.h linux-2.6.32.60-pax/include/net/sctp/sctp.h
--- linux-2.6.32.60/include/net/sctp/sctp.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/sctp/sctp.h	2012-03-13 13:15:35.564097967 +0100
@@ -305,8 +305,8 @@ extern int sctp_debug_flag;
 
 #else	/* SCTP_DEBUG */
 
-#define SCTP_DEBUG_PRINTK(whatever...)
-#define SCTP_DEBUG_PRINTK_IPADDR(whatever...)
+#define SCTP_DEBUG_PRINTK(whatever...) do {} while (0)
+#define SCTP_DEBUG_PRINTK_IPADDR(whatever...) do {} while (0)
 #define SCTP_ENABLE_DEBUG
 #define SCTP_DISABLE_DEBUG
 #define SCTP_ASSERT(expr, str, func)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/sctp/structs.h linux-2.6.32.60-pax/include/net/sctp/structs.h
--- linux-2.6.32.60/include/net/sctp/structs.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/sctp/structs.h	2013-01-22 17:38:23.596543624 +0100
@@ -608,7 +608,7 @@ struct sctp_af {
 	int		sockaddr_len;
 	sa_family_t	sa_family;
 	struct list_head list;
-};
+} __do_const;
 
 struct sctp_af *sctp_get_af_specific(sa_family_t);
 int sctp_register_af(struct sctp_af *);
@@ -628,7 +628,7 @@ struct sctp_pf {
 					  struct sctp_association *asoc);
 	void (*addr_v4map) (struct sctp_sock *, union sctp_addr *);
 	struct sctp_af *af;
-};
+} __do_const;
 
 
 /* Structure to track chunk fragments that have been acked, but peer
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/sock.h linux-2.6.32.60-pax/include/net/sock.h
--- linux-2.6.32.60/include/net/sock.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/sock.h	2012-09-11 20:58:31.540023288 +0200
@@ -272,7 +272,7 @@ struct sock {
 	rwlock_t		sk_callback_lock;
 	int			sk_err,
 				sk_err_soft;
-	atomic_t		sk_drops;
+	atomic_unchecked_t	sk_drops;
 	unsigned short		sk_ack_backlog;
 	unsigned short		sk_max_ack_backlog;
 	__u32			sk_priority;
@@ -1398,7 +1398,7 @@ static inline void sk_stream_moderate_sn
 	}
 }
 
-struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp);
+struct sk_buff * __intentional_overflow(0) sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp);
 
 static inline struct page *sk_stream_alloc_page(struct sock *sk)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/tcp.h linux-2.6.32.60-pax/include/net/tcp.h
--- linux-2.6.32.60/include/net/tcp.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/tcp.h	2013-01-22 17:41:36.868533305 +0100
@@ -483,7 +483,7 @@ extern void tcp_retransmit_timer(struct
 extern void tcp_xmit_retransmit_queue(struct sock *);
 extern void tcp_simple_retransmit(struct sock *);
 extern int tcp_trim_head(struct sock *, struct sk_buff *, u32);
-extern int tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int);
+extern int __intentional_overflow(3) tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int);
 
 extern void tcp_send_probe0(struct sock *);
 extern void tcp_send_partial(struct sock *);
@@ -632,8 +632,8 @@ struct tcp_skb_cb {
 		struct inet6_skb_parm	h6;
 #endif
 	} header;	/* For incoming frames		*/
-	__u32		seq;		/* Starting sequence number	*/
-	__u32		end_seq;	/* SEQ + FIN + SYN + datalen	*/
+	__u32		seq __intentional_overflow(0);	/* Starting sequence number	*/
+	__u32		end_seq __intentional_overflow(0);	/* SEQ + FIN + SYN + datalen	*/
 	__u32		when;		/* used to compute rtt's	*/
 	__u8		flags;		/* TCP header flags.		*/
 
@@ -658,7 +658,7 @@ struct tcp_skb_cb {
 #define TCPCB_EVER_RETRANS	0x80	/* Ever retransmitted frame	*/
 #define TCPCB_RETRANS		(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)
 
-	__u32		ack_seq;	/* Sequence number ACK'd	*/
+	__u32		ack_seq __intentional_overflow(0);	/* Sequence number ACK'd	*/
 };
 
 #define TCP_SKB_CB(__skb)	((struct tcp_skb_cb *)&((__skb)->cb[0]))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/net/xfrm.h linux-2.6.32.60-pax/include/net/xfrm.h
--- linux-2.6.32.60/include/net/xfrm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/net/xfrm.h	2013-01-22 17:38:23.472543631 +0100
@@ -389,7 +389,7 @@ struct xfrm_mode {
 	struct module *owner;
 	unsigned int encap;
 	int flags;
-};
+} __do_const;
 
 /* Flags for xfrm_mode. */
 enum {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/rdma/iw_cm.h linux-2.6.32.60-pax/include/rdma/iw_cm.h
--- linux-2.6.32.60/include/rdma/iw_cm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/rdma/iw_cm.h	2012-03-13 13:15:35.568097967 +0100
@@ -129,7 +129,7 @@ struct iw_cm_verbs {
 					 int backlog);
 
 	int		(*destroy_listen)(struct iw_cm_id *cm_id);
-};
+} __no_const;
 
 /**
  * iw_create_cm_id - Create an IW CM identifier.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/scsi/libfc.h linux-2.6.32.60-pax/include/scsi/libfc.h
--- linux-2.6.32.60/include/scsi/libfc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/scsi/libfc.h	2012-03-13 13:15:35.568097967 +0100
@@ -675,6 +675,7 @@ struct libfc_function_template {
 	 */
 	void (*disc_stop_final) (struct fc_lport *);
 };
+typedef struct libfc_function_template __no_const libfc_function_template_no_const;
 
 /* information used by the discovery layer */
 struct fc_disc {
@@ -707,7 +708,7 @@ struct fc_lport {
 	struct fc_disc          disc;
 
 	/* Operational Information */
-	struct libfc_function_template tt;
+	libfc_function_template_no_const tt;
 	u8			link_up;
 	u8			qfull;
 	enum fc_lport_state	state;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/scsi/scsi_device.h linux-2.6.32.60-pax/include/scsi/scsi_device.h
--- linux-2.6.32.60/include/scsi/scsi_device.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/scsi/scsi_device.h	2012-03-13 13:15:35.572097967 +0100
@@ -156,9 +156,9 @@ struct scsi_device {
 	unsigned int max_device_blocked; /* what device_blocked counts down from  */
 #define SCSI_DEFAULT_DEVICE_BLOCKED	3
 
-	atomic_t iorequest_cnt;
-	atomic_t iodone_cnt;
-	atomic_t ioerr_cnt;
+	atomic_unchecked_t iorequest_cnt;
+	atomic_unchecked_t iodone_cnt;
+	atomic_unchecked_t ioerr_cnt;
 
 	struct device		sdev_gendev,
 				sdev_dev;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/scsi/scsi_transport_fc.h linux-2.6.32.60-pax/include/scsi/scsi_transport_fc.h
--- linux-2.6.32.60/include/scsi/scsi_transport_fc.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/scsi/scsi_transport_fc.h	2012-03-13 13:15:35.576097966 +0100
@@ -708,7 +708,7 @@ struct fc_function_template {
 	unsigned long	show_host_system_hostname:1;
 
 	unsigned long	disable_target_scan:1;
-};
+} __do_const;
 
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/sound/ymfpci.h linux-2.6.32.60-pax/include/sound/ymfpci.h
--- linux-2.6.32.60/include/sound/ymfpci.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/sound/ymfpci.h	2012-03-13 13:15:35.588097966 +0100
@@ -358,7 +358,7 @@ struct snd_ymfpci {
 	spinlock_t reg_lock;
 	spinlock_t voice_lock;
 	wait_queue_head_t interrupt_sleep;
-	atomic_t interrupt_sleep_count;
+	atomic_unchecked_t interrupt_sleep_count;
 	struct snd_info_entry *proc_entry;
 	const struct firmware *dsp_microcode;
 	const struct firmware *controller_microcode;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/trace/events/irq.h linux-2.6.32.60-pax/include/trace/events/irq.h
--- linux-2.6.32.60/include/trace/events/irq.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/trace/events/irq.h	2012-03-13 13:15:35.588097966 +0100
@@ -34,7 +34,7 @@
  */
 TRACE_EVENT(irq_handler_entry,
 
-	TP_PROTO(int irq, struct irqaction *action),
+	TP_PROTO(int irq, const struct irqaction *action),
 
 	TP_ARGS(irq, action),
 
@@ -64,7 +64,7 @@ TRACE_EVENT(irq_handler_entry,
  */
 TRACE_EVENT(irq_handler_exit,
 
-	TP_PROTO(int irq, struct irqaction *action, int ret),
+	TP_PROTO(int irq, const struct irqaction *action, int ret),
 
 	TP_ARGS(irq, action, ret),
 
@@ -95,7 +95,7 @@ TRACE_EVENT(irq_handler_exit,
  */
 TRACE_EVENT(softirq_entry,
 
-	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+	TP_PROTO(const struct softirq_action *h, const struct softirq_action *vec),
 
 	TP_ARGS(h, vec),
 
@@ -124,7 +124,7 @@ TRACE_EVENT(softirq_entry,
  */
 TRACE_EVENT(softirq_exit,
 
-	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+	TP_PROTO(const struct softirq_action *h, const struct softirq_action *vec),
 
 	TP_ARGS(h, vec),
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/include/video/uvesafb.h linux-2.6.32.60-pax/include/video/uvesafb.h
--- linux-2.6.32.60/include/video/uvesafb.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/include/video/uvesafb.h	2012-03-13 13:15:35.592097965 +0100
@@ -177,6 +177,7 @@ struct uvesafb_par {
 	u8 ypan;			/* 0 - nothing, 1 - ypan, 2 - ywrap */
 	u8 pmi_setpal;			/* PMI for palette changes */
 	u16 *pmi_base;			/* protected mode interface location */
+	u8 *pmi_code;			/* protected mode code location */
 	void *pmi_start;
 	void *pmi_pal;
 	u8 *vbe_state_orig;		/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/do_mounts.c linux-2.6.32.60-pax/init/do_mounts.c
--- linux-2.6.32.60/init/do_mounts.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/do_mounts.c	2012-03-13 13:15:35.592097965 +0100
@@ -216,11 +216,11 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = sys_mount((__force char __user *)name, (__force char __user *)"/root", (__force char __user *)fs, flags, (__force void __user *)data);
 	if (err)
 		return err;
 
-	sys_chdir("/root");
+	sys_chdir((__force const char __user *)"/root");
 	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       current->fs->pwd.mnt->mnt_sb->s_type->name,
@@ -311,18 +311,18 @@ void __init change_floppy(char *fmt, ...
 	va_start(args, fmt);
 	vsprintf(buf, fmt, args);
 	va_end(args);
-	fd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);
+	fd = sys_open((char __user *)"/dev/root", O_RDWR | O_NDELAY, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, FDEJECT, 0);
 		sys_close(fd);
 	}
 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
-	fd = sys_open("/dev/console", O_RDWR, 0);
+	fd = sys_open((char __user *)"/dev/console", O_RDWR, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, TCGETS, (long)&termios);
 		termios.c_lflag &= ~ICANON;
 		sys_ioctl(fd, TCSETSF, (long)&termios);
-		sys_read(fd, &c, 1);
+		sys_read(fd, (char __user *)&c, 1);
 		termios.c_lflag |= ICANON;
 		sys_ioctl(fd, TCSETSF, (long)&termios);
 		sys_close(fd);
@@ -416,6 +416,6 @@ void __init prepare_namespace(void)
 	mount_root();
 out:
 	devtmpfs_mount("dev");
-	sys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot(".");
+	sys_mount((__force char __user *)".", (__force char __user *)"/", NULL, MS_MOVE, NULL);
+	sys_chroot((__force char __user *)".");
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/do_mounts.h linux-2.6.32.60-pax/init/do_mounts.h
--- linux-2.6.32.60/init/do_mounts.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/do_mounts.h	2012-04-08 22:52:45.144281171 +0200
@@ -15,15 +15,15 @@ extern int root_mountflags;
 
 static inline int create_dev(char *name, dev_t dev)
 {
-	sys_unlink(name);
-	return sys_mknod(name, S_IFBLK|0600, new_encode_dev(dev));
+	sys_unlink((char __force_user *)name);
+	return sys_mknod((char __force_user *)name, S_IFBLK|0600, new_encode_dev(dev));
 }
 
 #if BITS_PER_LONG == 32
 static inline u32 bstat(char *name)
 {
 	struct stat64 stat;
-	if (sys_stat64(name, &stat) != 0)
+	if (sys_stat64((char __force_user *)name, (struct stat64 __force_user *)&stat) != 0)
 		return 0;
 	if (!S_ISBLK(stat.st_mode))
 		return 0;
@@ -35,7 +35,7 @@ static inline u32 bstat(char *name)
 static inline u32 bstat(char *name)
 {
 	struct stat stat;
-	if (sys_newstat(name, &stat) != 0)
+	if (sys_newstat((char __force_user *)name, (struct stat __force_user *)&stat) != 0)
 		return 0;
 	if (!S_ISBLK(stat.st_mode))
 		return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/do_mounts_initrd.c linux-2.6.32.60-pax/init/do_mounts_initrd.c
--- linux-2.6.32.60/init/do_mounts_initrd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/do_mounts_initrd.c	2012-03-13 13:15:35.592097965 +0100
@@ -32,7 +32,7 @@ static int __init do_linuxrc(void * shel
 	sys_close(old_fd);sys_close(root_fd);
 	sys_close(0);sys_close(1);sys_close(2);
 	sys_setsid();
-	(void) sys_open("/dev/console",O_RDWR,0);
+	(void) sys_open((__force const char __user *)"/dev/console",O_RDWR,0);
 	(void) sys_dup(0);
 	(void) sys_dup(0);
 	return kernel_execve(shell, argv, envp_init);
@@ -47,13 +47,13 @@ static void __init handle_initrd(void)
 	create_dev("/dev/root.old", Root_RAM0);
 	/* mount initrd on rootfs' /root */
 	mount_block_root("/dev/root.old", root_mountflags & ~MS_RDONLY);
-	sys_mkdir("/old", 0700);
-	root_fd = sys_open("/", 0, 0);
-	old_fd = sys_open("/old", 0, 0);
+	sys_mkdir((const char __force_user *)"/old", 0700);
+	root_fd = sys_open((const char __force_user *)"/", 0, 0);
+	old_fd = sys_open((const char __force_user *)"/old", 0, 0);
 	/* move initrd over / and chdir/chroot in initrd root */
-	sys_chdir("/root");
-	sys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot(".");
+	sys_chdir((const char __force_user *)"/root");
+	sys_mount((char __force_user *)".", (char __force_user *)"/", NULL, MS_MOVE, NULL);
+	sys_chroot((const char __force_user *)".");
 
 	/*
 	 * In case that a resume from disk is carried out by linuxrc or one of
@@ -70,15 +70,15 @@ static void __init handle_initrd(void)
 
 	/* move initrd to rootfs' /old */
 	sys_fchdir(old_fd);
-	sys_mount("/", ".", NULL, MS_MOVE, NULL);
+	sys_mount((char __force_user *)"/", (char __force_user *)".", NULL, MS_MOVE, NULL);
 	/* switch root and cwd back to / of rootfs */
 	sys_fchdir(root_fd);
-	sys_chroot(".");
+	sys_chroot((const char __force_user *)".");
 	sys_close(old_fd);
 	sys_close(root_fd);
 
 	if (new_decode_dev(real_root_dev) == Root_RAM0) {
-		sys_chdir("/old");
+		sys_chdir((const char __force_user *)"/old");
 		return;
 	}
 
@@ -86,17 +86,17 @@ static void __init handle_initrd(void)
 	mount_root();
 
 	printk(KERN_NOTICE "Trying to move old root to /initrd ... ");
-	error = sys_mount("/old", "/root/initrd", NULL, MS_MOVE, NULL);
+	error = sys_mount((char __force_user *)"/old", (char __force_user *)"/root/initrd", NULL, MS_MOVE, NULL);
 	if (!error)
 		printk("okay\n");
 	else {
-		int fd = sys_open("/dev/root.old", O_RDWR, 0);
+		int fd = sys_open((const char __force_user *)"/dev/root.old", O_RDWR, 0);
 		if (error == -ENOENT)
 			printk("/initrd does not exist. Ignored.\n");
 		else
 			printk("failed\n");
 		printk(KERN_NOTICE "Unmounting old root\n");
-		sys_umount("/old", MNT_DETACH);
+		sys_umount((char __force_user *)"/old", MNT_DETACH);
 		printk(KERN_NOTICE "Trying to free ramdisk memory ... ");
 		if (fd < 0) {
 			error = fd;
@@ -119,11 +119,11 @@ int __init initrd_load(void)
 		 * mounted in the normal path.
 		 */
 		if (rd_load_image("/initrd.image") && ROOT_DEV != Root_RAM0) {
-			sys_unlink("/initrd.image");
+			sys_unlink((const char __force_user *)"/initrd.image");
 			handle_initrd();
 			return 1;
 		}
 	}
-	sys_unlink("/initrd.image");
+	sys_unlink((const char __force_user *)"/initrd.image");
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/do_mounts_md.c linux-2.6.32.60-pax/init/do_mounts_md.c
--- linux-2.6.32.60/init/do_mounts_md.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/do_mounts_md.c	2012-03-13 13:15:35.592097965 +0100
@@ -170,7 +170,7 @@ static void __init md_setup_drive(void)
 			partitioned ? "_d" : "", minor,
 			md_setup_args[ent].device_names);
 
-		fd = sys_open(name, 0, 0);
+		fd = sys_open((char __force_user *)name, 0, 0);
 		if (fd < 0) {
 			printk(KERN_ERR "md: open failed - cannot start "
 					"array %s\n", name);
@@ -233,7 +233,7 @@ static void __init md_setup_drive(void)
 			 * array without it
 			 */
 			sys_close(fd);
-			fd = sys_open(name, 0, 0);
+			fd = sys_open((char __force_user *)name, 0, 0);
 			sys_ioctl(fd, BLKRRPART, 0);
 		}
 		sys_close(fd);
@@ -283,7 +283,7 @@ static void __init autodetect_raid(void)
 
 	wait_for_device_probe();
 
-	fd = sys_open("/dev/md0", 0, 0);
+	fd = sys_open((__force char __user *)"/dev/md0", 0, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, RAID_AUTORUN, raid_autopart);
 		sys_close(fd);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/initramfs.c linux-2.6.32.60-pax/init/initramfs.c
--- linux-2.6.32.60/init/initramfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/initramfs.c	2012-03-13 13:15:35.596097965 +0100
@@ -74,7 +74,7 @@ static void __init free_hash(void)
 	}
 }
 
-static long __init do_utime(char __user *filename, time_t mtime)
+static long __init do_utime(__force char __user *filename, time_t mtime)
 {
 	struct timespec t[2];
 
@@ -109,7 +109,7 @@ static void __init dir_utime(void)
 	struct dir_entry *de, *tmp;
 	list_for_each_entry_safe(de, tmp, &dir_list, list) {
 		list_del(&de->list);
-		do_utime(de->name, de->mtime);
+		do_utime((char __force_user *)de->name, de->mtime);
 		kfree(de->name);
 		kfree(de);
 	}
@@ -271,7 +271,7 @@ static int __init maybe_link(void)
 	if (nlink >= 2) {
 		char *old = find_link(major, minor, ino, mode, collected);
 		if (old)
-			return (sys_link(old, collected) < 0) ? -1 : 1;
+			return (sys_link((char __force_user *)old, (char __force_user *)collected) < 0) ? -1 : 1;
 	}
 	return 0;
 }
@@ -280,11 +280,11 @@ static void __init clean_path(char *path
 {
 	struct stat st;
 
-	if (!sys_newlstat(path, &st) && (st.st_mode^mode) & S_IFMT) {
+	if (!sys_newlstat((char __force_user *)path, (struct stat __force_user *)&st) && (st.st_mode^mode) & S_IFMT) {
 		if (S_ISDIR(st.st_mode))
-			sys_rmdir(path);
+			sys_rmdir((char __force_user *)path);
 		else
-			sys_unlink(path);
+			sys_unlink((char __force_user *)path);
 	}
 }
 
@@ -305,7 +305,7 @@ static int __init do_name(void)
 			int openflags = O_WRONLY|O_CREAT;
 			if (ml != 1)
 				openflags |= O_TRUNC;
-			wfd = sys_open(collected, openflags, mode);
+			wfd = sys_open((char __force_user *)collected, openflags, mode);
 
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
@@ -317,17 +317,17 @@ static int __init do_name(void)
 			}
 		}
 	} else if (S_ISDIR(mode)) {
-		sys_mkdir(collected, mode);
-		sys_chown(collected, uid, gid);
-		sys_chmod(collected, mode);
+		sys_mkdir((char __force_user *)collected, mode);
+		sys_chown((char __force_user *)collected, uid, gid);
+		sys_chmod((char __force_user *)collected, mode);
 		dir_add(collected, mtime);
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
-			sys_mknod(collected, mode, rdev);
-			sys_chown(collected, uid, gid);
-			sys_chmod(collected, mode);
-			do_utime(collected, mtime);
+			sys_mknod((char __force_user *)collected, mode, rdev);
+			sys_chown((char __force_user *)collected, uid, gid);
+			sys_chmod((char __force_user *)collected, mode);
+			do_utime((char __force_user *)collected, mtime);
 		}
 	}
 	return 0;
@@ -336,15 +336,15 @@ static int __init do_name(void)
 static int __init do_copy(void)
 {
 	if (count >= body_len) {
-		sys_write(wfd, victim, body_len);
+		sys_write(wfd, (char __force_user *)victim, body_len);
 		sys_close(wfd);
-		do_utime(vcollected, mtime);
+		do_utime((char __force_user *)vcollected, mtime);
 		kfree(vcollected);
 		eat(body_len);
 		state = SkipIt;
 		return 0;
 	} else {
-		sys_write(wfd, victim, count);
+		sys_write(wfd, (char __force_user *)victim, count);
 		body_len -= count;
 		eat(count);
 		return 1;
@@ -355,9 +355,9 @@ static int __init do_symlink(void)
 {
 	collected[N_ALIGN(name_len) + body_len] = '\0';
 	clean_path(collected, 0);
-	sys_symlink(collected + N_ALIGN(name_len), collected);
-	sys_lchown(collected, uid, gid);
-	do_utime(collected, mtime);
+	sys_symlink((char __force_user *)collected + N_ALIGN(name_len), (char __force_user *)collected);
+	sys_lchown((char __force_user *)collected, uid, gid);
+	do_utime((char __force_user *)collected, mtime);
 	state = SkipIt;
 	next_state = Reset;
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/Kconfig linux-2.6.32.60-pax/init/Kconfig
--- linux-2.6.32.60/init/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/Kconfig	2012-03-13 13:15:35.596097965 +0100
@@ -1004,7 +1004,7 @@ config SLUB_DEBUG
 
 config COMPAT_BRK
 	bool "Disable heap randomization"
-	default y
+	default n
 	help
 	  Randomizing heap placement makes heap exploits harder, but it
 	  also breaks ancient binaries (including anything libc5 based).
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/main.c linux-2.6.32.60-pax/init/main.c
--- linux-2.6.32.60/init/main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/main.c	2013-01-22 17:39:16.884540779 +0100
@@ -183,6 +183,51 @@ static int __init set_reset_devices(char
 
 __setup("reset_devices", set_reset_devices);
 
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
+extern char pax_enter_kernel_user[];
+extern char pax_exit_kernel_user[];
+extern pgdval_t clone_pgd_mask;
+#endif
+
+#if defined(CONFIG_X86) && defined(CONFIG_PAX_MEMORY_UDEREF)
+static int __init setup_pax_nouderef(char *str)
+{
+#ifdef CONFIG_X86_32
+	unsigned int cpu;
+	struct desc_struct *gdt;
+
+	for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
+		gdt = get_cpu_gdt_table(cpu);
+		gdt[GDT_ENTRY_KERNEL_DS].type = 3;
+		gdt[GDT_ENTRY_KERNEL_DS].limit = 0xf;
+		gdt[GDT_ENTRY_DEFAULT_USER_CS].limit = 0xf;
+		gdt[GDT_ENTRY_DEFAULT_USER_DS].limit = 0xf;
+	}
+	loadsegment(ds, __KERNEL_DS);
+	loadsegment(es, __KERNEL_DS);
+	loadsegment(ss, __KERNEL_DS);
+#else
+	memcpy(pax_enter_kernel_user, (unsigned char []){0xc3}, 1);
+	memcpy(pax_exit_kernel_user, (unsigned char []){0xc3}, 1);
+	clone_pgd_mask = ~(pgdval_t)0UL;
+#endif
+
+	return 0;
+}
+early_param("pax_nouderef", setup_pax_nouderef);
+#endif
+
+#ifdef CONFIG_PAX_SOFTMODE
+int pax_softmode;
+
+static int __init setup_pax_softmode(char *str)
+{
+	get_option(&str, &pax_softmode);
+	return 1;
+}
+__setup("pax_softmode=", setup_pax_softmode);
+#endif
+
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
 static const char *panic_later, *panic_param;
@@ -705,64 +750,75 @@ int initcall_debug;
 core_param(initcall_debug, initcall_debug, bool, 0644);
 
 static char msgbuf[64];
-static struct boot_trace_call call;
-static struct boot_trace_ret ret;
+static struct boot_trace_call trace_call;
+static struct boot_trace_ret trace_ret;
 
 int do_one_initcall(initcall_t fn)
 {
 	int count = preempt_count();
 	ktime_t calltime, delta, rettime;
+	const char *msg1 = "", *msg2 = "";
 
 	if (initcall_debug) {
-		call.caller = task_pid_nr(current);
-		printk("calling  %pF @ %i\n", fn, call.caller);
+		trace_call.caller = task_pid_nr(current);
+		printk("calling  %pF @ %i\n", fn, trace_call.caller);
 		calltime = ktime_get();
-		trace_boot_call(&call, fn);
+		trace_boot_call(&trace_call, fn);
 		enable_boot_trace();
 	}
 
-	ret.result = fn();
+	trace_ret.result = fn();
 
 	if (initcall_debug) {
 		disable_boot_trace();
 		rettime = ktime_get();
 		delta = ktime_sub(rettime, calltime);
-		ret.duration = (unsigned long long) ktime_to_ns(delta) >> 10;
-		trace_boot_ret(&ret, fn);
+		trace_ret.duration = (unsigned long long) ktime_to_ns(delta) >> 10;
+		trace_boot_ret(&trace_ret, fn);
 		printk("initcall %pF returned %d after %Ld usecs\n", fn,
-			ret.result, ret.duration);
+			trace_ret.result, trace_ret.duration);
 	}
 
 	msgbuf[0] = 0;
 
-	if (ret.result && ret.result != -ENODEV && initcall_debug)
-		sprintf(msgbuf, "error code %d ", ret.result);
+	if (trace_ret.result && trace_ret.result != -ENODEV && initcall_debug)
+		sprintf(msgbuf, "error code %d ", trace_ret.result);
 
 	if (preempt_count() != count) {
-		strlcat(msgbuf, "preemption imbalance ", sizeof(msgbuf));
+		msg1 = " preemption imbalance";
 		preempt_count() = count;
 	}
 	if (irqs_disabled()) {
-		strlcat(msgbuf, "disabled interrupts ", sizeof(msgbuf));
+		msg2 = " disabled interrupts";
 		local_irq_enable();
 	}
-	if (msgbuf[0]) {
-		printk("initcall %pF returned with %s\n", fn, msgbuf);
+	if (msgbuf[0] || *msg1 || *msg2) {
+		printk("initcall %pF returned with %s%s%s\n", fn, msgbuf, msg1, msg2);
 	}
 
-	return ret.result;
+	return trace_ret.result;
 }
 
 
 extern initcall_t __initcall_start[], __initcall_end[], __early_initcall_end[];
 
+#ifdef CONFIG_PAX_LATENT_ENTROPY
+u64 latent_entropy;
+#endif
+
 static void __init do_initcalls(void)
 {
 	initcall_t *call;
 
-	for (call = __early_initcall_end; call < __initcall_end; call++)
+	for (call = __early_initcall_end; call < __initcall_end; call++) {
 		do_one_initcall(*call);
 
+#ifdef CONFIG_PAX_LATENT_ENTROPY
+		add_device_randomness(&latent_entropy, sizeof(latent_entropy));
+#endif
+
+	}
+
 	/* Make sure there is no pending stuff from the initcall sequence */
 	flush_scheduled_work();
 }
@@ -790,8 +846,14 @@ static void __init do_pre_smp_initcalls(
 {
 	initcall_t *call;
 
-	for (call = __initcall_start; call < __early_initcall_end; call++)
+	for (call = __initcall_start; call < __early_initcall_end; call++) {
 		do_one_initcall(*call);
+
+#ifdef CONFIG_PAX_LATENT_ENTROPY
+		add_device_randomness(&latent_entropy, sizeof(latent_entropy));
+#endif
+
+	}
 }
 
 static void run_init_process(char *init_filename)
@@ -893,7 +955,7 @@ static int __init kernel_init(void * unu
 	if (!ramdisk_execute_command)
 		ramdisk_execute_command = "/init";
 
-	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
+	if (sys_access((const char __force_user *) ramdisk_execute_command, 0) != 0) {
 		ramdisk_execute_command = NULL;
 		prepare_namespace();
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/init/noinitramfs.c linux-2.6.32.60-pax/init/noinitramfs.c
--- linux-2.6.32.60/init/noinitramfs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/init/noinitramfs.c	2012-03-13 13:15:35.596097965 +0100
@@ -29,7 +29,7 @@ static int __init default_rootfs(void)
 {
 	int err;
 
-	err = sys_mkdir("/dev", 0755);
+	err = sys_mkdir((const char __user *)"/dev", 0755);
 	if (err < 0)
 		goto out;
 
@@ -39,7 +39,7 @@ static int __init default_rootfs(void)
 	if (err < 0)
 		goto out;
 
-	err = sys_mkdir("/root", 0700);
+	err = sys_mkdir((const char __user *)"/root", 0700);
 	if (err < 0)
 		goto out;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/ipc/msg.c linux-2.6.32.60-pax/ipc/msg.c
--- linux-2.6.32.60/ipc/msg.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/ipc/msg.c	2012-03-13 13:15:35.600097965 +0100
@@ -310,18 +310,19 @@ static inline int msg_security(struct ke
 	return security_msg_queue_associate(msq, msgflg);
 }
 
+static struct ipc_ops msg_ops = {
+	.getnew		= newque,
+	.associate	= msg_security,
+	.more_checks	= NULL
+};
+
 SYSCALL_DEFINE2(msgget, key_t, key, int, msgflg)
 {
 	struct ipc_namespace *ns;
-	struct ipc_ops msg_ops;
 	struct ipc_params msg_params;
 
 	ns = current->nsproxy->ipc_ns;
 
-	msg_ops.getnew = newque;
-	msg_ops.associate = msg_security;
-	msg_ops.more_checks = NULL;
-
 	msg_params.key = key;
 	msg_params.flg = msgflg;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/ipc/sem.c linux-2.6.32.60-pax/ipc/sem.c
--- linux-2.6.32.60/ipc/sem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/ipc/sem.c	2012-03-13 13:15:35.600097965 +0100
@@ -309,10 +309,15 @@ static inline int sem_more_checks(struct
 	return 0;
 }
 
+static struct ipc_ops sem_ops = {
+	.getnew		= newary,
+	.associate	= sem_security,
+	.more_checks	= sem_more_checks
+};
+
 SYSCALL_DEFINE3(semget, key_t, key, int, nsems, int, semflg)
 {
 	struct ipc_namespace *ns;
-	struct ipc_ops sem_ops;
 	struct ipc_params sem_params;
 
 	ns = current->nsproxy->ipc_ns;
@@ -320,10 +325,6 @@ SYSCALL_DEFINE3(semget, key_t, key, int,
 	if (nsems < 0 || nsems > ns->sc_semmsl)
 		return -EINVAL;
 
-	sem_ops.getnew = newary;
-	sem_ops.associate = sem_security;
-	sem_ops.more_checks = sem_more_checks;
-
 	sem_params.key = key;
 	sem_params.flg = semflg;
 	sem_params.u.nsems = nsems;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/ipc/shm.c linux-2.6.32.60-pax/ipc/shm.c
--- linux-2.6.32.60/ipc/shm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/ipc/shm.c	2012-03-13 13:15:35.600097965 +0100
@@ -446,18 +446,19 @@ static inline int shm_more_checks(struct
 	return 0;
 }
 
+static struct ipc_ops shm_ops = {
+	.getnew		= newseg,
+	.associate	= shm_security,
+	.more_checks	= shm_more_checks
+};
+
 SYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg)
 {
 	struct ipc_namespace *ns;
-	struct ipc_ops shm_ops;
 	struct ipc_params shm_params;
 
 	ns = current->nsproxy->ipc_ns;
 
-	shm_ops.getnew = newseg;
-	shm_ops.associate = shm_security;
-	shm_ops.more_checks = shm_more_checks;
-
 	shm_params.key = key;
 	shm_params.flg = shmflg;
 	shm_params.u.size = size;
@@ -857,6 +858,12 @@ long do_shmat(int shmid, char __user *sh
 		f_mode = FMODE_READ | FMODE_WRITE;
 	}
 	if (shmflg & SHM_EXEC) {
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (current->mm->pax_flags & MF_PAX_MPROTECT)
+			goto out;
+#endif
+
 		prot |= PROT_EXEC;
 		acc_mode |= S_IXUGO;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/acct.c linux-2.6.32.60-pax/kernel/acct.c
--- linux-2.6.32.60/kernel/acct.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/acct.c	2012-03-13 13:15:35.600097965 +0100
@@ -579,7 +579,7 @@ static void do_acct_process(struct bsd_a
 	 */
 	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
-	file->f_op->write(file, (char *)&ac,
+	file->f_op->write(file, (char __force_user *)&ac,
 			       sizeof(acct_t), &file->f_pos);
 	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
 	set_fs(fs);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/audit.c linux-2.6.32.60-pax/kernel/audit.c
--- linux-2.6.32.60/kernel/audit.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/audit.c	2012-03-13 13:15:35.604097965 +0100
@@ -110,7 +110,7 @@ u32		audit_sig_sid = 0;
    3) suppressed due to audit_rate_limit
    4) suppressed due to audit_backlog_limit
 */
-static atomic_t    audit_lost = ATOMIC_INIT(0);
+static atomic_unchecked_t    audit_lost = ATOMIC_INIT(0);
 
 /* The netlink socket. */
 static struct sock *audit_sock;
@@ -232,7 +232,7 @@ void audit_log_lost(const char *message)
 	unsigned long		now;
 	int			print;
 
-	atomic_inc(&audit_lost);
+	atomic_inc_unchecked(&audit_lost);
 
 	print = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);
 
@@ -251,7 +251,7 @@ void audit_log_lost(const char *message)
 			printk(KERN_WARNING
 				"audit: audit_lost=%d audit_rate_limit=%d "
 				"audit_backlog_limit=%d\n",
-				atomic_read(&audit_lost),
+				atomic_read_unchecked(&audit_lost),
 				audit_rate_limit,
 				audit_backlog_limit);
 		audit_panic(message);
@@ -691,7 +691,7 @@ static int audit_receive_msg(struct sk_b
 		status_set.pid		 = audit_pid;
 		status_set.rate_limit	 = audit_rate_limit;
 		status_set.backlog_limit = audit_backlog_limit;
-		status_set.lost		 = atomic_read(&audit_lost);
+		status_set.lost		 = atomic_read_unchecked(&audit_lost);
 		status_set.backlog	 = skb_queue_len(&audit_skb_queue);
 		audit_send_reply(NETLINK_CB(skb).pid, seq, AUDIT_GET, 0, 0,
 				 &status_set, sizeof(status_set));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/auditsc.c linux-2.6.32.60-pax/kernel/auditsc.c
--- linux-2.6.32.60/kernel/auditsc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/auditsc.c	2012-03-13 13:15:35.604097965 +0100
@@ -2113,7 +2113,7 @@ int auditsc_get_stamp(struct audit_conte
 }
 
 /* global counter which is incremented every time something logs in */
-static atomic_t session_id = ATOMIC_INIT(0);
+static atomic_unchecked_t session_id = ATOMIC_INIT(0);
 
 /**
  * audit_set_loginuid - set a task's audit_context loginuid
@@ -2126,7 +2126,7 @@ static atomic_t session_id = ATOMIC_INIT
  */
 int audit_set_loginuid(struct task_struct *task, uid_t loginuid)
 {
-	unsigned int sessionid = atomic_inc_return(&session_id);
+	unsigned int sessionid = atomic_inc_return_unchecked(&session_id);
 	struct audit_context *context = task->audit_context;
 
 	if (context && context->in_syscall) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/capability.c linux-2.6.32.60-pax/kernel/capability.c
--- linux-2.6.32.60/kernel/capability.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/capability.c	2012-09-20 00:53:06.414663488 +0200
@@ -254,7 +254,7 @@ SYSCALL_DEFINE2(capset, cap_user_header_
 	if (pid != 0 && pid != task_pid_vnr(current))
 		return -EPERM;
 
-	if (copy_from_user(&kdata, data,
+	if (tocopy > _KERNEL_CAPABILITY_U32S || copy_from_user(&kdata, data,
 			   tocopy * sizeof(struct __user_cap_data_struct)))
 		return -EFAULT;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/compat.c linux-2.6.32.60-pax/kernel/compat.c
--- linux-2.6.32.60/kernel/compat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/compat.c	2012-03-13 13:15:35.608097965 +0100
@@ -108,7 +108,7 @@ static long compat_nanosleep_restart(str
 	mm_segment_t oldfs;
 	long ret;
 
-	restart->nanosleep.rmtp = (struct timespec __user *) &rmt;
+	restart->nanosleep.rmtp = (struct timespec __force_user *) &rmt;
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	ret = hrtimer_nanosleep_restart(restart);
@@ -140,7 +140,7 @@ asmlinkage long compat_sys_nanosleep(str
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	ret = hrtimer_nanosleep(&tu,
-				rmtp ? (struct timespec __user *)&rmt : NULL,
+				rmtp ? (struct timespec __force_user *)&rmt : NULL,
 				HRTIMER_MODE_REL, CLOCK_MONOTONIC);
 	set_fs(oldfs);
 
@@ -247,7 +247,7 @@ asmlinkage long compat_sys_sigpending(co
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
-	ret = sys_sigpending((old_sigset_t __user *) &s);
+	ret = sys_sigpending((old_sigset_t __force_user *) &s);
 	set_fs(old_fs);
 	if (ret == 0)
 		ret = put_user(s, set);
@@ -266,8 +266,8 @@ asmlinkage long compat_sys_sigprocmask(i
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
 	ret = sys_sigprocmask(how,
-			      set ? (old_sigset_t __user *) &s : NULL,
-			      oset ? (old_sigset_t __user *) &s : NULL);
+			      set ? (old_sigset_t __force_user *) &s : NULL,
+			      oset ? (old_sigset_t __force_user *) &s : NULL);
 	set_fs(old_fs);
 	if (ret == 0)
 		if (oset)
@@ -310,7 +310,7 @@ asmlinkage long compat_sys_old_getrlimit
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
-	ret = sys_old_getrlimit(resource, &r);
+	ret = sys_old_getrlimit(resource, (struct rlimit __force_user *)&r);
 	set_fs(old_fs);
 
 	if (!ret) {
@@ -385,7 +385,7 @@ asmlinkage long compat_sys_getrusage(int
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
-	ret = sys_getrusage(who, (struct rusage __user *) &r);
+	ret = sys_getrusage(who, (struct rusage __force_user *) &r);
 	set_fs(old_fs);
 
 	if (ret)
@@ -412,8 +412,8 @@ compat_sys_wait4(compat_pid_t pid, compa
 		set_fs (KERNEL_DS);
 		ret = sys_wait4(pid,
 				(stat_addr ?
-				 (unsigned int __user *) &status : NULL),
-				options, (struct rusage __user *) &r);
+				 (unsigned int __force_user *) &status : NULL),
+				options, (struct rusage __force_user *) &r);
 		set_fs (old_fs);
 
 		if (ret > 0) {
@@ -438,8 +438,8 @@ asmlinkage long compat_sys_waitid(int wh
 	memset(&info, 0, sizeof(info));
 
 	set_fs(KERNEL_DS);
-	ret = sys_waitid(which, pid, (siginfo_t __user *)&info, options,
-			 uru ? (struct rusage __user *)&ru : NULL);
+	ret = sys_waitid(which, pid, (siginfo_t __force_user *)&info, options,
+			 uru ? (struct rusage __force_user *)&ru : NULL);
 	set_fs(old_fs);
 
 	if ((ret < 0) || (info.si_signo == 0))
@@ -569,8 +569,8 @@ long compat_sys_timer_settime(timer_t ti
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_timer_settime(timer_id, flags,
-				(struct itimerspec __user *) &newts,
-				(struct itimerspec __user *) &oldts);
+				(struct itimerspec __force_user *) &newts,
+				(struct itimerspec __force_user *) &oldts);
 	set_fs(oldfs);
 	if (!err && old && put_compat_itimerspec(old, &oldts))
 		return -EFAULT;
@@ -587,7 +587,7 @@ long compat_sys_timer_gettime(timer_t ti
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_timer_gettime(timer_id,
-				(struct itimerspec __user *) &ts);
+				(struct itimerspec __force_user *) &ts);
 	set_fs(oldfs);
 	if (!err && put_compat_itimerspec(setting, &ts))
 		return -EFAULT;
@@ -606,7 +606,7 @@ long compat_sys_clock_settime(clockid_t
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_clock_settime(which_clock,
-				(struct timespec __user *) &ts);
+				(struct timespec __force_user *) &ts);
 	set_fs(oldfs);
 	return err;
 }
@@ -621,7 +621,7 @@ long compat_sys_clock_gettime(clockid_t
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_clock_gettime(which_clock,
-				(struct timespec __user *) &ts);
+				(struct timespec __force_user *) &ts);
 	set_fs(oldfs);
 	if (!err && put_compat_timespec(&ts, tp))
 		return -EFAULT;
@@ -638,7 +638,7 @@ long compat_sys_clock_getres(clockid_t w
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_clock_getres(which_clock,
-			       (struct timespec __user *) &ts);
+			       (struct timespec __force_user *) &ts);
 	set_fs(oldfs);
 	if (!err && tp && put_compat_timespec(&ts, tp))
 		return -EFAULT;
@@ -650,9 +650,9 @@ static long compat_clock_nanosleep_resta
 	long err;
 	mm_segment_t oldfs;
 	struct timespec tu;
-	struct compat_timespec *rmtp = restart->nanosleep.compat_rmtp;
+	struct compat_timespec __user *rmtp = restart->nanosleep.compat_rmtp;
 
-	restart->nanosleep.rmtp = (struct timespec __user *) &tu;
+	restart->nanosleep.rmtp = (struct timespec __force_user *) &tu;
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = clock_nanosleep_restart(restart);
@@ -684,8 +684,8 @@ long compat_sys_clock_nanosleep(clockid_
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	err = sys_clock_nanosleep(which_clock, flags,
-				  (struct timespec __user *) &in,
-				  (struct timespec __user *) &out);
+				  (struct timespec __force_user *) &in,
+				  (struct timespec __force_user *) &out);
 	set_fs(oldfs);
 
 	if ((err == -ERESTART_RESTARTBLOCK) && rmtp &&
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/cpu.c linux-2.6.32.60-pax/kernel/cpu.c
--- linux-2.6.32.60/kernel/cpu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/cpu.c	2012-03-13 13:15:35.608097965 +0100
@@ -20,7 +20,7 @@
 /* Serializes the updates to cpu_online_mask, cpu_present_mask */
 static DEFINE_MUTEX(cpu_add_remove_lock);
 
-static __cpuinitdata RAW_NOTIFIER_HEAD(cpu_chain);
+static RAW_NOTIFIER_HEAD(cpu_chain);
 
 /* If set, cpu_up and cpu_down will return -EBUSY and do nothing.
  * Should always be manipulated under cpu_add_remove_lock
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/exit.c linux-2.6.32.60-pax/kernel/exit.c
--- linux-2.6.32.60/kernel/exit.c	2012-10-09 11:00:35.496882479 +0200
+++ linux-2.6.32.60-pax/kernel/exit.c	2012-10-09 11:00:39.352883054 +0200
@@ -397,7 +397,7 @@ int allow_signal(int sig)
 	 * know it'll be handled, so that they don't get converted to
 	 * SIGKILL or just silently dropped.
 	 */
-	current->sighand->action[(sig)-1].sa.sa_handler = (void __user *)2;
+	current->sighand->action[(sig)-1].sa.sa_handler = (__force void __user *)2;
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 	return 0;
@@ -1059,7 +1059,7 @@ SYSCALL_DEFINE1(exit, int, error_code)
  * Take down every thread in the group.  This is called by fatal signals
  * as well as by sys_exit_group (below).
  */
-NORET_TYPE void
+__noreturn void
 do_group_exit(int exit_code)
 {
 	struct signal_struct *sig = current->signal;
@@ -1188,7 +1188,7 @@ static int wait_task_zombie(struct wait_
 
 	if (unlikely(wo->wo_flags & WNOWAIT)) {
 		int exit_code = p->exit_code;
-		int why, status;
+		int why;
 
 		get_task_struct(p);
 		read_unlock(&tasklist_lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/fork.c linux-2.6.32.60-pax/kernel/fork.c
--- linux-2.6.32.60/kernel/fork.c	2012-10-09 11:00:35.496882479 +0200
+++ linux-2.6.32.60-pax/kernel/fork.c	2012-10-09 11:00:39.352883054 +0200
@@ -254,7 +254,7 @@ static struct task_struct *dup_task_stru
 	*stackend = STACK_END_MAGIC;	/* for overflow detection */
 
 #ifdef CONFIG_CC_STACKPROTECTOR
-	tsk->stack_canary = get_random_int();
+	tsk->stack_canary = pax_get_random_long();
 #endif
 
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
@@ -294,8 +294,8 @@ static int dup_mmap(struct mm_struct *mm
 	mm->locked_vm = 0;
 	mm->mmap = NULL;
 	mm->mmap_cache = NULL;
-	mm->free_area_cache = oldmm->mmap_base;
-	mm->cached_hole_size = ~0UL;
+	mm->free_area_cache = oldmm->free_area_cache;
+	mm->cached_hole_size = oldmm->cached_hole_size;
 	mm->map_count = 0;
 	cpumask_clear(mm_cpumask(mm));
 	mm->mm_rb = RB_ROOT;
@@ -336,6 +336,7 @@ static int dup_mmap(struct mm_struct *mm
 		tmp->vm_flags &= ~VM_LOCKED;
 		tmp->vm_mm = mm;
 		tmp->vm_next = tmp->vm_prev = NULL;
+		tmp->vm_mirror = NULL;
 		anon_vma_link(tmp);
 		file = tmp->vm_file;
 		if (file) {
@@ -385,6 +386,31 @@ static int dup_mmap(struct mm_struct *mm
 		if (retval)
 			goto out;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (oldmm->pax_flags & MF_PAX_SEGMEXEC) {
+		struct vm_area_struct *mpnt_m;
+
+		for (mpnt = oldmm->mmap, mpnt_m = mm->mmap; mpnt; mpnt = mpnt->vm_next, mpnt_m = mpnt_m->vm_next) {
+			BUG_ON(!mpnt_m || mpnt_m->vm_mirror || mpnt->vm_mm != oldmm || mpnt_m->vm_mm != mm);
+
+			if (!mpnt->vm_mirror)
+				continue;
+
+			if (mpnt->vm_end <= SEGMEXEC_TASK_SIZE) {
+				BUG_ON(mpnt->vm_mirror->vm_mirror != mpnt);
+				mpnt->vm_mirror = mpnt_m;
+			} else {
+				BUG_ON(mpnt->vm_mirror->vm_mirror == mpnt || mpnt->vm_mirror->vm_mirror->vm_mm != mm);
+				mpnt_m->vm_mirror = mpnt->vm_mirror->vm_mirror;
+				mpnt_m->vm_mirror->vm_mirror = mpnt_m;
+				mpnt->vm_mirror->vm_mirror = mpnt;
+			}
+		}
+		BUG_ON(mpnt_m);
+	}
+#endif
+
 	/* a new mm has just been created */
 	arch_dup_mmap(oldmm, mm);
 	retval = 0;
@@ -735,7 +761,7 @@ static int copy_fs(unsigned long clone_f
 			write_unlock(&fs->lock);
 			return -EAGAIN;
 		}
-		fs->users++;
+		atomic_inc(&fs->users);
 		write_unlock(&fs->lock);
 		return 0;
 	}
@@ -1562,7 +1588,7 @@ static int unshare_fs(unsigned long unsh
 		return 0;
 
 	/* don't need lock here; in the worst case we'll do useless copy */
-	if (fs->users == 1)
+	if (atomic_read(&fs->users) == 1)
 		return 0;
 
 	*new_fsp = copy_fs_struct(fs);
@@ -1685,7 +1711,7 @@ SYSCALL_DEFINE1(unshare, unsigned long,
 			fs = current->fs;
 			write_lock(&fs->lock);
 			current->fs = new_fs;
-			if (--fs->users)
+			if (atomic_dec_return(&fs->users))
 				new_fs = NULL;
 			else
 				new_fs = fs;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/futex.c linux-2.6.32.60-pax/kernel/futex.c
--- linux-2.6.32.60/kernel/futex.c	2012-10-09 11:00:35.496882479 +0200
+++ linux-2.6.32.60-pax/kernel/futex.c	2012-10-09 11:00:39.352883054 +0200
@@ -223,6 +223,11 @@ get_futex_key(u32 __user *uaddr, int fsh
 	struct page *page;
 	int err, ro = 0;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && address >= SEGMEXEC_TASK_SIZE)
+		return -EFAULT;
+#endif
+
 	/*
 	 * The futex address must be "naturally" aligned.
 	 */
@@ -1883,7 +1888,7 @@ retry:
 
 	restart = &current_thread_info()->restart_block;
 	restart->fn = futex_wait_restart;
-	restart->futex.uaddr = (u32 *)uaddr;
+	restart->futex.uaddr = uaddr;
 	restart->futex.val = val;
 	restart->futex.time = abs_time->tv64;
 	restart->futex.bitset = bitset;
@@ -2504,7 +2509,7 @@ retry:
  */
 static inline int fetch_robust_entry(struct robust_list __user **entry,
 				     struct robust_list __user * __user *head,
-				     int *pi)
+				     unsigned int *pi)
 {
 	unsigned long uentry;
 
@@ -2685,6 +2690,7 @@ static int __init futex_init(void)
 {
 	u32 curval;
 	int i;
+	mm_segment_t oldfs;
 
 	/*
 	 * This will fail and we want it. Some arch implementations do
@@ -2696,7 +2702,10 @@ static int __init futex_init(void)
 	 * implementation, the non functional ones will return
 	 * -ENOSYS.
 	 */
+	oldfs = get_fs();
+	set_fs(USER_DS);
 	curval = cmpxchg_futex_value_locked(NULL, 0, 0);
+	set_fs(oldfs);
 	if (curval == -EFAULT)
 		futex_cmpxchg_enabled = 1;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/gcov/base.c linux-2.6.32.60-pax/kernel/gcov/base.c
--- linux-2.6.32.60/kernel/gcov/base.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/gcov/base.c	2012-03-13 13:15:35.612097964 +0100
@@ -102,11 +102,6 @@ void gcov_enable_events(void)
 }
 
 #ifdef CONFIG_MODULES
-static inline int within(void *addr, void *start, unsigned long size)
-{
-	return ((addr >= start) && (addr < start + size));
-}
-
 /* Update list and generate events when modules are unloaded. */
 static int gcov_module_notifier(struct notifier_block *nb, unsigned long event,
 				void *data)
@@ -121,7 +116,7 @@ static int gcov_module_notifier(struct n
 	prev = NULL;
 	/* Remove entries located in module from linked list. */
 	for (info = gcov_info_head; info; info = info->next) {
-		if (within(info, mod->module_core, mod->core_size)) {
+		if (within_module_core_rw((unsigned long)info, mod)) {
 			if (prev)
 				prev->next = info->next;
 			else
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/hrtimer.c linux-2.6.32.60-pax/kernel/hrtimer.c
--- linux-2.6.32.60/kernel/hrtimer.c	2012-10-09 11:00:35.496882479 +0200
+++ linux-2.6.32.60-pax/kernel/hrtimer.c	2012-10-09 11:03:16.276904321 +0200
@@ -1402,7 +1402,7 @@ void hrtimer_peek_ahead_timers(void)
 	local_irq_restore(flags);
 }
 
-static void run_hrtimer_softirq(struct softirq_action *h)
+static void run_hrtimer_softirq(void)
 {
 	struct hrtimer_cpu_base *cpu_base = &__get_cpu_var(hrtimer_bases);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/kallsyms.c linux-2.6.32.60-pax/kernel/kallsyms.c
--- linux-2.6.32.60/kernel/kallsyms.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/kallsyms.c	2012-03-13 13:15:35.616097964 +0100
@@ -51,12 +51,33 @@ extern const unsigned long kallsyms_mark
 
 static inline int is_kernel_inittext(unsigned long addr)
 {
+	if (system_state != SYSTEM_BOOTING)
+		return 0;
+
 	if (addr >= (unsigned long)_sinittext
 	    && addr <= (unsigned long)_einittext)
 		return 1;
 	return 0;
 }
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#ifdef CONFIG_MODULES
+static inline int is_module_text(unsigned long addr)
+{
+	if ((unsigned long)MODULES_EXEC_VADDR <= addr && addr <= (unsigned long)MODULES_EXEC_END)
+		return 1;
+
+	addr = ktla_ktva(addr);
+	return (unsigned long)MODULES_EXEC_VADDR <= addr && addr <= (unsigned long)MODULES_EXEC_END;
+}
+#else
+static inline int is_module_text(unsigned long addr)
+{
+	return 0;
+}
+#endif
+#endif
+
 static inline int is_kernel_text(unsigned long addr)
 {
 	if ((addr >= (unsigned long)_stext && addr <= (unsigned long)_etext) ||
@@ -67,13 +88,28 @@ static inline int is_kernel_text(unsigne
 
 static inline int is_kernel(unsigned long addr)
 {
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	if (is_kernel_text(addr) || is_kernel_inittext(addr))
+		return 1;
+
+	if (ktla_ktva((unsigned long)_text) <= addr && addr < (unsigned long)_end)
+#else
 	if (addr >= (unsigned long)_stext && addr <= (unsigned long)_end)
+#endif
+
 		return 1;
 	return in_gate_area_no_task(addr);
 }
 
 static int is_ksym_addr(unsigned long addr)
 {
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	if (is_module_text(addr))
+		return 0;
+#endif
+
 	if (all_var)
 		return is_kernel(addr);
 
@@ -413,7 +449,6 @@ static unsigned long get_ksymbol_core(st
 
 static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)
 {
-	iter->name[0] = '\0';
 	iter->nameoff = get_symbol_offset(new_pos);
 	iter->pos = new_pos;
 }
@@ -501,7 +536,7 @@ static int kallsyms_open(struct inode *i
 	struct kallsym_iter *iter;
 	int ret;
 
-	iter = kmalloc(sizeof(*iter), GFP_KERNEL);
+	iter = kzalloc(sizeof(*iter), GFP_KERNEL);
 	if (!iter)
 		return -ENOMEM;
 	reset_iter(iter, 0);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/kexec.c linux-2.6.32.60-pax/kernel/kexec.c
--- linux-2.6.32.60/kernel/kexec.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/kexec.c	2012-03-13 13:15:35.620097964 +0100
@@ -1028,7 +1028,8 @@ asmlinkage long compat_sys_kexec_load(un
 				unsigned long flags)
 {
 	struct compat_kexec_segment in;
-	struct kexec_segment out, __user *ksegments;
+	struct kexec_segment out;
+	struct kexec_segment __user *ksegments;
 	unsigned long i, result;
 
 	/* Don't allow clients that don't understand the native
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/kgdb.c linux-2.6.32.60-pax/kernel/kgdb.c
--- linux-2.6.32.60/kernel/kgdb.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/kgdb.c	2012-12-14 21:11:13.585805780 +0100
@@ -86,7 +86,7 @@ static int			kgdb_io_module_registered;
 /* Guard for recursive entry */
 static int			exception_level;
 
-static struct kgdb_io		*kgdb_io_ops;
+static struct kgdb_io	*kgdb_io_ops;
 static DEFINE_SPINLOCK(kgdb_registration_lock);
 
 /* kgdb console driver is loaded */
@@ -123,7 +123,7 @@ atomic_t			kgdb_active = ATOMIC_INIT(-1)
  */
 static atomic_t			passive_cpu_wait[NR_CPUS];
 static atomic_t			cpu_in_kgdb[NR_CPUS];
-atomic_t			kgdb_setting_breakpoint;
+atomic_unchecked_t		kgdb_setting_breakpoint;
 
 struct task_struct		*kgdb_usethread;
 struct task_struct		*kgdb_contthread;
@@ -140,7 +140,7 @@ static unsigned long		gdb_regs[(NUMREGBY
 					sizeof(unsigned long)];
 
 /* to keep track of the CPU which is doing the single stepping*/
-atomic_t			kgdb_cpu_doing_single_step = ATOMIC_INIT(-1);
+atomic_unchecked_t		kgdb_cpu_doing_single_step = ATOMIC_INIT(-1);
 
 /*
  * If you are debugging a problem where roundup (the collection of
@@ -815,7 +815,7 @@ static int kgdb_io_ready(int print_wait)
 		return 0;
 	if (kgdb_connected)
 		return 1;
-	if (atomic_read(&kgdb_setting_breakpoint))
+	if (atomic_read_unchecked(&kgdb_setting_breakpoint))
 		return 1;
 	if (print_wait)
 		printk(KERN_CRIT "KGDB: Waiting for remote debugger\n");
@@ -1426,8 +1426,8 @@ acquirelock:
 	 * instance of the exception handler wanted to come into the
 	 * debugger on a different CPU via a single step
 	 */
-	if (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&
-	    atomic_read(&kgdb_cpu_doing_single_step) != cpu) {
+	if (atomic_read_unchecked(&kgdb_cpu_doing_single_step) != -1 &&
+	    atomic_read_unchecked(&kgdb_cpu_doing_single_step) != cpu) {
 
 		atomic_set(&kgdb_active, -1);
 		touch_softlockup_watchdog();
@@ -1712,11 +1712,11 @@ EXPORT_SYMBOL_GPL(kgdb_unregister_io_mod
  */
 void kgdb_breakpoint(void)
 {
-	atomic_set(&kgdb_setting_breakpoint, 1);
+	atomic_set_unchecked(&kgdb_setting_breakpoint, 1);
 	wmb(); /* Sync point before breakpoint */
 	arch_kgdb_breakpoint();
 	wmb(); /* Sync point after breakpoint */
-	atomic_set(&kgdb_setting_breakpoint, 0);
+	atomic_set_unchecked(&kgdb_setting_breakpoint, 0);
 }
 EXPORT_SYMBOL_GPL(kgdb_breakpoint);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/kmod.c linux-2.6.32.60-pax/kernel/kmod.c
--- linux-2.6.32.60/kernel/kmod.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/kmod.c	2012-03-13 13:15:35.624097964 +0100
@@ -231,7 +231,7 @@ static int wait_for_helper(void *data)
 		 *
 		 * Thus the __user pointer cast is valid here.
 		 */
-		sys_wait4(pid, (int __user *)&ret, 0, NULL);
+		sys_wait4(pid, (int __force_user *)&ret, 0, NULL);
 
 		/*
 		 * If ret is 0, either ____call_usermodehelper failed and the
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/kprobes.c linux-2.6.32.60-pax/kernel/kprobes.c
--- linux-2.6.32.60/kernel/kprobes.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/kprobes.c	2012-03-13 13:15:35.624097964 +0100
@@ -183,7 +183,7 @@ static kprobe_opcode_t __kprobes *__get_
 	 * kernel image and loaded module images reside. This is required
 	 * so x86_64 can correctly handle the %rip-relative fixups.
 	 */
-	kip->insns = module_alloc(PAGE_SIZE);
+	kip->insns = module_alloc_exec(PAGE_SIZE);
 	if (!kip->insns) {
 		kfree(kip);
 		return NULL;
@@ -220,7 +220,7 @@ static int __kprobes collect_one_slot(st
 		 */
 		if (!list_is_singular(&kprobe_insn_pages)) {
 			list_del(&kip->list);
-			module_free(NULL, kip->insns);
+			module_free_exec(NULL, kip->insns);
 			kfree(kip);
 		}
 		return 1;
@@ -1189,7 +1189,7 @@ static int __init init_kprobes(void)
 {
 	int i, err = 0;
 	unsigned long offset = 0, size = 0;
-	char *modname, namebuf[128];
+	char *modname, namebuf[KSYM_NAME_LEN];
 	const char *symbol_name;
 	void *addr;
 	struct kprobe_blackpoint *kb;
@@ -1304,7 +1304,7 @@ static int __kprobes show_kprobe_addr(st
 	const char *sym = NULL;
 	unsigned int i = *(loff_t *) v;
 	unsigned long offset = 0;
-	char *modname, namebuf[128];
+	char *modname, namebuf[KSYM_NAME_LEN];
 
 	head = &kprobe_table[i];
 	preempt_disable();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/lockdep.c linux-2.6.32.60-pax/kernel/lockdep.c
--- linux-2.6.32.60/kernel/lockdep.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/lockdep.c	2012-03-13 13:15:35.628097964 +0100
@@ -421,20 +421,20 @@ static struct stack_trace lockdep_init_t
 /*
  * Various lockdep statistics:
  */
-atomic_t chain_lookup_hits;
-atomic_t chain_lookup_misses;
-atomic_t hardirqs_on_events;
-atomic_t hardirqs_off_events;
-atomic_t redundant_hardirqs_on;
-atomic_t redundant_hardirqs_off;
-atomic_t softirqs_on_events;
-atomic_t softirqs_off_events;
-atomic_t redundant_softirqs_on;
-atomic_t redundant_softirqs_off;
-atomic_t nr_unused_locks;
-atomic_t nr_cyclic_checks;
-atomic_t nr_find_usage_forwards_checks;
-atomic_t nr_find_usage_backwards_checks;
+atomic_unchecked_t chain_lookup_hits;
+atomic_unchecked_t chain_lookup_misses;
+atomic_unchecked_t hardirqs_on_events;
+atomic_unchecked_t hardirqs_off_events;
+atomic_unchecked_t redundant_hardirqs_on;
+atomic_unchecked_t redundant_hardirqs_off;
+atomic_unchecked_t softirqs_on_events;
+atomic_unchecked_t softirqs_off_events;
+atomic_unchecked_t redundant_softirqs_on;
+atomic_unchecked_t redundant_softirqs_off;
+atomic_unchecked_t nr_unused_locks;
+atomic_unchecked_t nr_cyclic_checks;
+atomic_unchecked_t nr_find_usage_forwards_checks;
+atomic_unchecked_t nr_find_usage_backwards_checks;
 #endif
 
 /*
@@ -577,6 +577,10 @@ static int static_obj(void *obj)
 	int i;
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+	start = ktla_ktva(start);
+#endif
+
 	/*
 	 * static variable?
 	 */
@@ -592,8 +596,7 @@ static int static_obj(void *obj)
 	 */
 	for_each_possible_cpu(i) {
 		start = (unsigned long) &__per_cpu_start + per_cpu_offset(i);
-		end   = (unsigned long) &__per_cpu_start + PERCPU_ENOUGH_ROOM
-					+ per_cpu_offset(i);
+		end   = start + PERCPU_ENOUGH_ROOM;
 
 		if ((addr >= start) && (addr < end))
 			return 1;
@@ -710,6 +713,7 @@ register_lock_class(struct lockdep_map *
 	if (!static_obj(lock->key)) {
 		debug_locks_off();
 		printk("INFO: trying to register non-static key.\n");
+		printk("lock:%pS key:%pS.\n", lock, lock->key);
 		printk("the code is fine but needs lockdep annotation.\n");
 		printk("turning off the locking correctness validator.\n");
 		dump_stack();
@@ -2751,7 +2755,7 @@ static int __lock_acquire(struct lockdep
 		if (!class)
 			return 0;
 	}
-	debug_atomic_inc((atomic_t *)&class->ops);
+	debug_atomic_inc((atomic_unchecked_t *)&class->ops);
 	if (very_verbose(class)) {
 		printk("\nacquire class [%p] %s", class->key, class->name);
 		if (class->name_version > 1)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/lockdep_internals.h linux-2.6.32.60-pax/kernel/lockdep_internals.h
--- linux-2.6.32.60/kernel/lockdep_internals.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/lockdep_internals.h	2012-03-13 13:15:35.628097964 +0100
@@ -113,26 +113,26 @@ lockdep_count_backward_deps(struct lock_
 /*
  * Various lockdep statistics:
  */
-extern atomic_t chain_lookup_hits;
-extern atomic_t chain_lookup_misses;
-extern atomic_t hardirqs_on_events;
-extern atomic_t hardirqs_off_events;
-extern atomic_t redundant_hardirqs_on;
-extern atomic_t redundant_hardirqs_off;
-extern atomic_t softirqs_on_events;
-extern atomic_t softirqs_off_events;
-extern atomic_t redundant_softirqs_on;
-extern atomic_t redundant_softirqs_off;
-extern atomic_t nr_unused_locks;
-extern atomic_t nr_cyclic_checks;
-extern atomic_t nr_cyclic_check_recursions;
-extern atomic_t nr_find_usage_forwards_checks;
-extern atomic_t nr_find_usage_forwards_recursions;
-extern atomic_t nr_find_usage_backwards_checks;
-extern atomic_t nr_find_usage_backwards_recursions;
-# define debug_atomic_inc(ptr)		atomic_inc(ptr)
-# define debug_atomic_dec(ptr)		atomic_dec(ptr)
-# define debug_atomic_read(ptr)		atomic_read(ptr)
+extern atomic_unchecked_t chain_lookup_hits;
+extern atomic_unchecked_t chain_lookup_misses;
+extern atomic_unchecked_t hardirqs_on_events;
+extern atomic_unchecked_t hardirqs_off_events;
+extern atomic_unchecked_t redundant_hardirqs_on;
+extern atomic_unchecked_t redundant_hardirqs_off;
+extern atomic_unchecked_t softirqs_on_events;
+extern atomic_unchecked_t softirqs_off_events;
+extern atomic_unchecked_t redundant_softirqs_on;
+extern atomic_unchecked_t redundant_softirqs_off;
+extern atomic_unchecked_t nr_unused_locks;
+extern atomic_unchecked_t nr_cyclic_checks;
+extern atomic_unchecked_t nr_cyclic_check_recursions;
+extern atomic_unchecked_t nr_find_usage_forwards_checks;
+extern atomic_unchecked_t nr_find_usage_forwards_recursions;
+extern atomic_unchecked_t nr_find_usage_backwards_checks;
+extern atomic_unchecked_t nr_find_usage_backwards_recursions;
+# define debug_atomic_inc(ptr)		atomic_inc_unchecked(ptr)
+# define debug_atomic_dec(ptr)		atomic_dec_unchecked(ptr)
+# define debug_atomic_read(ptr)		atomic_read_unchecked(ptr)
 #else
 # define debug_atomic_inc(ptr)		do { } while (0)
 # define debug_atomic_dec(ptr)		do { } while (0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/lockdep_proc.c linux-2.6.32.60-pax/kernel/lockdep_proc.c
--- linux-2.6.32.60/kernel/lockdep_proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/lockdep_proc.c	2012-03-13 13:15:35.628097964 +0100
@@ -39,7 +39,7 @@ static void l_stop(struct seq_file *m, v
 
 static void print_name(struct seq_file *m, struct lock_class *class)
 {
-	char str[128];
+	char str[KSYM_NAME_LEN];
 	const char *name = class->name;
 
 	if (!name) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/module.c linux-2.6.32.60-pax/kernel/module.c
--- linux-2.6.32.60/kernel/module.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/module.c	2013-02-17 17:16:58.652165824 +0100
@@ -89,7 +89,8 @@ static DECLARE_WAIT_QUEUE_HEAD(module_wq
 static BLOCKING_NOTIFIER_HEAD(module_notify_list);
 
 /* Bounds of module allocation, for speeding __module_address */
-static unsigned long module_addr_min = -1UL, module_addr_max = 0;
+static unsigned long module_addr_min_rw = -1UL, module_addr_max_rw = 0;
+static unsigned long module_addr_min_rx = -1UL, module_addr_max_rx = 0;
 
 int register_module_notifier(struct notifier_block * nb)
 {
@@ -245,7 +246,7 @@ bool each_symbol(bool (*fn)(const struct
 		return true;
 
 	list_for_each_entry_rcu(mod, &modules, list) {
-		struct symsearch arr[] = {
+		struct symsearch modarr[] = {
 			{ mod->syms, mod->syms + mod->num_syms, mod->crcs,
 			  NOT_GPL_ONLY, false },
 			{ mod->gpl_syms, mod->gpl_syms + mod->num_gpl_syms,
@@ -267,7 +268,7 @@ bool each_symbol(bool (*fn)(const struct
 #endif
 		};
 
-		if (each_symbol_in_section(arr, ARRAY_SIZE(arr), mod, fn, data))
+		if (each_symbol_in_section(modarr, ARRAY_SIZE(modarr), mod, fn, data))
 			return true;
 	}
 	return false;
@@ -442,7 +443,7 @@ static void *percpu_modalloc(unsigned lo
 	void *ptr;
 	int cpu;
 
-	if (align > PAGE_SIZE) {
+	if (align-1 >= PAGE_SIZE) {
 		printk(KERN_WARNING "%s: per-cpu alignment %li > %li\n",
 		       name, align, PAGE_SIZE);
 		align = PAGE_SIZE;
@@ -1545,7 +1546,8 @@ static void free_module(struct module *m
 	destroy_params(mod->kp, mod->num_kp);
 
 	/* This may be NULL, but that's OK */
-	module_free(mod, mod->module_init);
+	module_free(mod, mod->module_init_rw);
+	module_free_exec(mod, mod->module_init_rx);
 	kfree(mod->args);
 	if (mod->percpu)
 		percpu_modfree(mod->percpu);
@@ -1554,10 +1556,12 @@ static void free_module(struct module *m
 		percpu_modfree(mod->refptr);
 #endif
 	/* Free lock-classes: */
-	lockdep_free_key_range(mod->module_core, mod->core_size);
+	lockdep_free_key_range(mod->module_core_rx, mod->core_size_rx);
+	lockdep_free_key_range(mod->module_core_rw, mod->core_size_rw);
 
 	/* Finally, free the core (containing the module structure) */
-	module_free(mod, mod->module_core);
+	module_free_exec(mod, mod->module_core_rx);
+	module_free(mod, mod->module_core_rw);
 
 #ifdef CONFIG_MPU
 	update_protections(current->mm);
@@ -1651,7 +1655,9 @@ static int simplify_symbols(Elf_Shdr *se
 					      strtab + sym[i].st_name, mod);
 			/* Ok if resolved.  */
 			if (ksym) {
+				pax_open_kernel();
 				sym[i].st_value = ksym->value;
+				pax_close_kernel();
 				break;
 			}
 
@@ -1670,7 +1676,9 @@ static int simplify_symbols(Elf_Shdr *se
 				secbase = (unsigned long)mod->percpu;
 			else
 				secbase = sechdrs[sym[i].st_shndx].sh_addr;
+			pax_open_kernel();
 			sym[i].st_value += secbase;
+			pax_close_kernel();
 			break;
 		}
 	}
@@ -1731,11 +1739,12 @@ static void layout_sections(struct modul
 			    || s->sh_entsize != ~0UL
 			    || strstarts(secstrings + s->sh_name, ".init"))
 				continue;
-			s->sh_entsize = get_offset(mod, &mod->core_size, s, i);
+			if ((s->sh_flags & SHF_WRITE) || !(s->sh_flags & SHF_ALLOC))
+				s->sh_entsize = get_offset(mod, &mod->core_size_rw, s, i);
+			else
+				s->sh_entsize = get_offset(mod, &mod->core_size_rx, s, i);
 			DEBUGP("\t%s\n", secstrings + s->sh_name);
 		}
-		if (m == 0)
-			mod->core_text_size = mod->core_size;
 	}
 
 	DEBUGP("Init section allocation order:\n");
@@ -1748,12 +1757,13 @@ static void layout_sections(struct modul
 			    || s->sh_entsize != ~0UL
 			    || !strstarts(secstrings + s->sh_name, ".init"))
 				continue;
-			s->sh_entsize = (get_offset(mod, &mod->init_size, s, i)
-					 | INIT_OFFSET_MASK);
+			if ((s->sh_flags & SHF_WRITE) || !(s->sh_flags & SHF_ALLOC))
+				s->sh_entsize = get_offset(mod, &mod->init_size_rw, s, i);
+			else
+				s->sh_entsize = get_offset(mod, &mod->init_size_rx, s, i);
+			s->sh_entsize |= INIT_OFFSET_MASK;
 			DEBUGP("\t%s\n", secstrings + s->sh_name);
 		}
-		if (m == 0)
-			mod->init_text_size = mod->init_size;
 	}
 }
 
@@ -1857,9 +1867,8 @@ static int is_exported(const char *name,
 
 /* As per nm */
 static char elf_type(const Elf_Sym *sym,
-		     Elf_Shdr *sechdrs,
-		     const char *secstrings,
-		     struct module *mod)
+		     const Elf_Shdr *sechdrs,
+		     const char *secstrings)
 {
 	if (ELF_ST_BIND(sym->st_info) == STB_WEAK) {
 		if (ELF_ST_TYPE(sym->st_info) == STT_OBJECT)
@@ -1934,7 +1943,7 @@ static unsigned long layout_symtab(struc
 
 	/* Put symbol section at end of init part of module. */
 	symsect->sh_flags |= SHF_ALLOC;
-	symsect->sh_entsize = get_offset(mod, &mod->init_size, symsect,
+	symsect->sh_entsize = get_offset(mod, &mod->init_size_rx, symsect,
 					 symindex) | INIT_OFFSET_MASK;
 	DEBUGP("\t%s\n", secstrings + symsect->sh_name);
 
@@ -1951,19 +1960,19 @@ static unsigned long layout_symtab(struc
 		}
 
 	/* Append room for core symbols at end of core part. */
-	symoffs = ALIGN(mod->core_size, symsect->sh_addralign ?: 1);
-	mod->core_size = symoffs + ndst * sizeof(Elf_Sym);
+	symoffs = ALIGN(mod->core_size_rx, symsect->sh_addralign ?: 1);
+	mod->core_size_rx = symoffs + ndst * sizeof(Elf_Sym);
 
 	/* Put string table section at end of init part of module. */
 	strsect->sh_flags |= SHF_ALLOC;
-	strsect->sh_entsize = get_offset(mod, &mod->init_size, strsect,
+	strsect->sh_entsize = get_offset(mod, &mod->init_size_rx, strsect,
 					 strindex) | INIT_OFFSET_MASK;
 	DEBUGP("\t%s\n", secstrings + strsect->sh_name);
 
 	/* Append room for core symbols' strings at end of core part. */
-	*pstroffs = mod->core_size;
+	*pstroffs = mod->core_size_rx;
 	__set_bit(0, strmap);
-	mod->core_size += bitmap_weight(strmap, strsect->sh_size);
+	mod->core_size_rx += bitmap_weight(strmap, strsect->sh_size);
 
 	return symoffs;
 }
@@ -1987,12 +1996,14 @@ static void add_kallsyms(struct module *
 	mod->num_symtab = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
 	mod->strtab = (void *)sechdrs[strindex].sh_addr;
 
+	pax_open_kernel();
+
 	/* Set types up while we still have access to sections. */
 	for (i = 0; i < mod->num_symtab; i++)
 		mod->symtab[i].st_info
-			= elf_type(&mod->symtab[i], sechdrs, secstrings, mod);
+			= elf_type(&mod->symtab[i], sechdrs, secstrings);
 
-	mod->core_symtab = dst = mod->module_core + symoffs;
+	mod->core_symtab = dst = mod->module_core_rx + symoffs;
 	src = mod->symtab;
 	*dst = *src;
 	for (ndst = i = 1; i < mod->num_symtab; ++i, ++src) {
@@ -2004,10 +2015,12 @@ static void add_kallsyms(struct module *
 	}
 	mod->core_num_syms = ndst;
 
-	mod->core_strtab = s = mod->module_core + stroffs;
+	mod->core_strtab = s = mod->module_core_rx + stroffs;
 	for (*s = 0, i = 1; i < sechdrs[strindex].sh_size; ++i)
 		if (test_bit(i, strmap))
 			*++s = mod->strtab[i];
+
+	pax_close_kernel();
 }
 #else
 static inline unsigned long layout_symtab(struct module *mod,
@@ -2044,16 +2057,30 @@ static void dynamic_debug_setup(struct _
 #endif
 }
 
-static void *module_alloc_update_bounds(unsigned long size)
+static void *module_alloc_update_bounds_rw(unsigned long size)
 {
 	void *ret = module_alloc(size);
 
 	if (ret) {
 		/* Update module bounds. */
-		if ((unsigned long)ret < module_addr_min)
-			module_addr_min = (unsigned long)ret;
-		if ((unsigned long)ret + size > module_addr_max)
-			module_addr_max = (unsigned long)ret + size;
+		if ((unsigned long)ret < module_addr_min_rw)
+			module_addr_min_rw = (unsigned long)ret;
+		if ((unsigned long)ret + size > module_addr_max_rw)
+			module_addr_max_rw = (unsigned long)ret + size;
+	}
+	return ret;
+}
+
+static void *module_alloc_update_bounds_rx(unsigned long size)
+{
+	void *ret = module_alloc_exec(size);
+
+	if (ret) {
+		/* Update module bounds. */
+		if ((unsigned long)ret < module_addr_min_rx)
+			module_addr_min_rx = (unsigned long)ret;
+		if ((unsigned long)ret + size > module_addr_max_rx)
+			module_addr_max_rx = (unsigned long)ret + size;
 	}
 	return ret;
 }
@@ -2065,8 +2092,8 @@ static void kmemleak_load_module(struct
 	unsigned int i;
 
 	/* only scan the sections containing data */
-	kmemleak_scan_area(mod->module_core, (unsigned long)mod -
-			   (unsigned long)mod->module_core,
+	kmemleak_scan_area(mod->module_core_rw, (unsigned long)mod -
+			   (unsigned long)mod->module_core_rw,
 			   sizeof(struct module), GFP_KERNEL);
 
 	for (i = 1; i < hdr->e_shnum; i++) {
@@ -2076,8 +2103,8 @@ static void kmemleak_load_module(struct
 		    && strncmp(secstrings + sechdrs[i].sh_name, ".bss", 4) != 0)
 			continue;
 
-		kmemleak_scan_area(mod->module_core, sechdrs[i].sh_addr -
-				   (unsigned long)mod->module_core,
+		kmemleak_scan_area(mod->module_core_rw, sechdrs[i].sh_addr -
+				   (unsigned long)mod->module_core_rw,
 				   sechdrs[i].sh_size, GFP_KERNEL);
 	}
 }
@@ -2097,7 +2124,7 @@ static noinline struct module *load_modu
 	Elf_Ehdr *hdr;
 	Elf_Shdr *sechdrs;
 	char *secstrings, *args, *modmagic, *strtab = NULL;
-	char *staging;
+	char *staging, *license;
 	unsigned int i;
 	unsigned int symindex = 0;
 	unsigned int strindex = 0;
@@ -2195,6 +2222,14 @@ static noinline struct module *load_modu
 		goto free_hdr;
 	}
 
+	license = get_modinfo(sechdrs, infoindex, "license");
+#ifdef CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR
+	if (!license || !license_is_gpl_compatible(license)) {
+		err = -ENOEXEC;
+		goto free_hdr;
+	}
+#endif
+
 	modmagic = get_modinfo(sechdrs, infoindex, "vermagic");
 	/* This is allowed: modprobe --force will invalidate it. */
 	if (!modmagic) {
@@ -2263,7 +2298,7 @@ static noinline struct module *load_modu
 				secstrings, &stroffs, strmap);
 
 	/* Do the allocs. */
-	ptr = module_alloc_update_bounds(mod->core_size);
+	ptr = module_alloc_update_bounds_rw(mod->core_size_rw);
 	/*
 	 * The pointer to this block is stored in the module structure
 	 * which is inside the block. Just mark it as not being a
@@ -2274,10 +2309,10 @@ static noinline struct module *load_modu
 		err = -ENOMEM;
 		goto free_percpu;
 	}
-	memset(ptr, 0, mod->core_size);
-	mod->module_core = ptr;
+	memset(ptr, 0, mod->core_size_rw);
+	mod->module_core_rw = ptr;
 
-	ptr = module_alloc_update_bounds(mod->init_size);
+	ptr = module_alloc_update_bounds_rw(mod->init_size_rw);
 	/*
 	 * The pointer to this block is stored in the module structure
 	 * which is inside the block. This block doesn't need to be
@@ -2285,12 +2320,36 @@ static noinline struct module *load_modu
 	 * after the module is initialized.
 	 */
 	kmemleak_ignore(ptr);
-	if (!ptr && mod->init_size) {
+	if (!ptr && mod->init_size_rw) {
+		err = -ENOMEM;
+		goto free_core_rw;
+	}
+	memset(ptr, 0, mod->init_size_rw);
+	mod->module_init_rw = ptr;
+
+	ptr = module_alloc_update_bounds_rx(mod->core_size_rx);
+	kmemleak_not_leak(ptr);
+	if (!ptr) {
+		err = -ENOMEM;
+		goto free_init_rw;
+	}
+
+	pax_open_kernel();
+	memset(ptr, 0, mod->core_size_rx);
+	pax_close_kernel();
+	mod->module_core_rx = ptr;
+
+	ptr = module_alloc_update_bounds_rx(mod->init_size_rx);
+	kmemleak_ignore(ptr);
+	if (!ptr && mod->init_size_rx) {
 		err = -ENOMEM;
-		goto free_core;
+		goto free_core_rx;
 	}
-	memset(ptr, 0, mod->init_size);
-	mod->module_init = ptr;
+
+	pax_open_kernel();
+	memset(ptr, 0, mod->init_size_rx);
+	pax_close_kernel();
+	mod->module_init_rx = ptr;
 
 	/* Transfer each section which specifies SHF_ALLOC */
 	DEBUGP("final section addresses:\n");
@@ -2300,17 +2359,45 @@ static noinline struct module *load_modu
 		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
 			continue;
 
-		if (sechdrs[i].sh_entsize & INIT_OFFSET_MASK)
-			dest = mod->module_init
-				+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
-		else
-			dest = mod->module_core + sechdrs[i].sh_entsize;
+		if (sechdrs[i].sh_entsize & INIT_OFFSET_MASK) {
+			if ((sechdrs[i].sh_flags & SHF_WRITE) || !(sechdrs[i].sh_flags & SHF_ALLOC))
+				dest = mod->module_init_rw
+					+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
+			else
+				dest = mod->module_init_rx
+					+ (sechdrs[i].sh_entsize & ~INIT_OFFSET_MASK);
+		} else {
+			if ((sechdrs[i].sh_flags & SHF_WRITE) || !(sechdrs[i].sh_flags & SHF_ALLOC))
+				dest = mod->module_core_rw + sechdrs[i].sh_entsize;
+			else
+				dest = mod->module_core_rx + sechdrs[i].sh_entsize;
+		}
+
+		if (sechdrs[i].sh_type != SHT_NOBITS) {
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_X86_64
+			if ((sechdrs[i].sh_flags & SHF_WRITE) && (sechdrs[i].sh_flags & SHF_EXECINSTR))
+				set_memory_x((unsigned long)dest, (sechdrs[i].sh_size + PAGE_SIZE) >> PAGE_SHIFT);
+#endif
+			if (!(sechdrs[i].sh_flags & SHF_WRITE) && (sechdrs[i].sh_flags & SHF_ALLOC)) {
+				pax_open_kernel();
+				memcpy(dest, (void *)sechdrs[i].sh_addr, sechdrs[i].sh_size);
+				pax_close_kernel();
+			} else
+#endif
 
-		if (sechdrs[i].sh_type != SHT_NOBITS)
-			memcpy(dest, (void *)sechdrs[i].sh_addr,
-			       sechdrs[i].sh_size);
+			memcpy(dest, (void *)sechdrs[i].sh_addr, sechdrs[i].sh_size);
+		}
 		/* Update sh_addr to point to copy in image. */
-		sechdrs[i].sh_addr = (unsigned long)dest;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if (sechdrs[i].sh_flags & SHF_EXECINSTR)
+			sechdrs[i].sh_addr = ktva_ktla((unsigned long)dest);
+		else
+#endif
+
+			sechdrs[i].sh_addr = (unsigned long)dest;
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
 	/* Module has been moved. */
@@ -2322,7 +2409,7 @@ static noinline struct module *load_modu
 				      mod->name);
 	if (!mod->refptr) {
 		err = -ENOMEM;
-		goto free_init;
+		goto free_init_rx;
 	}
 #endif
 	/* Now we've moved module, initialize linked lists, etc. */
@@ -2334,7 +2421,7 @@ static noinline struct module *load_modu
 		goto free_unload;
 
 	/* Set up license info based on the info section */
-	set_license(mod, get_modinfo(sechdrs, infoindex, "license"));
+	set_license(mod, license);
 
 	/*
 	 * ndiswrapper is under GPL by itself, but loads proprietary modules.
@@ -2431,8 +2518,8 @@ static noinline struct module *load_modu
 
 	/* Now do relocations. */
 	for (i = 1; i < hdr->e_shnum; i++) {
-		const char *strtab = (char *)sechdrs[strindex].sh_addr;
 		unsigned int info = sechdrs[i].sh_info;
+		strtab = (char *)sechdrs[strindex].sh_addr;
 
 		/* Not a valid relocation section? */
 		if (info >= hdr->e_shnum)
@@ -2493,12 +2580,12 @@ static noinline struct module *load_modu
 	 * Do it before processing of module parameters, so the module
 	 * can provide parameter accessor functions of its own.
 	 */
-	if (mod->module_init)
-		flush_icache_range((unsigned long)mod->module_init,
-				   (unsigned long)mod->module_init
-				   + mod->init_size);
-	flush_icache_range((unsigned long)mod->module_core,
-			   (unsigned long)mod->module_core + mod->core_size);
+	if (mod->module_init_rx)
+		flush_icache_range((unsigned long)mod->module_init_rx,
+				   (unsigned long)mod->module_init_rx
+				   + mod->init_size_rx);
+	flush_icache_range((unsigned long)mod->module_core_rx,
+			   (unsigned long)mod->module_core_rx + mod->core_size_rx);
 
 	set_fs(old_fs);
 
@@ -2546,12 +2633,16 @@ static noinline struct module *load_modu
  free_unload:
 	module_unload_free(mod);
 #if defined(CONFIG_MODULE_UNLOAD) && defined(CONFIG_SMP)
+ free_init_rx:
 	percpu_modfree(mod->refptr);
- free_init:
 #endif
-	module_free(mod, mod->module_init);
- free_core:
-	module_free(mod, mod->module_core);
+	module_free_exec(mod, mod->module_init_rx);
+ free_core_rx:
+	module_free_exec(mod, mod->module_core_rx);
+ free_init_rw:
+	module_free(mod, mod->module_init_rw);
+ free_core_rw:
+	module_free(mod, mod->module_core_rw);
 	/* mod will be freed with core. Don't access it beyond this line! */
  free_percpu:
 	if (percpu)
@@ -2653,10 +2744,12 @@ SYSCALL_DEFINE3(init_module, void __user
 	mod->symtab = mod->core_symtab;
 	mod->strtab = mod->core_strtab;
 #endif
-	module_free(mod, mod->module_init);
-	mod->module_init = NULL;
-	mod->init_size = 0;
-	mod->init_text_size = 0;
+	module_free(mod, mod->module_init_rw);
+	module_free_exec(mod, mod->module_init_rx);
+	mod->module_init_rw = NULL;
+	mod->module_init_rx = NULL;
+	mod->init_size_rw = 0;
+	mod->init_size_rx = 0;
 	mutex_unlock(&module_mutex);
 
 	return 0;
@@ -2687,10 +2780,16 @@ static const char *get_ksymbol(struct mo
 	unsigned long nextval;
 
 	/* At worse, next value is at end of module */
-	if (within_module_init(addr, mod))
-		nextval = (unsigned long)mod->module_init+mod->init_text_size;
+	if (within_module_init_rx(addr, mod))
+		nextval = (unsigned long)mod->module_init_rx+mod->init_size_rx;
+	else if (within_module_init_rw(addr, mod))
+		nextval = (unsigned long)mod->module_init_rw+mod->init_size_rw;
+	else if (within_module_core_rx(addr, mod))
+		nextval = (unsigned long)mod->module_core_rx+mod->core_size_rx;
+	else if (within_module_core_rw(addr, mod))
+		nextval = (unsigned long)mod->module_core_rw+mod->core_size_rw;
 	else
-		nextval = (unsigned long)mod->module_core+mod->core_text_size;
+		return NULL;
 
 	/* Scan for closest preceeding symbol, and next symbol. (ELF
 	   starts real symbols at 1). */
@@ -2936,7 +3035,7 @@ static int m_show(struct seq_file *m, vo
 	char buf[8];
 
 	seq_printf(m, "%s %u",
-		   mod->name, mod->init_size + mod->core_size);
+		   mod->name, mod->init_size_rx + mod->init_size_rw + mod->core_size_rx + mod->core_size_rw);
 	print_unload_info(m, mod);
 
 	/* Informative for users. */
@@ -2945,7 +3044,7 @@ static int m_show(struct seq_file *m, vo
 		   mod->state == MODULE_STATE_COMING ? "Loading":
 		   "Live");
 	/* Used by oprofile and other similar tools. */
-	seq_printf(m, " 0x%p", mod->module_core);
+	seq_printf(m, " 0x%p 0x%p", mod->module_core_rx, mod->module_core_rw);
 
 	/* Taints info */
 	if (mod->taints)
@@ -3040,12 +3139,12 @@ struct module *__module_address(unsigned
 {
 	struct module *mod;
 
-	if (addr < module_addr_min || addr > module_addr_max)
+	if ((addr < module_addr_min_rx || addr > module_addr_max_rx) &&
+	    (addr < module_addr_min_rw || addr > module_addr_max_rw))
 		return NULL;
 
 	list_for_each_entry_rcu(mod, &modules, list)
-		if (within_module_core(addr, mod)
-		    || within_module_init(addr, mod))
+		if (within_module_init(addr, mod) || within_module_core(addr, mod))
 			return mod;
 	return NULL;
 }
@@ -3079,11 +3178,20 @@ bool is_module_text_address(unsigned lon
  */
 struct module *__module_text_address(unsigned long addr)
 {
-	struct module *mod = __module_address(addr);
+	struct module *mod;
+
+#ifdef CONFIG_X86_32
+	addr = ktla_ktva(addr);
+#endif
+
+	if (addr < module_addr_min_rx || addr > module_addr_max_rx)
+		return NULL;
+
+	mod = __module_address(addr);
+
 	if (mod) {
 		/* Make sure it's within the text section. */
-		if (!within(addr, mod->module_init, mod->init_text_size)
-		    && !within(addr, mod->module_core, mod->core_text_size))
+		if (!within_module_init_rx(addr, mod) && !within_module_core_rx(addr, mod))
 			mod = NULL;
 	}
 	return mod;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/mutex.c linux-2.6.32.60-pax/kernel/mutex.c
--- linux-2.6.32.60/kernel/mutex.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/mutex.c	2012-03-13 13:15:35.632097963 +0100
@@ -169,7 +169,7 @@ __mutex_lock_common(struct mutex *lock,
 	 */
 
 	for (;;) {
-		struct thread_info *owner;
+		struct task_struct *owner;
 
 		/*
 		 * If we own the BKL, then don't spin. The owner of
@@ -214,7 +214,7 @@ __mutex_lock_common(struct mutex *lock,
 	spin_lock_mutex(&lock->wait_lock, flags);
 
 	debug_mutex_lock_common(lock, &waiter);
-	debug_mutex_add_waiter(lock, &waiter, task_thread_info(task));
+	debug_mutex_add_waiter(lock, &waiter, task);
 
 	/* add waiting tasks to the end of the waitqueue (FIFO): */
 	list_add_tail(&waiter.list, &lock->wait_list);
@@ -243,8 +243,7 @@ __mutex_lock_common(struct mutex *lock,
 		 * TASK_UNINTERRUPTIBLE case.)
 		 */
 		if (unlikely(signal_pending_state(state, task))) {
-			mutex_remove_waiter(lock, &waiter,
-					    task_thread_info(task));
+			mutex_remove_waiter(lock, &waiter, task);
 			mutex_release(&lock->dep_map, 1, ip);
 			spin_unlock_mutex(&lock->wait_lock, flags);
 
@@ -265,7 +264,7 @@ __mutex_lock_common(struct mutex *lock,
 done:
 	lock_acquired(&lock->dep_map, ip);
 	/* got the lock - rejoice! */
-	mutex_remove_waiter(lock, &waiter, current_thread_info());
+	mutex_remove_waiter(lock, &waiter, task);
 	mutex_set_owner(lock);
 
 	/* set it to 0 if there are no waiters left: */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/mutex-debug.c linux-2.6.32.60-pax/kernel/mutex-debug.c
--- linux-2.6.32.60/kernel/mutex-debug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/mutex-debug.c	2012-03-13 13:15:35.632097963 +0100
@@ -49,21 +49,21 @@ void debug_mutex_free_waiter(struct mute
 }
 
 void debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,
-			    struct thread_info *ti)
+			    struct task_struct *task)
 {
 	SMP_DEBUG_LOCKS_WARN_ON(!spin_is_locked(&lock->wait_lock));
 
 	/* Mark the current thread as blocked on the lock: */
-	ti->task->blocked_on = waiter;
+	task->blocked_on = waiter;
 }
 
 void mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,
-			 struct thread_info *ti)
+			 struct task_struct *task)
 {
 	DEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));
-	DEBUG_LOCKS_WARN_ON(waiter->task != ti->task);
-	DEBUG_LOCKS_WARN_ON(ti->task->blocked_on != waiter);
-	ti->task->blocked_on = NULL;
+	DEBUG_LOCKS_WARN_ON(waiter->task != task);
+	DEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);
+	task->blocked_on = NULL;
 
 	list_del_init(&waiter->list);
 	waiter->task = NULL;
@@ -75,7 +75,7 @@ void debug_mutex_unlock(struct mutex *lo
 		return;
 
 	DEBUG_LOCKS_WARN_ON(lock->magic != lock);
-	DEBUG_LOCKS_WARN_ON(lock->owner != current_thread_info());
+	DEBUG_LOCKS_WARN_ON(lock->owner != current);
 	DEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);
 	mutex_clear_owner(lock);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/mutex-debug.h linux-2.6.32.60-pax/kernel/mutex-debug.h
--- linux-2.6.32.60/kernel/mutex-debug.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/mutex-debug.h	2012-03-13 13:15:35.632097963 +0100
@@ -20,16 +20,16 @@ extern void debug_mutex_wake_waiter(stru
 extern void debug_mutex_free_waiter(struct mutex_waiter *waiter);
 extern void debug_mutex_add_waiter(struct mutex *lock,
 				   struct mutex_waiter *waiter,
-				   struct thread_info *ti);
+				   struct task_struct *task);
 extern void mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,
-				struct thread_info *ti);
+				struct task_struct *task);
 extern void debug_mutex_unlock(struct mutex *lock);
 extern void debug_mutex_init(struct mutex *lock, const char *name,
 			     struct lock_class_key *key);
 
 static inline void mutex_set_owner(struct mutex *lock)
 {
-	lock->owner = current_thread_info();
+	lock->owner = current;
 }
 
 static inline void mutex_clear_owner(struct mutex *lock)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/mutex.h linux-2.6.32.60-pax/kernel/mutex.h
--- linux-2.6.32.60/kernel/mutex.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/mutex.h	2012-03-13 13:15:35.632097963 +0100
@@ -19,7 +19,7 @@
 #ifdef CONFIG_SMP
 static inline void mutex_set_owner(struct mutex *lock)
 {
-	lock->owner = current_thread_info();
+	lock->owner = current;
 }
 
 static inline void mutex_clear_owner(struct mutex *lock)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/notifier.c linux-2.6.32.60-pax/kernel/notifier.c
--- linux-2.6.32.60/kernel/notifier.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/notifier.c	2013-01-22 17:38:23.596543624 +0100
@@ -5,6 +5,7 @@
 #include <linux/rcupdate.h>
 #include <linux/vmalloc.h>
 #include <linux/reboot.h>
+#include <linux/mm.h>
 
 /*
  *	Notifier list for kernel code which wants to be called
@@ -24,10 +25,12 @@ static int notifier_chain_register(struc
 	while ((*nl) != NULL) {
 		if (n->priority > (*nl)->priority)
 			break;
-		nl = &((*nl)->next);
+		nl = (struct notifier_block **)&((*nl)->next);
 	}
-	n->next = *nl;
+	pax_open_kernel();
+	*(const void **)&n->next = *nl;
 	rcu_assign_pointer(*nl, n);
+	pax_close_kernel();
 	return 0;
 }
 
@@ -39,10 +42,12 @@ static int notifier_chain_cond_register(
 			return 0;
 		if (n->priority > (*nl)->priority)
 			break;
-		nl = &((*nl)->next);
+		nl = (struct notifier_block **)&((*nl)->next);
 	}
-	n->next = *nl;
+	pax_open_kernel();
+	*(const void **)&n->next = *nl;
 	rcu_assign_pointer(*nl, n);
+	pax_close_kernel();
 	return 0;
 }
 
@@ -51,10 +56,12 @@ static int notifier_chain_unregister(str
 {
 	while ((*nl) != NULL) {
 		if ((*nl) == n) {
+			pax_open_kernel();
 			rcu_assign_pointer(*nl, n->next);
+			pax_close_kernel();
 			return 0;
 		}
-		nl = &((*nl)->next);
+		nl = (struct notifier_block **)&((*nl)->next);
 	}
 	return -ENOENT;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/panic.c linux-2.6.32.60-pax/kernel/panic.c
--- linux-2.6.32.60/kernel/panic.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/panic.c	2012-03-13 13:15:35.636097963 +0100
@@ -71,7 +71,11 @@ NORET_TYPE void panic(const char * fmt,
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
 #ifdef CONFIG_DEBUG_BUGVERBOSE
-	dump_stack();
+	/*
+	 * Avoid nested stack-dumping if a panic occurs during oops processing
+	 */
+	if (!oops_in_progress)
+		dump_stack();
 #endif
 
 	/*
@@ -392,7 +396,8 @@ EXPORT_SYMBOL(warn_slowpath_null);
  */
 void __stack_chk_fail(void)
 {
-	panic("stack-protector: Kernel stack is corrupted in: %p\n",
+	dump_stack();
+	panic("stack-protector: Kernel stack is corrupted in: %pS\n",
 		__builtin_return_address(0));
 }
 EXPORT_SYMBOL(__stack_chk_fail);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/perf_event.c linux-2.6.32.60-pax/kernel/perf_event.c
--- linux-2.6.32.60/kernel/perf_event.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/perf_event.c	2012-03-13 13:15:35.636097963 +0100
@@ -77,7 +77,7 @@ int sysctl_perf_event_mlock __read_mostl
  */
 int sysctl_perf_event_sample_rate __read_mostly = 100000;
 
-static atomic64_t perf_event_id;
+static atomic64_unchecked_t perf_event_id;
 
 /*
  * Lock for (sysadmin-configurable) event reservations:
@@ -1094,9 +1094,9 @@ static void __perf_event_sync_stat(struc
 	 * In order to keep per-task stats reliable we need to flip the event
 	 * values when we flip the contexts.
 	 */
-	value = atomic64_read(&next_event->count);
-	value = atomic64_xchg(&event->count, value);
-	atomic64_set(&next_event->count, value);
+	value = atomic64_read_unchecked(&next_event->count);
+	value = atomic64_xchg_unchecked(&event->count, value);
+	atomic64_set_unchecked(&next_event->count, value);
 
 	swap(event->total_time_enabled, next_event->total_time_enabled);
 	swap(event->total_time_running, next_event->total_time_running);
@@ -1552,7 +1552,7 @@ static u64 perf_event_read(struct perf_e
 		update_event_times(event);
 	}
 
-	return atomic64_read(&event->count);
+	return atomic64_read_unchecked(&event->count);
 }
 
 /*
@@ -1790,11 +1790,11 @@ static int perf_event_read_group(struct
 	values[n++] = 1 + leader->nr_siblings;
 	if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {
 		values[n++] = leader->total_time_enabled +
-			atomic64_read(&leader->child_total_time_enabled);
+			atomic64_read_unchecked(&leader->child_total_time_enabled);
 	}
 	if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {
 		values[n++] = leader->total_time_running +
-			atomic64_read(&leader->child_total_time_running);
+			atomic64_read_unchecked(&leader->child_total_time_running);
 	}
 
 	size = n * sizeof(u64);
@@ -1829,11 +1829,11 @@ static int perf_event_read_one(struct pe
 	values[n++] = perf_event_read_value(event);
 	if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {
 		values[n++] = event->total_time_enabled +
-			atomic64_read(&event->child_total_time_enabled);
+			atomic64_read_unchecked(&event->child_total_time_enabled);
 	}
 	if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {
 		values[n++] = event->total_time_running +
-			atomic64_read(&event->child_total_time_running);
+			atomic64_read_unchecked(&event->child_total_time_running);
 	}
 	if (read_format & PERF_FORMAT_ID)
 		values[n++] = primary_event_id(event);
@@ -1903,7 +1903,7 @@ static unsigned int perf_poll(struct fil
 static void perf_event_reset(struct perf_event *event)
 {
 	(void)perf_event_read(event);
-	atomic64_set(&event->count, 0);
+	atomic64_set_unchecked(&event->count, 0);
 	perf_event_update_userpage(event);
 }
 
@@ -2079,15 +2079,15 @@ void perf_event_update_userpage(struct p
 	++userpg->lock;
 	barrier();
 	userpg->index = perf_event_index(event);
-	userpg->offset = atomic64_read(&event->count);
+	userpg->offset = atomic64_read_unchecked(&event->count);
 	if (event->state == PERF_EVENT_STATE_ACTIVE)
-		userpg->offset -= atomic64_read(&event->hw.prev_count);
+		userpg->offset -= atomic64_read_unchecked(&event->hw.prev_count);
 
 	userpg->time_enabled = event->total_time_enabled +
-			atomic64_read(&event->child_total_time_enabled);
+			atomic64_read_unchecked(&event->child_total_time_enabled);
 
 	userpg->time_running = event->total_time_running +
-			atomic64_read(&event->child_total_time_running);
+			atomic64_read_unchecked(&event->child_total_time_running);
 
 	barrier();
 	++userpg->lock;
@@ -2903,14 +2903,14 @@ static void perf_output_read_one(struct
 	u64 values[4];
 	int n = 0;
 
-	values[n++] = atomic64_read(&event->count);
+	values[n++] = atomic64_read_unchecked(&event->count);
 	if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {
 		values[n++] = event->total_time_enabled +
-			atomic64_read(&event->child_total_time_enabled);
+			atomic64_read_unchecked(&event->child_total_time_enabled);
 	}
 	if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {
 		values[n++] = event->total_time_running +
-			atomic64_read(&event->child_total_time_running);
+			atomic64_read_unchecked(&event->child_total_time_running);
 	}
 	if (read_format & PERF_FORMAT_ID)
 		values[n++] = primary_event_id(event);
@@ -2940,7 +2940,7 @@ static void perf_output_read_group(struc
 	if (leader != event)
 		leader->pmu->read(leader);
 
-	values[n++] = atomic64_read(&leader->count);
+	values[n++] = atomic64_read_unchecked(&leader->count);
 	if (read_format & PERF_FORMAT_ID)
 		values[n++] = primary_event_id(leader);
 
@@ -2952,7 +2952,7 @@ static void perf_output_read_group(struc
 		if (sub != event)
 			sub->pmu->read(sub);
 
-		values[n++] = atomic64_read(&sub->count);
+		values[n++] = atomic64_read_unchecked(&sub->count);
 		if (read_format & PERF_FORMAT_ID)
 			values[n++] = primary_event_id(sub);
 
@@ -3525,12 +3525,12 @@ static void perf_event_mmap_event(struct
 		 * need to add enough zero bytes after the string to handle
 		 * the 64bit alignment we do later.
 		 */
-		buf = kzalloc(PATH_MAX + sizeof(u64), GFP_KERNEL);
+		buf = kzalloc(PATH_MAX, GFP_KERNEL);
 		if (!buf) {
 			name = strncpy(tmp, "//enomem", sizeof(tmp));
 			goto got_name;
 		}
-		name = d_path(&file->f_path, buf, PATH_MAX);
+		name = d_path(&file->f_path, buf, PATH_MAX - sizeof(u64));
 		if (IS_ERR(name)) {
 			name = strncpy(tmp, "//toolong", sizeof(tmp));
 			goto got_name;
@@ -3783,7 +3783,7 @@ static void perf_swevent_add(struct perf
 {
 	struct hw_perf_event *hwc = &event->hw;
 
-	atomic64_add(nr, &event->count);
+	atomic64_add_unchecked(nr, &event->count);
 
 	if (!hwc->sample_period)
 		return;
@@ -4040,9 +4040,9 @@ static void cpu_clock_perf_event_update(
 	u64 now;
 
 	now = cpu_clock(cpu);
-	prev = atomic64_read(&event->hw.prev_count);
-	atomic64_set(&event->hw.prev_count, now);
-	atomic64_add(now - prev, &event->count);
+	prev = atomic64_read_unchecked(&event->hw.prev_count);
+	atomic64_set_unchecked(&event->hw.prev_count, now);
+	atomic64_add_unchecked(now - prev, &event->count);
 }
 
 static int cpu_clock_perf_event_enable(struct perf_event *event)
@@ -4050,7 +4050,7 @@ static int cpu_clock_perf_event_enable(s
 	struct hw_perf_event *hwc = &event->hw;
 	int cpu = raw_smp_processor_id();
 
-	atomic64_set(&hwc->prev_count, cpu_clock(cpu));
+	atomic64_set_unchecked(&hwc->prev_count, cpu_clock(cpu));
 	perf_swevent_start_hrtimer(event);
 
 	return 0;
@@ -4082,9 +4082,9 @@ static void task_clock_perf_event_update
 	u64 prev;
 	s64 delta;
 
-	prev = atomic64_xchg(&event->hw.prev_count, now);
+	prev = atomic64_xchg_unchecked(&event->hw.prev_count, now);
 	delta = now - prev;
-	atomic64_add(delta, &event->count);
+	atomic64_add_unchecked(delta, &event->count);
 }
 
 static int task_clock_perf_event_enable(struct perf_event *event)
@@ -4094,7 +4094,7 @@ static int task_clock_perf_event_enable(
 
 	now = event->ctx->time;
 
-	atomic64_set(&hwc->prev_count, now);
+	atomic64_set_unchecked(&hwc->prev_count, now);
 
 	perf_swevent_start_hrtimer(event);
 
@@ -4289,7 +4289,7 @@ perf_event_alloc(struct perf_event_attr
 	event->parent		= parent_event;
 
 	event->ns		= get_pid_ns(current->nsproxy->pid_ns);
-	event->id		= atomic64_inc_return(&perf_event_id);
+	event->id		= atomic64_inc_return_unchecked(&perf_event_id);
 
 	event->state		= PERF_EVENT_STATE_INACTIVE;
 
@@ -4720,15 +4720,15 @@ static void sync_child_event(struct perf
 	if (child_event->attr.inherit_stat)
 		perf_event_read_event(child_event, child);
 
-	child_val = atomic64_read(&child_event->count);
+	child_val = atomic64_read_unchecked(&child_event->count);
 
 	/*
 	 * Add back the child's count to the parent's count:
 	 */
-	atomic64_add(child_val, &parent_event->count);
-	atomic64_add(child_event->total_time_enabled,
+	atomic64_add_unchecked(child_val, &parent_event->count);
+	atomic64_add_unchecked(child_event->total_time_enabled,
 		     &parent_event->child_total_time_enabled);
-	atomic64_add(child_event->total_time_running,
+	atomic64_add_unchecked(child_event->total_time_running,
 		     &parent_event->child_total_time_running);
 
 	/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/pid.c linux-2.6.32.60-pax/kernel/pid.c
--- linux-2.6.32.60/kernel/pid.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/pid.c	2012-03-13 13:15:35.636097963 +0100
@@ -45,7 +45,7 @@ struct pid init_struct_pid = INIT_STRUCT
 
 int pid_max = PID_MAX_DEFAULT;
 
-#define RESERVED_PIDS		300
+#define RESERVED_PIDS		500
 
 int pid_max_min = RESERVED_PIDS + 1;
 int pid_max_max = PID_MAX_LIMIT;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/posix-cpu-timers.c linux-2.6.32.60-pax/kernel/posix-cpu-timers.c
--- linux-2.6.32.60/kernel/posix-cpu-timers.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/posix-cpu-timers.c	2012-03-13 13:15:35.640097963 +0100
@@ -1697,7 +1697,7 @@ static long thread_cpu_nsleep_restart(st
 
 static __init int init_posix_cpu_timers(void)
 {
-	struct k_clock process = {
+	static struct k_clock process = {
 		.clock_getres = process_cpu_clock_getres,
 		.clock_get = process_cpu_clock_get,
 		.clock_set = do_posix_clock_nosettime,
@@ -1705,7 +1705,7 @@ static __init int init_posix_cpu_timers(
 		.nsleep = process_cpu_nsleep,
 		.nsleep_restart = process_cpu_nsleep_restart,
 	};
-	struct k_clock thread = {
+	static struct k_clock thread = {
 		.clock_getres = thread_cpu_clock_getres,
 		.clock_get = thread_cpu_clock_get,
 		.clock_set = do_posix_clock_nosettime,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/posix-timers.c linux-2.6.32.60-pax/kernel/posix-timers.c
--- linux-2.6.32.60/kernel/posix-timers.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/posix-timers.c	2012-03-13 13:15:35.640097963 +0100
@@ -131,7 +131,7 @@ static DEFINE_SPINLOCK(idr_lock);
  *	    which we beg off on and pass to do_sys_settimeofday().
  */
 
-static struct k_clock posix_clocks[MAX_CLOCKS];
+static struct k_clock *posix_clocks[MAX_CLOCKS];
 
 /*
  * These ones are defined below.
@@ -157,8 +157,8 @@ static inline void unlock_timer(struct k
  */
 #define CLOCK_DISPATCH(clock, call, arglist) \
  	((clock) < 0 ? posix_cpu_##call arglist : \
- 	 (posix_clocks[clock].call != NULL \
- 	  ? (*posix_clocks[clock].call) arglist : common_##call arglist))
+ 	 (posix_clocks[clock]->call != NULL \
+ 	  ? (*posix_clocks[clock]->call) arglist : common_##call arglist))
 
 /*
  * Default clock hook functions when the struct k_clock passed
@@ -172,7 +172,7 @@ static inline int common_clock_getres(co
 				      struct timespec *tp)
 {
 	tp->tv_sec = 0;
-	tp->tv_nsec = posix_clocks[which_clock].res;
+	tp->tv_nsec = posix_clocks[which_clock]->res;
 	return 0;
 }
 
@@ -217,9 +217,11 @@ static inline int invalid_clockid(const
 		return 0;
 	if ((unsigned) which_clock >= MAX_CLOCKS)
 		return 1;
-	if (posix_clocks[which_clock].clock_getres != NULL)
+	if (posix_clocks[which_clock] == NULL)
+		return 1;
+	if (posix_clocks[which_clock]->clock_getres != NULL)
 		return 0;
-	if (posix_clocks[which_clock].res != 0)
+	if (posix_clocks[which_clock]->res != 0)
 		return 0;
 	return 1;
 }
@@ -266,29 +268,29 @@ int posix_get_coarse_res(const clockid_t
  */
 static __init int init_posix_timers(void)
 {
-	struct k_clock clock_realtime = {
+	static struct k_clock clock_realtime = {
 		.clock_getres = hrtimer_get_res,
 	};
-	struct k_clock clock_monotonic = {
+	static struct k_clock clock_monotonic = {
 		.clock_getres = hrtimer_get_res,
 		.clock_get = posix_ktime_get_ts,
 		.clock_set = do_posix_clock_nosettime,
 	};
-	struct k_clock clock_monotonic_raw = {
+	static struct k_clock clock_monotonic_raw = {
 		.clock_getres = hrtimer_get_res,
 		.clock_get = posix_get_monotonic_raw,
 		.clock_set = do_posix_clock_nosettime,
 		.timer_create = no_timer_create,
 		.nsleep = no_nsleep,
 	};
-	struct k_clock clock_realtime_coarse = {
+	static struct k_clock clock_realtime_coarse = {
 		.clock_getres = posix_get_coarse_res,
 		.clock_get = posix_get_realtime_coarse,
 		.clock_set = do_posix_clock_nosettime,
 		.timer_create = no_timer_create,
 		.nsleep = no_nsleep,
 	};
-	struct k_clock clock_monotonic_coarse = {
+	static struct k_clock clock_monotonic_coarse = {
 		.clock_getres = posix_get_coarse_res,
 		.clock_get = posix_get_monotonic_coarse,
 		.clock_set = do_posix_clock_nosettime,
@@ -484,7 +486,7 @@ void register_posix_clock(const clockid_
 		return;
 	}
 
-	posix_clocks[clock_id] = *new_clock;
+	posix_clocks[clock_id] = new_clock;
 }
 EXPORT_SYMBOL_GPL(register_posix_clock);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/power/poweroff.c linux-2.6.32.60-pax/kernel/power/poweroff.c
--- linux-2.6.32.60/kernel/power/poweroff.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/power/poweroff.c	2012-03-13 13:15:35.640097963 +0100
@@ -37,7 +37,7 @@ static struct sysrq_key_op	sysrq_powerof
 	.enable_mask	= SYSRQ_ENABLE_BOOT,
 };
 
-static int pm_sysrq_init(void)
+static int __init pm_sysrq_init(void)
 {
 	register_sysrq_key('o', &sysrq_poweroff_op);
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/power/process.c linux-2.6.32.60-pax/kernel/power/process.c
--- linux-2.6.32.60/kernel/power/process.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/power/process.c	2012-03-13 13:15:35.640097963 +0100
@@ -37,12 +37,15 @@ static int try_to_freeze_tasks(bool sig_
 	struct timeval start, end;
 	u64 elapsed_csecs64;
 	unsigned int elapsed_csecs;
+	bool timedout = false;
 
 	do_gettimeofday(&start);
 
 	end_time = jiffies + TIMEOUT;
 	do {
 		todo = 0;
+		if (time_after(jiffies, end_time))
+			timedout = true;
 		read_lock(&tasklist_lock);
 		do_each_thread(g, p) {
 			if (frozen(p) || !freezeable(p))
@@ -57,15 +60,17 @@ static int try_to_freeze_tasks(bool sig_
 			 * It is "frozen enough".  If the task does wake
 			 * up, it will immediately call try_to_freeze.
 			 */
-			if (!task_is_stopped_or_traced(p) &&
-			    !freezer_should_skip(p))
+			if (!task_is_stopped_or_traced(p) && !freezer_should_skip(p)) {
 				todo++;
+				if (timedout) {
+					printk(KERN_ERR "Task refusing to freeze:\n");
+					sched_show_task(p);
+				}
+			}
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 		yield();			/* Yield is okay here */
-		if (time_after(jiffies, end_time))
-			break;
-	} while (todo);
+	} while (todo && !timedout);
 
 	do_gettimeofday(&end);
 	elapsed_csecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/profile.c linux-2.6.32.60-pax/kernel/profile.c
--- linux-2.6.32.60/kernel/profile.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/profile.c	2012-03-13 13:15:35.644097963 +0100
@@ -39,7 +39,7 @@ struct profile_hit {
 /* Oprofile timer tick hook */
 static int (*timer_hook)(struct pt_regs *) __read_mostly;
 
-static atomic_t *prof_buffer;
+static atomic_unchecked_t *prof_buffer;
 static unsigned long prof_len, prof_shift;
 
 int prof_on __read_mostly;
@@ -283,7 +283,7 @@ static void profile_flip_buffers(void)
 					hits[i].pc = 0;
 				continue;
 			}
-			atomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);
+			atomic_add_unchecked(hits[i].hits, &prof_buffer[hits[i].pc]);
 			hits[i].hits = hits[i].pc = 0;
 		}
 	}
@@ -346,9 +346,9 @@ void profile_hits(int type, void *__pc,
 	 * Add the current hit(s) and flush the write-queue out
 	 * to the global buffer:
 	 */
-	atomic_add(nr_hits, &prof_buffer[pc]);
+	atomic_add_unchecked(nr_hits, &prof_buffer[pc]);
 	for (i = 0; i < NR_PROFILE_HIT; ++i) {
-		atomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);
+		atomic_add_unchecked(hits[i].hits, &prof_buffer[hits[i].pc]);
 		hits[i].pc = hits[i].hits = 0;
 	}
 out:
@@ -426,7 +426,7 @@ void profile_hits(int type, void *__pc,
 	if (prof_on != type || !prof_buffer)
 		return;
 	pc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;
-	atomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);
+	atomic_add_unchecked(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);
 }
 #endif /* !CONFIG_SMP */
 EXPORT_SYMBOL_GPL(profile_hits);
@@ -517,7 +517,7 @@ read_profile(struct file *file, char __u
 			return -EFAULT;
 		buf++; p++; count--; read++;
 	}
-	pnt = (char *)prof_buffer + p - sizeof(atomic_t);
+	pnt = (char *)prof_buffer + p - sizeof(atomic_unchecked_t);
 	if (copy_to_user(buf, (void *)pnt, count))
 		return -EFAULT;
 	read += count;
@@ -548,7 +548,7 @@ static ssize_t write_profile(struct file
 	}
 #endif
 	profile_discard_flip_buffers();
-	memset(prof_buffer, 0, prof_len * sizeof(atomic_t));
+	memset(prof_buffer, 0, prof_len * sizeof(atomic_unchecked_t));
 	return count;
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/ptrace.c linux-2.6.32.60-pax/kernel/ptrace.c
--- linux-2.6.32.60/kernel/ptrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/ptrace.c	2012-03-13 13:15:35.644097963 +0100
@@ -532,18 +532,18 @@ int ptrace_request(struct task_struct *c
 		ret = ptrace_setoptions(child, data);
 		break;
 	case PTRACE_GETEVENTMSG:
-		ret = put_user(child->ptrace_message, (unsigned long __user *) data);
+		ret = put_user(child->ptrace_message, (__force unsigned long __user *) data);
 		break;
 
 	case PTRACE_GETSIGINFO:
 		ret = ptrace_getsiginfo(child, &siginfo);
 		if (!ret)
-			ret = copy_siginfo_to_user((siginfo_t __user *) data,
+			ret = copy_siginfo_to_user((__force siginfo_t __user *) data,
 						   &siginfo);
 		break;
 
 	case PTRACE_SETSIGINFO:
-		if (copy_from_user(&siginfo, (siginfo_t __user *) data,
+		if (copy_from_user(&siginfo, (__force siginfo_t __user *) data,
 				   sizeof siginfo))
 			ret = -EFAULT;
 		else
@@ -653,7 +653,7 @@ int generic_ptrace_peekdata(struct task_
 	copied = access_process_vm(tsk, addr, &tmp, sizeof(tmp), 0);
 	if (copied != sizeof(tmp))
 		return -EIO;
-	return put_user(tmp, (unsigned long __user *)data);
+	return put_user(tmp, (__force unsigned long __user *)data);
 }
 
 int generic_ptrace_pokedata(struct task_struct *tsk, long addr, long data)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/rcutorture.c linux-2.6.32.60-pax/kernel/rcutorture.c
--- linux-2.6.32.60/kernel/rcutorture.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/rcutorture.c	2012-03-13 13:15:35.644097963 +0100
@@ -118,12 +118,12 @@ static DEFINE_PER_CPU(long [RCU_TORTURE_
 	{ 0 };
 static DEFINE_PER_CPU(long [RCU_TORTURE_PIPE_LEN + 1], rcu_torture_batch) =
 	{ 0 };
-static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];
-static atomic_t n_rcu_torture_alloc;
-static atomic_t n_rcu_torture_alloc_fail;
-static atomic_t n_rcu_torture_free;
-static atomic_t n_rcu_torture_mberror;
-static atomic_t n_rcu_torture_error;
+static atomic_unchecked_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];
+static atomic_unchecked_t n_rcu_torture_alloc;
+static atomic_unchecked_t n_rcu_torture_alloc_fail;
+static atomic_unchecked_t n_rcu_torture_free;
+static atomic_unchecked_t n_rcu_torture_mberror;
+static atomic_unchecked_t n_rcu_torture_error;
 static long n_rcu_torture_timers;
 static struct list_head rcu_torture_removed;
 static cpumask_var_t shuffle_tmp_mask;
@@ -187,11 +187,11 @@ rcu_torture_alloc(void)
 
 	spin_lock_bh(&rcu_torture_lock);
 	if (list_empty(&rcu_torture_freelist)) {
-		atomic_inc(&n_rcu_torture_alloc_fail);
+		atomic_inc_unchecked(&n_rcu_torture_alloc_fail);
 		spin_unlock_bh(&rcu_torture_lock);
 		return NULL;
 	}
-	atomic_inc(&n_rcu_torture_alloc);
+	atomic_inc_unchecked(&n_rcu_torture_alloc);
 	p = rcu_torture_freelist.next;
 	list_del_init(p);
 	spin_unlock_bh(&rcu_torture_lock);
@@ -204,7 +204,7 @@ rcu_torture_alloc(void)
 static void
 rcu_torture_free(struct rcu_torture *p)
 {
-	atomic_inc(&n_rcu_torture_free);
+	atomic_inc_unchecked(&n_rcu_torture_free);
 	spin_lock_bh(&rcu_torture_lock);
 	list_add_tail(&p->rtort_free, &rcu_torture_freelist);
 	spin_unlock_bh(&rcu_torture_lock);
@@ -319,7 +319,7 @@ rcu_torture_cb(struct rcu_head *p)
 	i = rp->rtort_pipe_count;
 	if (i > RCU_TORTURE_PIPE_LEN)
 		i = RCU_TORTURE_PIPE_LEN;
-	atomic_inc(&rcu_torture_wcount[i]);
+	atomic_inc_unchecked(&rcu_torture_wcount[i]);
 	if (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {
 		rp->rtort_mbtest = 0;
 		rcu_torture_free(rp);
@@ -359,7 +359,7 @@ static void rcu_sync_torture_deferred_fr
 		i = rp->rtort_pipe_count;
 		if (i > RCU_TORTURE_PIPE_LEN)
 			i = RCU_TORTURE_PIPE_LEN;
-		atomic_inc(&rcu_torture_wcount[i]);
+		atomic_inc_unchecked(&rcu_torture_wcount[i]);
 		if (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {
 			rp->rtort_mbtest = 0;
 			list_del(&rp->rtort_free);
@@ -653,7 +653,7 @@ rcu_torture_writer(void *arg)
 			i = old_rp->rtort_pipe_count;
 			if (i > RCU_TORTURE_PIPE_LEN)
 				i = RCU_TORTURE_PIPE_LEN;
-			atomic_inc(&rcu_torture_wcount[i]);
+			atomic_inc_unchecked(&rcu_torture_wcount[i]);
 			old_rp->rtort_pipe_count++;
 			cur_ops->deferred_free(old_rp);
 		}
@@ -718,7 +718,7 @@ static void rcu_torture_timer(unsigned l
 		return;
 	}
 	if (p->rtort_mbtest == 0)
-		atomic_inc(&n_rcu_torture_mberror);
+		atomic_inc_unchecked(&n_rcu_torture_mberror);
 	spin_lock(&rand_lock);
 	cur_ops->read_delay(&rand);
 	n_rcu_torture_timers++;
@@ -776,7 +776,7 @@ rcu_torture_reader(void *arg)
 			continue;
 		}
 		if (p->rtort_mbtest == 0)
-			atomic_inc(&n_rcu_torture_mberror);
+			atomic_inc_unchecked(&n_rcu_torture_mberror);
 		cur_ops->read_delay(&rand);
 		preempt_disable();
 		pipe_count = p->rtort_pipe_count;
@@ -834,17 +834,17 @@ rcu_torture_printk(char *page)
 		       rcu_torture_current,
 		       rcu_torture_current_version,
 		       list_empty(&rcu_torture_freelist),
-		       atomic_read(&n_rcu_torture_alloc),
-		       atomic_read(&n_rcu_torture_alloc_fail),
-		       atomic_read(&n_rcu_torture_free),
-		       atomic_read(&n_rcu_torture_mberror),
+		       atomic_read_unchecked(&n_rcu_torture_alloc),
+		       atomic_read_unchecked(&n_rcu_torture_alloc_fail),
+		       atomic_read_unchecked(&n_rcu_torture_free),
+		       atomic_read_unchecked(&n_rcu_torture_mberror),
 		       n_rcu_torture_timers);
-	if (atomic_read(&n_rcu_torture_mberror) != 0)
+	if (atomic_read_unchecked(&n_rcu_torture_mberror) != 0)
 		cnt += sprintf(&page[cnt], " !!!");
 	cnt += sprintf(&page[cnt], "\n%s%s ", torture_type, TORTURE_FLAG);
 	if (i > 1) {
 		cnt += sprintf(&page[cnt], "!!! ");
-		atomic_inc(&n_rcu_torture_error);
+		atomic_inc_unchecked(&n_rcu_torture_error);
 		WARN_ON_ONCE(1);
 	}
 	cnt += sprintf(&page[cnt], "Reader Pipe: ");
@@ -858,7 +858,7 @@ rcu_torture_printk(char *page)
 	cnt += sprintf(&page[cnt], "Free-Block Circulation: ");
 	for (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {
 		cnt += sprintf(&page[cnt], " %d",
-			       atomic_read(&rcu_torture_wcount[i]));
+			       atomic_read_unchecked(&rcu_torture_wcount[i]));
 	}
 	cnt += sprintf(&page[cnt], "\n");
 	if (cur_ops->stats)
@@ -1084,7 +1084,7 @@ rcu_torture_cleanup(void)
 
 	if (cur_ops->cleanup)
 		cur_ops->cleanup();
-	if (atomic_read(&n_rcu_torture_error))
+	if (atomic_read_unchecked(&n_rcu_torture_error))
 		rcu_torture_print_module_parms("End of test: FAILURE");
 	else
 		rcu_torture_print_module_parms("End of test: SUCCESS");
@@ -1138,13 +1138,13 @@ rcu_torture_init(void)
 
 	rcu_torture_current = NULL;
 	rcu_torture_current_version = 0;
-	atomic_set(&n_rcu_torture_alloc, 0);
-	atomic_set(&n_rcu_torture_alloc_fail, 0);
-	atomic_set(&n_rcu_torture_free, 0);
-	atomic_set(&n_rcu_torture_mberror, 0);
-	atomic_set(&n_rcu_torture_error, 0);
+	atomic_set_unchecked(&n_rcu_torture_alloc, 0);
+	atomic_set_unchecked(&n_rcu_torture_alloc_fail, 0);
+	atomic_set_unchecked(&n_rcu_torture_free, 0);
+	atomic_set_unchecked(&n_rcu_torture_mberror, 0);
+	atomic_set_unchecked(&n_rcu_torture_error, 0);
 	for (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)
-		atomic_set(&rcu_torture_wcount[i], 0);
+		atomic_set_unchecked(&rcu_torture_wcount[i], 0);
 	for_each_possible_cpu(cpu) {
 		for (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {
 			per_cpu(rcu_torture_count, cpu)[i] = 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/rcutree.c linux-2.6.32.60-pax/kernel/rcutree.c
--- linux-2.6.32.60/kernel/rcutree.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/rcutree.c	2012-03-13 13:15:35.648097962 +0100
@@ -1303,7 +1303,7 @@ __rcu_process_callbacks(struct rcu_state
 /*
  * Do softirq processing for the current CPU.
  */
-static void rcu_process_callbacks(struct softirq_action *unused)
+static void rcu_process_callbacks(void)
 {
 	/*
 	 * Memory references from any prior RCU read-side critical sections
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/rcutree_plugin.h linux-2.6.32.60-pax/kernel/rcutree_plugin.h
--- linux-2.6.32.60/kernel/rcutree_plugin.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/rcutree_plugin.h	2012-03-13 13:15:35.648097962 +0100
@@ -145,7 +145,7 @@ static void rcu_preempt_note_context_swi
  */
 void __rcu_read_lock(void)
 {
-	ACCESS_ONCE(current->rcu_read_lock_nesting)++;
+	ACCESS_ONCE_RW(current->rcu_read_lock_nesting)++;
 	barrier();  /* needed if we ever invoke rcu_read_lock in rcutree.c */
 }
 EXPORT_SYMBOL_GPL(__rcu_read_lock);
@@ -251,7 +251,7 @@ void __rcu_read_unlock(void)
 	struct task_struct *t = current;
 
 	barrier();  /* needed if we ever invoke rcu_read_unlock in rcutree.c */
-	if (--ACCESS_ONCE(t->rcu_read_lock_nesting) == 0 &&
+	if (--ACCESS_ONCE_RW(t->rcu_read_lock_nesting) == 0 &&
 	    unlikely(ACCESS_ONCE(t->rcu_read_unlock_special)))
 		rcu_read_unlock_special(t);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/relay.c linux-2.6.32.60-pax/kernel/relay.c
--- linux-2.6.32.60/kernel/relay.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/relay.c	2012-03-13 13:15:35.648097962 +0100
@@ -1228,7 +1228,7 @@ static int subbuf_splice_actor(struct fi
 			       unsigned int flags,
 			       int *nonpad_ret)
 {
-	unsigned int pidx, poff, total_len, subbuf_pages, nr_pages, ret;
+	unsigned int pidx, poff, total_len, subbuf_pages, nr_pages;
 	struct rchan_buf *rbuf = in->private_data;
 	unsigned int subbuf_size = rbuf->chan->subbuf_size;
 	uint64_t pos = (uint64_t) *ppos;
@@ -1247,6 +1247,7 @@ static int subbuf_splice_actor(struct fi
 		.ops = &relay_pipe_buf_ops,
 		.spd_release = relay_page_release,
 	};
+	ssize_t ret;
 
 	if (rbuf->subbufs_produced == rbuf->subbufs_consumed)
 		return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/rtmutex.c linux-2.6.32.60-pax/kernel/rtmutex.c
--- linux-2.6.32.60/kernel/rtmutex.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/rtmutex.c	2012-03-13 13:15:35.648097962 +0100
@@ -511,7 +511,7 @@ static void wakeup_next_waiter(struct rt
 	 */
 	spin_lock_irqsave(&pendowner->pi_lock, flags);
 
-	WARN_ON(!pendowner->pi_blocked_on);
+	BUG_ON(!pendowner->pi_blocked_on);
 	WARN_ON(pendowner->pi_blocked_on != waiter);
 	WARN_ON(pendowner->pi_blocked_on->lock != lock);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/rtmutex-tester.c linux-2.6.32.60-pax/kernel/rtmutex-tester.c
--- linux-2.6.32.60/kernel/rtmutex-tester.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/rtmutex-tester.c	2012-03-13 13:15:35.652097962 +0100
@@ -21,7 +21,7 @@
 #define MAX_RT_TEST_MUTEXES	8
 
 static spinlock_t rttest_lock;
-static atomic_t rttest_event;
+static atomic_unchecked_t rttest_event;
 
 struct test_thread_data {
 	int			opcode;
@@ -64,7 +64,7 @@ static int handle_op(struct test_thread_
 
 	case RTTEST_LOCKCONT:
 		td->mutexes[td->opdata] = 1;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		return 0;
 
 	case RTTEST_RESET:
@@ -82,7 +82,7 @@ static int handle_op(struct test_thread_
 		return 0;
 
 	case RTTEST_RESETEVENT:
-		atomic_set(&rttest_event, 0);
+		atomic_set_unchecked(&rttest_event, 0);
 		return 0;
 
 	default:
@@ -99,9 +99,9 @@ static int handle_op(struct test_thread_
 			return ret;
 
 		td->mutexes[id] = 1;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		rt_mutex_lock(&mutexes[id]);
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		td->mutexes[id] = 4;
 		return 0;
 
@@ -112,9 +112,9 @@ static int handle_op(struct test_thread_
 			return ret;
 
 		td->mutexes[id] = 1;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		ret = rt_mutex_lock_interruptible(&mutexes[id], 0);
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		td->mutexes[id] = ret ? 0 : 4;
 		return ret ? -EINTR : 0;
 
@@ -123,9 +123,9 @@ static int handle_op(struct test_thread_
 		if (id < 0 || id >= MAX_RT_TEST_MUTEXES || td->mutexes[id] != 4)
 			return ret;
 
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		rt_mutex_unlock(&mutexes[id]);
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		td->mutexes[id] = 0;
 		return 0;
 
@@ -187,7 +187,7 @@ void schedule_rt_mutex_test(struct rt_mu
 			break;
 
 		td->mutexes[dat] = 2;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		break;
 
 	case RTTEST_LOCKBKL:
@@ -208,7 +208,7 @@ void schedule_rt_mutex_test(struct rt_mu
 			return;
 
 		td->mutexes[dat] = 3;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		break;
 
 	case RTTEST_LOCKNOWAIT:
@@ -220,7 +220,7 @@ void schedule_rt_mutex_test(struct rt_mu
 			return;
 
 		td->mutexes[dat] = 1;
-		td->event = atomic_add_return(1, &rttest_event);
+		td->event = atomic_add_return_unchecked(1, &rttest_event);
 		return;
 
 	case RTTEST_LOCKBKL:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/sched.c linux-2.6.32.60-pax/kernel/sched.c
--- linux-2.6.32.60/kernel/sched.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/sched.c	2012-03-13 13:15:35.656097962 +0100
@@ -5043,7 +5043,7 @@ out:
  * In CONFIG_NO_HZ case, the idle load balance owner will do the
  * rebalancing for all the cpus for whom scheduler ticks are stopped.
  */
-static void run_rebalance_domains(struct softirq_action *h)
+static void run_rebalance_domains(void)
 {
 	int this_cpu = smp_processor_id();
 	struct rq *this_rq = cpu_rq(this_cpu);
@@ -5770,7 +5770,7 @@ EXPORT_SYMBOL(schedule);
  * Look out! "owner" is an entirely speculative pointer
  * access and not reliable.
  */
-int mutex_spin_on_owner(struct mutex *lock, struct thread_info *owner)
+int mutex_spin_on_owner(struct mutex *lock, struct task_struct *owner)
 {
 	unsigned int cpu;
 	struct rq *rq;
@@ -5784,10 +5784,10 @@ int mutex_spin_on_owner(struct mutex *lo
 	 * DEBUG_PAGEALLOC could have unmapped it if
 	 * the mutex owner just released it and exited.
 	 */
-	if (probe_kernel_address(&owner->cpu, cpu))
+	if (probe_kernel_address(&task_thread_info(owner)->cpu, cpu))
 		return 0;
 #else
-	cpu = owner->cpu;
+	cpu = task_thread_info(owner)->cpu;
 #endif
 
 	/*
@@ -5816,7 +5816,7 @@ int mutex_spin_on_owner(struct mutex *lo
 		/*
 		 * Is that owner really running on that cpu?
 		 */
-		if (task_thread_info(rq->curr) != owner || need_resched())
+		if (rq->curr != owner || need_resched())
 			return 0;
 
 		cpu_relax();
@@ -8774,7 +8774,7 @@ static void init_sched_groups_power(int
 	long power;
 	int weight;
 
-	WARN_ON(!sd || !sd->groups);
+	BUG_ON(!sd || !sd->groups);
 
 	if (cpu != group_first_cpu(sd->groups))
 		return;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/signal.c linux-2.6.32.60-pax/kernel/signal.c
--- linux-2.6.32.60/kernel/signal.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/signal.c	2012-03-13 13:15:35.656097962 +0100
@@ -41,12 +41,12 @@
 
 static struct kmem_cache *sigqueue_cachep;
 
-static void __user *sig_handler(struct task_struct *t, int sig)
+static __sighandler_t sig_handler(struct task_struct *t, int sig)
 {
 	return t->sighand->action[sig - 1].sa.sa_handler;
 }
 
-static int sig_handler_ignored(void __user *handler, int sig)
+static int sig_handler_ignored(__sighandler_t handler, int sig)
 {
 	/* Is it explicitly or implicitly ignored? */
 	return handler == SIG_IGN ||
@@ -56,7 +56,7 @@ static int sig_handler_ignored(void __us
 static int sig_task_ignored(struct task_struct *t, int sig,
 		int from_ancestor_ns)
 {
-	void __user *handler;
+	__sighandler_t handler;
 
 	handler = sig_handler(t, sig);
 
@@ -327,7 +327,7 @@ flush_signal_handlers(struct task_struct
 
 int unhandled_signal(struct task_struct *tsk, int sig)
 {
-	void __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;
+	__sighandler_t handler = tsk->sighand->action[sig-1].sa.sa_handler;
 	if (is_global_init(tsk))
 		return 1;
 	if (handler != SIG_IGN && handler != SIG_DFL)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/smp.c linux-2.6.32.60-pax/kernel/smp.c
--- linux-2.6.32.60/kernel/smp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/smp.c	2012-03-13 13:15:35.656097962 +0100
@@ -522,22 +522,22 @@ int smp_call_function(void (*func)(void
 }
 EXPORT_SYMBOL(smp_call_function);
 
-void ipi_call_lock(void)
+void ipi_call_lock(void) __acquires(call_function.lock)
 {
 	spin_lock(&call_function.lock);
 }
 
-void ipi_call_unlock(void)
+void ipi_call_unlock(void) __releases(call_function.lock)
 {
 	spin_unlock(&call_function.lock);
 }
 
-void ipi_call_lock_irq(void)
+void ipi_call_lock_irq(void) __acquires(call_function.lock)
 {
 	spin_lock_irq(&call_function.lock);
 }
 
-void ipi_call_unlock_irq(void)
+void ipi_call_unlock_irq(void) __releases(call_function.lock)
 {
 	spin_unlock_irq(&call_function.lock);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/softirq.c linux-2.6.32.60-pax/kernel/softirq.c
--- linux-2.6.32.60/kernel/softirq.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/softirq.c	2013-02-17 19:42:54.755698316 +0100
@@ -52,11 +52,11 @@ irq_cpustat_t irq_stat[NR_CPUS] ____cach
 EXPORT_SYMBOL(irq_stat);
 #endif
 
-static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
+static struct softirq_action softirq_vec[NR_SOFTIRQS] __read_only __aligned(PAGE_SIZE);
 
 static DEFINE_PER_CPU(struct task_struct *, ksoftirqd);
 
-char *softirq_to_name[NR_SOFTIRQS] = {
+const char * const softirq_to_name[NR_SOFTIRQS] = {
 	"HI", "TIMER", "NET_TX", "NET_RX", "BLOCK", "BLOCK_IOPOLL",
 	"TASKLET", "SCHED", "HRTIMER",	"RCU"
 };
@@ -233,7 +233,7 @@ restart:
 			kstat_incr_softirqs_this_cpu(h - softirq_vec);
 
 			trace_softirq_entry(h, softirq_vec);
-			h->action(h);
+			h->action();
 			trace_softirq_exit(h, softirq_vec);
 			if (unlikely(prev_count != preempt_count())) {
 				printk(KERN_ERR "huh, entered softirq %td %s %p"
@@ -363,7 +363,7 @@ void raise_softirq(unsigned int nr)
 	local_irq_restore(flags);
 }
 
-void open_softirq(int nr, void (*action)(struct softirq_action *))
+void open_softirq(int nr, void (*action)(void))
 {
 	softirq_vec[nr].action = action;
 }
@@ -419,7 +419,7 @@ void __tasklet_hi_schedule_first(struct
 
 EXPORT_SYMBOL(__tasklet_hi_schedule_first);
 
-static void tasklet_action(struct softirq_action *a)
+static void tasklet_action(void)
 {
 	struct tasklet_struct *list;
 
@@ -454,7 +454,7 @@ static void tasklet_action(struct softir
 	}
 }
 
-static void tasklet_hi_action(struct softirq_action *a)
+static void tasklet_hi_action(void)
 {
 	struct tasklet_struct *list;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/sys.c linux-2.6.32.60-pax/kernel/sys.c
--- linux-2.6.32.60/kernel/sys.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/sys.c	2012-03-13 13:15:35.660097962 +0100
@@ -190,10 +190,10 @@ SYSCALL_DEFINE3(setpriority, int, which,
 				 !(user = find_user(who)))
 				goto out_unlock;	/* No processes for this user */
 
-			do_each_thread(g, p)
+			do_each_thread(g, p) {
 				if (__task_cred(p)->uid == who)
 					error = set_one_prio(p, niceval, error);
-			while_each_thread(g, p);
+			} while_each_thread(g, p);
 			if (who != cred->uid)
 				free_uid(user);		/* For find_user() */
 			break;
@@ -253,13 +253,13 @@ SYSCALL_DEFINE2(getpriority, int, which,
 				 !(user = find_user(who)))
 				goto out_unlock;	/* No processes for this user */
 
-			do_each_thread(g, p)
+			do_each_thread(g, p) {
 				if (__task_cred(p)->uid == who) {
 					niceval = 20 - task_nice(p);
 					if (niceval > retval)
 						retval = niceval;
 				}
-			while_each_thread(g, p);
+			} while_each_thread(g, p);
 			if (who != cred->uid)
 				free_uid(user);		/* for find_user() */
 			break;
@@ -1454,7 +1454,7 @@ SYSCALL_DEFINE5(prctl, int, option, unsi
 			error = get_dumpable(me->mm);
 			break;
 		case PR_SET_DUMPABLE:
-			if (arg2 < 0 || arg2 > 1) {
+			if (arg2 > 1) {
 				error = -EINVAL;
 				break;
 			}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/sysctl.c linux-2.6.32.60-pax/kernel/sysctl.c
--- linux-2.6.32.60/kernel/sysctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/sysctl.c	2012-03-13 13:15:35.664097962 +0100
@@ -200,6 +200,21 @@ extern struct ctl_table epoll_table[];
 int sysctl_legacy_va_layout;
 #endif
 
+#ifdef CONFIG_PAX_SOFTMODE
+static ctl_table pax_table[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "softmode",
+		.data		= &pax_softmode,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+
+	{ .ctl_name = 0 }
+};
+#endif
+
 extern int prove_locking;
 extern int lock_stat;
 
@@ -251,6 +266,16 @@ static int max_wakeup_granularity_ns = N
 #endif
 
 static struct ctl_table kern_table[] = {
+
+#ifdef CONFIG_PAX_SOFTMODE
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pax",
+		.mode		= 0500,
+		.child		= pax_table,
+	},
+#endif
+
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "sched_child_runs_first",
@@ -1247,6 +1272,13 @@ static struct ctl_table vm_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+	{
+		.procname	= "heap_stack_gap",
+		.data		= &sysctl_heap_stack_gap,
+		.maxlen		= sizeof(sysctl_heap_stack_gap),
+		.mode		= 0644,
+		.proc_handler	= proc_doulongvec_minmax,
+	},
 #else
 	{
 		.ctl_name	= CTL_UNNUMBERED,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/time/tick-broadcast.c linux-2.6.32.60-pax/kernel/time/tick-broadcast.c
--- linux-2.6.32.60/kernel/time/tick-broadcast.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/time/tick-broadcast.c	2012-03-13 13:15:35.888097950 +0100
@@ -116,7 +116,7 @@ int tick_device_uses_broadcast(struct cl
 		 * then clear the broadcast bit.
 		 */
 		if (!(dev->features & CLOCK_EVT_FEAT_C3STOP)) {
-			int cpu = smp_processor_id();
+			cpu = smp_processor_id();
 
 			cpumask_clear_cpu(cpu, tick_get_broadcast_mask());
 			tick_broadcast_clear_oneshot(cpu);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/time/timekeeping.c linux-2.6.32.60-pax/kernel/time/timekeeping.c
--- linux-2.6.32.60/kernel/time/timekeeping.c	2012-10-09 11:00:35.500882480 +0200
+++ linux-2.6.32.60-pax/kernel/time/timekeeping.c	2012-10-09 11:02:49.032900563 +0200
@@ -208,7 +208,7 @@ void update_xtime_cache(u64 nsec)
 	 */
 	struct timespec ts = xtime;
 	timespec_add_ns(&ts, nsec);
-	ACCESS_ONCE(xtime_cache) = ts;
+	ACCESS_ONCE_RW(xtime_cache) = ts;
 }
 
 #ifdef CONFIG_GENERIC_TIME
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/time/timer_stats.c linux-2.6.32.60-pax/kernel/time/timer_stats.c
--- linux-2.6.32.60/kernel/time/timer_stats.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/time/timer_stats.c	2012-03-13 13:15:35.888097950 +0100
@@ -116,7 +116,7 @@ static ktime_t time_start, time_stop;
 static unsigned long nr_entries;
 static struct entry entries[MAX_ENTRIES];
 
-static atomic_t overflow_count;
+static atomic_unchecked_t overflow_count;
 
 /*
  * The entries are in a hash-table, for fast lookup:
@@ -140,7 +140,7 @@ static void reset_entries(void)
 	nr_entries = 0;
 	memset(entries, 0, sizeof(entries));
 	memset(tstat_hash_table, 0, sizeof(tstat_hash_table));
-	atomic_set(&overflow_count, 0);
+	atomic_set_unchecked(&overflow_count, 0);
 }
 
 static struct entry *alloc_entry(void)
@@ -261,7 +261,7 @@ void timer_stats_update_stats(void *time
 	if (likely(entry))
 		entry->count++;
 	else
-		atomic_inc(&overflow_count);
+		atomic_inc_unchecked(&overflow_count);
 
  out_unlock:
 	spin_unlock_irqrestore(lock, flags);
@@ -300,9 +300,9 @@ static int tstats_show(struct seq_file *
 
 	seq_puts(m, "Timer Stats Version: v0.2\n");
 	seq_printf(m, "Sample period: %ld.%03ld s\n", period.tv_sec, ms);
-	if (atomic_read(&overflow_count))
+	if (atomic_read_unchecked(&overflow_count))
 		seq_printf(m, "Overflow: %d entries\n",
-			atomic_read(&overflow_count));
+			atomic_read_unchecked(&overflow_count));
 
 	for (i = 0; i < nr_entries; i++) {
 		entry = entries + i;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/time.c linux-2.6.32.60-pax/kernel/time.c
--- linux-2.6.32.60/kernel/time.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/time.c	2012-03-13 13:15:35.892097949 +0100
@@ -240,7 +240,7 @@ EXPORT_SYMBOL(current_fs_time);
  * Avoid unnecessary multiplications/divisions in the
  * two most common HZ cases:
  */
-unsigned int inline jiffies_to_msecs(const unsigned long j)
+inline unsigned int jiffies_to_msecs(const unsigned long j)
 {
 #if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
 	return (MSEC_PER_SEC / HZ) * j;
@@ -256,7 +256,7 @@ unsigned int inline jiffies_to_msecs(con
 }
 EXPORT_SYMBOL(jiffies_to_msecs);
 
-unsigned int inline jiffies_to_usecs(const unsigned long j)
+inline unsigned int jiffies_to_usecs(const unsigned long j)
 {
 #if HZ <= USEC_PER_SEC && !(USEC_PER_SEC % HZ)
 	return (USEC_PER_SEC / HZ) * j;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/timer.c linux-2.6.32.60-pax/kernel/timer.c
--- linux-2.6.32.60/kernel/timer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/timer.c	2013-01-22 17:38:23.476543631 +0100
@@ -1213,7 +1213,7 @@ void update_process_times(int user_tick)
 /*
  * This function runs timers and the timer-tq in bottom half context.
  */
-static void run_timer_softirq(struct softirq_action *h)
+static void run_timer_softirq(void)
 {
 	struct tvec_base *base = __get_cpu_var(tvec_bases);
 
@@ -1645,7 +1645,7 @@ static int __cpuinit timer_cpu_notify(st
 	return NOTIFY_OK;
 }
 
-static struct notifier_block __cpuinitdata timers_nb = {
+static struct notifier_block __cpuinitconst timers_nb = {
 	.notifier_call	= timer_cpu_notify,
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/blktrace.c linux-2.6.32.60-pax/kernel/trace/blktrace.c
--- linux-2.6.32.60/kernel/trace/blktrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/blktrace.c	2012-03-13 13:15:35.892097949 +0100
@@ -313,7 +313,7 @@ static ssize_t blk_dropped_read(struct f
 	struct blk_trace *bt = filp->private_data;
 	char buf[16];
 
-	snprintf(buf, sizeof(buf), "%u\n", atomic_read(&bt->dropped));
+	snprintf(buf, sizeof(buf), "%u\n", atomic_read_unchecked(&bt->dropped));
 
 	return simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));
 }
@@ -376,7 +376,7 @@ static int blk_subbuf_start_callback(str
 		return 1;
 
 	bt = buf->chan->private_data;
-	atomic_inc(&bt->dropped);
+	atomic_inc_unchecked(&bt->dropped);
 	return 0;
 }
 
@@ -477,7 +477,7 @@ int do_blk_trace_setup(struct request_qu
 
 	bt->dir = dir;
 	bt->dev = dev;
-	atomic_set(&bt->dropped, 0);
+	atomic_set_unchecked(&bt->dropped, 0);
 
 	ret = -EIO;
 	bt->dropped_file = debugfs_create_file("dropped", 0444, dir, bt,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/ftrace.c linux-2.6.32.60-pax/kernel/trace/ftrace.c
--- linux-2.6.32.60/kernel/trace/ftrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/ftrace.c	2013-01-22 17:38:23.480543630 +0100
@@ -1100,13 +1100,18 @@ ftrace_code_disable(struct module *mod,
 
 	ip = rec->ip;
 
+	ret = ftrace_arch_code_modify_prepare();
+	FTRACE_WARN_ON(ret);
+	if (ret)
+		return 0;
+
 	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
+	FTRACE_WARN_ON(ftrace_arch_code_modify_post_process());
 	if (ret) {
 		ftrace_bug(ret, ip);
 		rec->flags |= FTRACE_FL_FAILED;
-		return 0;
 	}
-	return 1;
+	return ret ? 0 : 1;
 }
 
 /*
@@ -3068,8 +3073,6 @@ ftrace_enable_sysctl(struct ctl_table *t
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 
 static int ftrace_graph_active;
-static struct notifier_block ftrace_suspend_notifier;
-
 int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)
 {
 	return 0;
@@ -3213,6 +3216,10 @@ ftrace_suspend_notifier_call(struct noti
 	return NOTIFY_DONE;
 }
 
+static struct notifier_block ftrace_suspend_notifier = {
+	.notifier_call = ftrace_suspend_notifier_call
+};
+
 int register_ftrace_graph(trace_func_graph_ret_t retfunc,
 			trace_func_graph_ent_t entryfunc)
 {
@@ -3226,7 +3233,6 @@ int register_ftrace_graph(trace_func_gra
 		goto out;
 	}
 
-	ftrace_suspend_notifier.notifier_call = ftrace_suspend_notifier_call;
 	register_pm_notifier(&ftrace_suspend_notifier);
 
 	ftrace_graph_active++;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/ring_buffer.c linux-2.6.32.60-pax/kernel/trace/ring_buffer.c
--- linux-2.6.32.60/kernel/trace/ring_buffer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/ring_buffer.c	2012-12-14 21:47:15.137850497 +0100
@@ -325,9 +325,9 @@ struct buffer_data_page {
  */
 struct buffer_page {
 	struct list_head list;		/* list of buffer pages */
-	local_t		 write;		/* index for next write */
+	local_unchecked_t	 write;		/* index for next write */
 	unsigned	 read;		/* index for next read */
-	local_t		 entries;	/* entries on this page */
+	local_unchecked_t	 entries;	/* entries on this page */
 	struct buffer_data_page *page;	/* Actual data page */
 };
 
@@ -427,8 +427,8 @@ struct ring_buffer_per_cpu {
 	struct buffer_page		*tail_page;	/* write to tail */
 	struct buffer_page		*commit_page;	/* committed pages */
 	struct buffer_page		*reader_page;
-	local_t				commit_overrun;
-	local_t				overrun;
+	local_unchecked_t		commit_overrun;
+	local_unchecked_t		overrun;
 	local_t				entries;
 	local_t				committing;
 	local_t				commits;
@@ -606,7 +606,7 @@ static struct list_head *rb_list_head(st
  * the reader page). But if the next page is a header page,
  * its flags will be non zero.
  */
-static int inline
+static inline int
 rb_is_head_page(struct ring_buffer_per_cpu *cpu_buffer,
 		struct buffer_page *page, struct list_head *list)
 {
@@ -820,8 +820,8 @@ static int rb_tail_page_update(struct ri
 	 *
 	 * We add a counter to the write field to denote this.
 	 */
-	old_write = local_add_return(RB_WRITE_INTCNT, &next_page->write);
-	old_entries = local_add_return(RB_WRITE_INTCNT, &next_page->entries);
+	old_write = local_add_return_unchecked(RB_WRITE_INTCNT, &next_page->write);
+	old_entries = local_add_return_unchecked(RB_WRITE_INTCNT, &next_page->entries);
 
 	/*
 	 * Just make sure we have seen our old_write and synchronize
@@ -849,8 +849,8 @@ static int rb_tail_page_update(struct ri
 		 * cmpxchg to only update if an interrupt did not already
 		 * do it for us. If the cmpxchg fails, we don't care.
 		 */
-		(void)local_cmpxchg(&next_page->write, old_write, val);
-		(void)local_cmpxchg(&next_page->entries, old_entries, eval);
+		(void)local_cmpxchg_unchecked(&next_page->write, old_write, val);
+		(void)local_cmpxchg_unchecked(&next_page->entries, old_entries, eval);
 
 		/*
 		 * No need to worry about races with clearing out the commit.
@@ -1397,7 +1397,7 @@ rb_iter_head_event(struct ring_buffer_it
 
 static inline unsigned long rb_page_write(struct buffer_page *bpage)
 {
-	return local_read(&bpage->write) & RB_WRITE_MASK;
+	return local_read_unchecked(&bpage->write) & RB_WRITE_MASK;
 }
 
 static inline unsigned rb_page_commit(struct buffer_page *bpage)
@@ -1407,7 +1407,7 @@ static inline unsigned rb_page_commit(st
 
 static inline unsigned long rb_page_entries(struct buffer_page *bpage)
 {
-	return local_read(&bpage->entries) & RB_WRITE_MASK;
+	return local_read_unchecked(&bpage->entries) & RB_WRITE_MASK;
 }
 
 /* Size is determined by what has been commited */
@@ -1603,7 +1603,7 @@ rb_handle_head_page(struct ring_buffer_p
 		 * it is our responsibility to update
 		 * the counters.
 		 */
-		local_add(entries, &cpu_buffer->overrun);
+		local_add_unchecked(entries, &cpu_buffer->overrun);
 
 		/*
 		 * The entries will be zeroed out when we move the
@@ -1744,7 +1744,7 @@ rb_reset_tail(struct ring_buffer_per_cpu
 	 * must fill the old tail_page with padding.
 	 */
 	if (tail >= BUF_PAGE_SIZE) {
-		local_sub(length, &tail_page->write);
+		local_sub_unchecked(length, &tail_page->write);
 		return;
 	}
 
@@ -1769,7 +1769,7 @@ rb_reset_tail(struct ring_buffer_per_cpu
 		rb_event_set_padding(event);
 
 		/* Set the write back to the previous setting */
-		local_sub(length, &tail_page->write);
+		local_sub_unchecked(length, &tail_page->write);
 		return;
 	}
 
@@ -1781,7 +1781,7 @@ rb_reset_tail(struct ring_buffer_per_cpu
 
 	/* Set write to end of buffer */
 	length = (tail + length) - BUF_PAGE_SIZE;
-	local_sub(length, &tail_page->write);
+	local_sub_unchecked(length, &tail_page->write);
 }
 
 static struct ring_buffer_event *
@@ -1804,7 +1804,7 @@ rb_move_tail(struct ring_buffer_per_cpu
 	 * about it.
 	 */
 	if (unlikely(next_page == commit_page)) {
-		local_inc(&cpu_buffer->commit_overrun);
+		local_inc_unchecked(&cpu_buffer->commit_overrun);
 		goto out_reset;
 	}
 
@@ -1858,7 +1858,7 @@ rb_move_tail(struct ring_buffer_per_cpu
 				      cpu_buffer->tail_page) &&
 				     (cpu_buffer->commit_page ==
 				      cpu_buffer->reader_page))) {
-				local_inc(&cpu_buffer->commit_overrun);
+				local_inc_unchecked(&cpu_buffer->commit_overrun);
 				goto out_reset;
 			}
 		}
@@ -1900,7 +1900,7 @@ __rb_reserve_next(struct ring_buffer_per
 	/* we just need to protect against interrupts */
 	barrier();
 	tail_page = cpu_buffer->tail_page;
-	write = local_add_return(length, &tail_page->write);
+	write = local_add_return_unchecked(length, &tail_page->write);
 
 	/* set write to only the index of the write */
 	write &= RB_WRITE_MASK;
@@ -1919,7 +1919,7 @@ __rb_reserve_next(struct ring_buffer_per
 
 	/* The passed in type is zero for DATA */
 	if (likely(!type))
-		local_inc(&tail_page->entries);
+		local_inc_unchecked(&tail_page->entries);
 
 	/*
 	 * If this is the first commit on the page, then update
@@ -1949,7 +1949,7 @@ rb_try_to_discard(struct ring_buffer_per
 
 	if (bpage->page == (void *)addr && rb_page_write(bpage) == old_index) {
 		unsigned long write_mask =
-			local_read(&bpage->write) & ~RB_WRITE_MASK;
+			local_read_unchecked(&bpage->write) & ~RB_WRITE_MASK;
 		/*
 		 * This is on the tail page. It is possible that
 		 * a write could come in and move the tail page
@@ -1958,7 +1958,7 @@ rb_try_to_discard(struct ring_buffer_per
 		 */
 		old_index += write_mask;
 		new_index += write_mask;
-		index = local_cmpxchg(&bpage->write, old_index, new_index);
+		index = local_cmpxchg_unchecked(&bpage->write, old_index, new_index);
 		if (index == old_index)
 			return 1;
 	}
@@ -2363,7 +2363,7 @@ rb_decrement_entry(struct ring_buffer_pe
 
 	/* Do the likely case first */
 	if (likely(bpage->page == (void *)addr)) {
-		local_dec(&bpage->entries);
+		local_dec_unchecked(&bpage->entries);
 		return;
 	}
 
@@ -2375,7 +2375,7 @@ rb_decrement_entry(struct ring_buffer_pe
 	start = bpage;
 	do {
 		if (bpage->page == (void *)addr) {
-			local_dec(&bpage->entries);
+			local_dec_unchecked(&bpage->entries);
 			return;
 		}
 		rb_inc_page(cpu_buffer, &bpage);
@@ -2610,7 +2610,7 @@ unsigned long ring_buffer_entries_cpu(st
 		return 0;
 
 	cpu_buffer = buffer->buffers[cpu];
-	ret = (local_read(&cpu_buffer->entries) - local_read(&cpu_buffer->overrun))
+	ret = (local_read(&cpu_buffer->entries) - local_read_unchecked(&cpu_buffer->overrun))
 		- cpu_buffer->read;
 
 	return ret;
@@ -2631,7 +2631,7 @@ unsigned long ring_buffer_overrun_cpu(st
 		return 0;
 
 	cpu_buffer = buffer->buffers[cpu];
-	ret = local_read(&cpu_buffer->overrun);
+	ret = local_read_unchecked(&cpu_buffer->overrun);
 
 	return ret;
 }
@@ -2652,7 +2652,7 @@ ring_buffer_commit_overrun_cpu(struct ri
 		return 0;
 
 	cpu_buffer = buffer->buffers[cpu];
-	ret = local_read(&cpu_buffer->commit_overrun);
+	ret = local_read_unchecked(&cpu_buffer->commit_overrun);
 
 	return ret;
 }
@@ -2675,7 +2675,7 @@ unsigned long ring_buffer_entries(struct
 	for_each_buffer_cpu(buffer, cpu) {
 		cpu_buffer = buffer->buffers[cpu];
 		entries += (local_read(&cpu_buffer->entries) -
-			    local_read(&cpu_buffer->overrun)) - cpu_buffer->read;
+			    local_read_unchecked(&cpu_buffer->overrun)) - cpu_buffer->read;
 	}
 
 	return entries;
@@ -2698,7 +2698,7 @@ unsigned long ring_buffer_overruns(struc
 	/* if you care about this being correct, lock the buffer */
 	for_each_buffer_cpu(buffer, cpu) {
 		cpu_buffer = buffer->buffers[cpu];
-		overruns += local_read(&cpu_buffer->overrun);
+		overruns += local_read_unchecked(&cpu_buffer->overrun);
 	}
 
 	return overruns;
@@ -2867,8 +2867,8 @@ rb_get_reader_page(struct ring_buffer_pe
 	/*
 	 * Reset the reader page to size zero.
 	 */
-	local_set(&cpu_buffer->reader_page->write, 0);
-	local_set(&cpu_buffer->reader_page->entries, 0);
+	local_set_unchecked(&cpu_buffer->reader_page->write, 0);
+	local_set_unchecked(&cpu_buffer->reader_page->entries, 0);
 	local_set(&cpu_buffer->reader_page->page->commit, 0);
 
  spin:
@@ -3360,8 +3360,8 @@ rb_reset_cpu(struct ring_buffer_per_cpu
 
 	cpu_buffer->head_page
 		= list_entry(cpu_buffer->pages, struct buffer_page, list);
-	local_set(&cpu_buffer->head_page->write, 0);
-	local_set(&cpu_buffer->head_page->entries, 0);
+	local_set_unchecked(&cpu_buffer->head_page->write, 0);
+	local_set_unchecked(&cpu_buffer->head_page->entries, 0);
 	local_set(&cpu_buffer->head_page->page->commit, 0);
 
 	cpu_buffer->head_page->read = 0;
@@ -3370,13 +3370,13 @@ rb_reset_cpu(struct ring_buffer_per_cpu
 	cpu_buffer->commit_page = cpu_buffer->head_page;
 
 	INIT_LIST_HEAD(&cpu_buffer->reader_page->list);
-	local_set(&cpu_buffer->reader_page->write, 0);
-	local_set(&cpu_buffer->reader_page->entries, 0);
+	local_set_unchecked(&cpu_buffer->reader_page->write, 0);
+	local_set_unchecked(&cpu_buffer->reader_page->entries, 0);
 	local_set(&cpu_buffer->reader_page->page->commit, 0);
 	cpu_buffer->reader_page->read = 0;
 
-	local_set(&cpu_buffer->commit_overrun, 0);
-	local_set(&cpu_buffer->overrun, 0);
+	local_set_unchecked(&cpu_buffer->commit_overrun, 0);
+	local_set_unchecked(&cpu_buffer->overrun, 0);
 	local_set(&cpu_buffer->entries, 0);
 	local_set(&cpu_buffer->committing, 0);
 	local_set(&cpu_buffer->commits, 0);
@@ -3752,8 +3752,8 @@ int ring_buffer_read_page(struct ring_bu
 		rb_init_page(bpage);
 		bpage = reader->page;
 		reader->page = *data_page;
-		local_set(&reader->write, 0);
-		local_set(&reader->entries, 0);
+		local_set_unchecked(&reader->write, 0);
+		local_set_unchecked(&reader->entries, 0);
 		reader->read = 0;
 		*data_page = bpage;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace.c linux-2.6.32.60-pax/kernel/trace/trace.c
--- linux-2.6.32.60/kernel/trace/trace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace.c	2012-03-13 13:15:35.900097949 +0100
@@ -3816,10 +3816,9 @@ static const struct file_operations trac
 };
 #endif
 
-static struct dentry *d_tracer;
-
 struct dentry *tracing_init_dentry(void)
 {
+	static struct dentry *d_tracer;
 	static int once;
 
 	if (d_tracer)
@@ -3839,10 +3838,9 @@ struct dentry *tracing_init_dentry(void)
 	return d_tracer;
 }
 
-static struct dentry *d_percpu;
-
 struct dentry *tracing_dentry_percpu(void)
 {
+	static struct dentry *d_percpu;
 	static int once;
 	struct dentry *d_tracer;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace_events.c linux-2.6.32.60-pax/kernel/trace/trace_events.c
--- linux-2.6.32.60/kernel/trace/trace_events.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace_events.c	2013-02-17 19:39:30.031709247 +0100
@@ -951,13 +951,10 @@ static LIST_HEAD(ftrace_module_file_list
  * Modules must own their file_operations to keep up with
  * reference counting.
  */
+
 struct ftrace_module_file_ops {
 	struct list_head		list;
 	struct module			*mod;
-	struct file_operations		id;
-	struct file_operations		enable;
-	struct file_operations		format;
-	struct file_operations		filter;
 };
 
 static void remove_subsystem_dir(const char *name)
@@ -1004,17 +1001,12 @@ trace_create_file_ops(struct module *mod
 
 	file_ops->mod = mod;
 
-	file_ops->id = ftrace_event_id_fops;
-	file_ops->id.owner = mod;
-
-	file_ops->enable = ftrace_enable_fops;
-	file_ops->enable.owner = mod;
-
-	file_ops->filter = ftrace_event_filter_fops;
-	file_ops->filter.owner = mod;
-
-	file_ops->format = ftrace_event_format_fops;
-	file_ops->format.owner = mod;
+	pax_open_kernel();
+	mod->trace_id.owner = mod;
+	mod->trace_enable.owner = mod;
+	mod->trace_filter.owner = mod;
+	mod->trace_format.owner = mod;
+	pax_close_kernel();
 
 	list_add(&file_ops->list, &ftrace_module_file_list);
 
@@ -1063,8 +1055,8 @@ static void trace_module_add_events(stru
 		call->mod = mod;
 		list_add(&call->list, &ftrace_events);
 		event_create_dir(call, d_events,
-				 &file_ops->id, &file_ops->enable,
-				 &file_ops->filter, &file_ops->format);
+				 &mod->trace_id, &mod->trace_enable,
+				 &mod->trace_filter, &mod->trace_format);
 	}
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace_mmiotrace.c linux-2.6.32.60-pax/kernel/trace/trace_mmiotrace.c
--- linux-2.6.32.60/kernel/trace/trace_mmiotrace.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace_mmiotrace.c	2012-03-13 13:15:35.904097949 +0100
@@ -23,7 +23,7 @@ struct header_iter {
 static struct trace_array *mmio_trace_array;
 static bool overrun_detected;
 static unsigned long prev_overruns;
-static atomic_t dropped_count;
+static atomic_unchecked_t dropped_count;
 
 static void mmio_reset_data(struct trace_array *tr)
 {
@@ -126,7 +126,7 @@ static void mmio_close(struct trace_iter
 
 static unsigned long count_overruns(struct trace_iterator *iter)
 {
-	unsigned long cnt = atomic_xchg(&dropped_count, 0);
+	unsigned long cnt = atomic_xchg_unchecked(&dropped_count, 0);
 	unsigned long over = ring_buffer_overruns(iter->tr->buffer);
 
 	if (over > prev_overruns)
@@ -316,7 +316,7 @@ static void __trace_mmiotrace_rw(struct
 	event = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,
 					  sizeof(*entry), 0, pc);
 	if (!event) {
-		atomic_inc(&dropped_count);
+		atomic_inc_unchecked(&dropped_count);
 		return;
 	}
 	entry	= ring_buffer_event_data(event);
@@ -346,7 +346,7 @@ static void __trace_mmiotrace_map(struct
 	event = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,
 					  sizeof(*entry), 0, pc);
 	if (!event) {
-		atomic_inc(&dropped_count);
+		atomic_inc_unchecked(&dropped_count);
 		return;
 	}
 	entry	= ring_buffer_event_data(event);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace_output.c linux-2.6.32.60-pax/kernel/trace/trace_output.c
--- linux-2.6.32.60/kernel/trace/trace_output.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace_output.c	2013-01-22 22:06:40.175684192 +0100
@@ -237,7 +237,7 @@ int trace_seq_path(struct trace_seq *s,
 		return 0;
 	p = d_path(path, s->buffer + s->len, PAGE_SIZE - s->len);
 	if (!IS_ERR(p)) {
-		p = mangle_path(s->buffer + s->len, p, "\n");
+		p = mangle_path(s->buffer + s->len, p, "\n\\");
 		if (p) {
 			s->len = p - s->buffer;
 			return 1;
@@ -711,14 +711,16 @@ int register_ftrace_event(struct trace_e
 			goto out;
 	}
 
+	pax_open_kernel();
 	if (event->trace == NULL)
-		event->trace = trace_nop_print;
+		*(void **)&event->trace = trace_nop_print;
 	if (event->raw == NULL)
-		event->raw = trace_nop_print;
+		*(void **)&event->raw = trace_nop_print;
 	if (event->hex == NULL)
-		event->hex = trace_nop_print;
+		*(void **)&event->hex = trace_nop_print;
 	if (event->binary == NULL)
-		event->binary = trace_nop_print;
+		*(void **)&event->binary = trace_nop_print;
+	pax_close_kernel();
 
 	key = event->type & (EVENT_HASHSIZE - 1);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace_stack.c linux-2.6.32.60-pax/kernel/trace/trace_stack.c
--- linux-2.6.32.60/kernel/trace/trace_stack.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace_stack.c	2012-03-13 13:15:35.904097949 +0100
@@ -50,7 +50,7 @@ static inline void check_stack(void)
 		return;
 
 	/* we do not handle interrupt stacks yet */
-	if (!object_is_on_stack(&this_size))
+	if (!object_starts_on_stack(&this_size))
 		return;
 
 	local_irq_save(flags);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/kernel/trace/trace_workqueue.c linux-2.6.32.60-pax/kernel/trace/trace_workqueue.c
--- linux-2.6.32.60/kernel/trace/trace_workqueue.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/kernel/trace/trace_workqueue.c	2012-03-13 13:15:35.904097949 +0100
@@ -21,7 +21,7 @@ struct cpu_workqueue_stats {
 	int		            cpu;
 	pid_t			    pid;
 /* Can be inserted from interrupt or user context, need to be atomic */
-	atomic_t	            inserted;
+	atomic_unchecked_t          inserted;
 /*
  *  Don't need to be atomic, works are serialized in a single workqueue thread
  *  on a single CPU.
@@ -58,7 +58,7 @@ probe_workqueue_insertion(struct task_st
 	spin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);
 	list_for_each_entry(node, &workqueue_cpu_stat(cpu)->list, list) {
 		if (node->pid == wq_thread->pid) {
-			atomic_inc(&node->inserted);
+			atomic_inc_unchecked(&node->inserted);
 			goto found;
 		}
 	}
@@ -205,7 +205,7 @@ static int workqueue_stat_show(struct se
 		tsk = get_pid_task(pid, PIDTYPE_PID);
 		if (tsk) {
 			seq_printf(s, "%3d %6d     %6u       %s\n", cws->cpu,
-				   atomic_read(&cws->inserted), cws->executed,
+				   atomic_read_unchecked(&cws->inserted), cws->executed,
 				   tsk->comm);
 			put_task_struct(tsk);
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/bitmap.c linux-2.6.32.60-pax/lib/bitmap.c
--- linux-2.6.32.60/lib/bitmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/bitmap.c	2012-03-13 13:15:35.908097949 +0100
@@ -341,7 +341,7 @@ int __bitmap_parse(const char *buf, unsi
 {
 	int c, old_c, totaldigits, ndigits, nchunks, nbits;
 	u32 chunk;
-	const char __user *ubuf = buf;
+	const char __user *ubuf = (const char __force_user *)buf;
 
 	bitmap_zero(maskp, nmaskbits);
 
@@ -426,7 +426,7 @@ int bitmap_parse_user(const char __user
 {
 	if (!access_ok(VERIFY_READ, ubuf, ulen))
 		return -EFAULT;
-	return __bitmap_parse((const char *)ubuf, ulen, 1, maskp, nmaskbits);
+	return __bitmap_parse((const char __force_kernel *)ubuf, ulen, 1, maskp, nmaskbits);
 }
 EXPORT_SYMBOL(bitmap_parse_user);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/bug.c linux-2.6.32.60-pax/lib/bug.c
--- linux-2.6.32.60/lib/bug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/bug.c	2012-03-13 13:15:35.908097949 +0100
@@ -135,6 +135,8 @@ enum bug_trap_type report_bug(unsigned l
 		return BUG_TRAP_TYPE_NONE;
 
 	bug = find_bug(bugaddr);
+	if (!bug)
+		return BUG_TRAP_TYPE_NONE;
 
 	printk(KERN_EMERG "------------[ cut here ]------------\n");
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/debugobjects.c linux-2.6.32.60-pax/lib/debugobjects.c
--- linux-2.6.32.60/lib/debugobjects.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/debugobjects.c	2012-03-13 13:15:35.908097949 +0100
@@ -277,7 +277,7 @@ static void debug_object_is_on_stack(voi
 	if (limit > 4)
 		return;
 
-	is_on_stack = object_is_on_stack(addr);
+	is_on_stack = object_starts_on_stack(addr);
 	if (is_on_stack == onstack)
 		return;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/devres.c linux-2.6.32.60-pax/lib/devres.c
--- linux-2.6.32.60/lib/devres.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/devres.c	2012-03-13 13:15:35.908097949 +0100
@@ -80,7 +80,7 @@ void devm_iounmap(struct device *dev, vo
 {
 	iounmap(addr);
 	WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
-			       (void *)addr));
+			       (void __force *)addr));
 }
 EXPORT_SYMBOL(devm_iounmap);
 
@@ -140,7 +140,7 @@ void devm_ioport_unmap(struct device *de
 {
 	ioport_unmap(addr);
 	WARN_ON(devres_destroy(dev, devm_ioport_map_release,
-			       devm_ioport_map_match, (void *)addr));
+			       devm_ioport_map_match, (void __force *)addr));
 }
 EXPORT_SYMBOL(devm_ioport_unmap);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/dma-debug.c linux-2.6.32.60-pax/lib/dma-debug.c
--- linux-2.6.32.60/lib/dma-debug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/dma-debug.c	2013-01-22 17:38:23.480543630 +0100
@@ -696,7 +696,7 @@ static int dma_debug_device_change(struc
 
 void dma_debug_add_bus(struct bus_type *bus)
 {
-	struct notifier_block *nb;
+	notifier_block_no_const *nb;
 
 	if (global_disable)
 		return;
@@ -861,7 +861,7 @@ out:
 
 static void check_for_stack(struct device *dev, void *addr)
 {
-	if (object_is_on_stack(addr))
+	if (object_starts_on_stack(addr))
 		err_printk(dev, NULL, "DMA-API: device driver maps memory from"
 				"stack [addr=%p]\n", addr);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/idr.c linux-2.6.32.60-pax/lib/idr.c
--- linux-2.6.32.60/lib/idr.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/idr.c	2012-03-13 13:15:35.912097948 +0100
@@ -156,7 +156,7 @@ static int sub_alloc(struct idr *idp, in
 			id = (id | ((1 << (IDR_BITS * l)) - 1)) + 1;
 
 			/* if already at the top layer, we need to grow */
-			if (id >= 1 << (idp->layers * IDR_BITS)) {
+			if (id >= (1 << (idp->layers * IDR_BITS))) {
 				*starting_id = id;
 				return IDR_NEED_TO_GROW;
 			}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/inflate.c linux-2.6.32.60-pax/lib/inflate.c
--- linux-2.6.32.60/lib/inflate.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/inflate.c	2012-03-13 13:15:35.912097948 +0100
@@ -266,7 +266,7 @@ static void free(void *where)
 		malloc_ptr = free_mem_ptr;
 }
 #else
-#define malloc(a) kmalloc(a, GFP_KERNEL)
+#define malloc(a) kmalloc((a), GFP_KERNEL)
 #define free(a) kfree(a)
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/ioremap.c linux-2.6.32.60-pax/lib/ioremap.c
--- linux-2.6.32.60/lib/ioremap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/ioremap.c	2012-05-08 23:38:04.275923539 +0200
@@ -37,7 +37,7 @@ static inline int ioremap_pmd_range(pud_
 	unsigned long next;
 
 	phys_addr -= addr;
-	pmd = pmd_alloc(&init_mm, pud, addr);
+	pmd = pmd_alloc_kernel(&init_mm, pud, addr);
 	if (!pmd)
 		return -ENOMEM;
 	do {
@@ -55,7 +55,7 @@ static inline int ioremap_pud_range(pgd_
 	unsigned long next;
 
 	phys_addr -= addr;
-	pud = pud_alloc(&init_mm, pgd, addr);
+	pud = pud_alloc_kernel(&init_mm, pgd, addr);
 	if (!pud)
 		return -ENOMEM;
 	do {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/kref.c linux-2.6.32.60-pax/lib/kref.c
--- linux-2.6.32.60/lib/kref.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/kref.c	2012-03-13 13:15:35.912097948 +0100
@@ -61,7 +61,7 @@ void kref_get(struct kref *kref)
  */
 int kref_put(struct kref *kref, void (*release)(struct kref *kref))
 {
-	WARN_ON(release == NULL);
+	BUG_ON(release == NULL);
 	WARN_ON(release == (void (*)(struct kref *))kfree);
 
 	if (atomic_dec_and_test(&kref->refcount)) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/list_debug.c linux-2.6.32.60-pax/lib/list_debug.c
--- linux-2.6.32.60/lib/list_debug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/list_debug.c	2013-01-23 00:02:32.547312989 +0100
@@ -8,7 +8,9 @@
 
 #include <linux/module.h>
 #include <linux/list.h>
+#include <linux/mm.h>
 
+#ifdef CONFIG_DEBUG_LIST
 /*
  * Insert a new entry between two known consecutive entries.
  *
@@ -16,18 +18,31 @@
  * the prev/next entries already!
  */
 
-void __list_add(struct list_head *new,
-			      struct list_head *prev,
-			      struct list_head *next)
+static bool __list_add_debug(struct list_head *new,
+			     struct list_head *prev,
+			     struct list_head *next)
 {
-	WARN(next->prev != prev,
+	if (WARN(next->prev != prev,
 		"list_add corruption. next->prev should be "
 		"prev (%p), but was %p. (next=%p).\n",
-		prev, next->prev, next);
-	WARN(prev->next != next,
+		prev, next->prev, next) ||
+	    WARN(prev->next != next,
 		"list_add corruption. prev->next should be "
 		"next (%p), but was %p. (prev=%p).\n",
-		next, prev->next, prev);
+		next, prev->next, prev) ||
+	    WARN(new == prev || new == next,
+		"list_add double add: new=%p, prev=%p, next=%p.\n",
+		new, prev, next))
+		return false;
+	return true;
+}
+
+void __list_add(struct list_head *new,
+		struct list_head *prev,
+		struct list_head *next)
+{
+	if (!__list_add_debug(new, prev, next))
+		return;
 	next->prev = new;
 	new->next = next;
 	new->prev = prev;
@@ -41,16 +56,61 @@ EXPORT_SYMBOL(__list_add);
  * Note: list_empty on entry does not return true after this, the entry is
  * in an undefined state.
  */
-void list_del(struct list_head *entry)
+static bool list_del_debug(struct list_head *entry)
 {
-	WARN(entry->prev->next != entry,
+	if (WARN(entry->prev->next != entry,
 		"list_del corruption. prev->next should be %p, "
-		"but was %p\n", entry, entry->prev->next);
-	WARN(entry->next->prev != entry,
+		"but was %p\n", entry, entry->prev->next) ||
+	    WARN(entry->next->prev != entry,
 		"list_del corruption. next->prev should be %p, "
-		"but was %p\n", entry, entry->next->prev);
+		"but was %p\n", entry, entry->next->prev))
+		return false;
+	return true;
+}
+
+void list_del(struct list_head *entry)
+{
+	if (!list_del_debug(entry))
+		return;
 	__list_del(entry->prev, entry->next);
 	entry->next = LIST_POISON1;
 	entry->prev = LIST_POISON2;
 }
 EXPORT_SYMBOL(list_del);
+#endif
+
+void pax_list_add_tail(struct list_head *new, struct list_head *head)
+{
+	struct list_head *prev, *next;
+
+	prev = head->prev;
+	next = head;
+
+#ifdef CONFIG_DEBUG_LIST
+	if (!__list_add_debug(new, prev, next))
+		return;
+#endif
+
+	pax_open_kernel();
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+	pax_close_kernel();
+}
+EXPORT_SYMBOL(pax_list_add_tail);
+
+void pax_list_del(struct list_head *entry)
+{
+#ifdef CONFIG_DEBUG_LIST
+	if (!list_del_debug(entry))
+		return;
+#endif
+
+	pax_open_kernel();
+	__list_del(entry->prev, entry->next);
+	entry->next = LIST_POISON1;
+	entry->prev = LIST_POISON2;
+	pax_close_kernel();
+}
+EXPORT_SYMBOL(pax_list_del);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/Makefile linux-2.6.32.60-pax/lib/Makefile
--- linux-2.6.32.60/lib/Makefile	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/Makefile	2013-01-22 17:33:09.356560402 +0100
@@ -42,7 +42,7 @@ obj-$(CONFIG_GENERIC_FIND_LAST_BIT) += f
 obj-$(CONFIG_GENERIC_HWEIGHT) += hweight.o
 obj-$(CONFIG_LOCK_KERNEL) += kernel_lock.o
 obj-$(CONFIG_DEBUG_PREEMPT) += smp_processor_id.o
-obj-$(CONFIG_DEBUG_LIST) += list_debug.o
+obj-y += list_debug.o
 obj-$(CONFIG_DEBUG_OBJECTS) += debugobjects.o
 
 ifneq ($(CONFIG_HAVE_DEC_LOCK),y)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/radix-tree.c linux-2.6.32.60-pax/lib/radix-tree.c
--- linux-2.6.32.60/lib/radix-tree.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/radix-tree.c	2012-03-13 13:15:35.916097948 +0100
@@ -81,7 +81,7 @@ struct radix_tree_preload {
 	int nr;
 	struct radix_tree_node *nodes[RADIX_TREE_MAX_PATH];
 };
-static DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads) = { 0, };
+static DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads);
 
 static inline gfp_t root_gfp_mask(struct radix_tree_root *root)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/random32.c linux-2.6.32.60-pax/lib/random32.c
--- linux-2.6.32.60/lib/random32.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/random32.c	2012-03-13 13:15:35.916097948 +0100
@@ -61,7 +61,7 @@ static u32 __random32(struct rnd_state *
  */
 static inline u32 __seed(u32 x, u32 m)
 {
-	return (x < m) ? x + m : x;
+	return (x <= m) ? x + m + 1 : x;
 }
 
 /**
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/lib/vsprintf.c linux-2.6.32.60-pax/lib/vsprintf.c
--- linux-2.6.32.60/lib/vsprintf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/lib/vsprintf.c	2012-03-13 13:15:35.920097948 +0100
@@ -546,12 +546,12 @@ static char *number(char *buf, char *end
 	return buf;
 }
 
-static char *string(char *buf, char *end, char *s, struct printf_spec spec)
+static char *string(char *buf, char *end, const char *s, struct printf_spec spec)
 {
 	int len, i;
 
 	if ((unsigned long)s < PAGE_SIZE)
-		s = "<NULL>";
+		s = "(null)";
 
 	len = strnlen(s, spec.precision);
 
@@ -822,7 +822,7 @@ static char *pointer(const char *fmt, ch
 			struct printf_spec spec)
 {
 	if (!ptr)
-		return string(buf, end, "(null)", spec);
+		return string(buf, end, "(nil)", spec);
 
 	switch (*fmt) {
 	case 'F':
@@ -1445,7 +1445,7 @@ do {									\
 			size_t len;
 			if ((unsigned long)save_str > (unsigned long)-PAGE_SIZE
 					|| (unsigned long)save_str < PAGE_SIZE)
-				save_str = "<NULL>";
+				save_str = "(null)";
 			len = strlen(save_str);
 			if (str + len + 1 < end)
 				memcpy(str, save_str, len + 1);
@@ -1555,11 +1555,11 @@ int bstr_printf(char *buf, size_t size,
 	typeof(type) value;						\
 	if (sizeof(type) == 8) {					\
 		args = PTR_ALIGN(args, sizeof(u32));			\
-		*(u32 *)&value = *(u32 *)args;				\
-		*((u32 *)&value + 1) = *(u32 *)(args + 4);		\
+		*(u32 *)&value = *(const u32 *)args;			\
+		*((u32 *)&value + 1) = *(const u32 *)(args + 4);	\
 	} else {							\
 		args = PTR_ALIGN(args, sizeof(type));			\
-		value = *(typeof(type) *)args;				\
+		value = *(const typeof(type) *)args;			\
 	}								\
 	args += sizeof(type);						\
 	value;								\
@@ -1622,7 +1622,7 @@ int bstr_printf(char *buf, size_t size,
 			const char *str_arg = args;
 			size_t len = strlen(str_arg);
 			args += len + 1;
-			str = string(str, end, (char *)str_arg, spec);
+			str = string(str, end, str_arg, spec);
 			break;
 		}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/Makefile linux-2.6.32.60-pax/Makefile
--- linux-2.6.32.60/Makefile	2012-10-09 11:00:35.412882459 +0200
+++ linux-2.6.32.60-pax/Makefile	2013-02-18 00:10:32.675770964 +0100
@@ -221,8 +221,9 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH"
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-HOSTCXXFLAGS = -O2
+HOSTCFLAGS   = -Wall -W -Wmissing-prototypes -Wstrict-prototypes -Wno-unused-parameter -Wno-missing-field-initializers -O2 -fomit-frame-pointer -fno-delete-null-pointer-checks
+HOSTCLFAGS  += $(call cc-option, -Wno-empty-body)
+HOSTCXXFLAGS = -O2 -Wall -W -fno-delete-null-pointer-checks
 
 # Decide whether to build built-in, modular, or both.
 # Normally, just do built-in.
@@ -376,8 +377,8 @@ export RCS_TAR_IGNORE := --exclude SCCS
 # Rules shared between *config targets and build targets
 
 # Basic helpers built in scripts/
-PHONY += scripts_basic
-scripts_basic:
+PHONY += scripts_basic gcc-plugins
+scripts_basic: gcc-plugins
 	$(Q)$(MAKE) $(build)=scripts/basic
 
 # To avoid any implicit rule to kick in, define an empty command.
@@ -403,7 +404,7 @@ endif
 # of make so .config is not included in this case either (for *config).
 
 no-dot-config-targets := clean mrproper distclean \
-			 cscope TAGS tags help %docs check% \
+			 cscope gtags TAGS tags help %docs check% \
 			 include/linux/version.h headers_% \
 			 kernelrelease kernelversion
 
@@ -526,6 +527,60 @@ else
 KBUILD_CFLAGS	+= -O2
 endif
 
+ifeq ($(call cc-ifversion, -ge, 0408, y), y)
+PLUGINCC := $(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-plugin.sh "$(HOSTCXX)" "$(HOSTCXX)" "$(CC)")
+else
+PLUGINCC := $(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-plugin.sh "$(HOSTCC)" "$(HOSTCXX)" "$(CC)")
+endif
+ifneq ($(PLUGINCC),)
+ifdef CONFIG_PAX_CONSTIFY_PLUGIN
+CONSTIFY_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/constify_plugin.so -DCONSTIFY_PLUGIN
+endif
+ifdef CONFIG_PAX_MEMORY_STACKLEAK
+STACKLEAK_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/stackleak_plugin.so -DSTACKLEAK_PLUGIN
+STACKLEAK_PLUGIN_CFLAGS += -fplugin-arg-stackleak_plugin-track-lowest-sp=100
+endif
+ifdef CONFIG_KALLOCSTAT_PLUGIN
+KALLOCSTAT_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/kallocstat_plugin.so
+endif
+ifdef CONFIG_PAX_KERNEXEC_PLUGIN
+KERNEXEC_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/kernexec_plugin.so
+KERNEXEC_PLUGIN_CFLAGS += -fplugin-arg-kernexec_plugin-method=$(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD) -DKERNEXEC_PLUGIN
+KERNEXEC_PLUGIN_AFLAGS := -DKERNEXEC_PLUGIN
+endif
+ifdef CONFIG_CHECKER_PLUGIN
+ifeq ($(call cc-ifversion, -ge, 0406, y), y)
+CHECKER_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/checker_plugin.so -DCHECKER_PLUGIN
+endif
+endif
+COLORIZE_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/colorize_plugin.so
+ifdef CONFIG_PAX_SIZE_OVERFLOW
+SIZE_OVERFLOW_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/size_overflow_plugin.so -DSIZE_OVERFLOW_PLUGIN
+endif
+ifdef CONFIG_PAX_LATENT_ENTROPY
+LATENT_ENTROPY_PLUGIN_CFLAGS := -fplugin=$(objtree)/tools/gcc/latent_entropy_plugin.so -DLATENT_ENTROPY_PLUGIN
+endif
+GCC_PLUGINS_CFLAGS := $(CONSTIFY_PLUGIN_CFLAGS) $(STACKLEAK_PLUGIN_CFLAGS) $(KALLOCSTAT_PLUGIN_CFLAGS)
+GCC_PLUGINS_CFLAGS += $(KERNEXEC_PLUGIN_CFLAGS) $(CHECKER_PLUGIN_CFLAGS) $(COLORIZE_PLUGIN_CFLAGS)
+GCC_PLUGINS_CFLAGS += $(SIZE_OVERFLOW_PLUGIN_CFLAGS) $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+GCC_PLUGINS_AFLAGS := $(KERNEXEC_PLUGIN_AFLAGS)
+export PLUGINCC CONSTIFY_PLUGIN
+ifeq ($(KBUILD_EXTMOD),)
+gcc-plugins:
+	$(Q)$(MAKE) $(build)=tools/gcc
+else
+gcc-plugins: ;
+endif
+else
+gcc-plugins:
+ifeq ($(call cc-ifversion, -ge, 0405, y), y)
+	$(Q)echo "warning, your gcc installation does not support plugins, perhaps the necessary headers are missing?"
+else
+	$(Q)echo "warning, your gcc version does not support plugins, you should upgrade it to gcc 4.5 at least"
+endif
+	$(Q)echo "PAX_MEMORY_STACKLEAK and other features will be less secure"
+endif
+
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
 ifneq ($(CONFIG_FRAME_WARN),0)
@@ -868,6 +923,8 @@ vmlinux.o: $(modpost-init) $(vmlinux-mai
 
 # The actual objects are generated when descending, 
 # make sure no implicit rule kicks in
+$(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+$(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 $(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): $(vmlinux-dirs) ;
 
 # Handle descending into subdirectories listed in $(vmlinux-dirs)
@@ -877,7 +934,7 @@ $(sort $(vmlinux-init) $(vmlinux-main))
 # Error messages still appears in the original language
 
 PHONY += $(vmlinux-dirs)
-$(vmlinux-dirs): prepare scripts
+$(vmlinux-dirs): gcc-plugins prepare scripts
 	$(Q)$(MAKE) $(build)=$@
 
 # Build the kernel release string
@@ -986,6 +1043,7 @@ prepare0: archprepare FORCE
 	$(Q)$(MAKE) $(build)=. missing-syscalls
 
 # All the preparing..
+prepare: KBUILD_CFLAGS := $(filter-out $(GCC_PLUGINS_CFLAGS),$(KBUILD_CFLAGS))
 prepare: prepare0
 
 # The asm symlink changes when $(ARCH) changes.
@@ -1127,6 +1185,8 @@ all: modules
 #	using awk while concatenating to the final file.
 
 PHONY += modules
+modules: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+modules: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux)
 	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
 	@$(kecho) '  Building modules, stage 2.';
@@ -1136,7 +1196,7 @@ modules: $(vmlinux-dirs) $(if $(KBUILD_B
 
 # Target to prepare building external modules
 PHONY += modules_prepare
-modules_prepare: prepare scripts
+modules_prepare: gcc-plugins prepare scripts
 
 # Target to install modules
 PHONY += modules_install
@@ -1199,9 +1259,9 @@ CLEAN_FILES +=	vmlinux System.map \
 MRPROPER_DIRS  += include/config include2 usr/include include/generated
 MRPROPER_FILES += .config .config.old include/asm .version .old_version \
                   include/linux/autoconf.h include/linux/version.h      \
-                  include/linux/utsrelease.h                            \
+                  include/linux/utsrelease.h tools/gcc/size_overflow_hash.h \
                   include/linux/bounds.h include/asm*/asm-offsets.h     \
-		  Module.symvers Module.markers tags TAGS cscope*
+		  Module.symvers Module.markers tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS
 
 # clean - Delete most, but leave enough to build external modules
 #
@@ -1245,7 +1305,7 @@ distclean: mrproper
 	@find $(srctree) $(RCS_FIND_IGNORE) \
 		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
 		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -size 0 \
+		-o -name '.*.rej' -o -name '*.so' -o -size 0 \
 		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
 		-type f -print | xargs rm -f
 
@@ -1292,6 +1352,7 @@ help:
 	@echo  '  modules_prepare - Set up for building external modules'
 	@echo  '  tags/TAGS	  - Generate tags file for editors'
 	@echo  '  cscope	  - Generate cscope index'
+	@echo  '  gtags           - Generate GNU GLOBAL index'
 	@echo  '  kernelrelease	  - Output the release version string'
 	@echo  '  kernelversion	  - Output the version stored in Makefile'
 	@echo  '  headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH'; \
@@ -1393,6 +1454,8 @@ PHONY += $(module-dirs) modules
 $(module-dirs): crmodverdir $(objtree)/Module.symvers
 	$(Q)$(MAKE) $(build)=$(patsubst _module_%,%,$@)
 
+modules: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+modules: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 modules: $(module-dirs)
 	@$(kecho) '  Building modules, stage 2.';
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
@@ -1448,7 +1511,7 @@ endif # KBUILD_EXTMOD
 quiet_cmd_tags = GEN     $@
       cmd_tags = $(CONFIG_SHELL) $(srctree)/scripts/tags.sh $@
 
-tags TAGS cscope: FORCE
+tags TAGS cscope gtags: FORCE
 	$(call cmd,tags)
 
 # Scripts to check various things for consistency
@@ -1513,17 +1576,21 @@ else
         target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
 endif
 
-%.s: %.c prepare scripts FORCE
+%.s: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+%.s: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
+%.s: %.c gcc-plugins prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
 %.i: %.c prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.c prepare scripts FORCE
+%.o: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+%.o: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
+%.o: %.c gcc-plugins prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
 %.lst: %.c prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.s: %.S prepare scripts FORCE
+%.s: %.S gcc-plugins prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.S prepare scripts FORCE
+%.o: %.S gcc-plugins prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
 %.symtypes: %.c prepare scripts FORCE
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
@@ -1533,11 +1600,15 @@ endif
 	$(cmd_crmodverdir)
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
 	$(build)=$(build-dir)
-%/: prepare scripts FORCE
+%/: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+%/: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
+%/: gcc-plugins prepare scripts FORCE
 	$(cmd_crmodverdir)
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
 	$(build)=$(build-dir)
-%.ko: prepare scripts FORCE
+%.ko: KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+%.ko: KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
+%.ko: gcc-plugins prepare scripts FORCE
 	$(cmd_crmodverdir)
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
 	$(build)=$(build-dir) $(@:.ko=.o)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/backing-dev.c linux-2.6.32.60-pax/mm/backing-dev.c
--- linux-2.6.32.60/mm/backing-dev.c	2012-03-18 17:44:12.492057971 +0100
+++ linux-2.6.32.60-pax/mm/backing-dev.c	2012-03-18 17:44:18.448057847 +0100
@@ -489,7 +489,7 @@ static void bdi_add_to_pending(struct rc
  * Add the default flusher task that gets created for any bdi
  * that has dirty data pending writeout
  */
-void static bdi_add_default_flusher_task(struct backing_dev_info *bdi)
+static void bdi_add_default_flusher_task(struct backing_dev_info *bdi)
 {
 	if (!bdi_cap_writeback_dirty(bdi))
 		return;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/filemap.c linux-2.6.32.60-pax/mm/filemap.c
--- linux-2.6.32.60/mm/filemap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/filemap.c	2012-03-13 13:15:35.924097948 +0100
@@ -1631,7 +1631,7 @@ int generic_file_mmap(struct file * file
 	struct address_space *mapping = file->f_mapping;
 
 	if (!mapping->a_ops->readpage)
-		return -ENOEXEC;
+		return -ENODEV;
 	file_accessed(file);
 	vma->vm_ops = &generic_file_vm_ops;
 	vma->vm_flags |= VM_CAN_NONLINEAR;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/fremap.c linux-2.6.32.60-pax/mm/fremap.c
--- linux-2.6.32.60/mm/fremap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/fremap.c	2012-03-13 13:15:35.924097948 +0100
@@ -153,6 +153,11 @@ SYSCALL_DEFINE5(remap_file_pages, unsign
  retry:
 	vma = find_vma(mm, start);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma && (mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_flags & VM_MAYEXEC))
+		goto out;
+#endif
+
 	/*
 	 * Make sure the vma is shared, that it supports prefaulting,
 	 * and that the remapped range is valid and fully within
@@ -221,7 +226,7 @@ SYSCALL_DEFINE5(remap_file_pages, unsign
 		/*
 		 * drop PG_Mlocked flag for over-mapped range
 		 */
-		unsigned int saved_flags = vma->vm_flags;
+		unsigned long saved_flags = vma->vm_flags;
 		munlock_vma_pages_range(vma, start, start + size);
 		vma->vm_flags = saved_flags;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/highmem.c linux-2.6.32.60-pax/mm/highmem.c
--- linux-2.6.32.60/mm/highmem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/highmem.c	2012-03-13 13:15:35.924097948 +0100
@@ -116,9 +116,10 @@ static void flush_all_zero_pkmaps(void)
 		 * So no dangers, even with speculative execution.
 		 */
 		page = pte_page(pkmap_page_table[i]);
+		pax_open_kernel();
 		pte_clear(&init_mm, (unsigned long)page_address(page),
 			  &pkmap_page_table[i]);
-
+		pax_close_kernel();
 		set_page_address(page, NULL);
 		need_flush = 1;
 	}
@@ -177,9 +178,11 @@ start:
 		}
 	}
 	vaddr = PKMAP_ADDR(last_pkmap_nr);
+
+	pax_open_kernel();
 	set_pte_at(&init_mm, vaddr,
 		   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));
-
+	pax_close_kernel();
 	pkmap_count[last_pkmap_nr] = 1;
 	set_page_address(page, (void *)vaddr);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/hugetlb.c linux-2.6.32.60-pax/mm/hugetlb.c
--- linux-2.6.32.60/mm/hugetlb.c	2012-10-09 11:00:35.500882480 +0200
+++ linux-2.6.32.60-pax/mm/hugetlb.c	2012-10-09 11:00:39.356883055 +0200
@@ -2012,6 +2012,26 @@ static int unmap_ref_private(struct mm_s
 	return 1;
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+static void pax_mirror_huge_pte(struct vm_area_struct *vma, unsigned long address, struct page *page_m)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	struct vm_area_struct *vma_m;
+	unsigned long address_m;
+	pte_t *ptep_m;
+
+	vma_m = pax_find_mirror_vma(vma);
+	if (!vma_m)
+		return;
+
+	BUG_ON(address >= SEGMEXEC_TASK_SIZE);
+	address_m = address + SEGMEXEC_TASK_SIZE;
+	ptep_m = huge_pte_offset(mm, address_m & HPAGE_MASK);
+	get_page(page_m);
+	set_huge_pte_at(mm, address_m, ptep_m, make_huge_pte(vma_m, page_m, 0));
+}
+#endif
+
 static int hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,
 			unsigned long address, pte_t *ptep, pte_t pte,
 			struct page *pagecache_page)
@@ -2083,6 +2103,11 @@ retry_avoidcopy:
 		huge_ptep_clear_flush(vma, address, ptep);
 		set_huge_pte_at(mm, address, ptep,
 				make_huge_pte(vma, new_page, 1));
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		pax_mirror_huge_pte(vma, address, new_page);
+#endif
+
 		/* Make the old page be freed below */
 		new_page = old_page;
 	}
@@ -2214,6 +2239,10 @@ retry:
 				&& (vma->vm_flags & VM_SHARED)));
 	set_huge_pte_at(mm, address, ptep, new_pte);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_mirror_huge_pte(vma, address, page);
+#endif
+
 	if ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {
 		/* Optimization, do the COW without a second fault */
 		ret = hugetlb_cow(mm, vma, address, ptep, new_pte, page);
@@ -2242,6 +2271,28 @@ int hugetlb_fault(struct mm_struct *mm,
 	static DEFINE_MUTEX(hugetlb_instantiation_mutex);
 	struct hstate *h = hstate_vma(vma);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+
+	vma_m = pax_find_mirror_vma(vma);
+	if (vma_m) {
+		unsigned long address_m;
+
+		if (vma->vm_start > vma_m->vm_start) {
+			address_m = address;
+			address -= SEGMEXEC_TASK_SIZE;
+			vma = vma_m;
+			h = hstate_vma(vma);
+		} else
+			address_m = address + SEGMEXEC_TASK_SIZE;
+
+		if (!huge_pte_alloc(mm, address_m, huge_page_size(h)))
+			return VM_FAULT_OOM;
+		address_m &= HPAGE_MASK;
+		unmap_hugepage_range(vma, address_m, address_m + HPAGE_SIZE, NULL);
+	}
+#endif
+
 	ptep = huge_pte_alloc(mm, address, huge_page_size(h));
 	if (!ptep)
 		return VM_FAULT_OOM;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/internal.h linux-2.6.32.60-pax/mm/internal.h
--- linux-2.6.32.60/mm/internal.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/internal.h	2012-03-13 13:15:35.928097948 +0100
@@ -49,6 +49,7 @@ extern void putback_lru_page(struct page
  * in mm/page_alloc.c
  */
 extern void __free_pages_bootmem(struct page *page, unsigned int order);
+extern void free_compound_page(struct page *page);
 extern void prep_compound_page(struct page *page, unsigned long order);
 
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/Kconfig linux-2.6.32.60-pax/mm/Kconfig
--- linux-2.6.32.60/mm/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/Kconfig	2012-03-13 13:15:35.928097948 +0100
@@ -226,10 +226,10 @@ config KSM
 	  root has set /sys/kernel/mm/ksm/run to 1 (if CONFIG_SYSFS is set).
 
 config DEFAULT_MMAP_MIN_ADDR
-        int "Low address space to protect from user allocation"
+	int "Low address space to protect from user allocation"
 	depends on MMU
-        default 4096
-        help
+	default 32768
+	help
 	  This is the portion of low virtual memory which should be protected
 	  from userspace allocation.  Keeping a user from writing to low pages
 	  can help reduce the impact of kernel NULL pointer bugs.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/maccess.c linux-2.6.32.60-pax/mm/maccess.c
--- linux-2.6.32.60/mm/maccess.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/maccess.c	2012-03-13 13:15:35.932097947 +0100
@@ -14,7 +14,7 @@
  * Safely read from address @src to the buffer at @dst.  If a kernel fault
  * happens, handle that and return -EFAULT.
  */
-long probe_kernel_read(void *dst, void *src, size_t size)
+long probe_kernel_read(void *dst, const void *src, size_t size)
 {
 	long ret;
 	mm_segment_t old_fs = get_fs();
@@ -22,7 +22,7 @@ long probe_kernel_read(void *dst, void *
 	set_fs(KERNEL_DS);
 	pagefault_disable();
 	ret = __copy_from_user_inatomic(dst,
-			(__force const void __user *)src, size);
+			(const void __force_user *)src, size);
 	pagefault_enable();
 	set_fs(old_fs);
 
@@ -39,14 +39,14 @@ EXPORT_SYMBOL_GPL(probe_kernel_read);
  * Safely write to address @dst from the buffer at @src.  If a kernel fault
  * happens, handle that and return -EFAULT.
  */
-long notrace __weak probe_kernel_write(void *dst, void *src, size_t size)
+long notrace __weak probe_kernel_write(void *dst, const void *src, size_t size)
 {
 	long ret;
 	mm_segment_t old_fs = get_fs();
 
 	set_fs(KERNEL_DS);
 	pagefault_disable();
-	ret = __copy_to_user_inatomic((__force void __user *)dst, src, size);
+	ret = __copy_to_user_inatomic((void __force_user *)dst, src, size);
 	pagefault_enable();
 	set_fs(old_fs);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/madvise.c linux-2.6.32.60-pax/mm/madvise.c
--- linux-2.6.32.60/mm/madvise.c	2012-10-09 11:00:35.500882480 +0200
+++ linux-2.6.32.60-pax/mm/madvise.c	2012-10-09 11:00:39.356883055 +0200
@@ -45,6 +45,10 @@ static long madvise_behavior(struct vm_a
 	pgoff_t pgoff;
 	unsigned long new_flags = vma->vm_flags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+#endif
+
 	switch (behavior) {
 	case MADV_NORMAL:
 		new_flags = new_flags & ~VM_RAND_READ & ~VM_SEQ_READ;
@@ -104,6 +108,13 @@ success:
 	/*
 	 * vm_flags is protected by the mmap_sem held in write mode.
 	 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma_m = pax_find_mirror_vma(vma);
+	if (vma_m)
+		vma_m->vm_flags = new_flags & ~(VM_WRITE | VM_MAYWRITE | VM_ACCOUNT);
+#endif
+
 	vma->vm_flags = new_flags;
 
 out:
@@ -162,6 +173,11 @@ static long madvise_dontneed(struct vm_a
 			     struct vm_area_struct ** prev,
 			     unsigned long start, unsigned long end)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+#endif
+
 	*prev = vma;
 	if (vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP))
 		return -EINVAL;
@@ -174,6 +190,21 @@ static long madvise_dontneed(struct vm_a
 		zap_page_range(vma, start, end - start, &details);
 	} else
 		zap_page_range(vma, start, end - start, NULL);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma_m = pax_find_mirror_vma(vma);
+	if (vma_m) {
+		if (unlikely(vma->vm_flags & VM_NONLINEAR)) {
+			struct zap_details details = {
+				.nonlinear_vma = vma_m,
+				.last_index = ULONG_MAX,
+			};
+			zap_page_range(vma, start + SEGMEXEC_TASK_SIZE, end - start, &details);
+		} else
+			zap_page_range(vma, start + SEGMEXEC_TASK_SIZE, end - start, NULL);
+	}
+#endif
+
 	return 0;
 }
 
@@ -369,6 +400,16 @@ SYSCALL_DEFINE3(madvise, unsigned long,
 	if (end < start)
 		goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			goto out;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		goto out;
+
 	error = 0;
 	if (end == start)
 		goto out;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/memory.c linux-2.6.32.60-pax/mm/memory.c
--- linux-2.6.32.60/mm/memory.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/memory.c	2012-05-08 23:38:04.271923529 +0200
@@ -187,8 +187,12 @@ static inline void free_pmd_range(struct
 		return;
 
 	pmd = pmd_offset(pud, start);
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_PER_CPU_PGD)
 	pud_clear(pud);
 	pmd_free_tlb(tlb, pmd, start);
+#endif
+
 }
 
 static inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,
@@ -219,9 +223,12 @@ static inline void free_pud_range(struct
 	if (end - 1 > ceiling - 1)
 		return;
 
+#if !defined(CONFIG_X86_64) || !defined(CONFIG_PAX_PER_CPU_PGD)
 	pud = pud_offset(pgd, start);
 	pgd_clear(pgd);
 	pud_free_tlb(tlb, pud, start);
+#endif
+
 }
 
 /*
@@ -1251,10 +1258,10 @@ int __get_user_pages(struct task_struct
 			(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
 	i = 0;
 
-	do {
+	while (nr_pages) {
 		struct vm_area_struct *vma;
 
-		vma = find_extend_vma(mm, start);
+		vma = find_vma(mm, start);
 		if (!vma && in_gate_area(tsk, start)) {
 			unsigned long pg = start & PAGE_MASK;
 			struct vm_area_struct *gate_vma = get_gate_vma(tsk);
@@ -1306,7 +1313,7 @@ int __get_user_pages(struct task_struct
 			continue;
 		}
 
-		if (!vma ||
+		if (!vma || start < vma->vm_start ||
 		    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||
 		    !(vm_flags & vma->vm_flags))
 			return i ? : -EFAULT;
@@ -1381,7 +1388,7 @@ int __get_user_pages(struct task_struct
 			start += PAGE_SIZE;
 			nr_pages--;
 		} while (nr_pages && start < vma->vm_end);
-	} while (nr_pages);
+	}
 	return i;
 }
 
@@ -1526,6 +1533,10 @@ static int insert_page(struct vm_area_st
 	page_add_file_rmap(page);
 	set_pte_at(mm, addr, pte, mk_pte(page, prot));
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_mirror_file_pte(vma, addr, page, ptl);
+#endif
+
 	retval = 0;
 	pte_unmap_unlock(pte, ptl);
 	return retval;
@@ -1560,10 +1571,22 @@ out:
 int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,
 			struct page *page)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+#endif
+
 	if (addr < vma->vm_start || addr >= vma->vm_end)
 		return -EFAULT;
 	if (!page_count(page))
 		return -EINVAL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma_m = pax_find_mirror_vma(vma);
+	if (vma_m)
+		vma_m->vm_flags |= VM_INSERTPAGE;
+#endif
+
 	vma->vm_flags |= VM_INSERTPAGE;
 	return insert_page(vma, addr, page, vma->vm_page_prot);
 }
@@ -1649,6 +1672,7 @@ int vm_insert_mixed(struct vm_area_struc
 			unsigned long pfn)
 {
 	BUG_ON(!(vma->vm_flags & VM_MIXEDMAP));
+	BUG_ON(vma->vm_mirror);
 
 	if (addr < vma->vm_start || addr >= vma->vm_end)
 		return -EFAULT;
@@ -1855,7 +1879,9 @@ static int apply_to_pmd_range(struct mm_
 
 	BUG_ON(pud_huge(*pud));
 
-	pmd = pmd_alloc(mm, pud, addr);
+	pmd = (mm == &init_mm) ?
+		pmd_alloc_kernel(mm, pud, addr) :
+		pmd_alloc(mm, pud, addr);
 	if (!pmd)
 		return -ENOMEM;
 	do {
@@ -1875,7 +1901,9 @@ static int apply_to_pud_range(struct mm_
 	unsigned long next;
 	int err;
 
-	pud = pud_alloc(mm, pgd, addr);
+	pud = (mm == &init_mm) ?
+		pud_alloc_kernel(mm, pgd, addr) :
+		pud_alloc(mm, pgd, addr);
 	if (!pud)
 		return -ENOMEM;
 	do {
@@ -1977,6 +2005,186 @@ static inline void cow_user_page(struct
 		copy_user_highpage(dst, src, va, vma);
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+static void pax_unmap_mirror_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	spinlock_t *ptl;
+	pte_t *pte, entry;
+
+	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
+	entry = *pte;
+	if (!pte_present(entry)) {
+		if (!pte_none(entry)) {
+			BUG_ON(pte_file(entry));
+			free_swap_and_cache(pte_to_swp_entry(entry));
+			pte_clear_not_present_full(mm, address, pte, 0);
+		}
+	} else {
+		struct page *page;
+
+		flush_cache_page(vma, address, pte_pfn(entry));
+		entry = ptep_clear_flush(vma, address, pte);
+		BUG_ON(pte_dirty(entry));
+		page = vm_normal_page(vma, address, entry);
+		if (page) {
+			update_hiwater_rss(mm);
+			if (PageAnon(page))
+				dec_mm_counter(mm, anon_rss);
+			else
+				dec_mm_counter(mm, file_rss);
+			page_remove_rmap(page);
+			page_cache_release(page);
+		}
+	}
+	pte_unmap_unlock(pte, ptl);
+}
+
+/* PaX: if vma is mirrored, synchronize the mirror's PTE
+ *
+ * the ptl of the lower mapped page is held on entry and is not released on exit
+ * or inside to ensure atomic changes to the PTE states (swapout, mremap, munmap, etc)
+ */
+static void pax_mirror_anon_pte(struct vm_area_struct *vma, unsigned long address, struct page *page_m, spinlock_t *ptl)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m;
+	spinlock_t *ptl_m;
+	struct vm_area_struct *vma_m;
+	pmd_t *pmd_m;
+	pte_t *pte_m, entry_m;
+
+	BUG_ON(!page_m || !PageAnon(page_m));
+
+	vma_m = pax_find_mirror_vma(vma);
+	if (!vma_m)
+		return;
+
+	BUG_ON(!PageLocked(page_m));
+	BUG_ON(address >= SEGMEXEC_TASK_SIZE);
+	address_m = address + SEGMEXEC_TASK_SIZE;
+	pmd_m = pmd_offset(pud_offset(pgd_offset(mm, address_m), address_m), address_m);
+	pte_m = pte_offset_map_nested(pmd_m, address_m);
+	ptl_m = pte_lockptr(mm, pmd_m);
+	if (ptl != ptl_m) {
+		spin_lock_nested(ptl_m, SINGLE_DEPTH_NESTING);
+		if (!pte_none(*pte_m))
+			goto out;
+	}
+
+	entry_m = pfn_pte(page_to_pfn(page_m), vma_m->vm_page_prot);
+	page_cache_get(page_m);
+	page_add_anon_rmap(page_m, vma_m, address_m);
+	inc_mm_counter(mm, anon_rss);
+	set_pte_at(mm, address_m, pte_m, entry_m);
+	update_mmu_cache(vma_m, address_m, entry_m);
+out:
+	if (ptl != ptl_m)
+		spin_unlock(ptl_m);
+	pte_unmap_nested(pte_m);
+	unlock_page(page_m);
+}
+
+void pax_mirror_file_pte(struct vm_area_struct *vma, unsigned long address, struct page *page_m, spinlock_t *ptl)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m;
+	spinlock_t *ptl_m;
+	struct vm_area_struct *vma_m;
+	pmd_t *pmd_m;
+	pte_t *pte_m, entry_m;
+
+	BUG_ON(!page_m || PageAnon(page_m));
+
+	vma_m = pax_find_mirror_vma(vma);
+	if (!vma_m)
+		return;
+
+	BUG_ON(address >= SEGMEXEC_TASK_SIZE);
+	address_m = address + SEGMEXEC_TASK_SIZE;
+	pmd_m = pmd_offset(pud_offset(pgd_offset(mm, address_m), address_m), address_m);
+	pte_m = pte_offset_map_nested(pmd_m, address_m);
+	ptl_m = pte_lockptr(mm, pmd_m);
+	if (ptl != ptl_m) {
+		spin_lock_nested(ptl_m, SINGLE_DEPTH_NESTING);
+		if (!pte_none(*pte_m))
+			goto out;
+	}
+
+	entry_m = pfn_pte(page_to_pfn(page_m), vma_m->vm_page_prot);
+	page_cache_get(page_m);
+	page_add_file_rmap(page_m);
+	inc_mm_counter(mm, file_rss);
+	set_pte_at(mm, address_m, pte_m, entry_m);
+	update_mmu_cache(vma_m, address_m, entry_m);
+out:
+	if (ptl != ptl_m)
+		spin_unlock(ptl_m);
+	pte_unmap_nested(pte_m);
+}
+
+static void pax_mirror_pfn_pte(struct vm_area_struct *vma, unsigned long address, unsigned long pfn_m, spinlock_t *ptl)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address_m;
+	spinlock_t *ptl_m;
+	struct vm_area_struct *vma_m;
+	pmd_t *pmd_m;
+	pte_t *pte_m, entry_m;
+
+	vma_m = pax_find_mirror_vma(vma);
+	if (!vma_m)
+		return;
+
+	BUG_ON(address >= SEGMEXEC_TASK_SIZE);
+	address_m = address + SEGMEXEC_TASK_SIZE;
+	pmd_m = pmd_offset(pud_offset(pgd_offset(mm, address_m), address_m), address_m);
+	pte_m = pte_offset_map_nested(pmd_m, address_m);
+	ptl_m = pte_lockptr(mm, pmd_m);
+	if (ptl != ptl_m) {
+		spin_lock_nested(ptl_m, SINGLE_DEPTH_NESTING);
+		if (!pte_none(*pte_m))
+			goto out;
+	}
+
+	entry_m = pfn_pte(pfn_m, vma_m->vm_page_prot);
+	set_pte_at(mm, address_m, pte_m, entry_m);
+out:
+	if (ptl != ptl_m)
+		spin_unlock(ptl_m);
+	pte_unmap_nested(pte_m);
+}
+
+static void pax_mirror_pte(struct vm_area_struct *vma, unsigned long address, pte_t *pte, pmd_t *pmd, spinlock_t *ptl)
+{
+	struct page *page_m;
+	pte_t entry;
+
+	if (!(vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC))
+		goto out;
+
+	entry = *pte;
+	page_m  = vm_normal_page(vma, address, entry);
+	if (!page_m)
+		pax_mirror_pfn_pte(vma, address, pte_pfn(entry), ptl);
+	else if (PageAnon(page_m)) {
+		if (pax_find_mirror_vma(vma)) {
+			pte_unmap_unlock(pte, ptl);
+			lock_page(page_m);
+			pte = pte_offset_map_lock(vma->vm_mm, pmd, address, &ptl);
+			if (pte_same(entry, *pte))
+				pax_mirror_anon_pte(vma, address, page_m, ptl);
+			else
+				unlock_page(page_m);
+		}
+	} else
+		pax_mirror_file_pte(vma, address, page_m, ptl);
+
+out:
+	pte_unmap_unlock(pte, ptl);
+}
+#endif
+
 /*
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
@@ -2156,6 +2364,12 @@ gotten:
 	 */
 	page_table = pte_offset_map_lock(mm, pmd, address, &ptl);
 	if (likely(pte_same(*page_table, orig_pte))) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (pax_find_mirror_vma(vma))
+			BUG_ON(!trylock_page(new_page));
+#endif
+
 		if (old_page) {
 			if (!PageAnon(old_page)) {
 				dec_mm_counter(mm, file_rss);
@@ -2207,6 +2421,10 @@ gotten:
 			page_remove_rmap(old_page);
 		}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		pax_mirror_anon_pte(vma, address, new_page, ptl);
+#endif
+
 		/* Free the old page.. */
 		new_page = old_page;
 		ret |= VM_FAULT_WRITE;
@@ -2606,6 +2824,11 @@ static int do_swap_page(struct mm_struct
 	swap_free(entry);
 	if (vm_swap_full() || (vma->vm_flags & VM_LOCKED) || PageMlocked(page))
 		try_to_free_swap(page);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((flags & FAULT_FLAG_WRITE) || !pax_find_mirror_vma(vma))
+#endif
+
 	unlock_page(page);
 
 	if (flags & FAULT_FLAG_WRITE) {
@@ -2617,6 +2840,11 @@ static int do_swap_page(struct mm_struct
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, pte);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_mirror_anon_pte(vma, address, page, ptl);
+#endif
+
 unlock:
 	pte_unmap_unlock(page_table, ptl);
 out:
@@ -2632,40 +2860,6 @@ out_release:
 }
 
 /*
- * This is like a special single-page "expand_{down|up}wards()",
- * except we must first make sure that 'address{-|+}PAGE_SIZE'
- * doesn't hit another vma.
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		struct vm_area_struct *prev = vma->vm_prev;
-
-		/*
-		 * Is there a mapping abutting this one below?
-		 *
-		 * That's only ok if it's the same stack mapping
-		 * that has gotten split..
-		 */
-		if (prev && prev->vm_end == address)
-			return prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;
-
-		expand_stack(vma, address - PAGE_SIZE);
-	}
-	if ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {
-		struct vm_area_struct *next = vma->vm_next;
-
-		/* As VM_GROWSDOWN but s/below/above/ */
-		if (next && next->vm_start == address + PAGE_SIZE)
-			return next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;
-
-		expand_upwards(vma, address + PAGE_SIZE);
-	}
-	return 0;
-}
-
-/*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
@@ -2674,27 +2868,23 @@ static int do_anonymous_page(struct mm_s
 		unsigned long address, pte_t *page_table, pmd_t *pmd,
 		unsigned int flags)
 {
-	struct page *page;
+	struct page *page = NULL;
 	spinlock_t *ptl;
 	pte_t entry;
 
-	pte_unmap(page_table);
-
-	/* Check if we need to add a guard page to the stack */
-	if (check_stack_guard_page(vma, address) < 0)
-		return VM_FAULT_SIGBUS;
-
-	/* Use the zero-page for reads */
 	if (!(flags & FAULT_FLAG_WRITE)) {
 		entry = pte_mkspecial(pfn_pte(my_zero_pfn(address),
 						vma->vm_page_prot));
-		page_table = pte_offset_map_lock(mm, pmd, address, &ptl);
+		ptl = pte_lockptr(mm, pmd);
+		spin_lock(ptl);
 		if (!pte_none(*page_table))
 			goto unlock;
 		goto setpte;
 	}
 
 	/* Allocate our own private page. */
+	pte_unmap(page_table);
+
 	if (unlikely(anon_vma_prepare(vma)))
 		goto oom;
 	page = alloc_zeroed_user_highpage_movable(vma, address);
@@ -2713,6 +2903,11 @@ static int do_anonymous_page(struct mm_s
 	if (!pte_none(*page_table))
 		goto release;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (pax_find_mirror_vma(vma))
+		BUG_ON(!trylock_page(page));
+#endif
+
 	inc_mm_counter(mm, anon_rss);
 	page_add_new_anon_rmap(page, vma, address);
 setpte:
@@ -2720,6 +2915,12 @@ setpte:
 
 	/* No need to invalidate - it was non-present before */
 	update_mmu_cache(vma, address, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (page)
+		pax_mirror_anon_pte(vma, address, page, ptl);
+#endif
+
 unlock:
 	pte_unmap_unlock(page_table, ptl);
 	return 0;
@@ -2862,6 +3063,12 @@ static int __do_fault(struct mm_struct *
 	 */
 	/* Only go through if we didn't race with anybody else... */
 	if (likely(pte_same(*page_table, orig_pte))) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (anon && pax_find_mirror_vma(vma))
+			BUG_ON(!trylock_page(page));
+#endif
+
 		flush_icache_page(vma, page);
 		entry = mk_pte(page, vma->vm_page_prot);
 		if (flags & FAULT_FLAG_WRITE)
@@ -2881,6 +3088,14 @@ static int __do_fault(struct mm_struct *
 
 		/* no need to invalidate: a not-present page won't be cached */
 		update_mmu_cache(vma, address, entry);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (anon)
+			pax_mirror_anon_pte(vma, address, page, ptl);
+		else
+			pax_mirror_file_pte(vma, address, page, ptl);
+#endif
+
 	} else {
 		if (charged)
 			mem_cgroup_uncharge_page(page);
@@ -3028,6 +3243,12 @@ static inline int handle_pte_fault(struc
 		if (flags & FAULT_FLAG_WRITE)
 			flush_tlb_page(vma, address);
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	pax_mirror_pte(vma, address, pte, pmd, ptl);
+	return 0;
+#endif
+
 unlock:
 	pte_unmap_unlock(pte, ptl);
 	return 0;
@@ -3044,6 +3265,10 @@ int handle_mm_fault(struct mm_struct *mm
 	pmd_t *pmd;
 	pte_t *pte;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+#endif
+
 	__set_current_state(TASK_RUNNING);
 
 	count_vm_event(PGFAULT);
@@ -3051,6 +3276,34 @@ int handle_mm_fault(struct mm_struct *mm
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		return hugetlb_fault(mm, vma, address, flags);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma_m = pax_find_mirror_vma(vma);
+	if (vma_m) {
+		unsigned long address_m;
+		pgd_t *pgd_m;
+		pud_t *pud_m;
+		pmd_t *pmd_m;
+
+		if (vma->vm_start > vma_m->vm_start) {
+			address_m = address;
+			address -= SEGMEXEC_TASK_SIZE;
+			vma = vma_m;
+		} else
+			address_m = address + SEGMEXEC_TASK_SIZE;
+
+		pgd_m = pgd_offset(mm, address_m);
+		pud_m = pud_alloc(mm, pgd_m, address_m);
+		if (!pud_m)
+			return VM_FAULT_OOM;
+		pmd_m = pmd_alloc(mm, pud_m, address_m);
+		if (!pmd_m)
+			return VM_FAULT_OOM;
+		if (!pmd_present(*pmd_m) && __pte_alloc(mm, pmd_m, address_m))
+			return VM_FAULT_OOM;
+		pax_unmap_mirror_pte(vma_m, address_m, pmd_m);
+	}
+#endif
+
 	pgd = pgd_offset(mm, address);
 	pud = pud_alloc(mm, pgd, address);
 	if (!pud)
@@ -3086,6 +3339,23 @@ int __pud_alloc(struct mm_struct *mm, pg
 	spin_unlock(&mm->page_table_lock);
 	return 0;
 }
+
+int __pud_alloc_kernel(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
+{
+	pud_t *new = pud_alloc_one(mm, address);
+	if (!new)
+		return -ENOMEM;
+
+	smp_wmb(); /* See comment in __pte_alloc */
+
+	spin_lock(&mm->page_table_lock);
+	if (pgd_present(*pgd))		/* Another has populated it */
+		pud_free(mm, new);
+	else
+		pgd_populate_kernel(mm, pgd, new);
+	spin_unlock(&mm->page_table_lock);
+	return 0;
+}
 #endif /* __PAGETABLE_PUD_FOLDED */
 
 #ifndef __PAGETABLE_PMD_FOLDED
@@ -3116,6 +3386,30 @@ int __pmd_alloc(struct mm_struct *mm, pu
 	spin_unlock(&mm->page_table_lock);
 	return 0;
 }
+
+int __pmd_alloc_kernel(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+	pmd_t *new = pmd_alloc_one(mm, address);
+	if (!new)
+		return -ENOMEM;
+
+	smp_wmb(); /* See comment in __pte_alloc */
+
+	spin_lock(&mm->page_table_lock);
+#ifndef __ARCH_HAS_4LEVEL_HACK
+	if (pud_present(*pud))		/* Another has populated it */
+		pmd_free(mm, new);
+	else
+		pud_populate_kernel(mm, pud, new);
+#else
+	if (pgd_present(*pud))		/* Another has populated it */
+		pmd_free(mm, new);
+	else
+		pgd_populate_kernel(mm, pud, new);
+#endif /* __ARCH_HAS_4LEVEL_HACK */
+	spin_unlock(&mm->page_table_lock);
+	return 0;
+}
 #endif /* __PAGETABLE_PMD_FOLDED */
 
 int make_pages_present(unsigned long addr, unsigned long end)
@@ -3148,7 +3442,7 @@ static int __init gate_vma_init(void)
 	gate_vma.vm_start = FIXADDR_USER_START;
 	gate_vma.vm_end = FIXADDR_USER_END;
 	gate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;
-	gate_vma.vm_page_prot = __P101;
+	gate_vma.vm_page_prot = vm_get_page_prot(gate_vma.vm_flags);
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/memory-failure.c linux-2.6.32.60-pax/mm/memory-failure.c
--- linux-2.6.32.60/mm/memory-failure.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/memory-failure.c	2012-03-13 13:15:35.936097947 +0100
@@ -46,7 +46,7 @@ int sysctl_memory_failure_early_kill __r
 
 int sysctl_memory_failure_recovery __read_mostly = 1;
 
-atomic_long_t mce_bad_pages __read_mostly = ATOMIC_LONG_INIT(0);
+atomic_long_unchecked_t mce_bad_pages __read_mostly = ATOMIC_LONG_INIT(0);
 
 /*
  * Send all the processes who have the page mapped an ``action optional''
@@ -64,7 +64,7 @@ static int kill_proc_ao(struct task_stru
 	si.si_signo = SIGBUS;
 	si.si_errno = 0;
 	si.si_code = BUS_MCEERR_AO;
-	si.si_addr = (void *)addr;
+	si.si_addr = (void __user *)addr;
 #ifdef __ARCH_SI_TRAPNO
 	si.si_trapno = trapno;
 #endif
@@ -745,7 +745,7 @@ int __memory_failure(unsigned long pfn,
 		return 0;
 	}
 
-	atomic_long_add(1, &mce_bad_pages);
+	atomic_long_add_unchecked(1, &mce_bad_pages);
 
 	/*
 	 * We need/can do nothing about count=0 pages.
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/mempolicy.c linux-2.6.32.60-pax/mm/mempolicy.c
--- linux-2.6.32.60/mm/mempolicy.c	2012-10-09 11:00:35.500882480 +0200
+++ linux-2.6.32.60-pax/mm/mempolicy.c	2012-10-09 11:00:39.356883055 +0200
@@ -573,6 +573,10 @@ static int mbind_range(struct vm_area_st
 	struct vm_area_struct *next;
 	int err;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m;
+#endif
+
 	err = 0;
 	for (; vma && vma->vm_start < end; vma = next) {
 		next = vma->vm_next;
@@ -584,6 +588,16 @@ static int mbind_range(struct vm_area_st
 			err = policy_vma(vma, new);
 		if (err)
 			break;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		vma_m = pax_find_mirror_vma(vma);
+		if (vma_m) {
+			err = policy_vma(vma_m, new);
+			if (err)
+				break;
+		}
+#endif
+
 	}
 	return err;
 }
@@ -1002,6 +1016,17 @@ static long do_mbind(unsigned long start
 
 	if (end < start)
 		return -EINVAL;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (end == start)
 		return 0;
 
@@ -2396,7 +2421,7 @@ int show_numa_map(struct seq_file *m, vo
 
 	if (file) {
 		seq_printf(m, " file=");
-		seq_path(m, &file->f_path, "\n\t= ");
+		seq_path(m, &file->f_path, "\n\t\\= ");
 	} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {
 		seq_printf(m, " heap");
 	} else if (vma->vm_start <= mm->start_stack &&
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/mlock.c linux-2.6.32.60-pax/mm/mlock.c
--- linux-2.6.32.60/mm/mlock.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/mlock.c	2012-07-29 01:31:54.478589101 +0200
@@ -138,13 +138,6 @@ void munlock_vma_page(struct page *page)
 	}
 }
 
-static inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSDOWN) &&
-		(vma->vm_start == addr) &&
-		!vma_stack_continue(vma->vm_prev, addr);
-}
-
 /**
  * __mlock_vma_pages_range() -  mlock a range of pages in the vma.
  * @vma:   target vma
@@ -177,12 +170,6 @@ static long __mlock_vma_pages_range(stru
 	if (vma->vm_flags & VM_WRITE)
 		gup_flags |= FOLL_WRITE;
 
-	/* We don't try to access the guard page of a stack vma */
-	if (stack_guard_page(vma, start)) {
-		addr += PAGE_SIZE;
-		nr_pages--;
-	}
-
 	while (nr_pages > 0) {
 		int i;
 
@@ -440,7 +427,7 @@ static int do_mlock(unsigned long start,
 {
 	unsigned long nstart, end, tmp;
 	struct vm_area_struct * vma, * prev;
-	int error;
+	int error = 0;
 
 	len = PAGE_ALIGN(len);
 	end = start + len;
@@ -448,6 +435,9 @@ static int do_mlock(unsigned long start,
 		return -EINVAL;
 	if (end == start)
 		return 0;
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	vma = find_vma_prev(current->mm, start, &prev);
 	if (!vma || vma->vm_start > start)
 		return -ENOMEM;
@@ -458,6 +448,11 @@ static int do_mlock(unsigned long start,
 	for (nstart = start ; ; ) {
 		unsigned int newflags;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_start >= SEGMEXEC_TASK_SIZE))
+			break;
+#endif
+
 		/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */
 
 		newflags = vma->vm_flags | VM_LOCKED;
@@ -528,17 +523,23 @@ SYSCALL_DEFINE2(munlock, unsigned long,
 static int do_mlockall(int flags)
 {
 	struct vm_area_struct * vma, * prev = NULL;
-	unsigned int def_flags = 0;
 
 	if (flags & MCL_FUTURE)
-		def_flags = VM_LOCKED;
-	current->mm->def_flags = def_flags;
+		current->mm->def_flags |= VM_LOCKED;
+	else
+		current->mm->def_flags &= ~VM_LOCKED;
 	if (flags == MCL_FUTURE)
 		goto out;
 
 	for (vma = current->mm->mmap; vma ; vma = prev->vm_next) {
-		unsigned int newflags;
+		unsigned long newflags;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((current->mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_start >= SEGMEXEC_TASK_SIZE))
+			break;
+#endif
 
+		BUG_ON(vma->vm_end > TASK_SIZE);
 		newflags = vma->vm_flags | VM_LOCKED;
 		if (!(flags & MCL_CURRENT))
 			newflags &= ~VM_LOCKED;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/mmap.c linux-2.6.32.60-pax/mm/mmap.c
--- linux-2.6.32.60/mm/mmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/mmap.c	2012-04-08 22:11:05.244273306 +0200
@@ -45,6 +45,16 @@
 #define arch_rebalance_pgtables(addr, len)		(addr)
 #endif
 
+static inline void verify_mm_writelocked(struct mm_struct *mm)
+{
+#if defined(CONFIG_DEBUG_VM) || defined(CONFIG_PAX)
+	if (unlikely(down_read_trylock(&mm->mmap_sem))) {
+		up_read(&mm->mmap_sem);
+		BUG();
+	}
+#endif
+}
+
 static void unmap_region(struct mm_struct *mm,
 		struct vm_area_struct *vma, struct vm_area_struct *prev,
 		unsigned long start, unsigned long end);
@@ -70,22 +80,32 @@ static void unmap_region(struct mm_struc
  *		x: (no) no	x: (no) yes	x: (no) yes	x: (yes) yes
  *
  */
-pgprot_t protection_map[16] = {
+pgprot_t protection_map[16] __read_only = {
 	__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,
 	__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
 };
 
 pgprot_t vm_get_page_prot(unsigned long vm_flags)
 {
-	return __pgprot(pgprot_val(protection_map[vm_flags &
+	pgprot_t prot = __pgprot(pgprot_val(protection_map[vm_flags &
 				(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |
 			pgprot_val(arch_vm_get_page_prot(vm_flags)));
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if (!nx_enabled &&
+	    (vm_flags & (VM_PAGEEXEC | VM_EXEC)) == VM_PAGEEXEC &&
+	    (vm_flags & (VM_READ | VM_WRITE)))
+		prot = __pgprot(pte_val(pte_exprotect(__pte(pgprot_val(prot)))));
+#endif
+
+	return prot;
 }
 EXPORT_SYMBOL(vm_get_page_prot);
 
 int sysctl_overcommit_memory = OVERCOMMIT_GUESS;  /* heuristic overcommit */
 int sysctl_overcommit_ratio = 50;	/* default is 50% */
 int sysctl_max_map_count __read_mostly = DEFAULT_MAX_MAP_COUNT;
+unsigned long sysctl_heap_stack_gap __read_mostly = 64*1024;
 struct percpu_counter vm_committed_as;
 
 /*
@@ -231,6 +251,7 @@ static struct vm_area_struct *remove_vma
 	struct vm_area_struct *next = vma->vm_next;
 
 	might_sleep();
+	BUG_ON(vma->vm_mirror);
 	if (vma->vm_ops && vma->vm_ops->close)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file) {
@@ -704,6 +725,12 @@ static int
 can_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,
 	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_start == SEGMEXEC_TASK_SIZE)
+		return 0;
+#endif
+
 	if (is_mergeable_vma(vma, file, vm_flags) &&
 	    is_mergeable_anon_vma(anon_vma, vma->anon_vma)) {
 		if (vma->vm_pgoff == vm_pgoff)
@@ -723,6 +750,12 @@ static int
 can_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,
 	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end == SEGMEXEC_TASK_SIZE)
+		return 0;
+#endif
+
 	if (is_mergeable_vma(vma, file, vm_flags) &&
 	    is_mergeable_anon_vma(anon_vma, vma->anon_vma)) {
 		pgoff_t vm_pglen;
@@ -765,12 +798,19 @@ can_vma_merge_after(struct vm_area_struc
 struct vm_area_struct *vma_merge(struct mm_struct *mm,
 			struct vm_area_struct *prev, unsigned long addr,
 			unsigned long end, unsigned long vm_flags,
-		     	struct anon_vma *anon_vma, struct file *file,
+			struct anon_vma *anon_vma, struct file *file,
 			pgoff_t pgoff, struct mempolicy *policy)
 {
 	pgoff_t pglen = (end - addr) >> PAGE_SHIFT;
 	struct vm_area_struct *area, *next;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	unsigned long addr_m = addr + SEGMEXEC_TASK_SIZE, end_m = end + SEGMEXEC_TASK_SIZE;
+	struct vm_area_struct *area_m = NULL, *next_m = NULL, *prev_m = NULL;
+
+	BUG_ON((mm->pax_flags & MF_PAX_SEGMEXEC) && SEGMEXEC_TASK_SIZE < end);
+#endif
+
 	/*
 	 * We later require that vma->vm_flags == vm_flags,
 	 * so this tests vma->vm_flags & VM_SPECIAL, too.
@@ -786,6 +826,15 @@ struct vm_area_struct *vma_merge(struct
 	if (next && next->vm_end == end)		/* cases 6, 7, 8 */
 		next = next->vm_next;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (prev)
+		prev_m = pax_find_mirror_vma(prev);
+	if (area)
+		area_m = pax_find_mirror_vma(area);
+	if (next)
+		next_m = pax_find_mirror_vma(next);
+#endif
+
 	/*
 	 * Can it merge with the predecessor?
 	 */
@@ -805,9 +854,24 @@ struct vm_area_struct *vma_merge(struct
 							/* cases 1, 6 */
 			vma_adjust(prev, prev->vm_start,
 				next->vm_end, prev->vm_pgoff, NULL);
-		} else					/* cases 2, 5, 7 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (prev_m)
+				vma_adjust(prev_m, prev_m->vm_start,
+					next_m->vm_end, prev_m->vm_pgoff, NULL);
+#endif
+
+		} else {				/* cases 2, 5, 7 */
 			vma_adjust(prev, prev->vm_start,
 				end, prev->vm_pgoff, NULL);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (prev_m)
+				vma_adjust(prev_m, prev_m->vm_start,
+					end_m, prev_m->vm_pgoff, NULL);
+#endif
+
+		}
 		return prev;
 	}
 
@@ -818,12 +882,27 @@ struct vm_area_struct *vma_merge(struct
  			mpol_equal(policy, vma_policy(next)) &&
 			can_vma_merge_before(next, vm_flags,
 					anon_vma, file, pgoff+pglen)) {
-		if (prev && addr < prev->vm_end)	/* case 4 */
+		if (prev && addr < prev->vm_end) {	/* case 4 */
 			vma_adjust(prev, prev->vm_start,
 				addr, prev->vm_pgoff, NULL);
-		else					/* cases 3, 8 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (prev_m)
+				vma_adjust(prev_m, prev_m->vm_start,
+					addr_m, prev_m->vm_pgoff, NULL);
+#endif
+
+		} else {				/* cases 3, 8 */
 			vma_adjust(area, addr, next->vm_end,
 				next->vm_pgoff - pglen, NULL);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			if (area_m)
+				vma_adjust(area_m, addr_m, next_m->vm_end,
+					next_m->vm_pgoff - pglen, NULL);
+#endif
+
+		}
 		return area;
 	}
 
@@ -898,14 +977,11 @@ none:
 void vm_stat_account(struct mm_struct *mm, unsigned long flags,
 						struct file *file, long pages)
 {
-	const unsigned long stack_flags
-		= VM_STACK_FLAGS & (VM_GROWSUP|VM_GROWSDOWN);
-
 	if (file) {
 		mm->shared_vm += pages;
 		if ((flags & (VM_EXEC|VM_WRITE)) == VM_EXEC)
 			mm->exec_vm += pages;
-	} else if (flags & stack_flags)
+	} else if (flags & (VM_GROWSUP|VM_GROWSDOWN))
 		mm->stack_vm += pages;
 	if (flags & (VM_RESERVED|VM_IO))
 		mm->reserved_vm += pages;
@@ -932,7 +1008,7 @@ unsigned long do_mmap_pgoff(struct file
 	 * (the exception is when the underlying filesystem is noexec
 	 *  mounted, in which case we dont add PROT_EXEC.)
 	 */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & (PROT_READ | PROT_WRITE)) && (current->personality & READ_IMPLIES_EXEC))
 		if (!(file && (file->f_path.mnt->mnt_flags & MNT_NOEXEC)))
 			prot |= PROT_EXEC;
 
@@ -958,7 +1034,7 @@ unsigned long do_mmap_pgoff(struct file
 	/* Obtain the address to map to. we verify (or select) it and ensure
 	 * that it represents a valid section of the address space.
 	 */
-	addr = get_unmapped_area(file, addr, len, pgoff, flags);
+	addr = get_unmapped_area(file, addr, len, pgoff, flags | ((prot & PROT_EXEC) ? MAP_EXECUTABLE : 0));
 	if (addr & ~PAGE_MASK)
 		return addr;
 
@@ -969,6 +1045,28 @@ unsigned long do_mmap_pgoff(struct file
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->pax_flags & MF_PAX_MPROTECT) {
+		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC))
+
+#ifdef CONFIG_PAX_EMUPLT
+			vm_flags &= ~VM_EXEC;
+#else
+			return -EPERM;
+#endif
+
+		if (!(vm_flags & VM_EXEC))
+			vm_flags &= ~VM_MAYEXEC;
+		else
+			vm_flags &= ~VM_MAYWRITE;
+	}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && file)
+		vm_flags &= ~VM_PAGEEXEC;
+#endif
+
 	if (flags & MAP_LOCKED)
 		if (!can_do_mlock())
 			return -EPERM;
@@ -1065,10 +1163,10 @@ EXPORT_SYMBOL(do_mmap_pgoff);
  */
 int vma_wants_writenotify(struct vm_area_struct *vma)
 {
-	unsigned int vm_flags = vma->vm_flags;
+	unsigned long vm_flags = vma->vm_flags;
 
 	/* If it was private or non-writable, the write bit is already clear */
-	if ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))
+	if ((vm_flags & (VM_WRITE|VM_SHARED)) != (VM_WRITE|VM_SHARED))
 		return 0;
 
 	/* The backer wishes to know when pages are first written to? */
@@ -1117,14 +1215,24 @@ unsigned long mmap_region(struct file *f
 	unsigned long charged = 0;
 	struct inode *inode =  file ? file->f_path.dentry->d_inode : NULL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m = NULL;
+#endif
+
+	/*
+	 * mm->mmap_sem is required to protect against another thread
+	 * changing the mappings in case we sleep.
+	 */
+	verify_mm_writelocked(mm);
+
 	/* Clear old maps */
 	error = -ENOMEM;
-munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limit. */
@@ -1173,6 +1281,16 @@ munmap_back:
 		goto unacct_error;
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (vm_flags & VM_EXEC)) {
+		vma_m = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+		if (!vma_m) {
+			error = -ENOMEM;
+			goto free_vma;
+		}
+	}
+#endif
+
 	vma->vm_mm = mm;
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
@@ -1195,6 +1313,19 @@ munmap_back:
 		error = file->f_op->mmap(file, vma);
 		if (error)
 			goto unmap_and_free_vma;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma_m && (vm_flags & VM_EXECUTABLE))
+			added_exe_file_vma(mm);
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && !(vma->vm_flags & VM_SPECIAL)) {
+			vma->vm_flags |= VM_PAGEEXEC;
+			vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+		}
+#endif
+
 		if (vm_flags & VM_EXECUTABLE)
 			added_exe_file_vma(mm);
 
@@ -1218,6 +1349,11 @@ munmap_back:
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 	file = vma->vm_file;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m)
+		pax_mirror_vma(vma_m, vma);
+#endif
+
 	/* Once vma denies write, undo our temporary denial count */
 	if (correct_wcount)
 		atomic_inc(&inode->i_writecount);
@@ -1226,6 +1362,7 @@ out:
 
 	mm->total_vm += len >> PAGE_SHIFT;
 	vm_stat_account(mm, vm_flags, file, len >> PAGE_SHIFT);
+	track_exec_limit(mm, addr, addr + len, vm_flags);
 	if (vm_flags & VM_LOCKED) {
 		/*
 		 * makes pages present; downgrades, drops, reacquires mmap_sem
@@ -1248,6 +1385,12 @@ unmap_and_free_vma:
 	unmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);
 	charged = 0;
 free_vma:
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m)
+		kmem_cache_free(vm_area_cachep, vma_m);
+#endif
+
 	kmem_cache_free(vm_area_cachep, vma);
 unacct_error:
 	if (charged)
@@ -1255,6 +1398,44 @@ unacct_error:
 	return error;
 }
 
+bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len)
+{
+	if (!vma) {
+#ifdef CONFIG_STACK_GROWSUP
+		if (addr > sysctl_heap_stack_gap)
+			vma = find_vma(current->mm, addr - sysctl_heap_stack_gap);
+		else
+			vma = find_vma(current->mm, 0);
+		if (vma && (vma->vm_flags & VM_GROWSUP))
+			return false;
+#endif
+		return true;
+	}
+
+	if (addr + len > vma->vm_start)
+		return false;
+
+	if (vma->vm_flags & VM_GROWSDOWN)
+		return sysctl_heap_stack_gap <= vma->vm_start - addr - len;
+#ifdef CONFIG_STACK_GROWSUP
+	else if (vma->vm_prev && (vma->vm_prev->vm_flags & VM_GROWSUP))
+		return addr - vma->vm_prev->vm_end <= sysctl_heap_stack_gap;
+#endif
+
+	return true;
+}
+
+unsigned long skip_heap_stack_gap(const struct vm_area_struct *vma, unsigned long len)
+{
+	if (vma->vm_start < len)
+		return -ENOMEM;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		return vma->vm_start - len;
+	if (sysctl_heap_stack_gap <= vma->vm_start - len)
+		return vma->vm_start - len - sysctl_heap_stack_gap;
+	return -ENOMEM;
+}
+
 /* Get an address range which is currently unmapped.
  * For shmat() with addr=0.
  *
@@ -1281,18 +1462,23 @@ arch_get_unmapped_area(struct file *filp
 	if (flags & MAP_FIXED)
 		return addr;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
-		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vma->vm_start))
-			return addr;
+		if (TASK_SIZE - len >= addr) {
+			vma = find_vma(mm, addr);
+			if (check_heap_stack_gap(vma, addr, len))
+				return addr;
+		}
 	}
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
-	        mm->cached_hole_size = 0;
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
 	}
 
 full_search:
@@ -1303,34 +1489,40 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				addr = TASK_UNMAPPED_BASE;
-			        start_addr = addr;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
-			/*
-			 * Remember the place where we stopped the search:
-			 */
-			mm->free_area_cache = addr + len;
-			return addr;
-		}
+		if (check_heap_stack_gap(vma, addr, len))
+			break;
 		if (addr + mm->cached_hole_size < vma->vm_start)
 		        mm->cached_hole_size = vma->vm_start - addr;
 		addr = vma->vm_end;
 	}
+
+	/*
+	 * Remember the place where we stopped the search:
+	 */
+	mm->free_area_cache = addr + len;
+	return addr;
 }
 #endif	
 
 void arch_unmap_area(struct mm_struct *mm, unsigned long addr)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && SEGMEXEC_TASK_SIZE <= addr)
+		return;
+#endif
+
 	/*
 	 * Is this a new hole at the lowest possible address?
 	 */
-	if (addr >= TASK_UNMAPPED_BASE && addr < mm->free_area_cache) {
+	if (addr >= mm->mmap_base && addr < mm->free_area_cache) {
 		mm->free_area_cache = addr;
 		mm->cached_hole_size = ~0UL;
 	}
@@ -1348,7 +1540,7 @@ arch_get_unmapped_area_topdown(struct fi
 {
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	unsigned long addr = addr0;
+	unsigned long base = mm->mmap_base, addr = addr0;
 
 	/* requested length too big for entire address space */
 	if (len > TASK_SIZE)
@@ -1357,13 +1549,18 @@ arch_get_unmapped_area_topdown(struct fi
 	if (flags & MAP_FIXED)
 		return addr;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
-		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-				(!vma || addr + len <= vma->vm_start))
-			return addr;
+		if (TASK_SIZE - len >= addr) {
+			vma = find_vma(mm, addr);
+			if (check_heap_stack_gap(vma, addr, len))
+				return addr;
+		}
 	}
 
 	/* check if free_area_cache is useful for us */
@@ -1378,7 +1575,7 @@ arch_get_unmapped_area_topdown(struct fi
 	/* make sure it can fit in the remaining address space */
 	if (addr > len) {
 		vma = find_vma(mm, addr-len);
-		if (!vma || addr <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr - len, len))
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr-len);
 	}
@@ -1395,7 +1592,7 @@ arch_get_unmapped_area_topdown(struct fi
 		 * return with success:
 		 */
 		vma = find_vma(mm, addr);
-		if (!vma || addr+len <= vma->vm_start)
+		if (check_heap_stack_gap(vma, addr, len))
 			/* remember the address as a hint for next time */
 			return (mm->free_area_cache = addr);
 
@@ -1404,8 +1601,8 @@ arch_get_unmapped_area_topdown(struct fi
  		        mm->cached_hole_size = vma->vm_start - addr;
 
 		/* try just below the current vma->vm_start */
-		addr = vma->vm_start-len;
-	} while (len < vma->vm_start);
+		addr = skip_heap_stack_gap(vma, len);
+	} while (!IS_ERR_VALUE(addr));
 
 bottomup:
 	/*
@@ -1414,13 +1611,21 @@ bottomup:
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
-  	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
 	 */
-	mm->free_area_cache = mm->mmap_base;
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
 	return addr;
@@ -1429,6 +1634,12 @@ bottomup:
 
 void arch_unmap_area_topdown(struct mm_struct *mm, unsigned long addr)
 {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && SEGMEXEC_TASK_SIZE <= addr)
+		return;
+#endif
+
 	/*
 	 * Is this a new hole at the highest possible address?
 	 */
@@ -1436,8 +1647,10 @@ void arch_unmap_area_topdown(struct mm_s
 		mm->free_area_cache = addr;
 
 	/* dont allow allocations above current base */
-	if (mm->free_area_cache > mm->mmap_base)
+	if (mm->free_area_cache > mm->mmap_base) {
 		mm->free_area_cache = mm->mmap_base;
+		mm->cached_hole_size = ~0UL;
+	}
 }
 
 unsigned long
@@ -1510,40 +1723,50 @@ struct vm_area_struct *find_vma(struct m
 
 EXPORT_SYMBOL(find_vma);
 
-/* Same as find_vma, but also return a pointer to the previous VMA in *pprev. */
+/*
+ * Same as find_vma, but also return a pointer to the previous VMA in *pprev.
+ * Note: pprev is set to NULL when return value is NULL.
+ */
 struct vm_area_struct *
 find_vma_prev(struct mm_struct *mm, unsigned long addr,
 			struct vm_area_struct **pprev)
 {
-	struct vm_area_struct *vma = NULL, *prev = NULL;
-	struct rb_node *rb_node;
-	if (!mm)
-		goto out;
-
-	/* Guard against addr being lower than the first VMA */
-	vma = mm->mmap;
-
-	/* Go through the RB tree quickly. */
-	rb_node = mm->mm_rb.rb_node;
-
-	while (rb_node) {
-		struct vm_area_struct *vma_tmp;
-		vma_tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);
+	struct vm_area_struct *vma;
 
-		if (addr < vma_tmp->vm_end) {
-			rb_node = rb_node->rb_left;
-		} else {
-			prev = vma_tmp;
-			if (!prev->vm_next || (addr < prev->vm_next->vm_end))
-				break;
+	vma = find_vma(mm, addr);
+	if (vma) {
+		*pprev = vma->vm_prev;
+	} else {
+		struct rb_node *rb_node = mm->mm_rb.rb_node;
+		*pprev = NULL;
+		while (rb_node) {
+			*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);
 			rb_node = rb_node->rb_right;
 		}
 	}
+	return vma;
+}
 
-out:
-	*pprev = prev;
-	return prev ? prev->vm_next : vma;
+#ifdef CONFIG_PAX_SEGMEXEC
+struct vm_area_struct *pax_find_mirror_vma(struct vm_area_struct *vma)
+{
+	struct vm_area_struct *vma_m;
+
+	BUG_ON(!vma || vma->vm_start >= vma->vm_end);
+	if (!(vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) || !(vma->vm_flags & VM_EXEC)) {
+		BUG_ON(vma->vm_mirror);
+		return NULL;
+	}
+	BUG_ON(vma->vm_start < SEGMEXEC_TASK_SIZE && SEGMEXEC_TASK_SIZE < vma->vm_end);
+	vma_m = vma->vm_mirror;
+	BUG_ON(!vma_m || vma_m->vm_mirror != vma);
+	BUG_ON(vma->vm_file != vma_m->vm_file);
+	BUG_ON(vma->vm_end - vma->vm_start != vma_m->vm_end - vma_m->vm_start);
+	BUG_ON(vma->vm_pgoff != vma_m->vm_pgoff || vma->anon_vma != vma_m->anon_vma);
+	BUG_ON((vma->vm_flags ^ vma_m->vm_flags) & ~(VM_WRITE | VM_MAYWRITE | VM_ACCOUNT | VM_LOCKED | VM_RESERVED));
+	return vma_m;
 }
+#endif
 
 /*
  * Verify that the stack growth is acceptable and
@@ -1603,34 +1826,42 @@ static int acct_stack_growth(struct vm_a
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	int error;
+	bool locknext;
 
 	if (!(vma->vm_flags & VM_GROWSUP))
 		return -EFAULT;
 
+	/* Also guard against wrapping around to address 0. */
+	if (address < PAGE_ALIGN(address+1))
+		address = PAGE_ALIGN(address+1);
+	else
+		return -ENOMEM;
+
 	/*
 	 * We must make sure the anon_vma is allocated
 	 * so that the anon_vma locking is not a noop.
 	 */
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
+	locknext = vma->vm_next && (vma->vm_next->vm_flags & VM_GROWSDOWN);
+	if (locknext && anon_vma_prepare(vma->vm_next))
+		return -ENOMEM;
 	anon_vma_lock(vma);
+	if (locknext)
+		anon_vma_lock(vma->vm_next);
 
 	/*
 	 * vma->vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
-	 * anon_vma lock to serialize against concurrent expand_stacks.
-	 * Also guard against wrapping around to address 0.
+	 * anon_vma locks to serialize against concurrent expand_stacks
+	 * and expand_upwards.
 	 */
-	if (address < PAGE_ALIGN(address+4))
-		address = PAGE_ALIGN(address+4);
-	else {
-		anon_vma_unlock(vma);
-		return -ENOMEM;
-	}
 	error = 0;
 
 	/* Somebody else might have raced and expanded it already */
-	if (address > vma->vm_end) {
+	if (vma->vm_next && (vma->vm_next->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)) && vma->vm_next->vm_start - address < sysctl_heap_stack_gap)
+		error = -ENOMEM;
+	else if (address > vma->vm_end && (!locknext || vma->vm_next->vm_start >= address)) {
 		unsigned long size, grow;
 
 		size = address - vma->vm_start;
@@ -1643,6 +1874,8 @@ int expand_upwards(struct vm_area_struct
 				vma->vm_end = address;
 		}
 	}
+	if (locknext)
+		anon_vma_unlock(vma->vm_next);
 	anon_vma_unlock(vma);
 	return error;
 }
@@ -1655,6 +1888,8 @@ static int expand_downwards(struct vm_ar
 				   unsigned long address)
 {
 	int error;
+	bool lockprev = false;
+	struct vm_area_struct *prev;
 
 	/*
 	 * We must make sure the anon_vma is allocated
@@ -1668,6 +1903,15 @@ static int expand_downwards(struct vm_ar
 	if (error)
 		return error;
 
+	prev = vma->vm_prev;
+#if defined(CONFIG_STACK_GROWSUP) || defined(CONFIG_IA64)
+	lockprev = prev && (prev->vm_flags & VM_GROWSUP);
+#endif
+	if (lockprev && anon_vma_prepare(prev))
+		return -ENOMEM;
+	if (lockprev)
+		anon_vma_lock(prev);
+
 	anon_vma_lock(vma);
 
 	/*
@@ -1677,9 +1921,17 @@ static int expand_downwards(struct vm_ar
 	 */
 
 	/* Somebody else might have raced and expanded it already */
-	if (address < vma->vm_start) {
+	if (prev && (prev->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)) && address - prev->vm_end < sysctl_heap_stack_gap)
+		error = -ENOMEM;
+	else if (address < vma->vm_start && (!lockprev || prev->vm_end <= address)) {
 		unsigned long size, grow;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		struct vm_area_struct *vma_m;
+
+		vma_m = pax_find_mirror_vma(vma);
+#endif
+
 		size = vma->vm_end - address;
 		grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
@@ -1689,10 +1941,21 @@ static int expand_downwards(struct vm_ar
 			if (!error) {
 				vma->vm_start = address;
 				vma->vm_pgoff -= grow;
+				track_exec_limit(vma->vm_mm, vma->vm_start, vma->vm_end, vma->vm_flags);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+				if (vma_m) {
+					vma_m->vm_start -= grow << PAGE_SHIFT;
+					vma_m->vm_pgoff -= grow;
+				}
+#endif
+
 			}
 		}
 	}
 	anon_vma_unlock(vma);
+	if (lockprev)
+		anon_vma_unlock(prev);
 	return error;
 }
 
@@ -1768,6 +2031,13 @@ static void remove_vma_list(struct mm_st
 	do {
 		long nrpages = vma_pages(vma);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_start >= SEGMEXEC_TASK_SIZE)) {
+			vma = remove_vma(vma);
+			continue;
+		}
+#endif
+
 		mm->total_vm -= nrpages;
 		vm_stat_account(mm, vma->vm_flags, vma->vm_file, -nrpages);
 		vma = remove_vma(vma);
@@ -1813,6 +2083,16 @@ detach_vmas_to_be_unmapped(struct mm_str
 	insertion_point = (prev ? &prev->vm_next : &mm->mmap);
 	vma->vm_prev = NULL;
 	do {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (vma->vm_mirror) {
+			BUG_ON(!vma->vm_mirror->vm_mirror || vma->vm_mirror->vm_mirror != vma);
+			vma->vm_mirror->vm_mirror = NULL;
+			vma->vm_mirror->vm_flags &= ~VM_EXEC;
+			vma->vm_mirror = NULL;
+		}
+#endif
+
 		rb_erase(&vma->vm_rb, &mm->mm_rb);
 		mm->map_count--;
 		tail_vma = vma;
@@ -1840,10 +2120,25 @@ int split_vma(struct mm_struct * mm, str
 	struct mempolicy *pol;
 	struct vm_area_struct *new;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m, *new_m = NULL;
+	unsigned long addr_m = addr + SEGMEXEC_TASK_SIZE;
+#endif
+
 	if (is_vm_hugetlb_page(vma) && (addr &
 					~(huge_page_mask(hstate_vma(vma)))))
 		return -EINVAL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	vma_m = pax_find_mirror_vma(vma);
+
+	if (mm->pax_flags & MF_PAX_SEGMEXEC) {
+		BUG_ON(vma->vm_end > SEGMEXEC_TASK_SIZE);
+		if (mm->map_count >= sysctl_max_map_count-1)
+			return -ENOMEM;
+	} else
+#endif
+
 	if (mm->map_count >= sysctl_max_map_count)
 		return -ENOMEM;
 
@@ -1851,6 +2146,16 @@ int split_vma(struct mm_struct * mm, str
 	if (!new)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m) {
+		new_m = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+		if (!new_m) {
+			kmem_cache_free(vm_area_cachep, new);
+			return -ENOMEM;
+		}
+	}
+#endif
+
 	/* most fields are the same, copy all, and then fixup */
 	*new = *vma;
 
@@ -1861,8 +2166,29 @@ int split_vma(struct mm_struct * mm, str
 		new->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m) {
+		*new_m = *vma_m;
+		new_m->vm_mirror = new;
+		new->vm_mirror = new_m;
+
+		if (new_below)
+			new_m->vm_end = addr_m;
+		else {
+			new_m->vm_start = addr_m;
+			new_m->vm_pgoff += ((addr_m - vma_m->vm_start) >> PAGE_SHIFT);
+		}
+	}
+#endif
+
 	pol = mpol_dup(vma_policy(vma));
 	if (IS_ERR(pol)) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (new_m)
+			kmem_cache_free(vm_area_cachep, new_m);
+#endif
+
 		kmem_cache_free(vm_area_cachep, new);
 		return PTR_ERR(pol);
 	}
@@ -1883,6 +2209,28 @@ int split_vma(struct mm_struct * mm, str
 	else
 		vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m) {
+		mpol_get(pol);
+		vma_set_policy(new_m, pol);
+
+		if (new_m->vm_file) {
+			get_file(new_m->vm_file);
+			if (vma_m->vm_flags & VM_EXECUTABLE)
+				added_exe_file_vma(mm);
+		}
+
+		if (new_m->vm_ops && new_m->vm_ops->open)
+			new_m->vm_ops->open(new_m);
+
+		if (new_below)
+			vma_adjust(vma_m, addr_m, vma_m->vm_end, vma_m->vm_pgoff +
+				((addr_m - new_m->vm_start) >> PAGE_SHIFT), new_m);
+		else
+			vma_adjust(vma_m, vma_m->vm_start, addr_m, vma_m->vm_pgoff, new_m);
+	}
+#endif
+
 	return 0;
 }
 
@@ -1891,11 +2239,30 @@ int split_vma(struct mm_struct * mm, str
  * work.  This now handles partial unmappings.
  * Jeremy Fitzhardinge <jeremy@goop.org>
  */
+#ifdef CONFIG_PAX_SEGMEXEC
+int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+{
+	int ret = __do_munmap(mm, start, len);
+	if (ret || !(mm->pax_flags & MF_PAX_SEGMEXEC))
+		return ret;
+
+	return __do_munmap(mm, start + SEGMEXEC_TASK_SIZE, len);
+}
+
+int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#else
 int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)
+#endif
 {
 	unsigned long end;
 	struct vm_area_struct *vma, *prev, *last;
 
+	/*
+	 * mm->mmap_sem is required to protect against another thread
+	 * changing the mappings in case we sleep.
+	 */
+	verify_mm_writelocked(mm);
+
 	if ((start & ~PAGE_MASK) || start > TASK_SIZE || len > TASK_SIZE-start)
 		return -EINVAL;
 
@@ -1959,6 +2326,8 @@ int do_munmap(struct mm_struct *mm, unsi
 	/* Fix up all other VM information */
 	remove_vma_list(mm, vma);
 
+	track_exec_limit(mm, start, end, 0UL);
+
 	return 0;
 }
 
@@ -1971,22 +2340,18 @@ SYSCALL_DEFINE2(munmap, unsigned long, a
 
 	profile_munmap(addr);
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) &&
+	    (len > SEGMEXEC_TASK_SIZE || addr > SEGMEXEC_TASK_SIZE-len))
+		return -EINVAL;
+#endif
+
 	down_write(&mm->mmap_sem);
 	ret = do_munmap(mm, addr, len);
 	up_write(&mm->mmap_sem);
 	return ret;
 }
 
-static inline void verify_mm_writelocked(struct mm_struct *mm)
-{
-#ifdef CONFIG_DEBUG_VM
-	if (unlikely(down_read_trylock(&mm->mmap_sem))) {
-		WARN_ON(1);
-		up_read(&mm->mmap_sem);
-	}
-#endif
-}
-
 /*
  *  this is really a simplified "do_mmap".  it only handles
  *  anonymous maps.  eventually we may be able to do some
@@ -2000,6 +2365,7 @@ unsigned long do_brk(unsigned long addr,
 	struct rb_node ** rb_link, * rb_parent;
 	pgoff_t pgoff = addr >> PAGE_SHIFT;
 	int error;
+	unsigned long charged;
 
 	len = PAGE_ALIGN(len);
 	if (!len)
@@ -2011,16 +2377,30 @@ unsigned long do_brk(unsigned long addr,
 
 	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
 
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm->pax_flags & (MF_PAX_PAGEEXEC | MF_PAX_SEGMEXEC)) {
+		flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+		if (mm->pax_flags & MF_PAX_MPROTECT)
+			flags &= ~VM_MAYEXEC;
+#endif
+
+	}
+#endif
+
 	error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);
 	if (error & ~PAGE_MASK)
 		return error;
 
+	charged = len >> PAGE_SHIFT;
+
 	/*
 	 * mlock MCL_FUTURE?
 	 */
 	if (mm->def_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
-		locked = len >> PAGE_SHIFT;
+		locked = charged;
 		locked += mm->locked_vm;
 		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		lock_limit >>= PAGE_SHIFT;
@@ -2037,22 +2417,22 @@ unsigned long do_brk(unsigned long addr,
 	/*
 	 * Clear old maps.  this also does some error checking for us
 	 */
- munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 	if (vma && vma->vm_start < addr + len) {
 		if (do_munmap(mm, addr, len))
 			return -ENOMEM;
-		goto munmap_back;
+		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+		BUG_ON(vma && vma->vm_start < addr + len);
 	}
 
 	/* Check against address space limits *after* clearing old maps... */
-	if (!may_expand_vm(mm, len >> PAGE_SHIFT))
+	if (!may_expand_vm(mm, charged))
 		return -ENOMEM;
 
 	if (mm->map_count > sysctl_max_map_count)
 		return -ENOMEM;
 
-	if (security_vm_enough_memory(len >> PAGE_SHIFT))
+	if (security_vm_enough_memory(charged))
 		return -ENOMEM;
 
 	/* Can we just expand an old private anonymous mapping? */
@@ -2066,7 +2446,7 @@ unsigned long do_brk(unsigned long addr,
 	 */
 	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
 	if (!vma) {
-		vm_unacct_memory(len >> PAGE_SHIFT);
+		vm_unacct_memory(charged);
 		return -ENOMEM;
 	}
 
@@ -2078,11 +2458,12 @@ unsigned long do_brk(unsigned long addr,
 	vma->vm_page_prot = vm_get_page_prot(flags);
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 out:
-	mm->total_vm += len >> PAGE_SHIFT;
+	mm->total_vm += charged;
 	if (flags & VM_LOCKED) {
 		if (!mlock_vma_pages_range(vma, addr, addr + len))
-			mm->locked_vm += (len >> PAGE_SHIFT);
+			mm->locked_vm += charged;
 	}
+	track_exec_limit(mm, addr, addr + len, flags);
 	return addr;
 }
 
@@ -2129,8 +2510,10 @@ void exit_mmap(struct mm_struct *mm)
 	 * Walk the list again, actually closing and freeing it,
 	 * with preemption enabled, without holding any MM locks.
 	 */
-	while (vma)
+	while (vma) {
+		vma->vm_mirror = NULL;
 		vma = remove_vma(vma);
+	}
 
 	BUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);
 }
@@ -2144,6 +2527,10 @@ int insert_vm_struct(struct mm_struct *
 	struct vm_area_struct * __vma, * prev;
 	struct rb_node ** rb_link, * rb_parent;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m = NULL;
+#endif
+
 	/*
 	 * The vm_pgoff of a purely anonymous vma should be irrelevant
 	 * until its first write fault, when page's anon_vma and index
@@ -2166,7 +2553,22 @@ int insert_vm_struct(struct mm_struct *
 	if ((vma->vm_flags & VM_ACCOUNT) &&
 	     security_vm_enough_memory_mm(mm, vma_pages(vma)))
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (vma->vm_flags & VM_EXEC)) {
+		vma_m = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+		if (!vma_m)
+			return -ENOMEM;
+	}
+#endif
+
 	vma_link(mm, vma, prev, rb_link, rb_parent);
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma_m)
+		pax_mirror_vma(vma_m, vma);
+#endif
+
 	return 0;
 }
 
@@ -2184,6 +2586,8 @@ struct vm_area_struct *copy_vma(struct v
 	struct rb_node **rb_link, *rb_parent;
 	struct mempolicy *pol;
 
+	BUG_ON(vma->vm_mirror);
+
 	/*
 	 * If anonymous vma has not yet been faulted, update new pgoff
 	 * to match new location, to increase its chance of merging.
@@ -2227,6 +2631,35 @@ struct vm_area_struct *copy_vma(struct v
 	return new_vma;
 }
 
+#ifdef CONFIG_PAX_SEGMEXEC
+void pax_mirror_vma(struct vm_area_struct *vma_m, struct vm_area_struct *vma)
+{
+	struct vm_area_struct *prev_m;
+	struct rb_node **rb_link_m, *rb_parent_m;
+	struct mempolicy *pol_m;
+
+	BUG_ON(!(vma->vm_mm->pax_flags & MF_PAX_SEGMEXEC) || !(vma->vm_flags & VM_EXEC));
+	BUG_ON(vma->vm_mirror || vma_m->vm_mirror);
+	BUG_ON(!mpol_equal(vma_policy(vma), vma_policy(vma_m)));
+	*vma_m = *vma;
+	pol_m = vma_policy(vma_m);
+	mpol_get(pol_m);
+	vma_set_policy(vma_m, pol_m);
+	vma_m->vm_start += SEGMEXEC_TASK_SIZE;
+	vma_m->vm_end += SEGMEXEC_TASK_SIZE;
+	vma_m->vm_flags &= ~(VM_WRITE | VM_MAYWRITE | VM_ACCOUNT | VM_LOCKED);
+	vma_m->vm_page_prot = vm_get_page_prot(vma_m->vm_flags);
+	if (vma_m->vm_file)
+		get_file(vma_m->vm_file);
+	if (vma_m->vm_ops && vma_m->vm_ops->open)
+		vma_m->vm_ops->open(vma_m);
+	find_vma_prepare(vma->vm_mm, vma_m->vm_start, &prev_m, &rb_link_m, &rb_parent_m);
+	vma_link(vma->vm_mm, vma_m, prev_m, rb_link_m, rb_parent_m);
+	vma_m->vm_mirror = vma;
+	vma->vm_mirror = vma_m;
+}
+#endif
+
 /*
  * Return true if the calling process may expand its vm space by the passed
  * number of pages
@@ -2238,6 +2671,11 @@ int may_expand_vm(struct mm_struct *mm,
 
 	lim = current->signal->rlim[RLIMIT_AS].rlim_cur >> PAGE_SHIFT;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		cur -= mm->brk_gap;
+#endif
+
 	if (cur + npages > lim)
 		return 0;
 	return 1;
@@ -2307,6 +2745,17 @@ int install_special_mapping(struct mm_st
 	vma->vm_start = addr;
 	vma->vm_end = addr + len;
 
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->pax_flags & MF_PAX_MPROTECT) {
+		if ((vm_flags & (VM_WRITE | VM_EXEC)) == (VM_WRITE | VM_EXEC))
+			return -EPERM;
+		if (!(vm_flags & VM_EXEC))
+			vm_flags &= ~VM_MAYEXEC;
+		else
+			vm_flags &= ~VM_MAYWRITE;
+	}
+#endif
+
 	vma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND;
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/mprotect.c linux-2.6.32.60-pax/mm/mprotect.c
--- linux-2.6.32.60/mm/mprotect.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/mprotect.c	2012-03-13 13:15:35.940097947 +0100
@@ -24,10 +24,16 @@
 #include <linux/mmu_notifier.h>
 #include <linux/migrate.h>
 #include <linux/perf_event.h>
+
+#ifdef CONFIG_PAX_MPROTECT
+#include <linux/elf.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
+#include <asm/mmu_context.h>
 
 #ifndef pgprot_modify
 static inline pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
@@ -132,6 +138,48 @@ static void change_protection(struct vm_
 	flush_tlb_range(vma, start, end);
 }
 
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+/* called while holding the mmap semaphor for writing except stack expansion */
+void track_exec_limit(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long prot)
+{
+	unsigned long oldlimit, newlimit = 0UL;
+
+	if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || nx_enabled)
+		return;
+
+	spin_lock(&mm->page_table_lock);
+	oldlimit = mm->context.user_cs_limit;
+	if ((prot & VM_EXEC) && oldlimit < end)
+		/* USER_CS limit moved up */
+		newlimit = end;
+	else if (!(prot & VM_EXEC) && start < oldlimit && oldlimit <= end)
+		/* USER_CS limit moved down */
+		newlimit = start;
+
+	if (newlimit) {
+		mm->context.user_cs_limit = newlimit;
+
+#ifdef CONFIG_SMP
+		wmb();
+		cpus_clear(mm->context.cpu_user_cs_mask);
+		cpu_set(smp_processor_id(), mm->context.cpu_user_cs_mask);
+#endif
+
+		set_user_cs(mm->context.user_cs_base, mm->context.user_cs_limit, smp_processor_id());
+	}
+	spin_unlock(&mm->page_table_lock);
+	if (newlimit == end) {
+		struct vm_area_struct *vma = find_vma(mm, oldlimit);
+
+		for (; vma && vma->vm_start < end; vma = vma->vm_next)
+			if (is_vm_hugetlb_page(vma))
+				hugetlb_change_protection(vma, vma->vm_start, vma->vm_end, vma->vm_page_prot);
+			else
+				change_protection(vma, vma->vm_start, vma->vm_end, vma->vm_page_prot, vma_wants_writenotify(vma));
+	}
+}
+#endif
+
 int
 mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 	unsigned long start, unsigned long end, unsigned long newflags)
@@ -144,11 +192,29 @@ mprotect_fixup(struct vm_area_struct *vm
 	int error;
 	int dirty_accountable = 0;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	struct vm_area_struct *vma_m = NULL;
+	unsigned long start_m, end_m;
+
+	start_m = start + SEGMEXEC_TASK_SIZE;
+	end_m = end + SEGMEXEC_TASK_SIZE;
+#endif
+
 	if (newflags == oldflags) {
 		*pprev = vma;
 		return 0;
 	}
 
+	if (newflags & (VM_READ | VM_WRITE | VM_EXEC)) {
+		struct vm_area_struct *prev = vma->vm_prev, *next = vma->vm_next;
+
+		if (next && (next->vm_flags & VM_GROWSDOWN) && sysctl_heap_stack_gap > next->vm_start - end)
+			return -ENOMEM;
+
+		if (prev && (prev->vm_flags & VM_GROWSUP) && sysctl_heap_stack_gap > start - prev->vm_end)
+			return -ENOMEM;
+	}
+
 	/*
 	 * If we make a private mapping writable we increase our commit;
 	 * but (without finer accounting) cannot reduce our commit if we
@@ -165,6 +231,38 @@ mprotect_fixup(struct vm_area_struct *vm
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && ((oldflags ^ newflags) & VM_EXEC)) {
+		if (start != vma->vm_start) {
+			error = split_vma(mm, vma, start, 1);
+			if (error)
+				goto fail;
+			BUG_ON(!*pprev || (*pprev)->vm_next == vma);
+			*pprev = (*pprev)->vm_next;
+		}
+
+		if (end != vma->vm_end) {
+			error = split_vma(mm, vma, end, 0);
+			if (error)
+				goto fail;
+		}
+
+		if (pax_find_mirror_vma(vma)) {
+			error = __do_munmap(mm, start_m, end_m - start_m);
+			if (error)
+				goto fail;
+		} else {
+			vma_m = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+			if (!vma_m) {
+				error = -ENOMEM;
+				goto fail;
+			}
+			vma->vm_flags = newflags;
+			pax_mirror_vma(vma_m, vma);
+		}
+	}
+#endif
+
 	/*
 	 * First try to merge with previous and/or next vma.
 	 */
@@ -195,9 +293,21 @@ success:
 	 * vm_flags and vm_page_prot are protected by the mmap_sem
 	 * held in write mode.
 	 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (newflags & VM_EXEC) && ((vma->vm_flags ^ newflags) & VM_READ))
+		pax_find_mirror_vma(vma)->vm_flags ^= VM_READ;
+#endif
+
 	vma->vm_flags = newflags;
+
+#ifdef CONFIG_PAX_MPROTECT
+	if (mm->binfmt && mm->binfmt->handle_mprotect)
+		mm->binfmt->handle_mprotect(vma, newflags);
+#endif
+
 	vma->vm_page_prot = pgprot_modify(vma->vm_page_prot,
-					  vm_get_page_prot(newflags));
+					  vm_get_page_prot(vma->vm_flags));
 
 	if (vma_wants_writenotify(vma)) {
 		vma->vm_page_prot = vm_get_page_prot(newflags & ~VM_SHARED);
@@ -239,6 +349,17 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 	end = start + len;
 	if (end <= start)
 		return -ENOMEM;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC) {
+		if (end > SEGMEXEC_TASK_SIZE)
+			return -EINVAL;
+	} else
+#endif
+
+	if (end > TASK_SIZE)
+		return -EINVAL;
+
 	if (!arch_validate_prot(prot))
 		return -EINVAL;
 
@@ -246,7 +367,7 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 	/*
 	 * Does the application expect PROT_READ to imply PROT_EXEC:
 	 */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & (PROT_READ | PROT_WRITE)) && (current->personality & READ_IMPLIES_EXEC))
 		prot |= PROT_EXEC;
 
 	vm_flags = calc_vm_prot_bits(prot);
@@ -278,6 +399,11 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 	if (start > vma->vm_start)
 		prev = vma;
 
+#ifdef CONFIG_PAX_MPROTECT
+	if (current->mm->binfmt && current->mm->binfmt->handle_mprotect)
+		current->mm->binfmt->handle_mprotect(vma, vm_flags);
+#endif
+
 	for (nstart = start ; ; ) {
 		unsigned long newflags;
 
@@ -301,6 +427,9 @@ SYSCALL_DEFINE3(mprotect, unsigned long,
 		error = mprotect_fixup(vma, &prev, nstart, tmp, newflags);
 		if (error)
 			goto out;
+
+		track_exec_limit(current->mm, nstart, tmp, vm_flags);
+
 		nstart = tmp;
 
 		if (nstart < prev->vm_end)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/mremap.c linux-2.6.32.60-pax/mm/mremap.c
--- linux-2.6.32.60/mm/mremap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/mremap.c	2012-03-13 13:15:35.940097947 +0100
@@ -112,6 +112,12 @@ static void move_ptes(struct vm_area_str
 			continue;
 		pte = ptep_clear_flush(vma, old_addr, old_pte);
 		pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);
+
+#ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
+		if (!nx_enabled && (new_vma->vm_flags & (VM_PAGEEXEC | VM_EXEC)) == VM_PAGEEXEC)
+			pte = pte_exprotect(pte);
+#endif
+
 		set_pte_at(mm, new_addr, new_pte, pte);
 	}
 
@@ -271,6 +277,11 @@ static struct vm_area_struct *vma_to_res
 	if (is_vm_hugetlb_page(vma))
 		goto Einval;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (pax_find_mirror_vma(vma))
+		goto Einval;
+#endif
+
 	/* We can't remap across vm area boundaries */
 	if (old_len > vma->vm_end - addr)
 		goto Efault;
@@ -327,20 +338,25 @@ static unsigned long mremap_to(unsigned
 	unsigned long ret = -EINVAL;
 	unsigned long charged = 0;
 	unsigned long map_flags;
+	unsigned long pax_task_size = TASK_SIZE;
 
 	if (new_addr & ~PAGE_MASK)
 		goto out;
 
-	if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
+
+	if (new_len > TASK_SIZE || new_addr > pax_task_size - new_len)
 		goto out;
 
 	/* Check if the location we're moving into overlaps the
 	 * old location at all, and fail if it does.
 	 */
-	if ((new_addr <= addr) && (new_addr+new_len) > addr)
-		goto out;
-
-	if ((addr <= new_addr) && (addr+old_len) > new_addr)
+	if (addr + old_len > new_addr && new_addr + new_len > addr)
 		goto out;
 
 	ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
@@ -412,6 +428,7 @@ unsigned long do_mremap(unsigned long ad
 	struct vm_area_struct *vma;
 	unsigned long ret = -EINVAL;
 	unsigned long charged = 0;
+	unsigned long pax_task_size = TASK_SIZE;
 
 	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 		goto out;
@@ -430,6 +447,17 @@ unsigned long do_mremap(unsigned long ad
 	if (!new_len)
 		goto out;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	pax_task_size -= PAGE_SIZE;
+
+	if (new_len > pax_task_size || addr > pax_task_size-new_len ||
+	    old_len > pax_task_size || addr > pax_task_size-old_len)
+		goto out;
+
 	if (flags & MREMAP_FIXED) {
 		if (flags & MREMAP_MAYMOVE)
 			ret = mremap_to(addr, old_len, new_addr, new_len);
@@ -476,6 +504,7 @@ unsigned long do_mremap(unsigned long ad
 						   addr + new_len);
 			}
 			ret = addr;
+			track_exec_limit(vma->vm_mm, vma->vm_start, addr + new_len, vma->vm_flags);
 			goto out;
 		}
 	}
@@ -502,7 +531,13 @@ unsigned long do_mremap(unsigned long ad
 		ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
 		if (ret)
 			goto out;
+
+		map_flags = vma->vm_flags;
 		ret = move_vma(vma, addr, old_len, new_len, new_addr);
+		if (!(ret & ~PAGE_MASK)) {
+			track_exec_limit(current->mm, addr, addr + old_len, 0UL);
+			track_exec_limit(current->mm, new_addr, new_addr + new_len, map_flags);
+		}
 	}
 out:
 	if (ret & ~PAGE_MASK)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/nommu.c linux-2.6.32.60-pax/mm/nommu.c
--- linux-2.6.32.60/mm/nommu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/nommu.c	2012-03-13 13:15:35.944097947 +0100
@@ -67,7 +67,6 @@ int sysctl_overcommit_memory = OVERCOMMI
 int sysctl_overcommit_ratio = 50; /* default is 50% */
 int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;
 int sysctl_nr_trim_pages = CONFIG_NOMMU_INITIAL_TRIM_EXCESS;
-int heap_stack_gap = 0;
 
 atomic_long_t mmap_pages_allocated;
 
@@ -761,15 +760,6 @@ struct vm_area_struct *find_vma(struct m
 EXPORT_SYMBOL(find_vma);
 
 /*
- * find a VMA
- * - we don't extend stack VMAs under NOMMU conditions
- */
-struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)
-{
-	return find_vma(mm, addr);
-}
-
-/*
  * expand a stack to a given address
  * - not supported under NOMMU conditions
  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/page_alloc.c linux-2.6.32.60-pax/mm/page_alloc.c
--- linux-2.6.32.60/mm/page_alloc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/page_alloc.c	2012-03-13 13:15:35.944097947 +0100
@@ -289,7 +289,7 @@ out:
  * This usage means that zero-order pages may not be compound.
  */
 
-static void free_compound_page(struct page *page)
+void free_compound_page(struct page *page)
 {
 	__free_pages_ok(page, compound_order(page));
 }
@@ -587,6 +587,10 @@ static void __free_pages_ok(struct page
 	int bad = 0;
 	int wasMlocked = __TestClearPageMlocked(page);
 
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	unsigned long index = 1UL << order;
+#endif
+
 	kmemcheck_free_shadow(page, order);
 
 	for (i = 0 ; i < (1 << order) ; ++i)
@@ -599,6 +603,12 @@ static void __free_pages_ok(struct page
 		debug_check_no_obj_freed(page_address(page),
 					   PAGE_SIZE << order);
 	}
+
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	for (; index; --index)
+		sanitize_highpage(page + index - 1);
+#endif
+
 	arch_free_page(page, order);
 	kernel_map_pages(page, 1 << order, 0);
 
@@ -702,8 +712,10 @@ static int prep_new_page(struct page *pa
 	arch_alloc_page(page, order);
 	kernel_map_pages(page, 1 << order, 1);
 
+#ifndef CONFIG_PAX_MEMORY_SANITIZE
 	if (gfp_flags & __GFP_ZERO)
 		prep_zero_page(page, order, gfp_flags);
+#endif
 
 	if (order && (gfp_flags & __GFP_COMP))
 		prep_compound_page(page, order);
@@ -1097,6 +1109,11 @@ static void free_hot_cold_page(struct pa
 		debug_check_no_locks_freed(page_address(page), PAGE_SIZE);
 		debug_check_no_obj_freed(page_address(page), PAGE_SIZE);
 	}
+
+#ifdef CONFIG_PAX_MEMORY_SANITIZE
+	sanitize_highpage(page);
+#endif
+
 	arch_free_page(page, 0);
 	kernel_map_pages(page, 1, 0);
 
@@ -3736,7 +3753,7 @@ static void __init setup_usemap(struct p
 		zone->pageblock_flags = alloc_bootmem_node(pgdat, usemapsize);
 }
 #else
-static void inline setup_usemap(struct pglist_data *pgdat,
+static inline void setup_usemap(struct pglist_data *pgdat,
 				struct zone *zone, unsigned long zonesize) {}
 #endif /* CONFIG_SPARSEMEM */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/percpu.c linux-2.6.32.60-pax/mm/percpu.c
--- linux-2.6.32.60/mm/percpu.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/percpu.c	2012-03-13 13:15:35.948097946 +0100
@@ -115,7 +115,7 @@ static unsigned int pcpu_low_unit_cpu __
 static unsigned int pcpu_high_unit_cpu __read_mostly;
 
 /* the address of the first chunk which starts with the kernel static area */
-void *pcpu_base_addr __read_mostly;
+void *pcpu_base_addr __read_only;
 EXPORT_SYMBOL_GPL(pcpu_base_addr);
 
 static const int *pcpu_unit_map __read_mostly;		/* cpu -> unit */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/rmap.c linux-2.6.32.60-pax/mm/rmap.c
--- linux-2.6.32.60/mm/rmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/rmap.c	2012-03-13 13:15:35.948097946 +0100
@@ -121,6 +121,17 @@ int anon_vma_prepare(struct vm_area_stru
 		/* page_table_lock to protect against threads */
 		spin_lock(&mm->page_table_lock);
 		if (likely(!vma->anon_vma)) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+			struct vm_area_struct *vma_m = pax_find_mirror_vma(vma);
+
+			if (vma_m) {
+				BUG_ON(vma_m->anon_vma);
+				vma_m->anon_vma = anon_vma;
+				list_add_tail(&vma_m->anon_vma_node, &anon_vma->head);
+			}
+#endif
+
 			vma->anon_vma = anon_vma;
 			list_add_tail(&vma->anon_vma_node, &anon_vma->head);
 			allocated = NULL;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/shmem.c linux-2.6.32.60-pax/mm/shmem.c
--- linux-2.6.32.60/mm/shmem.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/shmem.c	2012-03-13 13:15:35.948097946 +0100
@@ -1061,6 +1061,8 @@ static int shmem_writepage(struct page *
 		goto unlock;
 	}
 	entry = shmem_swp_entry(info, index, NULL);
+	if (!entry)
+		goto unlock;
 	if (entry->val) {
 		/*
 		 * The more uptodate page coming down from a stacked
@@ -1962,7 +1964,7 @@ static int shmem_symlink(struct inode *d
 
 	info = SHMEM_I(inode);
 	inode->i_size = len-1;
-	if (len <= (char *)inode - (char *)info) {
+	if (len <= (char *)inode - (char *)info && len <= 64) {
 		/* do it inline */
 		memcpy(info, symname, len);
 		inode->i_op = &shmem_symlink_inline_operations;
@@ -2310,8 +2312,7 @@ int shmem_fill_super(struct super_block
 	int err = -ENOMEM;
 
 	/* Round up to L1_CACHE_BYTES to resist false sharing */
-	sbinfo = kzalloc(max((int)sizeof(struct shmem_sb_info),
-				L1_CACHE_BYTES), GFP_KERNEL);
+	sbinfo = kzalloc(max(sizeof(struct shmem_sb_info), L1_CACHE_BYTES), GFP_KERNEL);
 	if (!sbinfo)
 		return -ENOMEM;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/slab.c linux-2.6.32.60-pax/mm/slab.c
--- linux-2.6.32.60/mm/slab.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/slab.c	2013-01-22 17:38:23.484543630 +0100
@@ -174,7 +174,7 @@
 
 /* Legal flag mask for kmem_cache_create(). */
 #if DEBUG
-# define CREATE_MASK	(SLAB_RED_ZONE | \
+# define CREATE_MASK	(SLAB_USERCOPY | SLAB_RED_ZONE | \
 			 SLAB_POISON | SLAB_HWCACHE_ALIGN | \
 			 SLAB_CACHE_DMA | \
 			 SLAB_STORE_USER | \
@@ -182,7 +182,7 @@
 			 SLAB_DESTROY_BY_RCU | SLAB_MEM_SPREAD | \
 			 SLAB_DEBUG_OBJECTS | SLAB_NOLEAKTRACE | SLAB_NOTRACK)
 #else
-# define CREATE_MASK	(SLAB_HWCACHE_ALIGN | \
+# define CREATE_MASK	(SLAB_USERCOPY | SLAB_HWCACHE_ALIGN | \
 			 SLAB_CACHE_DMA | \
 			 SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | \
 			 SLAB_DESTROY_BY_RCU | SLAB_MEM_SPREAD | \
@@ -308,7 +308,7 @@ struct kmem_list3 {
  * Need this for bootstrapping a per node allocator.
  */
 #define NUM_INIT_LISTS (3 * MAX_NUMNODES)
-struct kmem_list3 __initdata initkmem_list3[NUM_INIT_LISTS];
+struct kmem_list3 initkmem_list3[NUM_INIT_LISTS];
 #define	CACHE_CACHE 0
 #define	SIZE_AC MAX_NUMNODES
 #define	SIZE_L3 (2 * MAX_NUMNODES)
@@ -409,10 +409,10 @@ static void kmem_list3_init(struct kmem_
 		if ((x)->max_freeable < i)				\
 			(x)->max_freeable = i;				\
 	} while (0)
-#define STATS_INC_ALLOCHIT(x)	atomic_inc(&(x)->allochit)
-#define STATS_INC_ALLOCMISS(x)	atomic_inc(&(x)->allocmiss)
-#define STATS_INC_FREEHIT(x)	atomic_inc(&(x)->freehit)
-#define STATS_INC_FREEMISS(x)	atomic_inc(&(x)->freemiss)
+#define STATS_INC_ALLOCHIT(x)	atomic_inc_unchecked(&(x)->allochit)
+#define STATS_INC_ALLOCMISS(x)	atomic_inc_unchecked(&(x)->allocmiss)
+#define STATS_INC_FREEHIT(x)	atomic_inc_unchecked(&(x)->freehit)
+#define STATS_INC_FREEMISS(x)	atomic_inc_unchecked(&(x)->freemiss)
 #else
 #define	STATS_INC_ACTIVE(x)	do { } while (0)
 #define	STATS_DEC_ACTIVE(x)	do { } while (0)
@@ -558,7 +558,7 @@ static inline void *index_to_obj(struct
  *   reciprocal_divide(offset, cache->reciprocal_buffer_size)
  */
 static inline unsigned int obj_to_index(const struct kmem_cache *cache,
-					const struct slab *slab, void *obj)
+					const struct slab *slab, const void *obj)
 {
 	u32 offset = (obj - slab->s_mem);
 	return reciprocal_divide(offset, cache->reciprocal_buffer_size);
@@ -579,10 +579,11 @@ EXPORT_SYMBOL(malloc_sizes);
 struct cache_names {
 	char *name;
 	char *name_dma;
+	char *name_usercopy;
 };
 
 static struct cache_names __initdata cache_names[] = {
-#define CACHE(x) { .name = "size-" #x, .name_dma = "size-" #x "(DMA)" },
+#define CACHE(x) { .name = "size-" #x, .name_dma = "size-" #x "(DMA)", .name_usercopy = "size-" #x "(USERCOPY)" },
 #include <linux/kmalloc_sizes.h>
 	{NULL,}
 #undef CACHE
@@ -719,6 +720,12 @@ static inline struct kmem_cache *__find_
 	if (unlikely(gfpflags & GFP_DMA))
 		return csizep->cs_dmacachep;
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	if (unlikely(gfpflags & GFP_USERCOPY))
+		return csizep->cs_usercopycachep;
+#endif
+
 	return csizep->cs_cachep;
 }
 
@@ -1453,7 +1460,7 @@ void __init kmem_cache_init(void)
 	sizes[INDEX_AC].cs_cachep = kmem_cache_create(names[INDEX_AC].name,
 					sizes[INDEX_AC].cs_size,
 					ARCH_KMALLOC_MINALIGN,
-					ARCH_KMALLOC_FLAGS|SLAB_PANIC,
+					ARCH_KMALLOC_FLAGS|SLAB_PANIC|SLAB_USERCOPY,
 					NULL);
 
 	if (INDEX_AC != INDEX_L3) {
@@ -1461,7 +1468,7 @@ void __init kmem_cache_init(void)
 			kmem_cache_create(names[INDEX_L3].name,
 				sizes[INDEX_L3].cs_size,
 				ARCH_KMALLOC_MINALIGN,
-				ARCH_KMALLOC_FLAGS|SLAB_PANIC,
+				ARCH_KMALLOC_FLAGS|SLAB_PANIC|SLAB_USERCOPY,
 				NULL);
 	}
 
@@ -1479,7 +1486,7 @@ void __init kmem_cache_init(void)
 			sizes->cs_cachep = kmem_cache_create(names->name,
 					sizes->cs_size,
 					ARCH_KMALLOC_MINALIGN,
-					ARCH_KMALLOC_FLAGS|SLAB_PANIC,
+					ARCH_KMALLOC_FLAGS|SLAB_PANIC|SLAB_USERCOPY,
 					NULL);
 		}
 #ifdef CONFIG_ZONE_DMA
@@ -1491,6 +1498,16 @@ void __init kmem_cache_init(void)
 						SLAB_PANIC,
 					NULL);
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+		sizes->cs_usercopycachep = kmem_cache_create(
+					names->name_usercopy,
+					sizes->cs_size,
+					ARCH_KMALLOC_MINALIGN,
+					ARCH_KMALLOC_FLAGS|SLAB_PANIC|SLAB_USERCOPY,
+					NULL);
+#endif
+
 		sizes++;
 		names++;
 	}
@@ -4211,10 +4228,10 @@ static int s_show(struct seq_file *m, vo
 	}
 	/* cpu stats */
 	{
-		unsigned long allochit = atomic_read(&cachep->allochit);
-		unsigned long allocmiss = atomic_read(&cachep->allocmiss);
-		unsigned long freehit = atomic_read(&cachep->freehit);
-		unsigned long freemiss = atomic_read(&cachep->freemiss);
+		unsigned long allochit = atomic_read_unchecked(&cachep->allochit);
+		unsigned long allocmiss = atomic_read_unchecked(&cachep->allocmiss);
+		unsigned long freehit = atomic_read_unchecked(&cachep->freehit);
+		unsigned long freemiss = atomic_read_unchecked(&cachep->freemiss);
 
 		seq_printf(m, " : cpustat %6lu %6lu %6lu %6lu",
 			   allochit, allocmiss, freehit, freemiss);
@@ -4480,6 +4497,64 @@ static int __init slab_proc_init(void)
 module_init(slab_proc_init);
 #endif
 
+bool is_usercopy_object(const void *ptr)
+{
+	struct page *page;
+	struct kmem_cache *cachep;
+
+	if (ZERO_OR_NULL_PTR(ptr))
+		return false;
+
+	if (!slab_is_available())
+		return false;
+
+	if (!virt_addr_valid(ptr))
+		return false;
+
+	page = virt_to_head_page(ptr);
+
+	if (!PageSlab(page))
+		return false;
+
+	cachep = page_get_cache(page);
+	return cachep->flags & SLAB_USERCOPY;
+}
+
+#ifdef CONFIG_PAX_USERCOPY
+const char *check_heap_object(const void *ptr, unsigned long n)
+{
+	struct page *page;
+	struct kmem_cache *cachep;
+	struct slab *slabp;
+	unsigned int objnr;
+	unsigned long offset;
+
+	if (ZERO_OR_NULL_PTR(ptr))
+		return "<null>";
+
+	if (!virt_addr_valid(ptr))
+		return NULL;
+
+	page = virt_to_head_page(ptr);
+
+	if (!PageSlab(page))
+		return NULL;
+
+	cachep = page_get_cache(page);
+	if (!(cachep->flags & SLAB_USERCOPY))
+		return cachep->name;
+
+	slabp = page_get_slab(page);
+	objnr = obj_to_index(cachep, slabp, ptr);
+	BUG_ON(objnr >= cachep->num);
+	offset = ptr - index_to_obj(cachep, slabp, objnr) - obj_offset(cachep);
+	if (offset <= obj_size(cachep) && n <= obj_size(cachep) - offset)
+		return NULL;
+
+	return cachep->name;
+}
+#endif
+
 /**
  * ksize - get the actual amount of memory allocated for a given object
  * @objp: Pointer to the object
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/slob.c linux-2.6.32.60-pax/mm/slob.c
--- linux-2.6.32.60/mm/slob.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/slob.c	2013-01-22 17:38:23.508543629 +0100
@@ -29,7 +29,7 @@
  * If kmalloc is asked for objects of PAGE_SIZE or larger, it calls
  * alloc_pages() directly, allocating compound pages so the page order
  * does not have to be separately tracked, and also stores the exact
- * allocation size in page->private so that it can be used to accurately
+ * allocation size in slob_page->size so that it can be used to accurately
  * provide ksize(). These objects are detected in kfree() because slob_page()
  * is false for them.
  *
@@ -58,6 +58,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/swap.h> /* struct reclaim_state */
@@ -100,7 +101,8 @@ struct slob_page {
 			unsigned long flags;	/* mandatory */
 			atomic_t _count;	/* mandatory */
 			slobidx_t units;	/* free units left in page */
-			unsigned long pad[2];
+			unsigned long pad[1];
+			unsigned long size;	/* size when >=PAGE_SIZE */
 			slob_t *free;		/* first free slob_t in page */
 			struct list_head list;	/* linked list of free pages */
 		};
@@ -133,7 +135,7 @@ static LIST_HEAD(free_slob_large);
  */
 static inline int is_slob_page(struct slob_page *sp)
 {
-	return PageSlab((struct page *)sp);
+	return PageSlab((struct page *)sp) && !sp->size;
 }
 
 static inline void set_slob_page(struct slob_page *sp)
@@ -148,7 +150,7 @@ static inline void clear_slob_page(struc
 
 static inline struct slob_page *slob_page(const void *addr)
 {
-	return (struct slob_page *)virt_to_page(addr);
+	return (struct slob_page *)virt_to_head_page(addr);
 }
 
 /*
@@ -208,7 +210,7 @@ static void set_slob(slob_t *s, slobidx_
 /*
  * Return the size of a slob block.
  */
-static slobidx_t slob_units(slob_t *s)
+static slobidx_t slob_units(const slob_t *s)
 {
 	if (s->units > 0)
 		return s->units;
@@ -218,7 +220,7 @@ static slobidx_t slob_units(slob_t *s)
 /*
  * Return the next free slob block pointer after this one.
  */
-static slob_t *slob_next(slob_t *s)
+static slob_t *slob_next(const slob_t *s)
 {
 	slob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);
 	slobidx_t next;
@@ -233,7 +235,7 @@ static slob_t *slob_next(slob_t *s)
 /*
  * Returns true if s is the last free block in its page.
  */
-static int slob_last(slob_t *s)
+static int slob_last(const slob_t *s)
 {
 	return !((unsigned long)slob_next(s) & ~PAGE_MASK);
 }
@@ -252,6 +254,7 @@ static void *slob_new_pages(gfp_t gfp, i
 	if (!page)
 		return NULL;
 
+	set_slob_page(page);
 	return page_address(page);
 }
 
@@ -368,11 +371,11 @@ static void *slob_alloc(size_t size, gfp
 		if (!b)
 			return NULL;
 		sp = slob_page(b);
-		set_slob_page(sp);
 
 		spin_lock_irqsave(&slob_lock, flags);
 		sp->units = SLOB_UNITS(PAGE_SIZE);
 		sp->free = b;
+		sp->size = 0;
 		INIT_LIST_HEAD(&sp->list);
 		set_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));
 		set_slob_page_free(sp, slob_list);
@@ -475,10 +478,9 @@ out:
 #define ARCH_SLAB_MINALIGN __alignof__(unsigned long)
 #endif
 
-void *__kmalloc_node(size_t size, gfp_t gfp, int node)
+static void *__kmalloc_node_align(size_t size, gfp_t gfp, int node, int align)
 {
-	unsigned int *m;
-	int align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);
+	slob_t *m;
 	void *ret;
 
 	lockdep_trace_alloc(gfp);
@@ -491,7 +493,10 @@ void *__kmalloc_node(size_t size, gfp_t
 
 		if (!m)
 			return NULL;
-		*m = size;
+		BUILD_BUG_ON(ARCH_KMALLOC_MINALIGN < 2 * SLOB_UNIT);
+		BUILD_BUG_ON(ARCH_SLAB_MINALIGN < 2 * SLOB_UNIT);
+		m[0].units = size;
+		m[1].units = align;
 		ret = (void *)m + align;
 
 		trace_kmalloc_node(_RET_IP_, ret,
@@ -501,16 +506,25 @@ void *__kmalloc_node(size_t size, gfp_t
 
 		ret = slob_new_pages(gfp | __GFP_COMP, get_order(size), node);
 		if (ret) {
-			struct page *page;
-			page = virt_to_page(ret);
-			page->private = size;
+			struct slob_page *sp;
+			sp = slob_page(ret);
+			sp->size = size;
 		}
 
 		trace_kmalloc_node(_RET_IP_, ret,
 				   size, PAGE_SIZE << order, gfp, node);
 	}
 
-	kmemleak_alloc(ret, size, 1, gfp);
+	return ret;
+}
+
+void *__kmalloc_node(size_t size, gfp_t gfp, int node)
+{
+	int align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);
+	void *ret = __kmalloc_node_align(size, gfp, node, align);
+
+	if (!ZERO_OR_NULL_PTR(ret))
+		kmemleak_alloc(ret, size, 1, gfp);
 	return ret;
 }
 EXPORT_SYMBOL(__kmalloc_node);
@@ -528,13 +542,88 @@ void kfree(const void *block)
 	sp = slob_page(block);
 	if (is_slob_page(sp)) {
 		int align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);
-		unsigned int *m = (unsigned int *)(block - align);
-		slob_free(m, *m + align);
-	} else
+		slob_t *m = (slob_t *)(block - align);
+		slob_free(m, m[0].units + align);
+	} else {
+		clear_slob_page(sp);
+		free_slob_page(sp);
+		sp->size = 0;
 		put_page(&sp->page);
+	}
 }
 EXPORT_SYMBOL(kfree);
 
+bool is_usercopy_object(const void *ptr)
+{
+	if (!slab_is_available())
+		return false;
+
+	// PAX: TODO
+
+	return false;
+}
+
+#ifdef CONFIG_PAX_USERCOPY
+const char *check_heap_object(const void *ptr, unsigned long n)
+{
+	struct slob_page *sp;
+	const slob_t *free;
+	const void *base;
+	unsigned long flags;
+
+	if (ZERO_OR_NULL_PTR(ptr))
+		return "<null>";
+
+	if (!virt_addr_valid(ptr))
+		return NULL;
+
+	sp = slob_page(ptr);
+	if (!PageSlab((struct page *)sp))
+		return NULL;
+
+	if (sp->size) {
+		base = page_address(&sp->page);
+		if (base <= ptr && n <= sp->size - (ptr - base))
+			return NULL;
+		return "<slob>";
+	}
+
+	/* some tricky double walking to find the chunk */
+	spin_lock_irqsave(&slob_lock, flags);
+	base = (void *)((unsigned long)ptr & PAGE_MASK);
+	free = sp->free;
+
+	while ((void *)free <= ptr) {
+		base = free + slob_units(free);
+		free = slob_next(free);
+	}
+
+	while (base < (void *)free) {
+		slobidx_t m = ((slob_t *)base)[0].units, align = ((slob_t *)base)[1].units;
+		int size = SLOB_UNIT * SLOB_UNITS(m + align);
+		int offset;
+
+		if (ptr < base + align)
+			break;
+
+		offset = ptr - base - align;
+		if (offset >= m) {
+			base += size;
+			continue;
+		}
+
+		if (n > m - offset)
+			break;
+
+		spin_unlock_irqrestore(&slob_lock, flags);
+		return NULL;
+	}
+
+	spin_unlock_irqrestore(&slob_lock, flags);
+	return "<slob>";
+}
+#endif
+
 /* can't use ksize for kmem_cache_alloc memory, only kmalloc */
 size_t ksize(const void *block)
 {
@@ -547,10 +636,10 @@ size_t ksize(const void *block)
 	sp = slob_page(block);
 	if (is_slob_page(sp)) {
 		int align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);
-		unsigned int *m = (unsigned int *)(block - align);
-		return SLOB_UNITS(*m) * SLOB_UNIT;
+		slob_t *m = (slob_t *)(block - align);
+		return SLOB_UNITS(m[0].units) * SLOB_UNIT;
 	} else
-		return sp->page.private;
+		return sp->size;
 }
 EXPORT_SYMBOL(ksize);
 
@@ -566,8 +655,13 @@ struct kmem_cache *kmem_cache_create(con
 {
 	struct kmem_cache *c;
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	c = __kmalloc_node_align(sizeof(struct kmem_cache),
+		GFP_KERNEL, -1, ARCH_KMALLOC_MINALIGN);
+#else
 	c = slob_alloc(sizeof(struct kmem_cache),
 		GFP_KERNEL, ARCH_KMALLOC_MINALIGN, -1);
+#endif
 
 	if (c) {
 		c->name = name;
@@ -605,17 +699,25 @@ void *kmem_cache_alloc_node(struct kmem_
 {
 	void *b;
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	b = __kmalloc_node_align(c->size, flags, node, c->align);
+#else
 	if (c->size < PAGE_SIZE) {
 		b = slob_alloc(c->size, flags, c->align, node);
 		trace_kmem_cache_alloc_node(_RET_IP_, b, c->size,
 					    SLOB_UNITS(c->size) * SLOB_UNIT,
 					    flags, node);
 	} else {
+		struct slob_page *sp;
+
 		b = slob_new_pages(flags, get_order(c->size), node);
+		sp = slob_page(b);
+		sp->size = c->size;
 		trace_kmem_cache_alloc_node(_RET_IP_, b, c->size,
 					    PAGE_SIZE << get_order(c->size),
 					    flags, node);
 	}
+#endif
 
 	if (c->ctor)
 		c->ctor(b);
@@ -627,10 +729,16 @@ EXPORT_SYMBOL(kmem_cache_alloc_node);
 
 static void __kmem_cache_free(void *b, int size)
 {
-	if (size < PAGE_SIZE)
+	struct slob_page *sp = slob_page(b);
+
+	if (is_slob_page(sp))
 		slob_free(b, size);
-	else
+	else {
+		clear_slob_page(sp);
+		free_slob_page(sp);
+		sp->size = 0;
 		slob_free_pages(b, get_order(size));
+	}
 }
 
 static void kmem_rcu_free(struct rcu_head *head)
@@ -643,18 +751,32 @@ static void kmem_rcu_free(struct rcu_hea
 
 void kmem_cache_free(struct kmem_cache *c, void *b)
 {
+	int size = c->size;
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	if (size + c->align < PAGE_SIZE) {
+		size += c->align;
+		b -= c->align;
+	}
+#endif
+
 	kmemleak_free_recursive(b, c->flags);
 	if (unlikely(c->flags & SLAB_DESTROY_BY_RCU)) {
 		struct slob_rcu *slob_rcu;
-		slob_rcu = b + (c->size - sizeof(struct slob_rcu));
+		slob_rcu = b + (size - sizeof(struct slob_rcu));
 		INIT_RCU_HEAD(&slob_rcu->head);
-		slob_rcu->size = c->size;
+		slob_rcu->size = size;
 		call_rcu(&slob_rcu->head, kmem_rcu_free);
 	} else {
-		__kmem_cache_free(b, c->size);
+		__kmem_cache_free(b, size);
 	}
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	trace_kfree(_RET_IP_, b);
+#else
 	trace_kmem_cache_free(_RET_IP_, b);
+#endif
+
 }
 EXPORT_SYMBOL(kmem_cache_free);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/slub.c linux-2.6.32.60-pax/mm/slub.c
--- linux-2.6.32.60/mm/slub.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/slub.c	2013-01-22 17:38:23.508543629 +0100
@@ -1893,6 +1893,8 @@ void kmem_cache_free(struct kmem_cache *
 
 	page = virt_to_head_page(x);
 
+	BUG_ON(!PageSlab(page));
+
 	slab_free(s, page, x, _RET_IP_);
 
 	trace_kmem_cache_free(_RET_IP_, x);
@@ -1937,7 +1939,7 @@ static int slub_min_objects;
  * Merge control. If this is set then no merging of slab caches will occur.
  * (Could be removed. This was introduced to pacify the merge skeptics.)
  */
-static int slub_nomerge;
+static int slub_nomerge = 1;
 
 /*
  * Calculate the order of allocation given an slab object size.
@@ -2493,7 +2495,7 @@ static int kmem_cache_open(struct kmem_c
 	 * list to avoid pounding the page allocator excessively.
 	 */
 	set_min_partial(s, ilog2(s->size));
-	s->refcount = 1;
+	atomic_set(&s->refcount, 1);
 #ifdef CONFIG_NUMA
 	s->remote_node_defrag_ratio = 1000;
 #endif
@@ -2630,8 +2632,7 @@ static inline int kmem_cache_close(struc
 void kmem_cache_destroy(struct kmem_cache *s)
 {
 	down_write(&slub_lock);
-	s->refcount--;
-	if (!s->refcount) {
+	if (atomic_dec_and_test(&s->refcount)) {
 		list_del(&s->list);
 		up_write(&slub_lock);
 		if (kmem_cache_close(s)) {
@@ -2691,12 +2692,10 @@ static int __init setup_slub_nomerge(cha
 __setup("slub_nomerge", setup_slub_nomerge);
 
 static struct kmem_cache *create_kmalloc_cache(struct kmem_cache *s,
-		const char *name, int size, gfp_t gfp_flags)
+		const char *name, int size, gfp_t gfp_flags, unsigned int flags)
 {
-	unsigned int flags = 0;
-
 	if (gfp_flags & SLUB_DMA)
-		flags = SLAB_CACHE_DMA;
+		flags |= SLAB_CACHE_DMA;
 
 	/*
 	 * This function is called with IRQs disabled during early-boot on
@@ -2792,6 +2791,10 @@ out:
 }
 #endif
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+static struct kmem_cache kmalloc_caches_usercopy[SLUB_PAGE_SHIFT];
+#endif
+
 /*
  * Conversion table for small slabs sizes / 8 to the index in the
  * kmalloc array. This is necessary for slabs < 192 since we have non power
@@ -2847,6 +2850,13 @@ static struct kmem_cache *get_slab(size_
 		return dma_kmalloc_cache(index, flags);
 
 #endif
+
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	if (flags & SLAB_USERCOPY)
+		return &kmalloc_caches_usercopy[index];
+
+#endif
+
 	return &kmalloc_caches[index];
 }
 
@@ -2915,6 +2925,59 @@ void *__kmalloc_node(size_t size, gfp_t
 EXPORT_SYMBOL(__kmalloc_node);
 #endif
 
+bool is_usercopy_object(const void *ptr)
+{
+	struct page *page;
+	struct kmem_cache *s;
+
+	if (ZERO_OR_NULL_PTR(ptr))
+		return false;
+
+	if (!slab_is_available())
+		return false;
+
+	if (!virt_addr_valid(ptr))
+		return false;
+
+	page = virt_to_head_page(ptr);
+
+	if (!PageSlab(page))
+		return false;
+
+	s = page->slab;
+	return s->flags & SLAB_USERCOPY;
+}
+
+#ifdef CONFIG_PAX_USERCOPY
+const char *check_heap_object(const void *ptr, unsigned long n)
+{
+	struct page *page;
+	struct kmem_cache *s;
+	unsigned long offset;
+
+	if (ZERO_OR_NULL_PTR(ptr))
+		return "<null>";
+
+	if (!virt_addr_valid(ptr))
+		return NULL;
+
+	page = get_object_page(ptr);
+
+	if (!page)
+		return NULL;
+
+	s = page->slab;
+	if (!(s->flags & SLAB_USERCOPY))
+		return s->name;
+
+	offset = (ptr - page_address(page)) % s->size;
+	if (offset <= s->objsize && n <= s->objsize - offset)
+		return NULL;
+
+	return s->name;
+}
+#endif
+
 size_t ksize(const void *object)
 {
 	struct page *page;
@@ -3185,8 +3248,8 @@ void __init kmem_cache_init(void)
 	 * kmem_cache_open for slab_state == DOWN.
 	 */
 	create_kmalloc_cache(&kmalloc_caches[0], "kmem_cache_node",
-		sizeof(struct kmem_cache_node), GFP_NOWAIT);
-	kmalloc_caches[0].refcount = -1;
+		sizeof(struct kmem_cache_node), GFP_NOWAIT, 0);
+	atomic_set(&kmalloc_caches[0].refcount, -1);
 	caches++;
 
 	hotplug_memory_notifier(slab_memory_callback, SLAB_CALLBACK_PRI);
@@ -3198,18 +3261,18 @@ void __init kmem_cache_init(void)
 	/* Caches that are not of the two-to-the-power-of size */
 	if (KMALLOC_MIN_SIZE <= 32) {
 		create_kmalloc_cache(&kmalloc_caches[1],
-				"kmalloc-96", 96, GFP_NOWAIT);
+				"kmalloc-96", 96, GFP_NOWAIT, SLAB_USERCOPY);
 		caches++;
 	}
 	if (KMALLOC_MIN_SIZE <= 64) {
 		create_kmalloc_cache(&kmalloc_caches[2],
-				"kmalloc-192", 192, GFP_NOWAIT);
+				"kmalloc-192", 192, GFP_NOWAIT, SLAB_USERCOPY);
 		caches++;
 	}
 
 	for (i = KMALLOC_SHIFT_LOW; i < SLUB_PAGE_SHIFT; i++) {
 		create_kmalloc_cache(&kmalloc_caches[i],
-			"kmalloc", 1 << i, GFP_NOWAIT);
+			"kmalloc", 1 << i, GFP_NOWAIT, SLAB_USERCOPY);
 		caches++;
 	}
 
@@ -3267,6 +3330,20 @@ void __init kmem_cache_init(void)
 	kmem_size = sizeof(struct kmem_cache);
 #endif
 
+#ifdef CONFIG_PAX_USERCOPY_SLABS
+	for (i = 0; i < SLUB_PAGE_SHIFT; i++) {
+		struct kmem_cache *s = &kmalloc_caches[i];
+
+		if (s->size) {
+			char *name = kasprintf(GFP_NOWAIT, "kmalloc-usercopy-%d", s->objsize);
+
+			BUG_ON(!name);
+			create_kmalloc_cache(&kmalloc_caches_usercopy[i], name,
+				s->objsize, GFP_NOWAIT, SLAB_USERCOPY);
+		}
+	}
+#endif
+
 	printk(KERN_INFO
 		"SLUB: Genslabs=%d, HWalign=%d, Order=%d-%d, MinObjects=%d,"
 		" CPUs=%d, Nodes=%d\n",
@@ -3293,7 +3370,7 @@ static int slab_unmergeable(struct kmem_
 	/*
 	 * We may have set a slab to be unmergeable during bootstrap.
 	 */
-	if (s->refcount < 0)
+	if (atomic_read(&s->refcount) < 0)
 		return 1;
 
 	return 0;
@@ -3353,7 +3430,7 @@ struct kmem_cache *kmem_cache_create(con
 	if (s) {
 		int cpu;
 
-		s->refcount++;
+		atomic_inc(&s->refcount);
 		/*
 		 * Adjust the object sizes so that we clear
 		 * the complete object on kzalloc.
@@ -3372,7 +3449,7 @@ struct kmem_cache *kmem_cache_create(con
 
 		if (sysfs_slab_alias(s, name)) {
 			down_write(&slub_lock);
-			s->refcount--;
+			atomic_dec(&s->refcount);
 			up_write(&slub_lock);
 			goto err;
 		}
@@ -4101,7 +4178,7 @@ SLAB_ATTR_RO(ctor);
 
 static ssize_t aliases_show(struct kmem_cache *s, char *buf)
 {
-	return sprintf(buf, "%d\n", s->refcount - 1);
+	return sprintf(buf, "%d\n", atomic_read(&s->refcount) - 1);
 }
 SLAB_ATTR_RO(aliases);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/sparse-vmemmap.c linux-2.6.32.60-pax/mm/sparse-vmemmap.c
--- linux-2.6.32.60/mm/sparse-vmemmap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/sparse-vmemmap.c	2012-05-07 17:49:12.048114620 +0200
@@ -108,7 +108,7 @@ pud_t * __meminit vmemmap_pud_populate(p
 		void *p = vmemmap_alloc_block(PAGE_SIZE, node);
 		if (!p)
 			return NULL;
-		pud_populate(&init_mm, pud, p);
+		pud_populate_kernel(&init_mm, pud, p);
 	}
 	return pud;
 }
@@ -120,7 +120,7 @@ pgd_t * __meminit vmemmap_pgd_populate(u
 		void *p = vmemmap_alloc_block(PAGE_SIZE, node);
 		if (!p)
 			return NULL;
-		pgd_populate(&init_mm, pgd, p);
+		pgd_populate_kernel(&init_mm, pgd, p);
 	}
 	return pgd;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/swap.c linux-2.6.32.60-pax/mm/swap.c
--- linux-2.6.32.60/mm/swap.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/swap.c	2012-03-13 13:15:35.956097946 +0100
@@ -30,6 +30,7 @@
 #include <linux/notifier.h>
 #include <linux/backing-dev.h>
 #include <linux/memcontrol.h>
+#include <linux/hugetlb.h>
 
 #include "internal.h"
 
@@ -65,6 +66,8 @@ static void put_compound_page(struct pag
 		compound_page_dtor *dtor;
 
 		dtor = get_compound_page_dtor(page);
+		if (!PageHuge(page))
+			BUG_ON(dtor != free_compound_page);
 		(*dtor)(page);
 	}
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/util.c linux-2.6.32.60-pax/mm/util.c
--- linux-2.6.32.60/mm/util.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/util.c	2012-03-13 13:15:35.956097946 +0100
@@ -228,6 +228,12 @@ EXPORT_SYMBOL(strndup_user);
 void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
 	mm->get_unmapped_area = arch_get_unmapped_area;
 	mm->unmap_area = arch_unmap_area;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/vmalloc.c linux-2.6.32.60-pax/mm/vmalloc.c
--- linux-2.6.32.60/mm/vmalloc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/vmalloc.c	2012-11-18 15:38:13.703503927 +0100
@@ -40,8 +40,19 @@ static void vunmap_pte_range(pmd_t *pmd,
 
 	pte = pte_offset_kernel(pmd, addr);
 	do {
-		pte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);
-		WARN_ON(!pte_none(ptent) && !pte_present(ptent));
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+		if ((unsigned long)MODULES_EXEC_VADDR <= addr && addr < (unsigned long)MODULES_EXEC_END) {
+			BUG_ON(!pte_exec(*pte));
+			set_pte_at(&init_mm, addr, pte, pfn_pte(__pa(addr) >> PAGE_SHIFT, PAGE_KERNEL_EXEC));
+			continue;
+		}
+#endif
+
+		{
+			pte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);
+			WARN_ON(!pte_none(ptent) && !pte_present(ptent));
+		}
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
 
@@ -101,16 +112,31 @@ static int vmap_pte_range(pmd_t *pmd, un
 	pte = pte_alloc_kernel(pmd, addr);
 	if (!pte)
 		return -ENOMEM;
+
+	pax_open_kernel();
 	do {
 		struct page *page = pages[*nr];
 
-		if (WARN_ON(!pte_none(*pte)))
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+		if (!(pgprot_val(prot) & _PAGE_NX))
+			BUG_ON(!pte_exec(*pte) || pte_pfn(*pte) != __pa(addr) >> PAGE_SHIFT);
+		else
+#endif
+
+		if (!pte_none(*pte)) {
+			pax_close_kernel();
+			WARN_ON(1);
 			return -EBUSY;
-		if (WARN_ON(!page))
+		}
+		if (!page) {
+			pax_close_kernel();
+			WARN_ON(1);
 			return -ENOMEM;
+		}
 		set_pte_at(&init_mm, addr, pte, mk_pte(page, prot));
 		(*nr)++;
 	} while (pte++, addr += PAGE_SIZE, addr != end);
+	pax_close_kernel();
 	return 0;
 }
 
@@ -120,7 +146,7 @@ static int vmap_pmd_range(pud_t *pud, un
 	pmd_t *pmd;
 	unsigned long next;
 
-	pmd = pmd_alloc(&init_mm, pud, addr);
+	pmd = pmd_alloc_kernel(&init_mm, pud, addr);
 	if (!pmd)
 		return -ENOMEM;
 	do {
@@ -137,7 +163,7 @@ static int vmap_pud_range(pgd_t *pgd, un
 	pud_t *pud;
 	unsigned long next;
 
-	pud = pud_alloc(&init_mm, pgd, addr);
+	pud = pud_alloc_kernel(&init_mm, pgd, addr);
 	if (!pud)
 		return -ENOMEM;
 	do {
@@ -192,11 +218,20 @@ int is_vmalloc_or_module_addr(const void
 	 * and fall back on vmalloc() if that fails. Others
 	 * just put it in the vmalloc space.
 	 */
-#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)
+#ifdef CONFIG_MODULES
+#ifdef MODULES_VADDR
 	unsigned long addr = (unsigned long)x;
 	if (addr >= MODULES_VADDR && addr < MODULES_END)
 		return 1;
 #endif
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	if (x >= (const void *)MODULES_EXEC_VADDR && x < (const void *)MODULES_EXEC_END)
+		return 1;
+#endif
+
+#endif
+
 	return is_vmalloc_addr(x);
 }
 
@@ -217,8 +252,14 @@ struct page *vmalloc_to_page(const void
 
 	if (!pgd_none(*pgd)) {
 		pud_t *pud = pud_offset(pgd, addr);
+#ifdef CONFIG_X86
+		if (!pud_large(*pud))
+#endif
 		if (!pud_none(*pud)) {
 			pmd_t *pmd = pmd_offset(pud, addr);
+#ifdef CONFIG_X86
+			if (!pmd_large(*pmd))
+#endif
 			if (!pmd_none(*pmd)) {
 				pte_t *ptep, pte;
 
@@ -292,13 +333,13 @@ static void __insert_vmap_area(struct vm
 	struct rb_node *tmp;
 
 	while (*p) {
-		struct vmap_area *tmp;
+		struct vmap_area *varea;
 
 		parent = *p;
-		tmp = rb_entry(parent, struct vmap_area, rb_node);
-		if (va->va_start < tmp->va_end)
+		varea = rb_entry(parent, struct vmap_area, rb_node);
+		if (va->va_start < varea->va_end)
 			p = &(*p)->rb_left;
-		else if (va->va_end > tmp->va_start)
+		else if (va->va_end > varea->va_start)
 			p = &(*p)->rb_right;
 		else
 			BUG();
@@ -323,7 +364,7 @@ static void purge_vmap_area_lazy(void);
  * Allocate a region of KVA of the specified size and alignment, within the
  * vstart and vend.
  */
-static struct vmap_area *alloc_vmap_area(unsigned long size,
+static __size_overflow(1) struct vmap_area *alloc_vmap_area(unsigned long size,
 				unsigned long align,
 				unsigned long vstart, unsigned long vend,
 				int node, gfp_t gfp_mask)
@@ -1245,6 +1286,16 @@ static struct vm_struct *__get_vm_area_n
 	struct vm_struct *area;
 
 	BUG_ON(in_interrupt());
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
+	if (flags & VM_KERNEXEC) {
+		if (start != VMALLOC_START || end != VMALLOC_END)
+			return NULL;
+		start = (unsigned long)MODULES_EXEC_VADDR;
+		end = (unsigned long)MODULES_EXEC_END;
+	}
+#endif
+
 	if (flags & VM_IOREMAP) {
 		int bit = fls(size);
 
@@ -1484,6 +1535,11 @@ void *vmap(struct page **pages, unsigned
 	if (count > totalram_pages)
 		return NULL;
 
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
+	if (!(pgprot_val(prot) & _PAGE_NX))
+		flags |= VM_KERNEXEC;
+#endif
+
 	area = get_vm_area_caller((count << PAGE_SHIFT), flags,
 					__builtin_return_address(0));
 	if (!area)
@@ -1594,6 +1650,14 @@ static void *__vmalloc_node(unsigned lon
 	if (!size || (size >> PAGE_SHIFT) > totalram_pages)
 		return NULL;
 
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
+	if (!(pgprot_val(prot) & _PAGE_NX))
+		area = __get_vm_area_node(size, align, VM_ALLOC | VM_UNLIST | VM_KERNEXEC,
+					  VMALLOC_START, VMALLOC_END, node,
+					  gfp_mask, caller);
+	else
+#endif
+
 	area = __get_vm_area_node(size, align, VM_ALLOC | VM_UNLIST,
 				  VMALLOC_START, VMALLOC_END, node,
 				  gfp_mask, caller);
@@ -1698,10 +1762,9 @@ EXPORT_SYMBOL(vmalloc_node);
  *	For tight control over page level allocator and protection flags
  *	use __vmalloc() instead.
  */
-
 void *vmalloc_exec(unsigned long size)
 {
-	return __vmalloc_node(size, 1, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL_EXEC,
+	return __vmalloc_node(size, 1, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL_EXEC,
 			      -1, __builtin_return_address(0));
 }
 
@@ -1998,6 +2061,8 @@ int remap_vmalloc_range(struct vm_area_s
 	unsigned long uaddr = vma->vm_start;
 	unsigned long usize = vma->vm_end - vma->vm_start;
 
+	BUG_ON(vma->vm_mirror);
+
 	if ((PAGE_SIZE-1) & (unsigned long)addr)
 		return -EINVAL;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/mm/vmstat.c linux-2.6.32.60-pax/mm/vmstat.c
--- linux-2.6.32.60/mm/vmstat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/mm/vmstat.c	2012-03-13 13:15:35.960097946 +0100
@@ -74,7 +74,7 @@ void vm_events_fold_cpu(int cpu)
  *
  * vm_stat contains the global counters
  */
-atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
+atomic_long_unchecked_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
 EXPORT_SYMBOL(vm_stat);
 
 #ifdef CONFIG_SMP
@@ -324,7 +324,7 @@ void refresh_cpu_vm_stats(int cpu)
 				v = p->vm_stat_diff[i];
 				p->vm_stat_diff[i] = 0;
 				local_irq_restore(flags);
-				atomic_long_add(v, &zone->vm_stat[i]);
+				atomic_long_add_unchecked(v, &zone->vm_stat[i]);
 				global_diff[i] += v;
 #ifdef CONFIG_NUMA
 				/* 3 seconds idle till flush */
@@ -362,7 +362,7 @@ void refresh_cpu_vm_stats(int cpu)
 
 	for (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)
 		if (global_diff[i])
-			atomic_long_add(global_diff[i], &vm_stat[i]);
+			atomic_long_add_unchecked(global_diff[i], &vm_stat[i]);
 }
 
 #endif
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/8021q/vlan.c linux-2.6.32.60-pax/net/8021q/vlan.c
--- linux-2.6.32.60/net/8021q/vlan.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/8021q/vlan.c	2013-01-22 17:38:23.508543629 +0100
@@ -547,7 +547,7 @@ out:
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block vlan_notifier_block __read_mostly = {
+static struct notifier_block vlan_notifier_block = {
 	.notifier_call = vlan_device_event,
 };
 
@@ -622,8 +622,7 @@ static int vlan_ioctl_handler(struct net
 		err = -EPERM;
 		if (!capable(CAP_NET_ADMIN))
 			break;
-		if ((args.u.name_type >= 0) &&
-		    (args.u.name_type < VLAN_NAME_TYPE_HIGHEST)) {
+		if (args.u.name_type < VLAN_NAME_TYPE_HIGHEST) {
 			struct vlan_net *vn;
 
 			vn = net_generic(net, vlan_net_id);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/9p/trans_fd.c linux-2.6.32.60-pax/net/9p/trans_fd.c
--- linux-2.6.32.60/net/9p/trans_fd.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/9p/trans_fd.c	2012-03-13 13:15:35.960097946 +0100
@@ -419,7 +419,7 @@ static int p9_fd_write(struct p9_client
 	oldfs = get_fs();
 	set_fs(get_ds());
 	/* The cast to a user pointer is valid due to the set_fs() */
-	ret = vfs_write(ts->wr, (__force void __user *)v, len, &ts->wr->f_pos);
+	ret = vfs_write(ts->wr, (void __force_user *)v, len, &ts->wr->f_pos);
 	set_fs(oldfs);
 
 	if (ret <= 0 && ret != -ERESTARTSYS && ret != -EAGAIN)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/atm/atm_misc.c linux-2.6.32.60-pax/net/atm/atm_misc.c
--- linux-2.6.32.60/net/atm/atm_misc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/atm/atm_misc.c	2012-03-13 13:15:35.964097946 +0100
@@ -19,7 +19,7 @@ int atm_charge(struct atm_vcc *vcc,int t
 	if (atomic_read(&sk_atm(vcc)->sk_rmem_alloc) <= sk_atm(vcc)->sk_rcvbuf)
 		return 1;
 	atm_return(vcc,truesize);
-	atomic_inc(&vcc->stats->rx_drop);
+	atomic_inc_unchecked(&vcc->stats->rx_drop);
 	return 0;
 }
 
@@ -41,7 +41,7 @@ struct sk_buff *atm_alloc_charge(struct
 		}
 	}
 	atm_return(vcc,guess);
-	atomic_inc(&vcc->stats->rx_drop);
+	atomic_inc_unchecked(&vcc->stats->rx_drop);
 	return NULL;
 }
 
@@ -88,7 +88,7 @@ int atm_pcr_goal(const struct atm_trafpr
 
 void sonet_copy_stats(struct k_sonet_stats *from,struct sonet_stats *to)
 {
-#define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)
+#define __HANDLE_ITEM(i) to->i = atomic_read_unchecked(&from->i)
 	__SONET_ITEMS
 #undef __HANDLE_ITEM
 }
@@ -96,7 +96,7 @@ void sonet_copy_stats(struct k_sonet_sta
 
 void sonet_subtract_stats(struct k_sonet_stats *from,struct sonet_stats *to)
 {
-#define __HANDLE_ITEM(i) atomic_sub(to->i,&from->i)
+#define __HANDLE_ITEM(i) atomic_sub_unchecked(to->i,&from->i)
 	__SONET_ITEMS
 #undef __HANDLE_ITEM
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/atm/lec.h linux-2.6.32.60-pax/net/atm/lec.h
--- linux-2.6.32.60/net/atm/lec.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/atm/lec.h	2012-03-13 13:15:35.964097946 +0100
@@ -48,7 +48,7 @@ struct lane2_ops {
 			      const u8 *tlvs, u32 sizeoftlvs);
 	void (*associate_indicator) (struct net_device *dev, const u8 *mac_addr,
 				     const u8 *tlvs, u32 sizeoftlvs);
-};
+} __no_const;
 
 /*
  * ATM LAN Emulation supports both LLC & Dix Ethernet EtherType
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/atm/proc.c linux-2.6.32.60-pax/net/atm/proc.c
--- linux-2.6.32.60/net/atm/proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/atm/proc.c	2012-03-13 13:15:35.964097946 +0100
@@ -43,9 +43,9 @@ static void add_stats(struct seq_file *s
   const struct k_atm_aal_stats *stats)
 {
 	seq_printf(seq, "%s ( %d %d %d %d %d )", aal,
-	    atomic_read(&stats->tx),atomic_read(&stats->tx_err),
-	    atomic_read(&stats->rx),atomic_read(&stats->rx_err),
-	    atomic_read(&stats->rx_drop));
+	    atomic_read_unchecked(&stats->tx),atomic_read_unchecked(&stats->tx_err),
+	    atomic_read_unchecked(&stats->rx),atomic_read_unchecked(&stats->rx_err),
+	    atomic_read_unchecked(&stats->rx_drop));
 }
 
 static void atm_dev_info(struct seq_file *seq, const struct atm_dev *dev)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/atm/resources.c linux-2.6.32.60-pax/net/atm/resources.c
--- linux-2.6.32.60/net/atm/resources.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/atm/resources.c	2012-03-13 13:15:35.964097946 +0100
@@ -161,7 +161,7 @@ void atm_dev_deregister(struct atm_dev *
 static void copy_aal_stats(struct k_atm_aal_stats *from,
     struct atm_aal_stats *to)
 {
-#define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)
+#define __HANDLE_ITEM(i) to->i = atomic_read_unchecked(&from->i)
 	__AAL_STAT_ITEMS
 #undef __HANDLE_ITEM
 }
@@ -170,7 +170,7 @@ static void copy_aal_stats(struct k_atm_
 static void subtract_aal_stats(struct k_atm_aal_stats *from,
     struct atm_aal_stats *to)
 {
-#define __HANDLE_ITEM(i) atomic_sub(to->i, &from->i)
+#define __HANDLE_ITEM(i) atomic_sub_unchecked(to->i, &from->i)
 	__AAL_STAT_ITEMS
 #undef __HANDLE_ITEM
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/bluetooth/hci_sock.c linux-2.6.32.60-pax/net/bluetooth/hci_sock.c
--- linux-2.6.32.60/net/bluetooth/hci_sock.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/bluetooth/hci_sock.c	2012-09-20 00:38:16.674660689 +0200
@@ -511,7 +511,7 @@ static int hci_sock_setsockopt(struct so
 			uf.event_mask[1] = *((u32 *) f->event_mask + 1);
 		}
 
-		len = min_t(unsigned int, len, sizeof(uf));
+		len = min((size_t)len, sizeof(uf));
 		if (copy_from_user(&uf, optval, len)) {
 			err = -EFAULT;
 			break;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/bluetooth/rfcomm/sock.c linux-2.6.32.60-pax/net/bluetooth/rfcomm/sock.c
--- linux-2.6.32.60/net/bluetooth/rfcomm/sock.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/bluetooth/rfcomm/sock.c	2012-09-20 00:38:16.678660688 +0200
@@ -792,7 +792,7 @@ static int rfcomm_sock_setsockopt(struct
 
 		sec.level = BT_SECURITY_LOW;
 
-		len = min_t(unsigned int, sizeof(sec), optlen);
+		len = min(sizeof(sec), len);
 		if (copy_from_user((char *) &sec, optval, len)) {
 			err = -EFAULT;
 			break;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/bridge/br_stp_if.c linux-2.6.32.60-pax/net/bridge/br_stp_if.c
--- linux-2.6.32.60/net/bridge/br_stp_if.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/bridge/br_stp_if.c	2012-03-13 13:15:35.968097945 +0100
@@ -146,7 +146,7 @@ static void br_stp_stop(struct net_bridg
 	char *envp[] = { NULL };
 
 	if (br->stp_enabled == BR_USER_STP) {
-		r = call_usermodehelper(BR_STP_PROG, argv, envp, 1);
+		r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);
 		printk(KERN_INFO "%s: userspace STP stopped, return code %d\n",
 			br->dev->name, r);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/can/af_can.c linux-2.6.32.60-pax/net/can/af_can.c
--- linux-2.6.32.60/net/can/af_can.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/can/af_can.c	2013-01-22 17:38:23.596543624 +0100
@@ -849,7 +849,7 @@ static struct net_proto_family can_famil
 };
 
 /* notifier block for netdevice event */
-static struct notifier_block can_netdev_notifier __read_mostly = {
+static struct notifier_block can_netdev_notifier = {
 	.notifier_call = can_notifier,
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/compat.c linux-2.6.32.60-pax/net/compat.c
--- linux-2.6.32.60/net/compat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/compat.c	2012-09-20 01:11:32.866666970 +0200
@@ -69,9 +69,9 @@ int get_compat_msghdr(struct msghdr *kms
 	    __get_user(kmsg->msg_controllen, &umsg->msg_controllen) ||
 	    __get_user(kmsg->msg_flags, &umsg->msg_flags))
 		return -EFAULT;
-	kmsg->msg_name = compat_ptr(tmp1);
-	kmsg->msg_iov = compat_ptr(tmp2);
-	kmsg->msg_control = compat_ptr(tmp3);
+	kmsg->msg_name = (void __force_kernel *)compat_ptr(tmp1);
+	kmsg->msg_iov = (void __force_kernel *)compat_ptr(tmp2);
+	kmsg->msg_control = (void __force_kernel *)compat_ptr(tmp3);
 	return 0;
 }
 
@@ -94,7 +94,7 @@ int verify_compat_iovec(struct msghdr *k
 		kern_msg->msg_name = NULL;
 
 	tot_len = iov_from_user_compat_to_kern(kern_iov,
-					  (struct compat_iovec __user *)kern_msg->msg_iov,
+					  (struct compat_iovec __force_user *)kern_msg->msg_iov,
 					  kern_msg->msg_iovlen);
 	if (tot_len >= 0)
 		kern_msg->msg_iov = kern_iov;
@@ -114,20 +114,20 @@ int verify_compat_iovec(struct msghdr *k
 
 #define CMSG_COMPAT_FIRSTHDR(msg)			\
 	(((msg)->msg_controllen) >= sizeof(struct compat_cmsghdr) ?	\
-	 (struct compat_cmsghdr __user *)((msg)->msg_control) :		\
+	 (struct compat_cmsghdr __force_user *)((msg)->msg_control) :		\
 	 (struct compat_cmsghdr __user *)NULL)
 
 #define CMSG_COMPAT_OK(ucmlen, ucmsg, mhdr) \
 	((ucmlen) >= sizeof(struct compat_cmsghdr) && \
 	 (ucmlen) <= (unsigned long) \
 	 ((mhdr)->msg_controllen - \
-	  ((char *)(ucmsg) - (char *)(mhdr)->msg_control)))
+	  ((char __force_kernel *)(ucmsg) - (char *)(mhdr)->msg_control)))
 
 static inline struct compat_cmsghdr __user *cmsg_compat_nxthdr(struct msghdr *msg,
 		struct compat_cmsghdr __user *cmsg, int cmsg_len)
 {
 	char __user *ptr = (char __user *)cmsg + CMSG_COMPAT_ALIGN(cmsg_len);
-	if ((unsigned long)(ptr + 1 - (char __user *)msg->msg_control) >
+	if ((unsigned long)(ptr + 1 - (char __force_user *)msg->msg_control) >
 			msg->msg_controllen)
 		return NULL;
 	return (struct compat_cmsghdr __user *)ptr;
@@ -219,7 +219,7 @@ int put_cmsg_compat(struct msghdr *kmsg,
 {
 	struct compat_timeval ctv;
 	struct compat_timespec cts[3];
-	struct compat_cmsghdr __user *cm = (struct compat_cmsghdr __user *) kmsg->msg_control;
+	struct compat_cmsghdr __user *cm = (struct compat_cmsghdr __force_user *) kmsg->msg_control;
 	struct compat_cmsghdr cmhdr;
 	int cmlen;
 
@@ -271,7 +271,7 @@ int put_cmsg_compat(struct msghdr *kmsg,
 
 void scm_detach_fds_compat(struct msghdr *kmsg, struct scm_cookie *scm)
 {
-	struct compat_cmsghdr __user *cm = (struct compat_cmsghdr __user *) kmsg->msg_control;
+	struct compat_cmsghdr __user *cm = (struct compat_cmsghdr __force_user *) kmsg->msg_control;
 	int fdmax = (kmsg->msg_controllen - sizeof(struct compat_cmsghdr)) / sizeof(int);
 	int fdnum = scm->fp->count;
 	struct file **fp = scm->fp->fp;
@@ -433,7 +433,7 @@ static int do_get_sock_timeout(struct so
 	len = sizeof(ktime);
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
-	err = sock_getsockopt(sock, level, optname, (char *) &ktime, &len);
+	err = sock_getsockopt(sock, level, optname, (char __force_user *) &ktime, (int __force_user *)&len);
 	set_fs(old_fs);
 
 	if (!err) {
@@ -570,7 +570,7 @@ int compat_mc_setsockopt(struct sock *so
 	case MCAST_JOIN_GROUP:
 	case MCAST_LEAVE_GROUP:
 	{
-		struct compat_group_req __user *gr32 = (void *)optval;
+		struct compat_group_req __user *gr32 = (void __user *)optval;
 		struct group_req __user *kgr =
 			compat_alloc_user_space(sizeof(struct group_req));
 		u32 interface;
@@ -591,7 +591,7 @@ int compat_mc_setsockopt(struct sock *so
 	case MCAST_BLOCK_SOURCE:
 	case MCAST_UNBLOCK_SOURCE:
 	{
-		struct compat_group_source_req __user *gsr32 = (void *)optval;
+		struct compat_group_source_req __user *gsr32 = (void __user *)optval;
 		struct group_source_req __user *kgsr = compat_alloc_user_space(
 			sizeof(struct group_source_req));
 		u32 interface;
@@ -612,7 +612,7 @@ int compat_mc_setsockopt(struct sock *so
 	}
 	case MCAST_MSFILTER:
 	{
-		struct compat_group_filter __user *gf32 = (void *)optval;
+		struct compat_group_filter __user *gf32 = (void __user *)optval;
 		struct group_filter __user *kgf;
 		u32 interface, fmode, numsrc;
 
@@ -765,7 +765,7 @@ asmlinkage long compat_sys_socketcall(in
 
 	if (call < SYS_SOCKET || call > SYS_ACCEPT4)
 		return -EINVAL;
-	if (copy_from_user(a, args, nas[call]))
+	if (nas[call] > sizeof a || copy_from_user(a, args, nas[call]))
 		return -EFAULT;
 	a0 = a[0];
 	a1 = a[1];
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/core/dev.c linux-2.6.32.60-pax/net/core/dev.c
--- linux-2.6.32.60/net/core/dev.c	2012-10-09 11:00:35.500882480 +0200
+++ linux-2.6.32.60-pax/net/core/dev.c	2012-10-09 11:00:39.360883056 +0200
@@ -1655,7 +1655,7 @@ static inline int illegal_highdma(struct
 
 struct dev_gso_cb {
 	void (*destructor)(struct sk_buff *skb);
-};
+} __no_const;
 
 #define DEV_GSO_CB(skb) ((struct dev_gso_cb *)(skb)->cb)
 
@@ -2064,7 +2064,7 @@ int netif_rx_ni(struct sk_buff *skb)
 }
 EXPORT_SYMBOL(netif_rx_ni);
 
-static void net_tx_action(struct softirq_action *h)
+static void net_tx_action(void)
 {
 	struct softnet_data *sd = &__get_cpu_var(softnet_data);
 
@@ -2828,7 +2828,7 @@ void netif_napi_del(struct napi_struct *
 EXPORT_SYMBOL(netif_napi_del);
 
 
-static void net_rx_action(struct softirq_action *h)
+static void net_rx_action(void)
 {
 	struct list_head *list = &__get_cpu_var(softnet_data).poll_list;
 	unsigned long time_limit = jiffies + 2;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/core/flow.c linux-2.6.32.60-pax/net/core/flow.c
--- linux-2.6.32.60/net/core/flow.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/core/flow.c	2012-03-13 13:15:35.972097945 +0100
@@ -35,11 +35,11 @@ struct flow_cache_entry {
 	atomic_t		*object_ref;
 };
 
-atomic_t flow_cache_genid = ATOMIC_INIT(0);
+atomic_unchecked_t flow_cache_genid = ATOMIC_INIT(0);
 
 static u32 flow_hash_shift;
 #define flow_hash_size	(1 << flow_hash_shift)
-static DEFINE_PER_CPU(struct flow_cache_entry **, flow_tables) = { NULL };
+static DEFINE_PER_CPU(struct flow_cache_entry **, flow_tables);
 
 #define flow_table(cpu) (per_cpu(flow_tables, cpu))
 
@@ -52,7 +52,7 @@ struct flow_percpu_info {
 	u32 hash_rnd;
 	int count;
 };
-static DEFINE_PER_CPU(struct flow_percpu_info, flow_hash_info) = { 0 };
+static DEFINE_PER_CPU(struct flow_percpu_info, flow_hash_info);
 
 #define flow_hash_rnd_recalc(cpu) \
 	(per_cpu(flow_hash_info, cpu).hash_rnd_recalc)
@@ -69,7 +69,7 @@ struct flow_flush_info {
 	atomic_t cpuleft;
 	struct completion completion;
 };
-static DEFINE_PER_CPU(struct tasklet_struct, flow_flush_tasklets) = { NULL };
+static DEFINE_PER_CPU(struct tasklet_struct, flow_flush_tasklets);
 
 #define flow_flush_tasklet(cpu) (&per_cpu(flow_flush_tasklets, cpu))
 
@@ -190,7 +190,7 @@ void *flow_cache_lookup(struct net *net,
 		if (fle->family == family &&
 		    fle->dir == dir &&
 		    flow_key_compare(key, &fle->key) == 0) {
-			if (fle->genid == atomic_read(&flow_cache_genid)) {
+			if (fle->genid == atomic_read_unchecked(&flow_cache_genid)) {
 				void *ret = fle->object;
 
 				if (ret)
@@ -228,7 +228,7 @@ nocache:
 		err = resolver(net, key, family, dir, &obj, &obj_ref);
 
 		if (fle && !err) {
-			fle->genid = atomic_read(&flow_cache_genid);
+			fle->genid = atomic_read_unchecked(&flow_cache_genid);
 
 			if (fle->object)
 				atomic_dec(fle->object_ref);
@@ -258,7 +258,7 @@ static void flow_cache_flush_tasklet(uns
 
 		fle = flow_table(cpu)[i];
 		for (; fle; fle = fle->next) {
-			unsigned genid = atomic_read(&flow_cache_genid);
+			unsigned genid = atomic_read_unchecked(&flow_cache_genid);
 
 			if (!fle->object || fle->genid == genid)
 				continue;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/core/rtnetlink.c linux-2.6.32.60-pax/net/core/rtnetlink.c
--- linux-2.6.32.60/net/core/rtnetlink.c	2012-10-09 11:00:35.504882482 +0200
+++ linux-2.6.32.60-pax/net/core/rtnetlink.c	2013-02-17 19:41:04.891704182 +0100
@@ -57,7 +57,7 @@ struct rtnl_link
 {
 	rtnl_doit_func		doit;
 	rtnl_dumpit_func	dumpit;
-};
+} __no_const;
 
 static DEFINE_MUTEX(rtnl_mutex);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/core/scm.c linux-2.6.32.60-pax/net/core/scm.c
--- linux-2.6.32.60/net/core/scm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/core/scm.c	2012-03-13 13:15:35.972097945 +0100
@@ -191,7 +191,7 @@ error:
 int put_cmsg(struct msghdr * msg, int level, int type, int len, void *data)
 {
 	struct cmsghdr __user *cm
-		= (__force struct cmsghdr __user *)msg->msg_control;
+		= (struct cmsghdr __force_user *)msg->msg_control;
 	struct cmsghdr cmhdr;
 	int cmlen = CMSG_LEN(len);
 	int err;
@@ -214,7 +214,7 @@ int put_cmsg(struct msghdr * msg, int le
 	err = -EFAULT;
 	if (copy_to_user(cm, &cmhdr, sizeof cmhdr))
 		goto out;
-	if (copy_to_user(CMSG_DATA(cm), data, cmlen - sizeof(struct cmsghdr)))
+	if (copy_to_user((void __force_user *)CMSG_DATA((void __force_kernel *)cm), data, cmlen - sizeof(struct cmsghdr)))
 		goto out;
 	cmlen = CMSG_SPACE(len);
 	if (msg->msg_controllen < cmlen)
@@ -229,7 +229,7 @@ out:
 void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)
 {
 	struct cmsghdr __user *cm
-		= (__force struct cmsghdr __user*)msg->msg_control;
+		= (struct cmsghdr __force_user *)msg->msg_control;
 
 	int fdmax = 0;
 	int fdnum = scm->fp->count;
@@ -249,7 +249,7 @@ void scm_detach_fds(struct msghdr *msg,
 	if (fdnum < fdmax)
 		fdmax = fdnum;
 
-	for (i=0, cmfptr=(__force int __user *)CMSG_DATA(cm); i<fdmax;
+	for (i=0, cmfptr=(int __force_user *)CMSG_DATA((void __force_kernel *)cm); i<fdmax;
 	     i++, cmfptr++)
 	{
 		int new_fd;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/core/sock.c linux-2.6.32.60-pax/net/core/sock.c
--- linux-2.6.32.60/net/core/sock.c	2012-10-09 11:00:35.504882482 +0200
+++ linux-2.6.32.60-pax/net/core/sock.c	2012-10-09 11:00:39.360883056 +0200
@@ -864,11 +864,15 @@ int sock_getsockopt(struct socket *sock,
 		break;
 
 	case SO_PEERCRED:
+	{
+		struct ucred peercred;
 		if (len > sizeof(sk->sk_peercred))
 			len = sizeof(sk->sk_peercred);
-		if (copy_to_user(optval, &sk->sk_peercred, len))
+		peercred = sk->sk_peercred;
+		if (copy_to_user(optval, &peercred, len))
 			return -EFAULT;
 		goto lenout;
+	}
 
 	case SO_PEERNAME:
 	{
@@ -1895,7 +1899,7 @@ void sock_init_data(struct socket *sock,
 	 */
 	smp_wmb();
 	atomic_set(&sk->sk_refcnt, 1);
-	atomic_set(&sk->sk_drops, 0);
+	atomic_set_unchecked(&sk->sk_drops, 0);
 }
 EXPORT_SYMBOL(sock_init_data);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/decnet/sysctl_net_decnet.c linux-2.6.32.60-pax/net/decnet/sysctl_net_decnet.c
--- linux-2.6.32.60/net/decnet/sysctl_net_decnet.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/decnet/sysctl_net_decnet.c	2012-03-13 13:15:35.976097945 +0100
@@ -206,7 +206,7 @@ static int dn_node_address_handler(ctl_t
 
 	if (len > *lenp) len = *lenp;
 
-	if (copy_to_user(buffer, addr, len))
+	if (len > sizeof addr || copy_to_user(buffer, addr, len))
 		return -EFAULT;
 
 	*lenp = len;
@@ -327,7 +327,7 @@ static int dn_def_dev_handler(ctl_table
 
 	if (len > *lenp) len = *lenp;
 
-	if (copy_to_user(buffer, devname, len))
+	if (len > sizeof devname || copy_to_user(buffer, devname, len))
 		return -EFAULT;
 
 	*lenp = len;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ieee802154/dgram.c linux-2.6.32.60-pax/net/ieee802154/dgram.c
--- linux-2.6.32.60/net/ieee802154/dgram.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ieee802154/dgram.c	2012-03-13 13:15:35.976097945 +0100
@@ -318,7 +318,7 @@ out:
 static int dgram_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	if (sock_queue_rcv_skb(sk, skb) < 0) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ieee802154/raw.c linux-2.6.32.60-pax/net/ieee802154/raw.c
--- linux-2.6.32.60/net/ieee802154/raw.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ieee802154/raw.c	2012-03-13 13:15:35.976097945 +0100
@@ -206,7 +206,7 @@ out:
 static int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	if (sock_queue_rcv_skb(sk, skb) < 0) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/inetpeer.c linux-2.6.32.60-pax/net/ipv4/inetpeer.c
--- linux-2.6.32.60/net/ipv4/inetpeer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/inetpeer.c	2012-03-13 13:15:35.976097945 +0100
@@ -390,7 +390,7 @@ struct inet_peer *inet_getpeer(__be32 da
 		return NULL;
 	n->v4daddr = daddr;
 	atomic_set(&n->refcnt, 1);
-	atomic_set(&n->rid, 0);
+	atomic_set_unchecked(&n->rid, 0);
 	n->ip_id_count = secure_ip_id(daddr);
 	n->tcp_ts_stamp = 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/ipconfig.c linux-2.6.32.60-pax/net/ipv4/ipconfig.c
--- linux-2.6.32.60/net/ipv4/ipconfig.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/ipconfig.c	2012-03-13 13:15:35.980097945 +0100
@@ -295,7 +295,7 @@ static int __init ic_devinet_ioctl(unsig
 
 	mm_segment_t oldfs = get_fs();
 	set_fs(get_ds());
-	res = devinet_ioctl(&init_net, cmd, (struct ifreq __user *) arg);
+	res = devinet_ioctl(&init_net, cmd, (struct ifreq __force_user *) arg);
 	set_fs(oldfs);
 	return res;
 }
@@ -306,7 +306,7 @@ static int __init ic_dev_ioctl(unsigned
 
 	mm_segment_t oldfs = get_fs();
 	set_fs(get_ds());
-	res = dev_ioctl(&init_net, cmd, (struct ifreq __user *) arg);
+	res = dev_ioctl(&init_net, cmd, (struct ifreq __force_user *) arg);
 	set_fs(oldfs);
 	return res;
 }
@@ -317,7 +317,7 @@ static int __init ic_route_ioctl(unsigne
 
 	mm_segment_t oldfs = get_fs();
 	set_fs(get_ds());
-	res = ip_rt_ioctl(&init_net, cmd, (void __user *) arg);
+	res = ip_rt_ioctl(&init_net, cmd, (void __force_user *) arg);
 	set_fs(oldfs);
 	return res;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/ip_fragment.c linux-2.6.32.60-pax/net/ipv4/ip_fragment.c
--- linux-2.6.32.60/net/ipv4/ip_fragment.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/ip_fragment.c	2012-03-13 13:15:35.980097945 +0100
@@ -255,7 +255,7 @@ static inline int ip_frag_too_far(struct
 		return 0;
 
 	start = qp->rid;
-	end = atomic_inc_return(&peer->rid);
+	end = atomic_inc_return_unchecked(&peer->rid);
 	qp->rid = end;
 
 	rc = qp->q.fragments && (end - start) > max;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/ip_sockglue.c linux-2.6.32.60-pax/net/ipv4/ip_sockglue.c
--- linux-2.6.32.60/net/ipv4/ip_sockglue.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/ip_sockglue.c	2012-03-13 13:15:35.980097945 +0100
@@ -1173,7 +1173,7 @@ static int do_ip_getsockopt(struct sock
 		if (sk->sk_type != SOCK_STREAM)
 			return -ENOPROTOOPT;
 
-		msg.msg_control = optval;
+		msg.msg_control = (void __force_kernel *)optval;
 		msg.msg_controllen = len;
 		msg.msg_flags = 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/netfilter/arp_tables.c linux-2.6.32.60-pax/net/ipv4/netfilter/arp_tables.c
--- linux-2.6.32.60/net/ipv4/netfilter/arp_tables.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/netfilter/arp_tables.c	2012-09-21 21:19:13.434698125 +0200
@@ -900,14 +900,14 @@ static int compat_table_info(const struc
 }
 #endif
 
-static int get_info(struct net *net, void __user *user, int *len, int compat)
+static int get_info(struct net *net, void __user *user, int len, int compat)
 {
 	char name[ARPT_TABLE_MAXNAMELEN];
 	struct xt_table *t;
 	int ret;
 
-	if (*len != sizeof(struct arpt_getinfo)) {
-		duprintf("length %u != %Zu\n", *len,
+	if (len != sizeof(struct arpt_getinfo)) {
+		duprintf("length %u != %Zu\n", len,
 			 sizeof(struct arpt_getinfo));
 		return -EINVAL;
 	}
@@ -943,7 +943,7 @@ static int get_info(struct net *net, voi
 		info.size = private->size;
 		strcpy(info.name, name);
 
-		if (copy_to_user(user, &info, *len) != 0)
+		if (copy_to_user(user, &info, len) != 0)
 			ret = -EFAULT;
 		else
 			ret = 0;
@@ -1702,7 +1702,7 @@ static int compat_do_arpt_get_ctl(struct
 
 	switch (cmd) {
 	case ARPT_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 1);
+		ret = get_info(sock_net(sk), user, *len, 1);
 		break;
 	case ARPT_SO_GET_ENTRIES:
 		ret = compat_get_entries(sock_net(sk), user, len);
@@ -1747,7 +1747,7 @@ static int do_arpt_get_ctl(struct sock *
 
 	switch (cmd) {
 	case ARPT_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 0);
+		ret = get_info(sock_net(sk), user, *len, 0);
 		break;
 
 	case ARPT_SO_GET_ENTRIES:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/netfilter/ip_tables.c linux-2.6.32.60-pax/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.32.60/net/ipv4/netfilter/ip_tables.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/netfilter/ip_tables.c	2012-09-21 21:19:33.270698146 +0200
@@ -1107,14 +1107,14 @@ static int compat_table_info(const struc
 }
 #endif
 
-static int get_info(struct net *net, void __user *user, int *len, int compat)
+static int get_info(struct net *net, void __user *user, int len, int compat)
 {
 	char name[IPT_TABLE_MAXNAMELEN];
 	struct xt_table *t;
 	int ret;
 
-	if (*len != sizeof(struct ipt_getinfo)) {
-		duprintf("length %u != %zu\n", *len,
+	if (len != sizeof(struct ipt_getinfo)) {
+		duprintf("length %u != %zu\n", len,
 			 sizeof(struct ipt_getinfo));
 		return -EINVAL;
 	}
@@ -1150,7 +1150,7 @@ static int get_info(struct net *net, voi
 		info.size = private->size;
 		strcpy(info.name, name);
 
-		if (copy_to_user(user, &info, *len) != 0)
+		if (copy_to_user(user, &info, len) != 0)
 			ret = -EFAULT;
 		else
 			ret = 0;
@@ -1979,7 +1979,7 @@ compat_do_ipt_get_ctl(struct sock *sk, i
 
 	switch (cmd) {
 	case IPT_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 1);
+		ret = get_info(sock_net(sk), user, *len, 1);
 		break;
 	case IPT_SO_GET_ENTRIES:
 		ret = compat_get_entries(sock_net(sk), user, len);
@@ -2026,7 +2026,7 @@ do_ipt_get_ctl(struct sock *sk, int cmd,
 
 	switch (cmd) {
 	case IPT_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 0);
+		ret = get_info(sock_net(sk), user, *len, 0);
 		break;
 
 	case IPT_SO_GET_ENTRIES:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/raw.c linux-2.6.32.60-pax/net/ipv4/raw.c
--- linux-2.6.32.60/net/ipv4/raw.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/raw.c	2012-03-13 13:15:35.984097945 +0100
@@ -292,7 +292,7 @@ static int raw_rcv_skb(struct sock * sk,
 	/* Charge it to the socket. */
 
 	if (sock_queue_rcv_skb(sk, skb) < 0) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
@@ -303,7 +303,7 @@ static int raw_rcv_skb(struct sock * sk,
 int raw_rcv(struct sock *sk, struct sk_buff *skb)
 {
 	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
@@ -724,16 +724,20 @@ static int raw_init(struct sock *sk)
 
 static int raw_seticmpfilter(struct sock *sk, char __user *optval, int optlen)
 {
+	struct icmp_filter filter;
+
 	if (optlen > sizeof(struct icmp_filter))
 		optlen = sizeof(struct icmp_filter);
-	if (copy_from_user(&raw_sk(sk)->filter, optval, optlen))
+	if (copy_from_user(&filter, optval, optlen))
 		return -EFAULT;
+	raw_sk(sk)->filter = filter;
 	return 0;
 }
 
 static int raw_geticmpfilter(struct sock *sk, char __user *optval, int __user *optlen)
 {
 	int len, ret = -EFAULT;
+	struct icmp_filter filter;
 
 	if (get_user(len, optlen))
 		goto out;
@@ -743,8 +747,8 @@ static int raw_geticmpfilter(struct sock
 	if (len > sizeof(struct icmp_filter))
 		len = sizeof(struct icmp_filter);
 	ret = -EFAULT;
-	if (put_user(len, optlen) ||
-	    copy_to_user(optval, &raw_sk(sk)->filter, len))
+	filter = raw_sk(sk)->filter;
+	if (put_user(len, optlen) || len > sizeof filter || copy_to_user(optval, &filter, len))
 		goto out;
 	ret = 0;
 out:	return ret;
@@ -954,7 +958,7 @@ static void raw_sock_seq_show(struct seq
 		sk_wmem_alloc_get(sp),
 		sk_rmem_alloc_get(sp),
 		0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
-		atomic_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));
+		atomic_read(&sp->sk_refcnt), sp, atomic_read_unchecked(&sp->sk_drops));
 }
 
 static int raw_seq_show(struct seq_file *seq, void *v)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/route.c linux-2.6.32.60-pax/net/ipv4/route.c
--- linux-2.6.32.60/net/ipv4/route.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/route.c	2012-03-13 13:15:35.984097945 +0100
@@ -269,7 +269,7 @@ static inline unsigned int rt_hash(__be3
 
 static inline int rt_genid(struct net *net)
 {
-	return atomic_read(&net->ipv4.rt_genid);
+	return atomic_read_unchecked(&net->ipv4.rt_genid);
 }
 
 #ifdef CONFIG_PROC_FS
@@ -889,7 +889,7 @@ static void rt_cache_invalidate(struct n
 	unsigned char shuffle;
 
 	get_random_bytes(&shuffle, sizeof(shuffle));
-	atomic_add(shuffle + 1U, &net->ipv4.rt_genid);
+	atomic_add_unchecked(shuffle + 1U, &net->ipv4.rt_genid);
 }
 
 /*
@@ -3357,7 +3357,7 @@ static __net_initdata struct pernet_oper
 
 static __net_init int rt_secret_timer_init(struct net *net)
 {
-	atomic_set(&net->ipv4.rt_genid,
+	atomic_set_unchecked(&net->ipv4.rt_genid,
 			(int) ((num_physpages ^ (num_physpages>>8)) ^
 			(jiffies ^ (jiffies >> 7))));
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/tcp_input.c linux-2.6.32.60-pax/net/ipv4/tcp_input.c
--- linux-2.6.32.60/net/ipv4/tcp_input.c	2012-10-09 11:00:35.508882483 +0200
+++ linux-2.6.32.60-pax/net/ipv4/tcp_input.c	2012-10-09 11:00:39.364883057 +0200
@@ -4528,7 +4528,7 @@ static struct sk_buff *tcp_collapse_one(
  * simplifies code)
  */
 static void
-tcp_collapse(struct sock *sk, struct sk_buff_head *list,
+__intentional_overflow(5,6) tcp_collapse(struct sock *sk, struct sk_buff_head *list,
 	     struct sk_buff *head, struct sk_buff *tail,
 	     u32 start, u32 end)
 {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/tcp_probe.c linux-2.6.32.60-pax/net/ipv4/tcp_probe.c
--- linux-2.6.32.60/net/ipv4/tcp_probe.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/tcp_probe.c	2012-03-13 13:15:35.984097945 +0100
@@ -200,7 +200,7 @@ static ssize_t tcpprobe_read(struct file
 		if (cnt + width >= len)
 			break;
 
-		if (copy_to_user(buf + cnt, tbuf, width))
+		if (width > sizeof tbuf || copy_to_user(buf + cnt, tbuf, width))
 			return -EFAULT;
 		cnt += width;
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv4/udp.c linux-2.6.32.60-pax/net/ipv4/udp.c
--- linux-2.6.32.60/net/ipv4/udp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv4/udp.c	2012-03-13 13:15:35.988097944 +0100
@@ -1068,7 +1068,7 @@ static int __udp_queue_rcv_skb(struct so
 		if (rc == -ENOMEM) {
 			UDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,
 					 is_udplite);
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 		}
 		goto drop;
 	}
@@ -1759,7 +1759,7 @@ static void udp4_format_sock(struct sock
 		sk_rmem_alloc_get(sp),
 		0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
 		atomic_read(&sp->sk_refcnt), sp,
-		atomic_read(&sp->sk_drops), len);
+		atomic_read_unchecked(&sp->sk_drops), len);
 }
 
 int udp4_seq_show(struct seq_file *seq, void *v)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/addrconf.c linux-2.6.32.60-pax/net/ipv6/addrconf.c
--- linux-2.6.32.60/net/ipv6/addrconf.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/addrconf.c	2012-03-13 13:15:35.988097944 +0100
@@ -2053,7 +2053,7 @@ int addrconf_set_dstaddr(struct net *net
 		p.iph.ihl = 5;
 		p.iph.protocol = IPPROTO_IPV6;
 		p.iph.ttl = 64;
-		ifr.ifr_ifru.ifru_data = (__force void __user *)&p;
+		ifr.ifr_ifru.ifru_data = (void __force_user *)&p;
 
 		if (ops->ndo_do_ioctl) {
 			mm_segment_t oldfs = get_fs();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/inet6_connection_sock.c linux-2.6.32.60-pax/net/ipv6/inet6_connection_sock.c
--- linux-2.6.32.60/net/ipv6/inet6_connection_sock.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/inet6_connection_sock.c	2012-03-13 13:15:35.988097944 +0100
@@ -152,7 +152,7 @@ void __inet6_csk_dst_store(struct sock *
 #ifdef CONFIG_XFRM
 	{
 		struct rt6_info *rt = (struct rt6_info  *)dst;
-		rt->rt6i_flow_cache_genid = atomic_read(&flow_cache_genid);
+		rt->rt6i_flow_cache_genid = atomic_read_unchecked(&flow_cache_genid);
 	}
 #endif
 }
@@ -167,7 +167,7 @@ struct dst_entry *__inet6_csk_dst_check(
 #ifdef CONFIG_XFRM
 	if (dst) {
 		struct rt6_info *rt = (struct rt6_info *)dst;
-		if (rt->rt6i_flow_cache_genid != atomic_read(&flow_cache_genid)) {
+		if (rt->rt6i_flow_cache_genid != atomic_read_unchecked(&flow_cache_genid)) {
 			sk->sk_dst_cache = NULL;
 			dst_release(dst);
 			dst = NULL;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/inet6_hashtables.c linux-2.6.32.60-pax/net/ipv6/inet6_hashtables.c
--- linux-2.6.32.60/net/ipv6/inet6_hashtables.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/inet6_hashtables.c	2012-03-13 13:15:35.992097944 +0100
@@ -119,7 +119,7 @@ out:
 }
 EXPORT_SYMBOL(__inet6_lookup_established);
 
-static int inline compute_score(struct sock *sk, struct net *net,
+static inline int compute_score(struct sock *sk, struct net *net,
 				const unsigned short hnum,
 				const struct in6_addr *daddr,
 				const int dif)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/ipv6_sockglue.c linux-2.6.32.60-pax/net/ipv6/ipv6_sockglue.c
--- linux-2.6.32.60/net/ipv6/ipv6_sockglue.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/ipv6_sockglue.c	2012-03-13 13:15:35.992097944 +0100
@@ -922,7 +922,7 @@ static int do_ipv6_getsockopt(struct soc
 		if (sk->sk_type != SOCK_STREAM)
 			return -ENOPROTOOPT;
 
-		msg.msg_control = optval;
+		msg.msg_control = (void __force_kernel *)optval;
 		msg.msg_controllen = len;
 		msg.msg_flags = 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/netfilter/ip6_tables.c linux-2.6.32.60-pax/net/ipv6/netfilter/ip6_tables.c
--- linux-2.6.32.60/net/ipv6/netfilter/ip6_tables.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/netfilter/ip6_tables.c	2012-09-21 21:19:44.206697586 +0200
@@ -1139,14 +1139,14 @@ static int compat_table_info(const struc
 }
 #endif
 
-static int get_info(struct net *net, void __user *user, int *len, int compat)
+static int get_info(struct net *net, void __user *user, int len, int compat)
 {
 	char name[IP6T_TABLE_MAXNAMELEN];
 	struct xt_table *t;
 	int ret;
 
-	if (*len != sizeof(struct ip6t_getinfo)) {
-		duprintf("length %u != %zu\n", *len,
+	if (len != sizeof(struct ip6t_getinfo)) {
+		duprintf("length %u != %zu\n", len,
 			 sizeof(struct ip6t_getinfo));
 		return -EINVAL;
 	}
@@ -1182,7 +1182,7 @@ static int get_info(struct net *net, voi
 		info.size = private->size;
 		strcpy(info.name, name);
 
-		if (copy_to_user(user, &info, *len) != 0)
+		if (copy_to_user(user, &info, len) != 0)
 			ret = -EFAULT;
 		else
 			ret = 0;
@@ -2014,7 +2014,7 @@ compat_do_ip6t_get_ctl(struct sock *sk,
 
 	switch (cmd) {
 	case IP6T_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 1);
+		ret = get_info(sock_net(sk), user, *len, 1);
 		break;
 	case IP6T_SO_GET_ENTRIES:
 		ret = compat_get_entries(sock_net(sk), user, len);
@@ -2061,7 +2061,7 @@ do_ip6t_get_ctl(struct sock *sk, int cmd
 
 	switch (cmd) {
 	case IP6T_SO_GET_INFO:
-		ret = get_info(sock_net(sk), user, len, 0);
+		ret = get_info(sock_net(sk), user, *len, 0);
 		break;
 
 	case IP6T_SO_GET_ENTRIES:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/raw.c linux-2.6.32.60-pax/net/ipv6/raw.c
--- linux-2.6.32.60/net/ipv6/raw.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/raw.c	2012-03-13 13:15:35.992097944 +0100
@@ -375,14 +375,14 @@ static inline int rawv6_rcv_skb(struct s
 {
 	if ((raw6_sk(sk)->checksum || sk->sk_filter) &&
 	    skb_checksum_complete(skb)) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
 
 	/* Charge it to the socket. */
 	if (sock_queue_rcv_skb(sk,skb)<0) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
@@ -403,7 +403,7 @@ int rawv6_rcv(struct sock *sk, struct sk
 	struct raw6_sock *rp = raw6_sk(sk);
 
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {
-		atomic_inc(&sk->sk_drops);
+		atomic_inc_unchecked(&sk->sk_drops);
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
@@ -427,7 +427,7 @@ int rawv6_rcv(struct sock *sk, struct sk
 
 	if (inet->hdrincl) {
 		if (skb_checksum_complete(skb)) {
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 			kfree_skb(skb);
 			return NET_RX_DROP;
 		}
@@ -518,7 +518,7 @@ csum_copy_err:
 	   as some normal condition.
 	 */
 	err = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;
-	atomic_inc(&sk->sk_drops);
+	atomic_inc_unchecked(&sk->sk_drops);
 	goto out;
 }
 
@@ -600,7 +600,7 @@ out:
 	return err;
 }
 
-static int rawv6_send_hdrinc(struct sock *sk, void *from, int length,
+static int rawv6_send_hdrinc(struct sock *sk, void *from, unsigned int length,
 			struct flowi *fl, struct rt6_info *rt,
 			unsigned int flags)
 {
@@ -916,12 +916,15 @@ do_confirm:
 static int rawv6_seticmpfilter(struct sock *sk, int level, int optname,
 			       char __user *optval, int optlen)
 {
+	struct icmp6_filter filter;
+
 	switch (optname) {
 	case ICMPV6_FILTER:
 		if (optlen > sizeof(struct icmp6_filter))
 			optlen = sizeof(struct icmp6_filter);
-		if (copy_from_user(&raw6_sk(sk)->filter, optval, optlen))
+		if (copy_from_user(&filter, optval, optlen))
 			return -EFAULT;
+		raw6_sk(sk)->filter = filter;
 		return 0;
 	default:
 		return -ENOPROTOOPT;
@@ -934,6 +937,7 @@ static int rawv6_geticmpfilter(struct so
 			       char __user *optval, int __user *optlen)
 {
 	int len;
+	struct icmp6_filter filter;
 
 	switch (optname) {
 	case ICMPV6_FILTER:
@@ -945,7 +949,8 @@ static int rawv6_geticmpfilter(struct so
 			len = sizeof(struct icmp6_filter);
 		if (put_user(len, optlen))
 			return -EFAULT;
-		if (copy_to_user(optval, &raw6_sk(sk)->filter, len))
+		filter = raw6_sk(sk)->filter;
+		if (len > sizeof filter || copy_to_user(optval, &filter, len))
 			return -EFAULT;
 		return 0;
 	default:
@@ -1241,7 +1246,7 @@ static void raw6_sock_seq_show(struct se
 		   0, 0L, 0,
 		   sock_i_uid(sp), 0,
 		   sock_i_ino(sp),
-		   atomic_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));
+		   atomic_read(&sp->sk_refcnt), sp, atomic_read_unchecked(&sp->sk_drops));
 }
 
 static int raw6_seq_show(struct seq_file *seq, void *v)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/udp.c linux-2.6.32.60-pax/net/ipv6/udp.c
--- linux-2.6.32.60/net/ipv6/udp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/udp.c	2012-03-13 13:15:35.992097944 +0100
@@ -391,7 +391,7 @@ int udpv6_queue_rcv_skb(struct sock * sk
 		if (rc == -ENOMEM) {
 			UDP6_INC_STATS_BH(sock_net(sk),
 					UDP_MIB_RCVBUFERRORS, is_udplite);
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 		}
 		goto drop;
 	}
@@ -1210,7 +1210,7 @@ static void udp6_sock_seq_show(struct se
 		   sock_i_uid(sp), 0,
 		   sock_i_ino(sp),
 		   atomic_read(&sp->sk_refcnt), sp,
-		   atomic_read(&sp->sk_drops));
+		   atomic_read_unchecked(&sp->sk_drops));
 }
 
 int udp6_seq_show(struct seq_file *seq, void *v)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/ipv6/xfrm6_tunnel.c linux-2.6.32.60-pax/net/ipv6/xfrm6_tunnel.c
--- linux-2.6.32.60/net/ipv6/xfrm6_tunnel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/ipv6/xfrm6_tunnel.c	2012-03-13 13:27:34.504059581 +0100
@@ -258,7 +258,7 @@ static int xfrm6_tunnel_rcv(struct sk_bu
 	__be32 spi;
 
 	spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);
-	return xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi) > 0 ? : 0;
+	return xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi);
 }
 
 static int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/irda/ircomm/ircomm_tty.c linux-2.6.32.60-pax/net/irda/ircomm/ircomm_tty.c
--- linux-2.6.32.60/net/irda/ircomm/ircomm_tty.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/irda/ircomm/ircomm_tty.c	2012-03-13 13:15:35.996097944 +0100
@@ -280,16 +280,16 @@ static int ircomm_tty_block_til_ready(st
 	add_wait_queue(&self->open_wait, &wait);
 
 	IRDA_DEBUG(2, "%s(%d):block_til_ready before block on %s open_count=%d\n",
-	      __FILE__,__LINE__, tty->driver->name, self->open_count );
+	      __FILE__,__LINE__, tty->driver->name, local_read(&self->open_count) );
 
 	/* As far as I can see, we protect open_count - Jean II */
 	spin_lock_irqsave(&self->spinlock, flags);
 	if (!tty_hung_up_p(filp)) {
 		extra_count = 1;
-		self->open_count--;
+		local_dec(&self->open_count);
 	}
 	spin_unlock_irqrestore(&self->spinlock, flags);
-	self->blocked_open++;
+	local_inc(&self->blocked_open);
 
 	while (1) {
 		if (tty->termios->c_cflag & CBAUD) {
@@ -329,7 +329,7 @@ static int ircomm_tty_block_til_ready(st
 		}
 
 		IRDA_DEBUG(1, "%s(%d):block_til_ready blocking on %s open_count=%d\n",
-		      __FILE__,__LINE__, tty->driver->name, self->open_count );
+		      __FILE__,__LINE__, tty->driver->name, local_read(&self->open_count) );
 
 		schedule();
 	}
@@ -340,13 +340,13 @@ static int ircomm_tty_block_til_ready(st
 	if (extra_count) {
 		/* ++ is not atomic, so this should be protected - Jean II */
 		spin_lock_irqsave(&self->spinlock, flags);
-		self->open_count++;
+		local_inc(&self->open_count);
 		spin_unlock_irqrestore(&self->spinlock, flags);
 	}
-	self->blocked_open--;
+	local_dec(&self->blocked_open);
 
 	IRDA_DEBUG(1, "%s(%d):block_til_ready after blocking on %s open_count=%d\n",
-	      __FILE__,__LINE__, tty->driver->name, self->open_count);
+	      __FILE__,__LINE__, tty->driver->name, local_read(&self->open_count));
 
 	if (!retval)
 		self->flags |= ASYNC_NORMAL_ACTIVE;
@@ -415,14 +415,14 @@ static int ircomm_tty_open(struct tty_st
 	}
 	/* ++ is not atomic, so this should be protected - Jean II */
 	spin_lock_irqsave(&self->spinlock, flags);
-	self->open_count++;
+	local_inc(&self->open_count);
 
 	tty->driver_data = self;
 	self->tty = tty;
 	spin_unlock_irqrestore(&self->spinlock, flags);
 
 	IRDA_DEBUG(1, "%s(), %s%d, count = %d\n", __func__ , tty->driver->name,
-		   self->line, self->open_count);
+		   self->line, local_read(&self->open_count));
 
 	/* Not really used by us, but lets do it anyway */
 	self->tty->low_latency = (self->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
@@ -511,7 +511,7 @@ static void ircomm_tty_close(struct tty_
 		return;
 	}
 
-	if ((tty->count == 1) && (self->open_count != 1)) {
+	if ((tty->count == 1) && (local_read(&self->open_count) != 1)) {
 		/*
 		 * Uh, oh.  tty->count is 1, which means that the tty
 		 * structure will be freed.  state->count should always
@@ -521,16 +521,16 @@ static void ircomm_tty_close(struct tty_
 		 */
 		IRDA_DEBUG(0, "%s(), bad serial port count; "
 			   "tty->count is 1, state->count is %d\n", __func__ ,
-			   self->open_count);
-		self->open_count = 1;
+			   local_read(&self->open_count));
+		local_set(&self->open_count, 1);
 	}
 
-	if (--self->open_count < 0) {
+	if (local_dec_return(&self->open_count) < 0) {
 		IRDA_ERROR("%s(), bad serial port count for ttys%d: %d\n",
-			   __func__, self->line, self->open_count);
-		self->open_count = 0;
+			   __func__, self->line, local_read(&self->open_count));
+		local_set(&self->open_count, 0);
 	}
-	if (self->open_count) {
+	if (local_read(&self->open_count)) {
 		spin_unlock_irqrestore(&self->spinlock, flags);
 
 		IRDA_DEBUG(0, "%s(), open count > 0\n", __func__ );
@@ -562,7 +562,7 @@ static void ircomm_tty_close(struct tty_
 	tty->closing = 0;
 	self->tty = NULL;
 
-	if (self->blocked_open) {
+	if (local_read(&self->blocked_open)) {
 		if (self->close_delay)
 			schedule_timeout_interruptible(self->close_delay);
 		wake_up_interruptible(&self->open_wait);
@@ -1017,7 +1017,7 @@ static void ircomm_tty_hangup(struct tty
 	spin_lock_irqsave(&self->spinlock, flags);
 	self->flags &= ~ASYNC_NORMAL_ACTIVE;
 	self->tty = NULL;
-	self->open_count = 0;
+	local_set(&self->open_count, 0);
 	spin_unlock_irqrestore(&self->spinlock, flags);
 
 	wake_up_interruptible(&self->open_wait);
@@ -1369,7 +1369,7 @@ static void ircomm_tty_line_info(struct
 	seq_putc(m, '\n');
 
 	seq_printf(m, "Role: %s\n", self->client ? "client" : "server");
-	seq_printf(m, "Open count: %d\n", self->open_count);
+	seq_printf(m, "Open count: %d\n", local_read(&self->open_count));
 	seq_printf(m, "Max data size: %d\n", self->max_data_size);
 	seq_printf(m, "Max header size: %d\n", self->max_header_size);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/iucv/af_iucv.c linux-2.6.32.60-pax/net/iucv/af_iucv.c
--- linux-2.6.32.60/net/iucv/af_iucv.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/iucv/af_iucv.c	2012-03-13 13:15:35.996097944 +0100
@@ -651,10 +651,10 @@ static int iucv_sock_autobind(struct soc
 
 	write_lock_bh(&iucv_sk_list.lock);
 
-	sprintf(name, "%08x", atomic_inc_return(&iucv_sk_list.autobind_name));
+	sprintf(name, "%08x", atomic_inc_return_unchecked(&iucv_sk_list.autobind_name));
 	while (__iucv_get_sock_by_name(name)) {
 		sprintf(name, "%08x",
-			atomic_inc_return(&iucv_sk_list.autobind_name));
+			atomic_inc_return_unchecked(&iucv_sk_list.autobind_name));
 	}
 
 	write_unlock_bh(&iucv_sk_list.lock);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/lapb/lapb_iface.c linux-2.6.32.60-pax/net/lapb/lapb_iface.c
--- linux-2.6.32.60/net/lapb/lapb_iface.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/lapb/lapb_iface.c	2012-03-13 13:15:35.996097944 +0100
@@ -157,7 +157,7 @@ int lapb_register(struct net_device *dev
 		goto out;
 
 	lapb->dev       = dev;
-	lapb->callbacks = *callbacks;
+	lapb->callbacks = callbacks;
 
 	__lapb_insert_cb(lapb);
 
@@ -379,32 +379,32 @@ int lapb_data_received(struct net_device
 
 void lapb_connect_confirmation(struct lapb_cb *lapb, int reason)
 {
-	if (lapb->callbacks.connect_confirmation)
-		lapb->callbacks.connect_confirmation(lapb->dev, reason);
+	if (lapb->callbacks->connect_confirmation)
+		lapb->callbacks->connect_confirmation(lapb->dev, reason);
 }
 
 void lapb_connect_indication(struct lapb_cb *lapb, int reason)
 {
-	if (lapb->callbacks.connect_indication)
-		lapb->callbacks.connect_indication(lapb->dev, reason);
+	if (lapb->callbacks->connect_indication)
+		lapb->callbacks->connect_indication(lapb->dev, reason);
 }
 
 void lapb_disconnect_confirmation(struct lapb_cb *lapb, int reason)
 {
-	if (lapb->callbacks.disconnect_confirmation)
-		lapb->callbacks.disconnect_confirmation(lapb->dev, reason);
+	if (lapb->callbacks->disconnect_confirmation)
+		lapb->callbacks->disconnect_confirmation(lapb->dev, reason);
 }
 
 void lapb_disconnect_indication(struct lapb_cb *lapb, int reason)
 {
-	if (lapb->callbacks.disconnect_indication)
-		lapb->callbacks.disconnect_indication(lapb->dev, reason);
+	if (lapb->callbacks->disconnect_indication)
+		lapb->callbacks->disconnect_indication(lapb->dev, reason);
 }
 
 int lapb_data_indication(struct lapb_cb *lapb, struct sk_buff *skb)
 {
-	if (lapb->callbacks.data_indication)
-		return lapb->callbacks.data_indication(lapb->dev, skb);
+	if (lapb->callbacks->data_indication)
+		return lapb->callbacks->data_indication(lapb->dev, skb);
 
 	kfree_skb(skb);
 	return NET_RX_SUCCESS; /* For now; must be != NET_RX_DROP */
@@ -414,8 +414,8 @@ int lapb_data_transmit(struct lapb_cb *l
 {
 	int used = 0;
 
-	if (lapb->callbacks.data_transmit) {
-		lapb->callbacks.data_transmit(lapb->dev, skb);
+	if (lapb->callbacks->data_transmit) {
+		lapb->callbacks->data_transmit(lapb->dev, skb);
 		used = 1;
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/ieee80211_i.h linux-2.6.32.60-pax/net/mac80211/ieee80211_i.h
--- linux-2.6.32.60/net/mac80211/ieee80211_i.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/ieee80211_i.h	2012-03-13 13:15:36.000097944 +0100
@@ -25,6 +25,7 @@
 #include <linux/etherdevice.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
+#include <asm/local.h>
 #include "key.h"
 #include "sta_info.h"
 
@@ -635,7 +636,7 @@ struct ieee80211_local {
 	/* also used to protect ampdu_ac_queue and amdpu_ac_stop_refcnt */
 	spinlock_t queue_stop_reason_lock;
 
-	int open_count;
+	local_t open_count;
 	int monitors, cooked_mntrs;
 	/* number of interfaces with corresponding FIF_ flags */
 	int fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/iface.c linux-2.6.32.60-pax/net/mac80211/iface.c
--- linux-2.6.32.60/net/mac80211/iface.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/iface.c	2012-03-13 13:15:36.000097944 +0100
@@ -166,7 +166,7 @@ static int ieee80211_open(struct net_dev
 		break;
 	}
 
-	if (local->open_count == 0) {
+	if (local_read(&local->open_count) == 0) {
 		res = drv_start(local);
 		if (res)
 			goto err_del_bss;
@@ -196,7 +196,7 @@ static int ieee80211_open(struct net_dev
 	 * Validate the MAC address for this device.
 	 */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
-		if (!local->open_count)
+		if (!local_read(&local->open_count))
 			drv_stop(local);
 		return -EADDRNOTAVAIL;
 	}
@@ -292,7 +292,7 @@ static int ieee80211_open(struct net_dev
 
 	hw_reconf_flags |= __ieee80211_recalc_idle(local);
 
-	local->open_count++;
+	local_inc(&local->open_count);
 	if (hw_reconf_flags) {
 		ieee80211_hw_config(local, hw_reconf_flags);
 		/*
@@ -320,7 +320,7 @@ static int ieee80211_open(struct net_dev
  err_del_interface:
 	drv_remove_interface(local, &conf);
  err_stop:
-	if (!local->open_count)
+	if (!local_read(&local->open_count))
 		drv_stop(local);
  err_del_bss:
 	sdata->bss = NULL;
@@ -420,7 +420,7 @@ static int ieee80211_stop(struct net_dev
 		WARN_ON(!list_empty(&sdata->u.ap.vlans));
 	}
 
-	local->open_count--;
+	local_dec(&local->open_count);
 
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_AP_VLAN:
@@ -526,7 +526,7 @@ static int ieee80211_stop(struct net_dev
 
 	ieee80211_recalc_ps(local, -1);
 
-	if (local->open_count == 0) {
+	if (local_read(&local->open_count) == 0) {
 		ieee80211_clear_tx_pending(local);
 		ieee80211_stop_device(local);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/main.c linux-2.6.32.60-pax/net/mac80211/main.c
--- linux-2.6.32.60/net/mac80211/main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/main.c	2012-03-13 13:15:36.000097944 +0100
@@ -145,7 +145,7 @@ int ieee80211_hw_config(struct ieee80211
 		local->hw.conf.power_level = power;
 	}
 
-	if (changed && local->open_count) {
+	if (changed && local_read(&local->open_count)) {
 		ret = drv_config(local, changed);
 		/*
 		 * Goal:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/pm.c linux-2.6.32.60-pax/net/mac80211/pm.c
--- linux-2.6.32.60/net/mac80211/pm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/pm.c	2012-03-13 13:15:36.004097943 +0100
@@ -107,7 +107,7 @@ int __ieee80211_suspend(struct ieee80211
 	}
 
 	/* stop hardware - this must stop RX */
-	if (local->open_count)
+	if (local_read(&local->open_count))
 		ieee80211_stop_device(local);
 
 	local->suspended = true;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/rate.c linux-2.6.32.60-pax/net/mac80211/rate.c
--- linux-2.6.32.60/net/mac80211/rate.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/rate.c	2012-03-13 13:15:36.004097943 +0100
@@ -287,7 +287,7 @@ int ieee80211_init_rate_ctrl_alg(struct
 	struct rate_control_ref *ref, *old;
 
 	ASSERT_RTNL();
-	if (local->open_count)
+	if (local_read(&local->open_count))
 		return -EBUSY;
 
 	ref = rate_control_alloc(name, local);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/tx.c linux-2.6.32.60-pax/net/mac80211/tx.c
--- linux-2.6.32.60/net/mac80211/tx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/tx.c	2012-03-13 13:15:36.008097943 +0100
@@ -173,7 +173,7 @@ static __le16 ieee80211_duration(struct
 	return cpu_to_le16(dur);
 }
 
-static int inline is_ieee80211_device(struct ieee80211_local *local,
+static inline int is_ieee80211_device(struct ieee80211_local *local,
 				      struct net_device *dev)
 {
 	return local == wdev_priv(dev->ieee80211_ptr);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/mac80211/util.c linux-2.6.32.60-pax/net/mac80211/util.c
--- linux-2.6.32.60/net/mac80211/util.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/mac80211/util.c	2012-03-13 13:15:36.008097943 +0100
@@ -1042,7 +1042,7 @@ int ieee80211_reconfig(struct ieee80211_
 		local->resuming = true;
 
 	/* restart hardware */
-	if (local->open_count) {
+	if (local_read(&local->open_count)) {
 		/*
 		 * Upon resume hardware can sometimes be goofy due to
 		 * various platform / driver / bus issues, so restarting
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_app.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_app.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_app.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_app.c	2012-03-13 13:15:36.012097943 +0100
@@ -564,7 +564,7 @@ static const struct file_operations ip_v
 	.open	 = ip_vs_app_open,
 	.read	 = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = seq_release_net,
 };
 #endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_conn.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_conn.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_conn.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_conn.c	2012-03-13 13:15:36.012097943 +0100
@@ -453,10 +453,10 @@ ip_vs_bind_dest(struct ip_vs_conn *cp, s
 		/* if the connection is not template and is created
 		 * by sync, preserve the activity flag.
 		 */
-		cp->flags |= atomic_read(&dest->conn_flags) &
+		cp->flags |= atomic_read_unchecked(&dest->conn_flags) &
 			     (~IP_VS_CONN_F_INACTIVE);
 	else
-		cp->flags |= atomic_read(&dest->conn_flags);
+		cp->flags |= atomic_read_unchecked(&dest->conn_flags);
 	cp->dest = dest;
 
 	IP_VS_DBG_BUF(7, "Bind-dest %s c:%s:%d v:%s:%d "
@@ -723,7 +723,7 @@ ip_vs_conn_new(int af, int proto, const
 	atomic_set(&cp->refcnt, 1);
 
 	atomic_set(&cp->n_control, 0);
-	atomic_set(&cp->in_pkts, 0);
+	atomic_set_unchecked(&cp->in_pkts, 0);
 
 	atomic_inc(&ip_vs_conn_count);
 	if (flags & IP_VS_CONN_F_NO_CPORT)
@@ -871,7 +871,7 @@ static const struct file_operations ip_v
 	.open    = ip_vs_conn_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = seq_release_net,
 };
 
 static const char *ip_vs_origin_name(unsigned flags)
@@ -934,7 +934,7 @@ static const struct file_operations ip_v
 	.open    = ip_vs_conn_sync_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = seq_release_net,
 };
 
 #endif
@@ -961,7 +961,7 @@ static inline int todrop_entry(struct ip
 
 	/* Don't drop the entry if its number of incoming packets is not
 	   located in [0, 8] */
-	i = atomic_read(&cp->in_pkts);
+	i = atomic_read_unchecked(&cp->in_pkts);
 	if (i > 8 || i < 0) return 0;
 
 	if (!todrop_rate[i]) return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_core.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_core.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_core.c	2012-03-13 13:15:36.016097943 +0100
@@ -485,7 +485,7 @@ int ip_vs_leave(struct ip_vs_service *sv
 		ret = cp->packet_xmit(skb, cp, pp);
 		/* do not touch skb anymore */
 
-		atomic_inc(&cp->in_pkts);
+		atomic_inc_unchecked(&cp->in_pkts);
 		ip_vs_conn_put(cp);
 		return ret;
 	}
@@ -1357,7 +1357,7 @@ ip_vs_in(unsigned int hooknum, struct sk
 	 * Sync connection if it is about to close to
 	 * encorage the standby servers to update the connections timeout
 	 */
-	pkts = atomic_add_return(1, &cp->in_pkts);
+	pkts = atomic_add_return_unchecked(1, &cp->in_pkts);
 	if (af == AF_INET &&
 	    (ip_vs_sync_state & IP_VS_STATE_MASTER) &&
 	    (((cp->protocol != IPPROTO_TCP ||
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_ctl.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_ctl.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_ctl.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_ctl.c	2012-03-13 13:15:36.020097943 +0100
@@ -792,7 +792,7 @@ __ip_vs_update_dest(struct ip_vs_service
 		ip_vs_rs_hash(dest);
 		write_unlock_bh(&__ip_vs_rs_lock);
 	}
-	atomic_set(&dest->conn_flags, conn_flags);
+	atomic_set_unchecked(&dest->conn_flags, conn_flags);
 
 	/* bind the service */
 	if (!dest->svc) {
@@ -1888,7 +1888,7 @@ static int ip_vs_info_seq_show(struct se
 					   "      %-7s %-6d %-10d %-10d\n",
 					   &dest->addr.in6,
 					   ntohs(dest->port),
-					   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),
+					   ip_vs_fwd_name(atomic_read_unchecked(&dest->conn_flags)),
 					   atomic_read(&dest->weight),
 					   atomic_read(&dest->activeconns),
 					   atomic_read(&dest->inactconns));
@@ -1899,7 +1899,7 @@ static int ip_vs_info_seq_show(struct se
 					   "%-7s %-6d %-10d %-10d\n",
 					   ntohl(dest->addr.ip),
 					   ntohs(dest->port),
-					   ip_vs_fwd_name(atomic_read(&dest->conn_flags)),
+					   ip_vs_fwd_name(atomic_read_unchecked(&dest->conn_flags)),
 					   atomic_read(&dest->weight),
 					   atomic_read(&dest->activeconns),
 					   atomic_read(&dest->inactconns));
@@ -1927,7 +1927,7 @@ static const struct file_operations ip_v
 	.open    = ip_vs_info_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release_private,
+	.release = seq_release_net,
 };
 
 #endif
@@ -1976,7 +1976,7 @@ static const struct file_operations ip_v
 	.open = ip_vs_stats_seq_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = single_release,
+	.release = single_release_net,
 };
 
 #endif
@@ -2292,7 +2292,7 @@ __ip_vs_get_dest_entries(const struct ip
 
 			entry.addr = dest->addr.ip;
 			entry.port = dest->port;
-			entry.conn_flags = atomic_read(&dest->conn_flags);
+			entry.conn_flags = atomic_read_unchecked(&dest->conn_flags);
 			entry.weight = atomic_read(&dest->weight);
 			entry.u_threshold = dest->u_threshold;
 			entry.l_threshold = dest->l_threshold;
@@ -2802,7 +2802,7 @@ static int ip_vs_genl_fill_dest(struct s
 	NLA_PUT_U16(skb, IPVS_DEST_ATTR_PORT, dest->port);
 
 	NLA_PUT_U32(skb, IPVS_DEST_ATTR_FWD_METHOD,
-		    atomic_read(&dest->conn_flags) & IP_VS_CONN_F_FWD_MASK);
+		    atomic_read_unchecked(&dest->conn_flags) & IP_VS_CONN_F_FWD_MASK);
 	NLA_PUT_U32(skb, IPVS_DEST_ATTR_WEIGHT, atomic_read(&dest->weight));
 	NLA_PUT_U32(skb, IPVS_DEST_ATTR_U_THRESH, dest->u_threshold);
 	NLA_PUT_U32(skb, IPVS_DEST_ATTR_L_THRESH, dest->l_threshold);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_sync.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_sync.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_sync.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_sync.c	2012-03-13 13:15:36.020097943 +0100
@@ -438,7 +438,7 @@ static void ip_vs_process_message(const
 
 		if (opt)
 			memcpy(&cp->in_seq, opt, sizeof(*opt));
-		atomic_set(&cp->in_pkts, sysctl_ip_vs_sync_threshold[0]);
+		atomic_set_unchecked(&cp->in_pkts, sysctl_ip_vs_sync_threshold[0]);
 		cp->state = state;
 		cp->old_state = cp->state;
 		/*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/ipvs/ip_vs_xmit.c linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_xmit.c
--- linux-2.6.32.60/net/netfilter/ipvs/ip_vs_xmit.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/ipvs/ip_vs_xmit.c	2012-03-13 13:15:36.020097943 +0100
@@ -875,7 +875,7 @@ ip_vs_icmp_xmit(struct sk_buff *skb, str
 		else
 			rc = NF_ACCEPT;
 		/* do not touch skb anymore */
-		atomic_inc(&cp->in_pkts);
+		atomic_inc_unchecked(&cp->in_pkts);
 		goto out;
 	}
 
@@ -949,7 +949,7 @@ ip_vs_icmp_xmit_v6(struct sk_buff *skb,
 		else
 			rc = NF_ACCEPT;
 		/* do not touch skb anymore */
-		atomic_inc(&cp->in_pkts);
+		atomic_inc_unchecked(&cp->in_pkts);
 		goto out;
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/nf_conntrack_netlink.c linux-2.6.32.60-pax/net/netfilter/nf_conntrack_netlink.c
--- linux-2.6.32.60/net/netfilter/nf_conntrack_netlink.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/nf_conntrack_netlink.c	2012-03-13 13:15:36.024097942 +0100
@@ -706,7 +706,7 @@ ctnetlink_parse_tuple_proto(struct nlatt
 static int
 ctnetlink_parse_tuple(const struct nlattr * const cda[],
 		      struct nf_conntrack_tuple *tuple,
-		      enum ctattr_tuple type, u_int8_t l3num)
+		      enum ctattr_type type, u_int8_t l3num)
 {
 	struct nlattr *tb[CTA_TUPLE_MAX+1];
 	int err;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netfilter/nfnetlink_log.c linux-2.6.32.60-pax/net/netfilter/nfnetlink_log.c
--- linux-2.6.32.60/net/netfilter/nfnetlink_log.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/netfilter/nfnetlink_log.c	2012-03-13 13:15:36.024097942 +0100
@@ -68,7 +68,7 @@ struct nfulnl_instance {
 };
 
 static DEFINE_RWLOCK(instances_lock);
-static atomic_t global_seq;
+static atomic_unchecked_t global_seq;
 
 #define INSTANCE_BUCKETS	16
 static struct hlist_head instance_table[INSTANCE_BUCKETS];
@@ -493,7 +493,7 @@ __build_packet_message(struct nfulnl_ins
 	/* global sequence number */
 	if (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)
 		NLA_PUT_BE32(inst->skb, NFULA_SEQ_GLOBAL,
-			     htonl(atomic_inc_return(&global_seq)));
+			     htonl(atomic_inc_return_unchecked(&global_seq)));
 
 	if (data_len) {
 		struct nlattr *nla;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/netlink/af_netlink.c linux-2.6.32.60-pax/net/netlink/af_netlink.c
--- linux-2.6.32.60/net/netlink/af_netlink.c	2012-10-09 11:00:35.508882483 +0200
+++ linux-2.6.32.60-pax/net/netlink/af_netlink.c	2012-10-09 11:00:39.368883058 +0200
@@ -733,7 +733,7 @@ static void netlink_overrun(struct sock
 			sk->sk_error_report(sk);
 		}
 	}
-	atomic_inc(&sk->sk_drops);
+	atomic_inc_unchecked(&sk->sk_drops);
 }
 
 static struct sock *netlink_getsockbypid(struct sock *ssk, u32 pid)
@@ -1974,7 +1974,7 @@ static int netlink_seq_show(struct seq_f
 			   sk_wmem_alloc_get(s),
 			   nlk->cb,
 			   atomic_read(&s->sk_refcnt),
-			   atomic_read(&s->sk_drops)
+			   atomic_read_unchecked(&s->sk_drops)
 			);
 
 	}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/packet/af_packet.c linux-2.6.32.60-pax/net/packet/af_packet.c
--- linux-2.6.32.60/net/packet/af_packet.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/packet/af_packet.c	2012-09-20 01:09:20.898666554 +0200
@@ -1724,7 +1724,7 @@ packet_setsockopt(struct socket *sock, i
 	case PACKET_DROP_MEMBERSHIP:
 	{
 		struct packet_mreq_max mreq;
-		int len = optlen;
+		unsigned int len = optlen;
 		memset(&mreq, 0, sizeof(mreq));
 		if (len < sizeof(struct packet_mreq))
 			return -EINVAL;
@@ -1895,7 +1895,7 @@ static int packet_getsockopt(struct sock
 	case PACKET_HDRLEN:
 		if (len > sizeof(int))
 			len = sizeof(int);
-		if (copy_from_user(&val, optval, len))
+		if (len > sizeof(val) || copy_from_user(&val, optval, len))
 			return -EFAULT;
 		switch (val) {
 		case TPACKET_V1:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/phonet/datagram.c linux-2.6.32.60-pax/net/phonet/datagram.c
--- linux-2.6.32.60/net/phonet/datagram.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/phonet/datagram.c	2012-03-13 13:15:36.028097942 +0100
@@ -162,7 +162,7 @@ static int pn_backlog_rcv(struct sock *s
 	if (err < 0) {
 		kfree_skb(skb);
 		if (err == -ENOMEM)
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 	}
 	return err ? NET_RX_DROP : NET_RX_SUCCESS;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/phonet/pep.c linux-2.6.32.60-pax/net/phonet/pep.c
--- linux-2.6.32.60/net/phonet/pep.c	2012-10-09 11:00:35.508882483 +0200
+++ linux-2.6.32.60-pax/net/phonet/pep.c	2012-10-09 11:00:39.368883058 +0200
@@ -348,7 +348,7 @@ static int pipe_do_rcv(struct sock *sk,
 
 	case PNS_PEP_CTRL_REQ:
 		if (skb_queue_len(&pn->ctrlreq_queue) >= PNPIPE_CTRLREQ_MAX) {
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 			break;
 		}
 		__skb_pull(skb, 4);
@@ -362,12 +362,12 @@ static int pipe_do_rcv(struct sock *sk,
 			if (!err)
 				return 0;
 			if (err == -ENOMEM)
-				atomic_inc(&sk->sk_drops);
+				atomic_inc_unchecked(&sk->sk_drops);
 			break;
 		}
 
 		if (pn->rx_credits == 0) {
-			atomic_inc(&sk->sk_drops);
+			atomic_inc_unchecked(&sk->sk_drops);
 			err = -ENOBUFS;
 			break;
 		}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/phonet/socket.c linux-2.6.32.60-pax/net/phonet/socket.c
--- linux-2.6.32.60/net/phonet/socket.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/phonet/socket.c	2012-03-13 13:15:36.028097942 +0100
@@ -483,7 +483,7 @@ static int pn_sock_seq_show(struct seq_f
 			sk_wmem_alloc_get(sk), sk_rmem_alloc_get(sk),
 			sock_i_uid(sk), sock_i_ino(sk),
 			atomic_read(&sk->sk_refcnt), sk,
-			atomic_read(&sk->sk_drops), &len);
+			atomic_read_unchecked(&sk->sk_drops), &len);
 	}
 	seq_printf(seq, "%*s\n", 127 - len, "");
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rds/cong.c linux-2.6.32.60-pax/net/rds/cong.c
--- linux-2.6.32.60/net/rds/cong.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rds/cong.c	2012-03-13 13:15:36.028097942 +0100
@@ -77,7 +77,7 @@
  * finds that the saved generation number is smaller than the global generation
  * number, it wakes up the process.
  */
-static atomic_t		rds_cong_generation = ATOMIC_INIT(0);
+static atomic_unchecked_t		rds_cong_generation = ATOMIC_INIT(0);
 
 /*
  * Congestion monitoring
@@ -232,7 +232,7 @@ void rds_cong_map_updated(struct rds_con
 	rdsdebug("waking map %p for %pI4\n",
 	  map, &map->m_addr);
 	rds_stats_inc(s_cong_update_received);
-	atomic_inc(&rds_cong_generation);
+	atomic_inc_unchecked(&rds_cong_generation);
 	if (waitqueue_active(&map->m_waitq))
 		wake_up(&map->m_waitq);
 	if (waitqueue_active(&rds_poll_waitq))
@@ -258,7 +258,7 @@ EXPORT_SYMBOL_GPL(rds_cong_map_updated);
 
 int rds_cong_updated_since(unsigned long *recent)
 {
-	unsigned long gen = atomic_read(&rds_cong_generation);
+	unsigned long gen = atomic_read_unchecked(&rds_cong_generation);
 
 	if (likely(*recent == gen))
 		return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rds/tcp.c linux-2.6.32.60-pax/net/rds/tcp.c
--- linux-2.6.32.60/net/rds/tcp.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rds/tcp.c	2012-03-13 13:15:36.032097942 +0100
@@ -57,7 +57,7 @@ void rds_tcp_nonagle(struct socket *sock
 	int val = 1;
 
 	set_fs(KERNEL_DS);
-	sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY, (char __user *)&val,
+	sock->ops->setsockopt(sock, SOL_TCP, TCP_NODELAY, (char __force_user *)&val,
 			      sizeof(val));
 	set_fs(oldfs);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rds/tcp_send.c linux-2.6.32.60-pax/net/rds/tcp_send.c
--- linux-2.6.32.60/net/rds/tcp_send.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rds/tcp_send.c	2012-03-13 13:15:36.032097942 +0100
@@ -43,7 +43,7 @@ static void rds_tcp_cork(struct socket *
 
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
-	sock->ops->setsockopt(sock, SOL_TCP, TCP_CORK, (char __user *)&val,
+	sock->ops->setsockopt(sock, SOL_TCP, TCP_CORK, (char __force_user *)&val,
 			      sizeof(val));
 	set_fs(oldfs);
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/af_rxrpc.c linux-2.6.32.60-pax/net/rxrpc/af_rxrpc.c
--- linux-2.6.32.60/net/rxrpc/af_rxrpc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/af_rxrpc.c	2012-03-13 13:15:36.032097942 +0100
@@ -38,7 +38,7 @@ static const struct proto_ops rxrpc_rpc_
 __be32 rxrpc_epoch;
 
 /* current debugging ID */
-atomic_t rxrpc_debug_id;
+atomic_unchecked_t rxrpc_debug_id;
 
 /* count of skbs currently in use */
 atomic_t rxrpc_n_skbs;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-ack.c linux-2.6.32.60-pax/net/rxrpc/ar-ack.c
--- linux-2.6.32.60/net/rxrpc/ar-ack.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-ack.c	2012-03-13 13:15:36.032097942 +0100
@@ -174,7 +174,7 @@ static void rxrpc_resend(struct rxrpc_ca
 
 	_enter("{%d,%d,%d,%d},",
 	       call->acks_hard, call->acks_unacked,
-	       atomic_read(&call->sequence),
+	       atomic_read_unchecked(&call->sequence),
 	       CIRC_CNT(call->acks_head, call->acks_tail, call->acks_winsz));
 
 	stop = 0;
@@ -198,7 +198,7 @@ static void rxrpc_resend(struct rxrpc_ca
 
 			/* each Tx packet has a new serial number */
 			sp->hdr.serial =
-				htonl(atomic_inc_return(&call->conn->serial));
+				htonl(atomic_inc_return_unchecked(&call->conn->serial));
 
 			hdr = (struct rxrpc_header *) txb->head;
 			hdr->serial = sp->hdr.serial;
@@ -401,7 +401,7 @@ static void rxrpc_rotate_tx_window(struc
  */
 static void rxrpc_clear_tx_window(struct rxrpc_call *call)
 {
-	rxrpc_rotate_tx_window(call, atomic_read(&call->sequence));
+	rxrpc_rotate_tx_window(call, atomic_read_unchecked(&call->sequence));
 }
 
 /*
@@ -627,7 +627,7 @@ process_further:
 
 		latest = ntohl(sp->hdr.serial);
 		hard = ntohl(ack.firstPacket);
-		tx = atomic_read(&call->sequence);
+		tx = atomic_read_unchecked(&call->sequence);
 
 		_proto("Rx ACK %%%u { m=%hu f=#%u p=#%u s=%%%u r=%s n=%u }",
 		       latest,
@@ -1159,7 +1159,7 @@ void rxrpc_process_call(struct work_stru
 	goto maybe_reschedule;
 
 send_ACK_with_skew:
-	ack.maxSkew = htons(atomic_read(&call->conn->hi_serial) -
+	ack.maxSkew = htons(atomic_read_unchecked(&call->conn->hi_serial) -
 			    ntohl(ack.serial));
 send_ACK:
 	mtu = call->conn->trans->peer->if_mtu;
@@ -1171,7 +1171,7 @@ send_ACK:
 	ackinfo.rxMTU	= htonl(5692);
 	ackinfo.jumbo_max = htonl(4);
 
-	hdr.serial = htonl(atomic_inc_return(&call->conn->serial));
+	hdr.serial = htonl(atomic_inc_return_unchecked(&call->conn->serial));
 	_proto("Tx ACK %%%u { m=%hu f=#%u p=#%u s=%%%u r=%s n=%u }",
 	       ntohl(hdr.serial),
 	       ntohs(ack.maxSkew),
@@ -1189,7 +1189,7 @@ send_ACK:
 send_message:
 	_debug("send message");
 
-	hdr.serial = htonl(atomic_inc_return(&call->conn->serial));
+	hdr.serial = htonl(atomic_inc_return_unchecked(&call->conn->serial));
 	_proto("Tx %s %%%u", rxrpc_pkts[hdr.type], ntohl(hdr.serial));
 send_message_2:
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-call.c linux-2.6.32.60-pax/net/rxrpc/ar-call.c
--- linux-2.6.32.60/net/rxrpc/ar-call.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-call.c	2012-03-13 13:15:36.032097942 +0100
@@ -82,7 +82,7 @@ static struct rxrpc_call *rxrpc_alloc_ca
 	spin_lock_init(&call->lock);
 	rwlock_init(&call->state_lock);
 	atomic_set(&call->usage, 1);
-	call->debug_id = atomic_inc_return(&rxrpc_debug_id);
+	call->debug_id = atomic_inc_return_unchecked(&rxrpc_debug_id);
 	call->state = RXRPC_CALL_CLIENT_SEND_REQUEST;
 
 	memset(&call->sock_node, 0xed, sizeof(call->sock_node));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-connection.c linux-2.6.32.60-pax/net/rxrpc/ar-connection.c
--- linux-2.6.32.60/net/rxrpc/ar-connection.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-connection.c	2012-03-13 13:15:36.036097942 +0100
@@ -205,7 +205,7 @@ static struct rxrpc_connection *rxrpc_al
 		rwlock_init(&conn->lock);
 		spin_lock_init(&conn->state_lock);
 		atomic_set(&conn->usage, 1);
-		conn->debug_id = atomic_inc_return(&rxrpc_debug_id);
+		conn->debug_id = atomic_inc_return_unchecked(&rxrpc_debug_id);
 		conn->avail_calls = RXRPC_MAXCALLS;
 		conn->size_align = 4;
 		conn->header_size = sizeof(struct rxrpc_header);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-connevent.c linux-2.6.32.60-pax/net/rxrpc/ar-connevent.c
--- linux-2.6.32.60/net/rxrpc/ar-connevent.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-connevent.c	2012-03-13 13:15:36.036097942 +0100
@@ -109,7 +109,7 @@ static int rxrpc_abort_connection(struct
 
 	len = iov[0].iov_len + iov[1].iov_len;
 
-	hdr.serial = htonl(atomic_inc_return(&conn->serial));
+	hdr.serial = htonl(atomic_inc_return_unchecked(&conn->serial));
 	_proto("Tx CONN ABORT %%%u { %d }", ntohl(hdr.serial), abort_code);
 
 	ret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 2, len);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-input.c linux-2.6.32.60-pax/net/rxrpc/ar-input.c
--- linux-2.6.32.60/net/rxrpc/ar-input.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-input.c	2012-03-13 13:15:36.036097942 +0100
@@ -339,9 +339,9 @@ void rxrpc_fast_process_packet(struct rx
 	/* track the latest serial number on this connection for ACK packet
 	 * information */
 	serial = ntohl(sp->hdr.serial);
-	hi_serial = atomic_read(&call->conn->hi_serial);
+	hi_serial = atomic_read_unchecked(&call->conn->hi_serial);
 	while (serial > hi_serial)
-		hi_serial = atomic_cmpxchg(&call->conn->hi_serial, hi_serial,
+		hi_serial = atomic_cmpxchg_unchecked(&call->conn->hi_serial, hi_serial,
 					   serial);
 
 	/* request ACK generation for any ACK or DATA packet that requests
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-internal.h linux-2.6.32.60-pax/net/rxrpc/ar-internal.h
--- linux-2.6.32.60/net/rxrpc/ar-internal.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-internal.h	2012-03-13 13:15:36.036097942 +0100
@@ -272,8 +272,8 @@ struct rxrpc_connection {
 	int			error;		/* error code for local abort */
 	int			debug_id;	/* debug ID for printks */
 	unsigned		call_counter;	/* call ID counter */
-	atomic_t		serial;		/* packet serial number counter */
-	atomic_t		hi_serial;	/* highest serial number received */
+	atomic_unchecked_t	serial;		/* packet serial number counter */
+	atomic_unchecked_t	hi_serial;	/* highest serial number received */
 	u8			avail_calls;	/* number of calls available */
 	u8			size_align;	/* data size alignment (for security) */
 	u8			header_size;	/* rxrpc + security header size */
@@ -346,7 +346,7 @@ struct rxrpc_call {
 	spinlock_t		lock;
 	rwlock_t		state_lock;	/* lock for state transition */
 	atomic_t		usage;
-	atomic_t		sequence;	/* Tx data packet sequence counter */
+	atomic_unchecked_t	sequence;	/* Tx data packet sequence counter */
 	u32			abort_code;	/* local/remote abort code */
 	enum {					/* current state of call */
 		RXRPC_CALL_CLIENT_SEND_REQUEST,	/* - client sending request phase */
@@ -420,7 +420,7 @@ static inline void rxrpc_abort_call(stru
  */
 extern atomic_t rxrpc_n_skbs;
 extern __be32 rxrpc_epoch;
-extern atomic_t rxrpc_debug_id;
+extern atomic_unchecked_t rxrpc_debug_id;
 extern struct workqueue_struct *rxrpc_workqueue;
 
 /*
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-local.c linux-2.6.32.60-pax/net/rxrpc/ar-local.c
--- linux-2.6.32.60/net/rxrpc/ar-local.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-local.c	2012-03-13 13:15:36.040097942 +0100
@@ -44,7 +44,7 @@ struct rxrpc_local *rxrpc_alloc_local(st
 		spin_lock_init(&local->lock);
 		rwlock_init(&local->services_lock);
 		atomic_set(&local->usage, 1);
-		local->debug_id = atomic_inc_return(&rxrpc_debug_id);
+		local->debug_id = atomic_inc_return_unchecked(&rxrpc_debug_id);
 		memcpy(&local->srx, srx, sizeof(*srx));
 	}
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-output.c linux-2.6.32.60-pax/net/rxrpc/ar-output.c
--- linux-2.6.32.60/net/rxrpc/ar-output.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-output.c	2012-03-13 13:15:36.040097942 +0100
@@ -680,9 +680,9 @@ static int rxrpc_send_data(struct kiocb
 			sp->hdr.cid = call->cid;
 			sp->hdr.callNumber = call->call_id;
 			sp->hdr.seq =
-				htonl(atomic_inc_return(&call->sequence));
+				htonl(atomic_inc_return_unchecked(&call->sequence));
 			sp->hdr.serial =
-				htonl(atomic_inc_return(&conn->serial));
+				htonl(atomic_inc_return_unchecked(&conn->serial));
 			sp->hdr.type = RXRPC_PACKET_TYPE_DATA;
 			sp->hdr.userStatus = 0;
 			sp->hdr.securityIndex = conn->security_ix;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-peer.c linux-2.6.32.60-pax/net/rxrpc/ar-peer.c
--- linux-2.6.32.60/net/rxrpc/ar-peer.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-peer.c	2012-03-13 13:15:36.040097942 +0100
@@ -86,7 +86,7 @@ static struct rxrpc_peer *rxrpc_alloc_pe
 		INIT_LIST_HEAD(&peer->error_targets);
 		spin_lock_init(&peer->lock);
 		atomic_set(&peer->usage, 1);
-		peer->debug_id = atomic_inc_return(&rxrpc_debug_id);
+		peer->debug_id = atomic_inc_return_unchecked(&rxrpc_debug_id);
 		memcpy(&peer->srx, srx, sizeof(*srx));
 
 		rxrpc_assess_MTU_size(peer);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-proc.c linux-2.6.32.60-pax/net/rxrpc/ar-proc.c
--- linux-2.6.32.60/net/rxrpc/ar-proc.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-proc.c	2012-03-13 13:15:36.040097942 +0100
@@ -164,8 +164,8 @@ static int rxrpc_connection_seq_show(str
 		   atomic_read(&conn->usage),
 		   rxrpc_conn_states[conn->state],
 		   key_serial(conn->key),
-		   atomic_read(&conn->serial),
-		   atomic_read(&conn->hi_serial));
+		   atomic_read_unchecked(&conn->serial),
+		   atomic_read_unchecked(&conn->hi_serial));
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/ar-transport.c linux-2.6.32.60-pax/net/rxrpc/ar-transport.c
--- linux-2.6.32.60/net/rxrpc/ar-transport.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/ar-transport.c	2012-03-13 13:15:36.040097942 +0100
@@ -46,7 +46,7 @@ static struct rxrpc_transport *rxrpc_all
 		spin_lock_init(&trans->client_lock);
 		rwlock_init(&trans->conn_lock);
 		atomic_set(&trans->usage, 1);
-		trans->debug_id = atomic_inc_return(&rxrpc_debug_id);
+		trans->debug_id = atomic_inc_return_unchecked(&rxrpc_debug_id);
 
 		if (peer->srx.transport.family == AF_INET) {
 			switch (peer->srx.transport_type) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/rxrpc/rxkad.c linux-2.6.32.60-pax/net/rxrpc/rxkad.c
--- linux-2.6.32.60/net/rxrpc/rxkad.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/rxrpc/rxkad.c	2012-03-13 13:15:36.044097941 +0100
@@ -609,7 +609,7 @@ static int rxkad_issue_challenge(struct
 
 	len = iov[0].iov_len + iov[1].iov_len;
 
-	hdr.serial = htonl(atomic_inc_return(&conn->serial));
+	hdr.serial = htonl(atomic_inc_return_unchecked(&conn->serial));
 	_proto("Tx CHALLENGE %%%u", ntohl(hdr.serial));
 
 	ret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 2, len);
@@ -659,7 +659,7 @@ static int rxkad_send_response(struct rx
 
 	len = iov[0].iov_len + iov[1].iov_len + iov[2].iov_len;
 
-	hdr->serial = htonl(atomic_inc_return(&conn->serial));
+	hdr->serial = htonl(atomic_inc_return_unchecked(&conn->serial));
 	_proto("Tx RESPONSE %%%u", ntohl(hdr->serial));
 
 	ret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 3, len);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sctp/ipv6.c linux-2.6.32.60-pax/net/sctp/ipv6.c
--- linux-2.6.32.60/net/sctp/ipv6.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sctp/ipv6.c	2013-01-22 17:38:23.596543624 +0100
@@ -1013,7 +1013,7 @@ void sctp_v6_pf_init(void)
 
 void sctp_v6_pf_exit(void)
 {
-	list_del(&sctp_af_inet6.list);
+	pax_list_del((struct list_head *)&sctp_af_inet6.list);
 }
 
 /* Initialize IPv6 support and register with socket layer.  */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sctp/protocol.c linux-2.6.32.60-pax/net/sctp/protocol.c
--- linux-2.6.32.60/net/sctp/protocol.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sctp/protocol.c	2013-01-22 17:38:23.596543624 +0100
@@ -727,8 +727,10 @@ int sctp_register_af(struct sctp_af *af)
 		return 0;
 	}
 
-	INIT_LIST_HEAD(&af->list);
-	list_add_tail(&af->list, &sctp_address_families);
+	pax_open_kernel();
+	INIT_LIST_HEAD((struct list_head *)&af->list);
+	pax_close_kernel();
+	pax_list_add_tail((struct list_head *)&af->list, &sctp_address_families);
 	return 1;
 }
 
@@ -1015,7 +1017,7 @@ static void sctp_v4_pf_init(void)
 
 static void sctp_v4_pf_exit(void)
 {
-	list_del(&sctp_af_inet.list);
+	pax_list_del((struct list_head *)&sctp_af_inet.list);
 }
 
 static int sctp_v4_protosw_init(void)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sctp/socket.c linux-2.6.32.60-pax/net/sctp/socket.c
--- linux-2.6.32.60/net/sctp/socket.c	2012-10-09 11:00:35.512882484 +0200
+++ linux-2.6.32.60-pax/net/sctp/socket.c	2012-10-09 11:00:39.372883059 +0200
@@ -5810,7 +5810,6 @@ pp_found:
 		 */
 		int reuse = sk->sk_reuse;
 		struct sock *sk2;
-		struct hlist_node *node;
 
 		SCTP_DEBUG_PRINTK("sctp_get_port() found a possible match\n");
 		if (pp->fastreuse && sk->sk_reuse &&
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/socket.c linux-2.6.32.60-pax/net/socket.c
--- linux-2.6.32.60/net/socket.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/socket.c	2012-03-13 13:15:36.048097941 +0100
@@ -2022,7 +2022,7 @@ SYSCALL_DEFINE3(recvmsg, int, fd, struct
 	 *      kernel msghdr to use the kernel address space)
 	 */
 
-	uaddr = (__force void __user *)msg_sys.msg_name;
+	uaddr = (void __force_user *)msg_sys.msg_name;
 	uaddr_len = COMPAT_NAMELEN(msg);
 	if (MSG_CMSG_COMPAT & flags) {
 		err = verify_compat_iovec(&msg_sys, iov,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sunrpc/sched.c linux-2.6.32.60-pax/net/sunrpc/sched.c
--- linux-2.6.32.60/net/sunrpc/sched.c	2012-10-09 11:00:35.512882484 +0200
+++ linux-2.6.32.60-pax/net/sunrpc/sched.c	2012-10-09 11:00:39.372883059 +0200
@@ -234,10 +234,10 @@ static int rpc_wait_bit_killable(void *w
 #ifdef RPC_DEBUG
 static void rpc_task_set_debuginfo(struct rpc_task *task)
 {
-	static atomic_t rpc_pid;
+	static atomic_unchecked_t rpc_pid;
 
 	task->tk_magic = RPC_TASK_MAGIC_ID;
-	task->tk_pid = atomic_inc_return(&rpc_pid);
+	task->tk_pid = atomic_inc_return_unchecked(&rpc_pid);
 }
 #else
 static inline void rpc_task_set_debuginfo(struct rpc_task *task)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma.c linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma.c
--- linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma.c	2012-03-13 13:15:36.048097941 +0100
@@ -59,15 +59,15 @@ unsigned int svcrdma_max_req_size = RPCR
 static unsigned int min_max_inline = 4096;
 static unsigned int max_max_inline = 65536;
 
-atomic_t rdma_stat_recv;
-atomic_t rdma_stat_read;
-atomic_t rdma_stat_write;
-atomic_t rdma_stat_sq_starve;
-atomic_t rdma_stat_rq_starve;
-atomic_t rdma_stat_rq_poll;
-atomic_t rdma_stat_rq_prod;
-atomic_t rdma_stat_sq_poll;
-atomic_t rdma_stat_sq_prod;
+atomic_unchecked_t rdma_stat_recv;
+atomic_unchecked_t rdma_stat_read;
+atomic_unchecked_t rdma_stat_write;
+atomic_unchecked_t rdma_stat_sq_starve;
+atomic_unchecked_t rdma_stat_rq_starve;
+atomic_unchecked_t rdma_stat_rq_poll;
+atomic_unchecked_t rdma_stat_rq_prod;
+atomic_unchecked_t rdma_stat_sq_poll;
+atomic_unchecked_t rdma_stat_sq_prod;
 
 /* Temporary NFS request map and context caches */
 struct kmem_cache *svc_rdma_map_cachep;
@@ -105,7 +105,7 @@ static int read_reset_stat(ctl_table *ta
 		len -= *ppos;
 		if (len > *lenp)
 			len = *lenp;
-		if (len && copy_to_user(buffer, str_buf, len))
+		if (len > sizeof str_buf || (len && copy_to_user(buffer, str_buf, len)))
 			return -EFAULT;
 		*lenp = len;
 		*ppos += len;
@@ -149,63 +149,63 @@ static ctl_table svcrdma_parm_table[] =
 	{
 		.procname	= "rdma_stat_read",
 		.data		= &rdma_stat_read,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_recv",
 		.data		= &rdma_stat_recv,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_write",
 		.data		= &rdma_stat_write,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_sq_starve",
 		.data		= &rdma_stat_sq_starve,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_rq_starve",
 		.data		= &rdma_stat_rq_starve,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_rq_poll",
 		.data		= &rdma_stat_rq_poll,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_rq_prod",
 		.data		= &rdma_stat_rq_prod,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_sq_poll",
 		.data		= &rdma_stat_sq_poll,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
 	{
 		.procname	= "rdma_stat_sq_prod",
 		.data		= &rdma_stat_sq_prod,
-		.maxlen		= sizeof(atomic_t),
+		.maxlen		= sizeof(atomic_unchecked_t),
 		.mode		= 0644,
 		.proc_handler	= &read_reset_stat,
 	},
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c
--- linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c	2012-03-13 13:15:36.048097941 +0100
@@ -495,7 +495,7 @@ next_sge:
 			svc_rdma_put_context(ctxt, 0);
 			goto out;
 		}
-		atomic_inc(&rdma_stat_read);
+		atomic_inc_unchecked(&rdma_stat_read);
 
 		if (read_wr.num_sge < chl_map->ch[ch_no].count) {
 			chl_map->ch[ch_no].count -= read_wr.num_sge;
@@ -606,7 +606,7 @@ int svc_rdma_recvfrom(struct svc_rqst *r
 				  dto_q);
 		list_del_init(&ctxt->dto_q);
 	} else {
-		atomic_inc(&rdma_stat_rq_starve);
+		atomic_inc_unchecked(&rdma_stat_rq_starve);
 		clear_bit(XPT_DATA, &xprt->xpt_flags);
 		ctxt = NULL;
 	}
@@ -626,7 +626,7 @@ int svc_rdma_recvfrom(struct svc_rqst *r
 	dprintk("svcrdma: processing ctxt=%p on xprt=%p, rqstp=%p, status=%d\n",
 		ctxt, rdma_xprt, rqstp, ctxt->wc_status);
 	BUG_ON(ctxt->wc_status != IB_WC_SUCCESS);
-	atomic_inc(&rdma_stat_recv);
+	atomic_inc_unchecked(&rdma_stat_recv);
 
 	/* Build up the XDR from the receive buffers. */
 	rdma_build_arg_xdr(rqstp, ctxt, ctxt->byte_len);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_sendto.c linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_sendto.c
--- linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_sendto.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_sendto.c	2012-03-13 13:15:36.052097941 +0100
@@ -328,7 +328,7 @@ static int send_write(struct svcxprt_rdm
 	write_wr.wr.rdma.remote_addr = to;
 
 	/* Post It */
-	atomic_inc(&rdma_stat_write);
+	atomic_inc_unchecked(&rdma_stat_write);
 	if (svc_rdma_send(xprt, &write_wr))
 		goto err;
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_transport.c linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_transport.c
--- linux-2.6.32.60/net/sunrpc/xprtrdma/svc_rdma_transport.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/sunrpc/xprtrdma/svc_rdma_transport.c	2012-03-13 13:15:36.052097941 +0100
@@ -292,7 +292,7 @@ static void rq_cq_reap(struct svcxprt_rd
 		return;
 
 	ib_req_notify_cq(xprt->sc_rq_cq, IB_CQ_NEXT_COMP);
-	atomic_inc(&rdma_stat_rq_poll);
+	atomic_inc_unchecked(&rdma_stat_rq_poll);
 
 	while ((ret = ib_poll_cq(xprt->sc_rq_cq, 1, &wc)) > 0) {
 		ctxt = (struct svc_rdma_op_ctxt *)(unsigned long)wc.wr_id;
@@ -314,7 +314,7 @@ static void rq_cq_reap(struct svcxprt_rd
 	}
 
 	if (ctxt)
-		atomic_inc(&rdma_stat_rq_prod);
+		atomic_inc_unchecked(&rdma_stat_rq_prod);
 
 	set_bit(XPT_DATA, &xprt->sc_xprt.xpt_flags);
 	/*
@@ -386,7 +386,7 @@ static void sq_cq_reap(struct svcxprt_rd
 		return;
 
 	ib_req_notify_cq(xprt->sc_sq_cq, IB_CQ_NEXT_COMP);
-	atomic_inc(&rdma_stat_sq_poll);
+	atomic_inc_unchecked(&rdma_stat_sq_poll);
 	while ((ret = ib_poll_cq(cq, 1, &wc)) > 0) {
 		if (wc.status != IB_WC_SUCCESS)
 			/* Close the transport */
@@ -404,7 +404,7 @@ static void sq_cq_reap(struct svcxprt_rd
 	}
 
 	if (ctxt)
-		atomic_inc(&rdma_stat_sq_prod);
+		atomic_inc_unchecked(&rdma_stat_sq_prod);
 }
 
 static void sq_comp_handler(struct ib_cq *cq, void *cq_context)
@@ -1260,7 +1260,7 @@ int svc_rdma_send(struct svcxprt_rdma *x
 		spin_lock_bh(&xprt->sc_lock);
 		if (xprt->sc_sq_depth < atomic_read(&xprt->sc_sq_count) + wr_count) {
 			spin_unlock_bh(&xprt->sc_lock);
-			atomic_inc(&rdma_stat_sq_starve);
+			atomic_inc_unchecked(&rdma_stat_sq_starve);
 
 			/* See if we can opportunistically reap SQ WR to make room */
 			sq_cq_reap(xprt);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/tipc/eth_media.c linux-2.6.32.60-pax/net/tipc/eth_media.c
--- linux-2.6.32.60/net/tipc/eth_media.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/tipc/eth_media.c	2013-01-22 22:05:13.555688816 +0100
@@ -60,7 +60,6 @@ struct eth_bearer {
 
 static struct eth_bearer eth_bearers[MAX_ETH_BEARERS];
 static int eth_started = 0;
-static struct notifier_block notifier;
 
 /**
  * send_msg - send a TIPC message out over an Ethernet interface
@@ -258,6 +257,11 @@ static char *eth_addr2str(struct tipc_me
  * with OS for notifications about device state changes.
  */
 
+static struct notifier_block notifier = {
+	.notifier_call = &recv_notification,
+	.priority = 0,
+};
+
 int tipc_eth_media_start(void)
 {
 	struct tipc_media_addr bcast_addr;
@@ -278,8 +282,6 @@ int tipc_eth_media_start(void)
 	if (res)
 		return res;
 
-	notifier.notifier_call = &recv_notification;
-	notifier.priority = 0;
 	res = register_netdevice_notifier(&notifier);
 	if (!res)
 		eth_started = 1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/tipc/link.c linux-2.6.32.60-pax/net/tipc/link.c
--- linux-2.6.32.60/net/tipc/link.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/tipc/link.c	2012-03-13 13:15:36.056097941 +0100
@@ -1418,7 +1418,7 @@ again:
 
 		if (!sect_rest) {
 			sect_rest = msg_sect[++curr_sect].iov_len;
-			sect_crs = (const unchar *)msg_sect[curr_sect].iov_base;
+			sect_crs = (const unchar __user *)msg_sect[curr_sect].iov_base;
 		}
 
 		if (sect_rest < fragm_rest)
@@ -1437,7 +1437,7 @@ error:
 			}
 		} else
 			skb_copy_to_linear_data_offset(buf, fragm_crs,
-						       sect_crs, sz);
+						       (const void __force_kernel *)sect_crs, sz);
 		sect_crs += sz;
 		sect_rest -= sz;
 		fragm_crs += sz;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/tipc/subscr.c linux-2.6.32.60-pax/net/tipc/subscr.c
--- linux-2.6.32.60/net/tipc/subscr.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/tipc/subscr.c	2012-03-13 13:15:36.056097941 +0100
@@ -104,7 +104,7 @@ static void subscr_send_event(struct sub
 {
 	struct iovec msg_sect;
 
-	msg_sect.iov_base = (void *)&sub->evt;
+	msg_sect.iov_base = (void __force_user *)&sub->evt;
 	msg_sect.iov_len = sizeof(struct tipc_event);
 
 	sub->evt.event = htohl(event, sub->swap);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/wireless/wext.c linux-2.6.32.60-pax/net/wireless/wext.c
--- linux-2.6.32.60/net/wireless/wext.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/wireless/wext.c	2012-03-13 13:15:36.056097941 +0100
@@ -816,8 +816,7 @@ static int ioctl_standard_iw_point(struc
 		 */
 
 		/* Support for very large requests */
-		if ((descr->flags & IW_DESCR_FLAG_NOMAX) &&
-		    (user_length > descr->max_tokens)) {
+		if (user_length > descr->max_tokens) {
 			/* Allow userspace to GET more than max so
 			 * we can support any size GET requests.
 			 * There is still a limit : -ENOMEM.
@@ -854,22 +853,6 @@ static int ioctl_standard_iw_point(struc
 		}
 	}
 
-	if (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {
-		/*
-		 * If this is a GET, but not NOMAX, it means that the extra
-		 * data is not bounded by userspace, but by max_tokens. Thus
-		 * set the length to max_tokens. This matches the extra data
-		 * allocation.
-		 * The driver should fill it with the number of tokens it
-		 * provided, and it may check iwp->length rather than having
-		 * knowledge of max_tokens. If the driver doesn't change the
-		 * iwp->length, this ioctl just copies back max_token tokens
-		 * filled with zeroes. Hopefully the driver isn't claiming
-		 * them to be valid data.
-		 */
-		iwp->length = descr->max_tokens;
-	}
-
 	err = handler(dev, info, (union iwreq_data *) iwp, extra);
 
 	iwp->length += essid_compat;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/xfrm/xfrm_policy.c linux-2.6.32.60-pax/net/xfrm/xfrm_policy.c
--- linux-2.6.32.60/net/xfrm/xfrm_policy.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/xfrm/xfrm_policy.c	2012-03-13 13:15:36.060097940 +0100
@@ -586,7 +586,7 @@ int xfrm_policy_insert(int dir, struct x
 		hlist_add_head(&policy->bydst, chain);
 	xfrm_pol_hold(policy);
 	net->xfrm.policy_count[dir]++;
-	atomic_inc(&flow_cache_genid);
+	atomic_inc_unchecked(&flow_cache_genid);
 	if (delpol)
 		__xfrm_policy_unlink(delpol, dir);
 	policy->index = delpol ? delpol->index : xfrm_gen_index(net, dir);
@@ -669,7 +669,7 @@ struct xfrm_policy *xfrm_policy_bysel_ct
 	write_unlock_bh(&xfrm_policy_lock);
 
 	if (ret && delete) {
-		atomic_inc(&flow_cache_genid);
+		atomic_inc_unchecked(&flow_cache_genid);
 		xfrm_policy_kill(ret);
 	}
 	return ret;
@@ -710,7 +710,7 @@ struct xfrm_policy *xfrm_policy_byid(str
 	write_unlock_bh(&xfrm_policy_lock);
 
 	if (ret && delete) {
-		atomic_inc(&flow_cache_genid);
+		atomic_inc_unchecked(&flow_cache_genid);
 		xfrm_policy_kill(ret);
 	}
 	return ret;
@@ -824,7 +824,7 @@ int xfrm_policy_flush(struct net *net, u
 		}
 
 	}
-	atomic_inc(&flow_cache_genid);
+	atomic_inc_unchecked(&flow_cache_genid);
 out:
 	write_unlock_bh(&xfrm_policy_lock);
 	return err;
@@ -1088,7 +1088,7 @@ int xfrm_policy_delete(struct xfrm_polic
 	write_unlock_bh(&xfrm_policy_lock);
 	if (pol) {
 		if (dir < XFRM_POLICY_MAX)
-			atomic_inc(&flow_cache_genid);
+			atomic_inc_unchecked(&flow_cache_genid);
 		xfrm_policy_kill(pol);
 		return 0;
 	}
@@ -1477,7 +1477,7 @@ free_dst:
 	goto out;
 }
 
-static int inline
+static inline int
 xfrm_dst_alloc_copy(void **target, void *src, int size)
 {
 	if (!*target) {
@@ -1489,7 +1489,7 @@ xfrm_dst_alloc_copy(void **target, void
 	return 0;
 }
 
-static int inline
+static inline int
 xfrm_dst_update_parent(struct dst_entry *dst, struct xfrm_selector *sel)
 {
 #ifdef CONFIG_XFRM_SUB_POLICY
@@ -1501,7 +1501,7 @@ xfrm_dst_update_parent(struct dst_entry
 #endif
 }
 
-static int inline
+static inline int
 xfrm_dst_update_origin(struct dst_entry *dst, struct flowi *fl)
 {
 #ifdef CONFIG_XFRM_SUB_POLICY
@@ -1537,7 +1537,7 @@ int __xfrm_lookup(struct net *net, struc
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 
 restart:
-	genid = atomic_read(&flow_cache_genid);
+	genid = atomic_read_unchecked(&flow_cache_genid);
 	policy = NULL;
 	for (pi = 0; pi < ARRAY_SIZE(pols); pi++)
 		pols[pi] = NULL;
@@ -1680,7 +1680,7 @@ restart:
 					goto error;
 				}
 				if (nx == -EAGAIN ||
-				    genid != atomic_read(&flow_cache_genid)) {
+				    genid != atomic_read_unchecked(&flow_cache_genid)) {
 					xfrm_pols_put(pols, npols);
 					goto restart;
 				}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/net/xfrm/xfrm_state.c linux-2.6.32.60-pax/net/xfrm/xfrm_state.c
--- linux-2.6.32.60/net/xfrm/xfrm_state.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/net/xfrm/xfrm_state.c	2013-01-22 17:38:23.600543624 +0100
@@ -281,7 +281,9 @@ int xfrm_register_mode(struct xfrm_mode
 	if (!try_module_get(afinfo->owner))
 		goto out;
 
-	mode->afinfo = afinfo;
+	pax_open_kernel();
+	*(void **)&mode->afinfo = afinfo;
+	pax_close_kernel();
 	modemap[mode->encap] = mode;
 	err = 0;
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/basic/fixdep.c linux-2.6.32.60-pax/scripts/basic/fixdep.c
--- linux-2.6.32.60/scripts/basic/fixdep.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/basic/fixdep.c	2012-03-13 13:15:36.060097940 +0100
@@ -162,7 +162,7 @@ static void grow_config(int len)
 /*
  * Lookup a value in the configuration string.
  */
-static int is_defined_config(const char * name, int len)
+static int is_defined_config(const char * name, unsigned int len)
 {
 	const char * pconfig;
 	const char * plast = str_config + len_config - len;
@@ -199,7 +199,7 @@ static void clear_config(void)
 /*
  * Record the use of a CONFIG_* word.
  */
-static void use_config(char *m, int slen)
+static void use_config(char *m, unsigned int slen)
 {
 	char s[PATH_MAX];
 	char *p;
@@ -222,9 +222,9 @@ static void use_config(char *m, int slen
 
 static void parse_config_file(char *map, size_t len)
 {
-	int *end = (int *) (map + len);
+	unsigned int *end = (unsigned int *) (map + len);
 	/* start at +1, so that p can never be < map */
-	int *m   = (int *) map + 1;
+	unsigned int *m   = (unsigned int *) map + 1;
 	char *p, *q;
 
 	for (; m < end; m++) {
@@ -371,7 +371,7 @@ static void print_deps(void)
 static void traps(void)
 {
 	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
-	int *p = (int *)test;
+	unsigned int *p = (unsigned int *)test;
 
 	if (*p != INT_CONF) {
 		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/gcc-plugin.sh linux-2.6.32.60-pax/scripts/gcc-plugin.sh
--- linux-2.6.32.60/scripts/gcc-plugin.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/gcc-plugin.sh	2013-02-18 00:10:32.675770964 +0100
@@ -0,0 +1,17 @@
+#!/bin/bash
+plugincc=`$1 -E -shared - -o /dev/null -I\`$3 -print-file-name=plugin\`/include 2>&1 <<EOF
+#include "gcc-plugin.h"
+#include "tree.h"
+#include "tm.h"
+#include "rtl.h"
+#ifdef ENABLE_BUILD_WITH_CXX
+#warning $2
+#else
+#warning $1
+#endif
+EOF`
+if [ $? -eq 0 ]
+then
+	[[ "$plugincc" =~ "$1" ]] && echo "$1"
+	[[ "$plugincc" =~ "$2" ]] && echo "$2"
+fi
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/Makefile.build linux-2.6.32.60-pax/scripts/Makefile.build
--- linux-2.6.32.60/scripts/Makefile.build	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/Makefile.build	2012-06-18 00:30:55.470362264 +0200
@@ -59,7 +59,7 @@ endif
 endif
 
 # Do not include host rules unless needed
-ifneq ($(hostprogs-y)$(hostprogs-m),)
+ifneq ($(hostprogs-y)$(hostprogs-m)$(hostlibs-y)$(hostlibs-m)$(hostcxxlibs-y)$(hostcxxlibs-m),)
 include scripts/Makefile.host
 endif
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/Makefile.clean linux-2.6.32.60-pax/scripts/Makefile.clean
--- linux-2.6.32.60/scripts/Makefile.clean	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/Makefile.clean	2012-03-13 13:15:36.064097940 +0100
@@ -43,7 +43,8 @@ subdir-ymn	:= $(addprefix $(obj)/,$(subd
 __clean-files	:= $(extra-y) $(always)                  \
 		   $(targets) $(clean-files)             \
 		   $(host-progs)                         \
-		   $(hostprogs-y) $(hostprogs-m) $(hostprogs-)
+		   $(hostprogs-y) $(hostprogs-m) $(hostprogs-) \
+		   $(hostlibs-y) $(hostlibs-m) $(hostlibs-)
 
 # as clean-files is given relative to the current directory, this adds
 # a $(obj) prefix, except for absolute paths
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/Makefile.host linux-2.6.32.60-pax/scripts/Makefile.host
--- linux-2.6.32.60/scripts/Makefile.host	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/Makefile.host	2012-06-18 00:30:55.470362264 +0200
@@ -31,6 +31,8 @@
 # Note: Shared libraries consisting of C++ files are not supported
 
 __hostprogs := $(sort $(hostprogs-y) $(hostprogs-m))
+__hostlibs := $(sort $(hostlibs-y) $(hostlibs-m))
+__hostcxxlibs := $(sort $(hostcxxlibs-y) $(hostcxxlibs-m))
 
 # C code
 # Executables compiled from a single .c file
@@ -54,11 +56,15 @@ host-cxxobjs	:= $(sort $(foreach m,$(hos
 # Shared libaries (only .c supported)
 # Shared libraries (.so) - all .so files referenced in "xxx-objs"
 host-cshlib	:= $(sort $(filter %.so, $(host-cobjs)))
+host-cshlib	+= $(sort $(filter %.so, $(__hostlibs)))
+host-cxxshlib	:= $(sort $(filter %.so, $(__hostcxxlibs)))
 # Remove .so files from "xxx-objs"
 host-cobjs	:= $(filter-out %.so,$(host-cobjs))
+host-cxxobjs	:= $(filter-out %.so,$(host-cxxobjs))
 
-#Object (.o) files used by the shared libaries
+# Object (.o) files used by the shared libaries
 host-cshobjs	:= $(sort $(foreach m,$(host-cshlib),$($(m:.so=-objs))))
+host-cxxshobjs	:= $(sort $(foreach m,$(host-cxxshlib),$($(m:.so=-objs))))
 
 # output directory for programs/.o files
 # hostprogs-y := tools/build may have been specified. Retrieve directory
@@ -82,7 +88,9 @@ host-cobjs	:= $(addprefix $(obj)/,$(host
 host-cxxmulti	:= $(addprefix $(obj)/,$(host-cxxmulti))
 host-cxxobjs	:= $(addprefix $(obj)/,$(host-cxxobjs))
 host-cshlib	:= $(addprefix $(obj)/,$(host-cshlib))
+host-cxxshlib	:= $(addprefix $(obj)/,$(host-cxxshlib))
 host-cshobjs	:= $(addprefix $(obj)/,$(host-cshobjs))
+host-cxxshobjs	:= $(addprefix $(obj)/,$(host-cxxshobjs))
 host-objdirs    := $(addprefix $(obj)/,$(host-objdirs))
 
 obj-dirs += $(host-objdirs)
@@ -156,6 +164,13 @@ quiet_cmd_host-cshobjs	= HOSTCC  -fPIC $
 $(host-cshobjs): $(obj)/%.o: $(src)/%.c FORCE
 	$(call if_changed_dep,host-cshobjs)
 
+# Compile .c file, create position independent .o file
+# host-cxxshobjs -> .o
+quiet_cmd_host-cxxshobjs	= HOSTCXX -fPIC $@
+      cmd_host-cxxshobjs	= $(HOSTCXX) $(hostcxx_flags) -fPIC -c -o $@ $<
+$(host-cxxshobjs): $(obj)/%.o: $(src)/%.c FORCE
+	$(call if_changed_dep,host-cxxshobjs)
+
 # Link a shared library, based on position independent .o files
 # *.o -> .so shared library (host-cshlib)
 quiet_cmd_host-cshlib	= HOSTLLD -shared $@
@@ -165,6 +180,15 @@ quiet_cmd_host-cshlib	= HOSTLLD -shared
 $(host-cshlib): $(obj)/%: $(host-cshobjs) FORCE
 	$(call if_changed,host-cshlib)
 
+# Link a shared library, based on position independent .o files
+# *.o -> .so shared library (host-cxxshlib)
+quiet_cmd_host-cxxshlib	= HOSTLLD -shared $@
+      cmd_host-cxxshlib	= $(HOSTCXX) $(HOSTLDFLAGS) -shared -o $@ \
+			  $(addprefix $(obj)/,$($(@F:.so=-objs))) \
+			  $(HOST_LOADLIBES) $(HOSTLOADLIBES_$(@F))
+$(host-cxxshlib): $(obj)/%: $(host-cxxshobjs) FORCE
+	$(call if_changed,host-cxxshlib)
+
 targets += $(host-csingle)  $(host-cmulti) $(host-cobjs)\
-	   $(host-cxxmulti) $(host-cxxobjs) $(host-cshlib) $(host-cshobjs) 
+	   $(host-cxxmulti) $(host-cxxobjs) $(host-cshlib) $(host-cshobjs) $(host-cxxshlib) $(host-cxxshobjs)
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/mod/file2alias.c linux-2.6.32.60-pax/scripts/mod/file2alias.c
--- linux-2.6.32.60/scripts/mod/file2alias.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/mod/file2alias.c	2012-03-13 13:15:36.064097940 +0100
@@ -72,7 +72,7 @@ static void device_id_check(const char *
 			    unsigned long size, unsigned long id_size,
 			    void *symval)
 {
-	int i;
+	unsigned int i;
 
 	if (size % id_size || size < id_size) {
 		if (cross_build != 0)
@@ -102,7 +102,7 @@ static void device_id_check(const char *
 /* USB is special because the bcdDevice can be matched against a numeric range */
 /* Looks like "usb:vNpNdNdcNdscNdpNicNiscNipN" */
 static void do_usb_entry(struct usb_device_id *id,
-			 unsigned int bcdDevice_initial, int bcdDevice_initial_digits,
+			 unsigned int bcdDevice_initial, unsigned int bcdDevice_initial_digits,
 			 unsigned char range_lo, unsigned char range_hi,
 			 struct module *mod)
 {
@@ -151,7 +151,7 @@ static void do_usb_entry_multi(struct us
 {
 	unsigned int devlo, devhi;
 	unsigned char chi, clo;
-	int ndigits;
+	unsigned int ndigits;
 
 	id->match_flags = TO_NATIVE(id->match_flags);
 	id->idVendor = TO_NATIVE(id->idVendor);
@@ -368,7 +368,7 @@ static void do_pnp_device_entry(void *sy
 	for (i = 0; i < count; i++) {
 		const char *id = (char *)devs[i].id;
 		char acpi_id[sizeof(devs[0].id)];
-		int j;
+		unsigned int j;
 
 		buf_printf(&mod->dev_table_buf,
 			   "MODULE_ALIAS(\"pnp:d%s*\");\n", id);
@@ -398,7 +398,7 @@ static void do_pnp_card_entries(void *sy
 
 		for (j = 0; j < PNP_MAX_DEVICES; j++) {
 			const char *id = (char *)card->devs[j].id;
-			int i2, j2;
+			unsigned int i2, j2;
 			int dup = 0;
 
 			if (!id[0])
@@ -424,7 +424,7 @@ static void do_pnp_card_entries(void *sy
 			/* add an individual alias for every device entry */
 			if (!dup) {
 				char acpi_id[sizeof(card->devs[0].id)];
-				int k;
+				unsigned int k;
 
 				buf_printf(&mod->dev_table_buf,
 					   "MODULE_ALIAS(\"pnp:d%s*\");\n", id);
@@ -699,7 +699,7 @@ static void dmi_ascii_filter(char *d, co
 static int do_dmi_entry(const char *filename, struct dmi_system_id *id,
 			char *alias)
 {
-	int i, j;
+	unsigned int i, j;
 
 	sprintf(alias, "dmi*");
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/mod/modpost.c linux-2.6.32.60-pax/scripts/mod/modpost.c
--- linux-2.6.32.60/scripts/mod/modpost.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/mod/modpost.c	2012-07-21 11:31:08.429077980 +0200
@@ -764,7 +764,7 @@ static void check_section(const char *mo
 
 #define ALL_INIT_DATA_SECTIONS \
 	".init.setup$", ".init.rodata$", \
-	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$" \
+	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$", \
 	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
 	".exit.data$", ".devexit.data$", ".cpuexit.data$", ".memexit.data$"
@@ -835,6 +835,7 @@ enum mismatch {
 	INIT_TO_EXIT,
 	EXIT_TO_INIT,
 	EXPORT_TO_INIT_EXIT,
+	DATA_TO_TEXT
 };
 
 struct sectioncheck {
@@ -920,6 +921,12 @@ const struct sectioncheck sectioncheck[]
 	.fromsec = { "__ksymtab*", NULL },
 	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
 	.mismatch = EXPORT_TO_INIT_EXIT
+},
+/* Do not reference code from writable data */
+{
+	.fromsec = { DATA_SECTIONS, NULL },
+	.tosec   = { TEXT_SECTIONS, NULL },
+	.mismatch = DATA_TO_TEXT
 }
 };
 
@@ -1024,10 +1031,10 @@ static Elf_Sym *find_elf_symbol(struct e
 			continue;
 		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
 			continue;
-		if (sym->st_value == addr)
-			return sym;
 		/* Find a symbol nearby - addr are maybe negative */
 		d = sym->st_value - addr;
+		if (d == 0)
+			return sym;
 		if (d < 0)
 			d = addr - sym->st_value;
 		if (d < distance) {
@@ -1268,6 +1275,14 @@ static void report_sec_mismatch(const ch
 		"Fix this by removing the %sannotation of %s "
 		"or drop the export.\n",
 		tosym, sec2annotation(tosec), sec2annotation(tosec), tosym);
+	case DATA_TO_TEXT:
+#if 0
+		fprintf(stderr,
+		"The %s %s:%s references\n"
+		"the %s %s:%s%s\n",
+		from, fromsec, fromsym, to, tosec, tosym, to_p);
+#endif
+		break;
 	case NO_MISMATCH:
 		/* To get warnings on missing members */
 		break;
@@ -1495,7 +1510,7 @@ static void section_rel(const char *modn
 static void check_sec_ref(struct module *mod, const char *modname,
                           struct elf_info *elf)
 {
-	int i;
+	unsigned int i;
 	Elf_Shdr *sechdrs = elf->sechdrs;
 
 	/* Walk through all sections */
@@ -1651,7 +1666,7 @@ void __attribute__((format(printf, 2, 3)
 	va_end(ap);
 }
 
-void buf_write(struct buffer *buf, const char *s, int len)
+void buf_write(struct buffer *buf, const char *s, unsigned int len)
 {
 	if (buf->size - buf->pos < len) {
 		buf->size += len + SZ;
@@ -1863,7 +1878,7 @@ static void write_if_changed(struct buff
 	if (fstat(fileno(file), &st) < 0)
 		goto close_write;
 
-	if (st.st_size != b->pos)
+	if (st.st_size != (off_t)b->pos)
 		goto close_write;
 
 	tmp = NOFAIL(malloc(b->pos));
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/mod/modpost.h linux-2.6.32.60-pax/scripts/mod/modpost.h
--- linux-2.6.32.60/scripts/mod/modpost.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/mod/modpost.h	2012-03-13 13:15:36.068097940 +0100
@@ -92,15 +92,15 @@ void *do_nofail(void *ptr, const char *e
 
 struct buffer {
 	char *p;
-	int pos;
-	int size;
+	unsigned int pos;
+	unsigned int size;
 };
 
 void __attribute__((format(printf, 2, 3)))
 buf_printf(struct buffer *buf, const char *fmt, ...);
 
 void
-buf_write(struct buffer *buf, const char *s, int len);
+buf_write(struct buffer *buf, const char *s, unsigned int len);
 
 struct module {
 	struct module *next;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/mod/sumversion.c linux-2.6.32.60-pax/scripts/mod/sumversion.c
--- linux-2.6.32.60/scripts/mod/sumversion.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/mod/sumversion.c	2012-03-13 13:15:36.068097940 +0100
@@ -455,7 +455,7 @@ static void write_version(const char *fi
 		goto out;
 	}
 
-	if (write(fd, sum, strlen(sum)+1) != strlen(sum)+1) {
+	if (write(fd, sum, strlen(sum)+1) != (ssize_t)strlen(sum)+1) {
 		warn("writing sum in %s failed: %s\n",
 			filename, strerror(errno));
 		goto out;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/package/mkspec linux-2.6.32.60-pax/scripts/package/mkspec
--- linux-2.6.32.60/scripts/package/mkspec	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/package/mkspec	2012-03-13 13:15:36.068097940 +0100
@@ -70,7 +70,7 @@ echo 'mkdir -p $RPM_BUILD_ROOT/boot $RPM
 echo 'mkdir -p $RPM_BUILD_ROOT/lib/firmware'
 echo "%endif"
 
-echo 'INSTALL_MOD_PATH=$RPM_BUILD_ROOT make %{_smp_mflags} KBUILD_SRC= modules_install'
+echo 'INSTALL_MOD_PATH=$RPM_BUILD_ROOT make %{?_smp_mflags} KBUILD_SRC= modules_install'
 echo "%ifarch ia64"
 echo 'cp $KBUILD_IMAGE $RPM_BUILD_ROOT'"/boot/efi/vmlinuz-$KERNELRELEASE"
 echo 'ln -s '"efi/vmlinuz-$KERNELRELEASE" '$RPM_BUILD_ROOT'"/boot/"
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/pnmtologo.c linux-2.6.32.60-pax/scripts/pnmtologo.c
--- linux-2.6.32.60/scripts/pnmtologo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/pnmtologo.c	2012-03-13 13:15:36.068097940 +0100
@@ -237,14 +237,14 @@ static void write_header(void)
     fprintf(out, " *  Linux logo %s\n", logoname);
     fputs(" */\n\n", out);
     fputs("#include <linux/linux_logo.h>\n\n", out);
-    fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
+    fprintf(out, "static unsigned char %s_data[] = {\n",
 	    logoname);
 }
 
 static void write_footer(void)
 {
     fputs("\n};\n\n", out);
-    fprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);
+    fprintf(out, "const struct linux_logo %s = {\n", logoname);
     fprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);
     fprintf(out, "\t.width\t\t= %d,\n", logo_width);
     fprintf(out, "\t.height\t\t= %d,\n", logo_height);
@@ -374,7 +374,7 @@ static void write_logo_clut224(void)
     fputs("\n};\n\n", out);
 
     /* write logo clut */
-    fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
+    fprintf(out, "static unsigned char %s_clut[] = {\n",
 	    logoname);
     write_hex_cnt = 0;
     for (i = 0; i < logo_clutsize; i++) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/scripts/tags.sh linux-2.6.32.60-pax/scripts/tags.sh
--- linux-2.6.32.60/scripts/tags.sh	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/scripts/tags.sh	2012-04-03 21:30:53.934006929 +0200
@@ -93,6 +93,11 @@ docscope()
 	cscope -b -f cscope.out
 }
 
+dogtags()
+{
+	all_sources | gtags -i -f -
+}
+
 exuberant()
 {
 	all_sources | xargs $1 -a                               \
@@ -164,6 +169,10 @@ case "$1" in
 		docscope
 		;;
 
+	"gtags")
+		dogtags
+		;;
+
 	"tags")
 		rm -f tags
 		xtags ctags
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/capability.c linux-2.6.32.60-pax/security/capability.c
--- linux-2.6.32.60/security/capability.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/capability.c	2012-03-13 13:15:36.072097940 +0100
@@ -890,7 +890,7 @@ static void cap_audit_rule_free(void *ls
 }
 #endif /* CONFIG_AUDIT */
 
-struct security_operations default_security_ops = {
+struct security_operations default_security_ops __read_only = {
 	.name	= "default",
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/integrity/ima/ima_api.c linux-2.6.32.60-pax/security/integrity/ima/ima_api.c
--- linux-2.6.32.60/security/integrity/ima/ima_api.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/integrity/ima/ima_api.c	2012-03-13 13:15:36.072097940 +0100
@@ -74,7 +74,7 @@ void ima_add_violation(struct inode *ino
 	int result;
 
 	/* can overflow, only indicator */
-	atomic_long_inc(&ima_htable.violations);
+	atomic_long_inc_unchecked(&ima_htable.violations);
 
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry) {
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/integrity/ima/ima_fs.c linux-2.6.32.60-pax/security/integrity/ima/ima_fs.c
--- linux-2.6.32.60/security/integrity/ima/ima_fs.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/integrity/ima/ima_fs.c	2012-03-13 13:15:36.072097940 +0100
@@ -27,12 +27,12 @@
 static int valid_policy = 1;
 #define TMPBUFLEN 12
 static ssize_t ima_show_htable_value(char __user *buf, size_t count,
-				     loff_t *ppos, atomic_long_t *val)
+				     loff_t *ppos, atomic_long_unchecked_t *val)
 {
 	char tmpbuf[TMPBUFLEN];
 	ssize_t len;
 
-	len = scnprintf(tmpbuf, TMPBUFLEN, "%li\n", atomic_long_read(val));
+	len = scnprintf(tmpbuf, TMPBUFLEN, "%li\n", atomic_long_read_unchecked(val));
 	return simple_read_from_buffer(buf, count, ppos, tmpbuf, len);
 }
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/integrity/ima/ima.h linux-2.6.32.60-pax/security/integrity/ima/ima.h
--- linux-2.6.32.60/security/integrity/ima/ima.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/integrity/ima/ima.h	2012-03-13 13:15:36.072097940 +0100
@@ -84,8 +84,8 @@ void ima_add_violation(struct inode *ino
 extern spinlock_t ima_queue_lock;
 
 struct ima_h_table {
-	atomic_long_t len;	/* number of stored measurements in the list */
-	atomic_long_t violations;
+	atomic_long_unchecked_t len;	/* number of stored measurements in the list */
+	atomic_long_unchecked_t violations;
 	struct hlist_head queue[IMA_MEASURE_HTABLE_SIZE];
 };
 extern struct ima_h_table ima_htable;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/integrity/ima/ima_queue.c linux-2.6.32.60-pax/security/integrity/ima/ima_queue.c
--- linux-2.6.32.60/security/integrity/ima/ima_queue.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/integrity/ima/ima_queue.c	2012-03-13 13:15:36.072097940 +0100
@@ -78,7 +78,7 @@ static int ima_add_digest_entry(struct i
 	INIT_LIST_HEAD(&qe->later);
 	list_add_tail_rcu(&qe->later, &ima_measurements);
 
-	atomic_long_inc(&ima_htable.len);
+	atomic_long_inc_unchecked(&ima_htable.len);
 	key = ima_hash_key(entry->digest);
 	hlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);
 	return 0;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/Kconfig linux-2.6.32.60-pax/security/Kconfig
--- linux-2.6.32.60/security/Kconfig	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/Kconfig	2013-02-17 17:18:15.220161736 +0100
@@ -4,6 +4,656 @@
 
 menu "Security options"
 
+menu "PaX"
+
+	config ARCH_TRACK_EXEC_LIMIT
+	bool
+
+	config PAX_KERNEXEC_PLUGIN
+	bool
+
+	config PAX_PER_CPU_PGD
+	bool
+
+	config TASK_SIZE_MAX_SHIFT
+	int
+	depends on X86_64
+	default 47 if !PAX_PER_CPU_PGD
+	default 42 if PAX_PER_CPU_PGD
+
+	config PAX_USERCOPY_SLABS
+	bool
+
+config PAX
+	bool "Enable various PaX features"
+	depends on ALPHA || ARM || AVR32 || IA64 || MIPS || PARISC || PPC || SPARC || X86
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+menu "PaX Control"
+	depends on PAX
+
+config PAX_SOFTMODE
+	bool 'Support soft mode'
+	help
+	  Enabling this option will allow you to run PaX in soft mode, that
+	  is, PaX features will not be enforced by default, only on executables
+	  marked explicitly.  You must also enable PT_PAX_FLAGS or XATTR_PAX_FLAGS
+	  support as they are the only way to mark executables for soft mode use.
+
+	  Soft mode can be activated by using the "pax_softmode=1" kernel command
+	  line option on boot.  Furthermore you can control various PaX features
+	  at runtime via the entries in /proc/sys/kernel/pax.
+
+config PAX_EI_PAX
+	bool 'Use legacy ELF header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'chpax' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  an otherwise reserved part of the ELF header.  This marking has
+	  numerous drawbacks (no support for soft-mode, toolchain does not
+	  know about the non-standard use of the ELF header) therefore it
+	  has been deprecated in favour of PT_PAX_FLAGS and XATTR_PAX_FLAGS
+	  support.
+
+	  Note that if you enable PT_PAX_FLAGS or XATTR_PAX_FLAGS marking
+	  support as well, they will override the legacy EI_PAX marks.
+
+	  If you enable none of the marking options then all applications
+	  will run with PaX enabled on them by default.
+
+config PAX_PT_PAX_FLAGS
+	bool 'Use ELF program header marking'
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'paxctl' utility available at
+	  http://pax.grsecurity.net/.  The control flags will be read from
+	  a PaX specific ELF program header (PT_PAX_FLAGS).  This marking
+	  has the benefits of supporting both soft mode and being fully
+	  integrated into the toolchain (the binutils patch is available
+	  from http://pax.grsecurity.net).
+
+	  Note that if you enable the legacy EI_PAX marking support as well,
+	  the EI_PAX marks will be overridden by the PT_PAX_FLAGS marks.
+
+	  If you enable both PT_PAX_FLAGS and XATTR_PAX_FLAGS support then you
+	  must make sure that the marks are the same if a binary has both marks.
+
+	  If you enable none of the marking options then all applications
+	  will run with PaX enabled on them by default.
+
+config PAX_XATTR_PAX_FLAGS
+	bool 'Use filesystem extended attributes marking'
+	select CIFS_XATTR if CIFS
+	select EXT2_FS_XATTR if EXT2_FS
+	select EXT3_FS_XATTR if EXT3_FS
+	select EXT4_FS_XATTR if EXT4_FS
+	select JFFS2_FS_XATTR if JFFS2_FS
+	select REISERFS_FS_XATTR if REISERFS_FS
+	select UBIFS_FS_XATTR if UBIFS_FS
+	help
+	  Enabling this option will allow you to control PaX features on
+	  a per executable basis via the 'setfattr' utility.  The control
+	  flags will be read from the user.pax.flags extended attribute of
+	  the file.  This marking has the benefit of supporting binary-only
+	  applications that self-check themselves (e.g., skype) and would
+	  not tolerate chpax/paxctl changes.  The main drawback is that
+	  extended attributes are not supported by some filesystems (e.g.,
+	  isofs, squashfs, tmpfs, udf, vfat) so copying files through such
+	  filesystems will lose the extended attributes and these PaX markings.
+
+	  Note that if you enable the legacy EI_PAX marking support as well,
+	  the EI_PAX marks will be overridden by the XATTR_PAX_FLAGS marks.
+
+	  If you enable both PT_PAX_FLAGS and XATTR_PAX_FLAGS support then you
+	  must make sure that the marks are the same if a binary has both marks.
+
+	  If you enable none of the marking options then all applications
+	  will run with PaX enabled on them by default.
+
+choice
+	prompt 'MAC system integration'
+	default PAX_NO_ACL_FLAGS
+	help
+	  Mandatory Access Control systems have the option of controlling
+	  PaX flags on a per executable basis, choose the method supported
+	  by your particular system.
+
+	  - "none": if your MAC system does not interact with PaX,
+	  - "direct": if your MAC system defines pax_set_initial_flags() itself,
+	  - "hook": if your MAC system uses the pax_set_initial_flags_func callback.
+
+	  NOTE: this option is for developers/integrators only.
+
+	config PAX_NO_ACL_FLAGS
+		bool 'none'
+
+	config PAX_HAVE_ACL_FLAGS
+		bool 'direct'
+
+	config PAX_HOOK_ACL_FLAGS
+		bool 'hook'
+endchoice
+
+endmenu
+
+menu "Non-executable pages"
+	depends on PAX
+
+config PAX_NOEXEC
+	bool "Enforce non-executable pages"
+	depends on ALPHA || (ARM && (CPU_V6 || CPU_V7)) || IA64 || MIPS || PARISC || PPC || S390 || SPARC || X86
+	help
+	  By design some architectures do not allow for protecting memory
+	  pages against execution or even if they do, Linux does not make
+	  use of this feature.  In practice this means that if a page is
+	  readable (such as the stack or heap) it is also executable.
+
+	  There is a well known exploit technique that makes use of this
+	  fact and a common programming mistake where an attacker can
+	  introduce code of his choice somewhere in the attacked program's
+	  memory (typically the stack or the heap) and then execute it.
+
+	  If the attacked program was running with different (typically
+	  higher) privileges than that of the attacker, then he can elevate
+	  his own privilege level (e.g. get a root shell, write to files for
+	  which he does not have write access to, etc).
+
+	  Enabling this option will let you choose from various features
+	  that prevent the injection and execution of 'foreign' code in
+	  a program.
+
+	  This will also break programs that rely on the old behaviour and
+	  expect that dynamically allocated memory via the malloc() family
+	  of functions is executable (which it is not).  Notable examples
+	  are the XFree86 4.x server, the java runtime and wine.
+
+config PAX_PAGEEXEC
+	bool "Paging based non-executable pages"
+	depends on PAX_NOEXEC && (!X86_32 || M586 || M586TSC || M586MMX || M686 || MPENTIUMII || MPENTIUMIII || MPENTIUMM || MCORE2 || MPENTIUM4 || MPSC || MATOM || MK7 || MK8 || MWINCHIPC6 || MWINCHIP2 || MWINCHIP3D || MVIAC3_2 || MVIAC7)
+	select X86_PAE if X86_32 && !HIGHMEM4G && (MCORE2 || MPSC || MATOM || MK8)
+	select ARCH_TRACK_EXEC_LIMIT if X86_32
+	select S390_SWITCH_AMODE if S390
+	select S390_EXEC_PROTECT if S390
+	help
+	  This implementation is based on the paging feature of the CPU.
+	  On i386 without hardware non-executable bit support there is a
+	  variable but usually low performance impact, however on Intel's
+	  P4 core based CPUs it is very high so you should not enable this
+	  for kernels meant to be used on such CPUs.
+
+	  On alpha, avr32, ia64, parisc, sparc, sparc64, x86_64 and i386
+	  with hardware non-executable bit support there is no performance
+	  impact, on ppc the impact is negligible.
+
+	  Note that several architectures require various emulations due to
+	  badly designed userland ABIs, this will cause a performance impact
+	  but will disappear as soon as userland is fixed. For example, ppc
+	  userland MUST have been built with secure-plt by a recent toolchain.
+
+config PAX_SEGMEXEC
+	bool "Segmentation based non-executable pages"
+	depends on PAX_NOEXEC && X86_32
+	help
+	  This implementation is based on the segmentation feature of the
+	  CPU and has a very small performance impact, however applications
+	  will be limited to a 1.5 GB address space instead of the normal
+	  3 GB.
+
+config PAX_EMUTRAMP
+	bool "Emulate trampolines" if (PAX_PAGEEXEC || PAX_SEGMEXEC) && (PARISC || X86)
+	default y if PARISC
+	help
+	  There are some programs and libraries that for one reason or
+	  another attempt to execute special small code snippets from
+	  non-executable memory pages.  Most notable examples are the
+	  signal handler return code generated by the kernel itself and
+	  the GCC trampolines.
+
+	  If you enabled CONFIG_PAX_PAGEEXEC or CONFIG_PAX_SEGMEXEC then
+	  such programs will no longer work under your kernel.
+
+	  As a remedy you can say Y here and use the 'chpax' or 'paxctl'
+	  utilities to enable trampoline emulation for the affected programs
+	  yet still have the protection provided by the non-executable pages.
+
+	  On parisc you MUST enable this option and EMUSIGRT as well, otherwise
+	  your system will not even boot.
+
+	  Alternatively you can say N here and use the 'chpax' or 'paxctl'
+	  utilities to disable CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC
+	  for the affected files.
+
+	  NOTE: enabling this feature *may* open up a loophole in the
+	  protection provided by non-executable pages that an attacker
+	  could abuse.  Therefore the best solution is to not have any
+	  files on your system that would require this option.  This can
+	  be achieved by not using libc5 (which relies on the kernel
+	  signal handler return code) and not using or rewriting programs
+	  that make use of the nested function implementation of GCC.
+	  Skilled users can just fix GCC itself so that it implements
+	  nested function calls in a way that does not interfere with PaX.
+
+config PAX_EMUSIGRT
+	bool "Automatically emulate sigreturn trampolines"
+	depends on PAX_EMUTRAMP && PARISC
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate signal return trampolines executing on the stack
+	  that would otherwise lead to task termination.
+
+	  This solution is intended as a temporary one for users with
+	  legacy versions of libc (libc5, glibc 2.0, uClibc before 0.9.17,
+	  Modula-3 runtime, etc) or executables linked to such, basically
+	  everything that does not specify its own SA_RESTORER function in
+	  normal executable memory like glibc 2.1+ does.
+
+	  On parisc you MUST enable this option, otherwise your system will
+	  not even boot.
+
+	  NOTE: this feature cannot be disabled on a per executable basis
+	  and since it *does* open up a loophole in the protection provided
+	  by non-executable pages, the best solution is to not have any
+	  files on your system that would require this option.
+
+config PAX_MPROTECT
+	bool "Restrict mprotect()"
+	depends on (PAX_PAGEEXEC || PAX_SEGMEXEC)
+	help
+	  Enabling this option will prevent programs from
+	   - changing the executable status of memory pages that were
+	     not originally created as executable,
+	   - making read-only executable pages writable again,
+	   - creating executable pages from anonymous memory,
+	   - making read-only-after-relocations (RELRO) data pages writable again.
+
+	  You should say Y here to complete the protection provided by
+	  the enforcement of non-executable pages.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_ELFRELOCS
+	bool "Allow ELF text relocations"
+	depends on PAX_MPROTECT
+	default n
+	help
+	  Non-executable pages and mprotect() restrictions are effective
+	  in preventing the introduction of new executable code into an
+	  attacked task's address space.  There remain only two venues
+	  for this kind of attack: if the attacker can execute already
+	  existing code in the attacked task then he can either have it
+	  create and mmap() a file containing his code or have it mmap()
+	  an already existing ELF library that does not have position
+	  independent code in it and use mprotect() on it to make it
+	  writable and copy his code there.  While protecting against
+	  the former approach is beyond PaX, the latter can be prevented
+	  by having only PIC ELF libraries on one's system (which do not
+	  need to relocate their code).  If you are sure this is your case,
+	  then disable this option otherwise be careful as you may not even
+	  be able to boot or log on your system (for example, some PAM
+	  modules are erroneously compiled as non-PIC by default).
+
+	  NOTE: if you are using dynamic ELF executables (as suggested
+	  when using ASLR) then you must have made sure that you linked
+	  your files using the PIC version of crt1 (the et_dyn.tar.gz package
+	  referenced there has already been updated to support this).
+
+config PAX_ETEXECRELOCS
+	bool "Allow ELF ET_EXEC text relocations"
+	depends on PAX_MPROTECT && (ALPHA || IA64 || PARISC)
+	select PAX_ELFRELOCS
+	default y
+	help
+	  On some architectures there are incorrectly created applications
+	  that require text relocations and would not work without enabling
+	  this option.  If you are an alpha, ia64 or parisc user, you should
+	  enable this option and disable it once you have made sure that
+	  none of your applications need it.
+
+config PAX_EMUPLT
+	bool "Automatically emulate ELF PLT"
+	depends on PAX_MPROTECT && (ALPHA || PARISC || SPARC)
+	default y
+	help
+	  Enabling this option will have the kernel automatically detect
+	  and emulate the Procedure Linkage Table entries in ELF files.
+	  On some architectures such entries are in writable memory, and
+	  become non-executable leading to task termination.  Therefore
+	  it is mandatory that you enable this option on alpha, parisc,
+	  sparc and sparc64, otherwise your system would not even boot.
+
+	  NOTE: this feature *does* open up a loophole in the protection
+	  provided by the non-executable pages, therefore the proper
+	  solution is to modify the toolchain to produce a PLT that does
+	  not need to be writable.
+
+config PAX_DLRESOLVE
+	bool 'Emulate old glibc resolver stub'
+	depends on PAX_EMUPLT && SPARC
+	default n
+	help
+	  This option is needed if userland has an old glibc (before 2.4)
+	  that puts a 'save' instruction into the runtime generated resolver
+	  stub that needs special emulation.
+
+config PAX_KERNEXEC
+	bool "Enforce non-executable kernel pages"
+	depends on X86 && !XEN && (!X86_32 || X86_WP_WORKS_OK)
+	select PAX_PER_CPU_PGD if X86_64 || (X86_32 && X86_PAE)
+	select PAX_KERNEXEC_PLUGIN if X86_64
+	help
+	  This is the kernel land equivalent of PAGEEXEC and MPROTECT,
+	  that is, enabling this option will make it harder to inject
+	  and execute 'foreign' code in kernel memory itself.
+
+choice
+	prompt "Return Address Instrumentation Method"
+	default PAX_KERNEXEC_PLUGIN_METHOD_BTS
+	depends on PAX_KERNEXEC_PLUGIN
+	help
+	  Select the method used to instrument function pointer dereferences.
+	  Note that binary modules cannot be instrumented by this approach.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+
+	config PAX_KERNEXEC_PLUGIN_METHOD_BTS
+		bool "bts"
+		help
+		  This method is compatible with binary only modules but has
+		  a higher runtime overhead.
+
+	config PAX_KERNEXEC_PLUGIN_METHOD_OR
+		bool "or"
+		depends on !PARAVIRT
+		help
+		  This method is incompatible with binary only modules but has
+		  a lower runtime overhead.
+endchoice
+
+config PAX_KERNEXEC_PLUGIN_METHOD
+	string
+	default "bts" if PAX_KERNEXEC_PLUGIN_METHOD_BTS
+	default "or" if PAX_KERNEXEC_PLUGIN_METHOD_OR
+	default ""
+
+config PAX_KERNEXEC_MODULE_TEXT
+	int "Minimum amount of memory reserved for module code"
+	default "4"
+	depends on PAX_KERNEXEC && X86_32 && MODULES
+	help
+	  Due to implementation details the kernel must reserve a fixed
+	  amount of memory for module code at compile time that cannot be
+	  changed at runtime.  Here you can specify the minimum amount
+	  in MB that will be reserved.  Due to the same implementation
+	  details this size will always be rounded up to the next 2/4 MB
+	  boundary (depends on PAE) so the actually available memory for
+	  module code will usually be more than this minimum.
+
+	  The default 4 MB should be enough for most users but if you have
+	  an excessive number of modules (e.g., most distribution configs
+	  compile many drivers as modules) or use huge modules such as
+	  nvidia's kernel driver, you will need to adjust this amount.
+	  A good rule of thumb is to look at your currently loaded kernel
+	  modules and add up their sizes.
+
+endmenu
+
+menu "Address Space Layout Randomization"
+	depends on PAX
+
+config PAX_ASLR
+	bool "Address Space Layout Randomization"
+	help
+	  Many if not most exploit techniques rely on the knowledge of
+	  certain addresses in the attacked program.  The following options
+	  will allow the kernel to apply a certain amount of randomization
+	  to specific parts of the program thereby forcing an attacker to
+	  guess them in most cases.  Any failed guess will most likely crash
+	  the attacked program which allows the kernel to detect such attempts
+	  and react on them.  PaX itself provides no reaction mechanisms,
+	  instead it is strongly encouraged that you make use of Nergal's
+	  segvguard (ftp://ftp.pl.openwall.com/misc/segvguard/) or grsecurity's
+	  (http://www.grsecurity.net/) built-in crash detection features or
+	  develop one yourself.
+
+	  By saying Y here you can choose to randomize the following areas:
+	   - top of the task's kernel stack
+	   - top of the task's userland stack
+	   - base address for mmap() requests that do not specify one
+	     (this includes all libraries)
+	   - base address of the main executable
+
+	  It is strongly recommended to say Y here as address space layout
+	  randomization has negligible impact on performance yet it provides
+	  a very effective protection.
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control
+	  this feature on a per file basis.
+
+config PAX_RANDKSTACK
+	bool "Randomize kernel stack base"
+	depends on X86_TSC && X86
+	help
+	  By saying Y here the kernel will randomize every task's kernel
+	  stack on every system call.  This will not only force an attacker
+	  to guess it but also prevent him from making use of possible
+	  leaked information about it.
+
+	  Since the kernel stack is a rather scarce resource, randomization
+	  may cause unexpected stack overflows, therefore you should very
+	  carefully test your system.  Note that once enabled in the kernel
+	  configuration, this feature cannot be disabled on a per file basis.
+
+config PAX_RANDUSTACK
+	bool "Randomize user stack base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will randomize every task's userland
+	  stack.  The randomization is done in two steps where the second
+	  one may apply a big amount of shift to the top of the stack and
+	  cause problems for programs that want to use lots of memory (more
+	  than 2.5 GB if SEGMEXEC is not active, or 1.25 GB when it is).
+	  For this reason the second step can be controlled by 'chpax' or
+	  'paxctl' on a per file basis.
+
+config PAX_RANDMMAP
+	bool "Randomize mmap() base"
+	depends on PAX_ASLR
+	help
+	  By saying Y here the kernel will use a randomized base address for
+	  mmap() requests that do not specify one themselves.  As a result
+	  all dynamically loaded libraries will appear at random addresses
+	  and therefore be harder to exploit by a technique where an attacker
+	  attempts to execute library code for his purposes (e.g. spawn a
+	  shell from an exploited program that is running at an elevated
+	  privilege level).
+
+	  Furthermore, if a program is relinked as a dynamic ELF file, its
+	  base address will be randomized as well, completing the full
+	  randomization of the address space layout.  Attacking such programs
+	  becomes a guess game.  You can find an example of doing this at
+	  http://pax.grsecurity.net/et_dyn.tar.gz and practical samples at
+	  http://www.grsecurity.net/grsec-gcc-specs.tar.gz .
+
+	  NOTE: you can use the 'chpax' or 'paxctl' utilities to control this
+	  feature on a per file basis.
+
+endmenu
+
+menu "Miscellaneous hardening features"
+
+config PAX_MEMORY_SANITIZE
+	bool "Sanitize all freed memory"
+	depends on !HIBERNATION
+	help
+	  By saying Y here the kernel will erase memory pages as soon as they
+	  are freed.  This in turn reduces the lifetime of data stored in the
+	  pages, making it less likely that sensitive information such as
+	  passwords, cryptographic secrets, etc stay in memory for too long.
+
+	  This is especially useful for programs whose runtime is short, long
+	  lived processes and the kernel itself benefit from this as long as
+	  they operate on whole memory pages and ensure timely freeing of pages
+	  that may hold sensitive information.
+
+	  The tradeoff is performance impact, on a single CPU system kernel
+	  compilation sees a 3% slowdown, other systems and workloads may vary
+	  and you are advised to test this feature on your expected workload
+	  before deploying it.
+
+	  Note that this feature does not protect data stored in live pages,
+	  e.g., process memory swapped to disk may stay there for a long time.
+
+config PAX_MEMORY_STACKLEAK
+	bool "Sanitize kernel stack"
+	depends on X86
+	help
+	  By saying Y here the kernel will erase the kernel stack before it
+	  returns from a system call.  This in turn reduces the information
+	  that a kernel stack leak bug can reveal.
+
+	  Note that such a bug can still leak information that was put on
+	  the stack by the current system call (the one eventually triggering
+	  the bug) but traces of earlier system calls on the kernel stack
+	  cannot leak anymore.
+
+	  The tradeoff is performance impact, on a single CPU system kernel
+	  compilation sees a 1% slowdown, other systems and workloads may vary
+	  and you are advised to test this feature on your expected workload
+	  before deploying it.
+
+	  Note that the full feature requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.  Using
+	  older gcc versions means that functions with large enough stack
+	  frames may leave uninitialized memory behind that may be exposed
+	  to a later syscall leaking the stack.
+
+config PAX_MEMORY_UDEREF
+	bool "Prevent invalid userland pointer dereference"
+	depends on X86 && !UML_X86 && !XEN
+	select PAX_PER_CPU_PGD if X86_64
+	help
+	  By saying Y here the kernel will be prevented from dereferencing
+	  userland pointers in contexts where the kernel expects only kernel
+	  pointers.  This is both a useful runtime debugging feature and a
+	  security measure that prevents exploiting a class of kernel bugs.
+
+	  The tradeoff is that some virtualization solutions may experience
+	  a huge slowdown and therefore you should not enable this feature
+	  for kernels meant to run in such environments.  Whether a given VM
+	  solution is affected or not is best determined by simply trying it
+	  out, the performance impact will be obvious right on boot as this
+	  mechanism engages from very early on.  A good rule of thumb is that
+	  VMs running on CPUs without hardware virtualization support (i.e.,
+	  the majority of IA-32 CPUs) will likely experience the slowdown.
+
+config PAX_REFCOUNT
+	bool "Prevent various kernel object reference counter overflows"
+	depends on (ARM && (CPU_32v6 || CPU_32v6K || CPU_32v7)) || SPARC64 || X86
+	help
+	  By saying Y here the kernel will detect and prevent overflowing
+	  various (but not all) kinds of object reference counters.  Such
+	  overflows can normally occur due to bugs only and are often, if
+	  not always, exploitable.
+
+	  The tradeoff is that data structures protected by an overflowed
+	  refcount will never be freed and therefore will leak memory.  Note
+	  that this leak also happens even without this protection but in
+	  that case the overflow can eventually trigger the freeing of the
+	  data structure while it is still being used elsewhere, resulting
+	  in the exploitable situation that this feature prevents.
+
+	  Since this has a negligible performance impact, you should enable
+	  this feature.
+
+config PAX_USERCOPY
+	bool "Harden heap object copies between kernel and userland"
+	depends on ARM || IA64 || PPC || SPARC || X86
+	depends on SLAB || SLUB || SLOB
+	select PAX_USERCOPY_SLABS
+	help
+	  By saying Y here the kernel will enforce the size of heap objects
+	  when they are copied in either direction between the kernel and
+	  userland, even if only a part of the heap object is copied.
+
+	  Specifically, this checking prevents information leaking from the
+	  kernel heap during kernel to userland copies (if the kernel heap
+	  object is otherwise fully initialized) and prevents kernel heap
+	  overflows during userland to kernel copies.  Only objects belonging
+	  to explictly marked slub types are allowed to be copied at all.
+
+	  Note that the current implementation provides the strictest checks
+	  for the SLUB allocator.
+
+	  If frame pointers are enabled on x86, this option will also restrict
+	  copies into and out of the kernel stack to local variables within a
+	  single frame.
+
+	  Since this has a negligible performance impact, you should enable
+	  this feature.
+
+config PAX_CONSTIFY_PLUGIN
+	bool "Automatically constify eligible structures"
+	depends on !UML
+	help
+	  By saying Y here the compiler will automatically constify a class
+	  of types that contain only function pointers.  This reduces the
+	  kernel's attack surface and also produces a better memory layout.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+
+	  Note that if some code really has to modify constified variables
+	  then the source code will have to be patched to allow it.  Examples
+	  can be found in PaX itself (the no_const attribute) and for some
+	  out-of-tree modules at http://www.grsecurity.net/~paxguy1/ .
+
+config PAX_SIZE_OVERFLOW
+	bool "Prevent various integer overflows in function size parameters"
+	depends on X86
+	help
+	  By saying Y here the kernel recomputes expressions of function
+	  arguments marked by a size_overflow attribute with double integer
+	  precision (DImode/TImode for 32/64 bit integer types).
+
+	  The recomputed argument is checked against TYPE_MAX and an event
+	  is logged on overflow and the triggering process is killed.
+
+	  Homepage: http://www.grsecurity.net/~ephox/overflow_plugin/
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+
+config PAX_LATENT_ENTROPY
+	bool "Generate some entropy during boot"
+	help
+	  By saying Y here the kernel will instrument early boot code to
+	  extract some entropy from both original and artificially created
+	  program state.  This will help especially embedded systems where
+	  there is little 'natural' source of entropy normally.  The cost
+	  is some slowdown of the boot process.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+
+	  Note that entropy extracted this way is not cryptographically
+	  secure!
+
+endmenu
+
+endmenu
+
 config KEYS
 	bool "Enable access key retention support"
 	help
@@ -146,7 +796,7 @@ config INTEL_TXT
 config LSM_MMAP_MIN_ADDR
 	int "Low address space for LSM to protect from user allocation"
 	depends on SECURITY && SECURITY_SELINUX
-	default 65536
+	default 32768
 	help
 	  This is the portion of low virtual memory which should be protected
 	  from userspace allocation.  Keeping a user from writing to low pages
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/keys/keyring.c linux-2.6.32.60-pax/security/keys/keyring.c
--- linux-2.6.32.60/security/keys/keyring.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/keys/keyring.c	2012-03-13 13:15:36.076097940 +0100
@@ -214,15 +214,15 @@ static long keyring_read(const struct ke
 			ret = -EFAULT;
 
 			for (loop = 0; loop < klist->nkeys; loop++) {
+				key_serial_t serial;
 				key = klist->keys[loop];
+				serial = key->serial;
 
 				tmp = sizeof(key_serial_t);
 				if (tmp > buflen)
 					tmp = buflen;
 
-				if (copy_to_user(buffer,
-						 &key->serial,
-						 tmp) != 0)
+				if (copy_to_user(buffer, &serial, tmp))
 					goto error;
 
 				buflen -= tmp;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/keys/process_keys.c linux-2.6.32.60-pax/security/keys/process_keys.c
--- linux-2.6.32.60/security/keys/process_keys.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/keys/process_keys.c	2012-03-13 13:15:36.076097940 +0100
@@ -208,7 +208,7 @@ static int install_process_keyring(void)
 	ret = install_process_keyring_to_cred(new);
 	if (ret < 0) {
 		abort_creds(new);
-		return ret != -EEXIST ?: 0;
+		return ret != -EEXIST ? ret : 0;
 	}
 
 	return commit_creds(new);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/root_plug.c linux-2.6.32.60-pax/security/root_plug.c
--- linux-2.6.32.60/security/root_plug.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/root_plug.c	2012-03-13 13:15:36.076097940 +0100
@@ -70,7 +70,7 @@ static int rootplug_bprm_check_security
 	return 0;
 }
 
-static struct security_operations rootplug_security_ops = {
+static struct security_operations rootplug_security_ops __read_only = {
 	.bprm_check_security =		rootplug_bprm_check_security,
 };
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/security.c linux-2.6.32.60-pax/security/security.c
--- linux-2.6.32.60/security/security.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/security.c	2012-03-13 13:15:36.080097939 +0100
@@ -24,7 +24,7 @@ static __initdata char chosen_lsm[SECURI
 extern struct security_operations default_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
-struct security_operations *security_ops;	/* Initialized to NULL */
+struct security_operations *security_ops __read_only; /* Initialized to NULL */
 
 static inline int verify(struct security_operations *ops)
 {
@@ -117,7 +117,9 @@ int register_security(struct security_op
 	if (security_ops != &default_security_ops)
 		return -EAGAIN;
 
+	pax_open_kernel();
 	security_ops = ops;
+	pax_close_kernel();
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/selinux/hooks.c linux-2.6.32.60-pax/security/selinux/hooks.c
--- linux-2.6.32.60/security/selinux/hooks.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/selinux/hooks.c	2012-03-13 13:15:36.080097939 +0100
@@ -131,7 +131,7 @@ int selinux_enabled = 1;
  * Minimal support for a secondary security module,
  * just to allow the use of the capability module.
  */
-static struct security_operations *secondary_ops;
+static struct security_operations *secondary_ops __read_only;
 
 /* Lists of inode and superblock security structures initialized
    before the policy was loaded. */
@@ -5457,7 +5457,7 @@ static int selinux_key_getsecurity(struc
 
 #endif
 
-static struct security_operations selinux_ops = {
+static struct security_operations selinux_ops __read_only = {
 	.name =				"selinux",
 
 	.ptrace_access_check =		selinux_ptrace_access_check,
@@ -5841,7 +5841,9 @@ int selinux_disable(void)
 	avc_disable();
 
 	/* Reset security_ops to the secondary module, dummy or capability. */
+	pax_open_kernel();
 	security_ops = secondary_ops;
+	pax_close_kernel();
 
 	/* Unregister netfilter hooks. */
 	selinux_nf_ip_exit();
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/selinux/include/xfrm.h linux-2.6.32.60-pax/security/selinux/include/xfrm.h
--- linux-2.6.32.60/security/selinux/include/xfrm.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/selinux/include/xfrm.h	2012-03-13 13:15:36.084097939 +0100
@@ -48,7 +48,7 @@ int selinux_xfrm_decode_session(struct s
 
 static inline void selinux_xfrm_notify_policyload(void)
 {
-	atomic_inc(&flow_cache_genid);
+	atomic_inc_unchecked(&flow_cache_genid);
 }
 #else
 static inline int selinux_xfrm_enabled(void)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/smack/smack_lsm.c linux-2.6.32.60-pax/security/smack/smack_lsm.c
--- linux-2.6.32.60/security/smack/smack_lsm.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/smack/smack_lsm.c	2012-03-13 13:15:36.084097939 +0100
@@ -3073,7 +3073,7 @@ static int smack_inode_getsecctx(struct
 	return 0;
 }
 
-struct security_operations smack_ops = {
+struct security_operations smack_ops __read_only = {
 	.name =				"smack",
 
 	.ptrace_access_check =		smack_ptrace_access_check,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/security/tomoyo/tomoyo.c linux-2.6.32.60-pax/security/tomoyo/tomoyo.c
--- linux-2.6.32.60/security/tomoyo/tomoyo.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/security/tomoyo/tomoyo.c	2012-03-13 13:15:36.084097939 +0100
@@ -275,7 +275,7 @@ static int tomoyo_dentry_open(struct fil
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
  */
-static struct security_operations tomoyo_security_ops = {
+static struct security_operations tomoyo_security_ops __read_only = {
 	.name                = "tomoyo",
 	.cred_alloc_blank    = tomoyo_cred_alloc_blank,
 	.cred_prepare        = tomoyo_cred_prepare,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/aoa/codecs/onyx.c linux-2.6.32.60-pax/sound/aoa/codecs/onyx.c
--- linux-2.6.32.60/sound/aoa/codecs/onyx.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/aoa/codecs/onyx.c	2012-03-13 13:15:36.084097939 +0100
@@ -53,7 +53,7 @@ struct onyx {
 				spdif_locked:1,
 				analog_locked:1,
 				original_mute:2;
-	int			open_count;
+	local_t			open_count;
 	struct codec_info	*codec_info;
 
 	/* mutex serializes concurrent access to the device
@@ -752,7 +752,7 @@ static int onyx_open(struct codec_info_i
 	struct onyx *onyx = cii->codec_data;
 
 	mutex_lock(&onyx->mutex);
-	onyx->open_count++;
+	local_inc(&onyx->open_count);
 	mutex_unlock(&onyx->mutex);
 
 	return 0;
@@ -764,8 +764,7 @@ static int onyx_close(struct codec_info_
 	struct onyx *onyx = cii->codec_data;
 
 	mutex_lock(&onyx->mutex);
-	onyx->open_count--;
-	if (!onyx->open_count)
+	if (local_dec_and_test(&onyx->open_count))
 		onyx->spdif_locked = onyx->analog_locked = 0;
 	mutex_unlock(&onyx->mutex);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/aoa/codecs/onyx.h linux-2.6.32.60-pax/sound/aoa/codecs/onyx.h
--- linux-2.6.32.60/sound/aoa/codecs/onyx.h	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/aoa/codecs/onyx.h	2012-03-13 13:15:36.088097939 +0100
@@ -11,6 +11,7 @@
 #include <linux/i2c.h>
 #include <asm/pmac_low_i2c.h>
 #include <asm/prom.h>
+#include <asm/local.h>
 
 /* PCM3052 register definitions */
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/core/oss/pcm_oss.c linux-2.6.32.60-pax/sound/core/oss/pcm_oss.c
--- linux-2.6.32.60/sound/core/oss/pcm_oss.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/core/oss/pcm_oss.c	2012-03-13 13:15:36.088097939 +0100
@@ -1395,7 +1395,7 @@ static ssize_t snd_pcm_oss_write1(struct
 			}
 		} else {
 			tmp = snd_pcm_oss_write2(substream,
-						 (const char __force *)buf,
+						 (const char __force_kernel *)buf,
 						 runtime->oss.period_bytes, 0);
 			if (tmp <= 0)
 				goto err;
@@ -1483,7 +1483,7 @@ static ssize_t snd_pcm_oss_read1(struct
 			xfer += tmp;
 			runtime->oss.buffer_used -= tmp;
 		} else {
-			tmp = snd_pcm_oss_read2(substream, (char __force *)buf,
+			tmp = snd_pcm_oss_read2(substream, (char __force_kernel *)buf,
 						runtime->oss.period_bytes, 0);
 			if (tmp <= 0)
 				goto err;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/core/pcm_compat.c linux-2.6.32.60-pax/sound/core/pcm_compat.c
--- linux-2.6.32.60/sound/core/pcm_compat.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/core/pcm_compat.c	2012-03-13 13:15:36.088097939 +0100
@@ -30,7 +30,7 @@ static int snd_pcm_ioctl_delay_compat(st
 	int err;
 
 	fs = snd_enter_user();
-	err = snd_pcm_delay(substream, &delay);
+	err = snd_pcm_delay(substream, (snd_pcm_sframes_t __force_user *)&delay);
 	snd_leave_user(fs);
 	if (err < 0)
 		return err;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/core/pcm_native.c linux-2.6.32.60-pax/sound/core/pcm_native.c
--- linux-2.6.32.60/sound/core/pcm_native.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/core/pcm_native.c	2012-03-13 13:15:36.092097939 +0100
@@ -2747,11 +2747,11 @@ int snd_pcm_kernel_ioctl(struct snd_pcm_
 	switch (substream->stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
 		result = snd_pcm_playback_ioctl1(NULL, substream, cmd,
-						 (void __user *)arg);
+						 (void __force_user *)arg);
 		break;
 	case SNDRV_PCM_STREAM_CAPTURE:
 		result = snd_pcm_capture_ioctl1(NULL, substream, cmd,
-						(void __user *)arg);
+						(void __force_user *)arg);
 		break;
 	default:
 		result = -EINVAL;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/core/seq/seq_device.c linux-2.6.32.60-pax/sound/core/seq/seq_device.c
--- linux-2.6.32.60/sound/core/seq/seq_device.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/core/seq/seq_device.c	2012-03-13 13:15:36.092097939 +0100
@@ -63,7 +63,7 @@ struct ops_list {
 	int argsize;		/* argument size */
 
 	/* operators */
-	struct snd_seq_dev_ops ops;
+	struct snd_seq_dev_ops *ops;
 
 	/* registred devices */
 	struct list_head dev_list;	/* list of devices */
@@ -332,7 +332,7 @@ int snd_seq_device_register_driver(char
 
 	mutex_lock(&ops->reg_mutex);
 	/* copy driver operators */
-	ops->ops = *entry;
+	ops->ops = entry;
 	ops->driver |= DRIVER_LOADED;
 	ops->argsize = argsize;
 
@@ -462,7 +462,7 @@ static int init_device(struct snd_seq_de
 			   dev->name, ops->id, ops->argsize, dev->argsize);
 		return -EINVAL;
 	}
-	if (ops->ops.init_device(dev) >= 0) {
+	if (ops->ops->init_device(dev) >= 0) {
 		dev->status = SNDRV_SEQ_DEVICE_REGISTERED;
 		ops->num_init_devices++;
 	} else {
@@ -489,7 +489,7 @@ static int free_device(struct snd_seq_de
 			   dev->name, ops->id, ops->argsize, dev->argsize);
 		return -EINVAL;
 	}
-	if ((result = ops->ops.free_device(dev)) >= 0 || result == -ENXIO) {
+	if ((result = ops->ops->free_device(dev)) >= 0 || result == -ENXIO) {
 		dev->status = SNDRV_SEQ_DEVICE_FREE;
 		dev->driver_data = NULL;
 		ops->num_init_devices--;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/drivers/mts64.c linux-2.6.32.60-pax/sound/drivers/mts64.c
--- linux-2.6.32.60/sound/drivers/mts64.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/drivers/mts64.c	2012-03-13 13:15:36.092097939 +0100
@@ -27,6 +27,7 @@
 #include <sound/initval.h>
 #include <sound/rawmidi.h>
 #include <sound/control.h>
+#include <asm/local.h>
 
 #define CARD_NAME "Miditerminal 4140"
 #define DRIVER_NAME "MTS64"
@@ -65,7 +66,7 @@ struct mts64 {
 	struct pardevice *pardev;
 	int pardev_claimed;
 
-	int open_count;
+	local_t open_count;
 	int current_midi_output_port;
 	int current_midi_input_port;
 	u8 mode[MTS64_NUM_INPUT_PORTS];
@@ -695,7 +696,7 @@ static int snd_mts64_rawmidi_open(struct
 {
 	struct mts64 *mts = substream->rmidi->private_data;
 
-	if (mts->open_count == 0) {
+	if (local_read(&mts->open_count) == 0) {
 		/* We don't need a spinlock here, because this is just called 
 		   if the device has not been opened before. 
 		   So there aren't any IRQs from the device */
@@ -703,7 +704,7 @@ static int snd_mts64_rawmidi_open(struct
 
 		msleep(50);
 	}
-	++(mts->open_count);
+	local_inc(&mts->open_count);
 
 	return 0;
 }
@@ -713,8 +714,7 @@ static int snd_mts64_rawmidi_close(struc
 	struct mts64 *mts = substream->rmidi->private_data;
 	unsigned long flags;
 
-	--(mts->open_count);
-	if (mts->open_count == 0) {
+	if (local_dec_return(&mts->open_count) == 0) {
 		/* We need the spinlock_irqsave here because we can still
 		   have IRQs at this point */
 		spin_lock_irqsave(&mts->lock, flags);
@@ -723,8 +723,8 @@ static int snd_mts64_rawmidi_close(struc
 
 		msleep(500);
 
-	} else if (mts->open_count < 0)
-		mts->open_count = 0;
+	} else if (local_read(&mts->open_count) < 0)
+		local_set(&mts->open_count, 0);
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/drivers/opl4/opl4_lib.c linux-2.6.32.60-pax/sound/drivers/opl4/opl4_lib.c
--- linux-2.6.32.60/sound/drivers/opl4/opl4_lib.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/drivers/opl4/opl4_lib.c	2012-03-13 13:15:36.096097939 +0100
@@ -27,7 +27,7 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@
 MODULE_DESCRIPTION("OPL4 driver");
 MODULE_LICENSE("GPL");
 
-static void inline snd_opl4_wait(struct snd_opl4 *opl4)
+static inline void snd_opl4_wait(struct snd_opl4 *opl4)
 {
 	int timeout = 10;
 	while ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/drivers/portman2x4.c linux-2.6.32.60-pax/sound/drivers/portman2x4.c
--- linux-2.6.32.60/sound/drivers/portman2x4.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/drivers/portman2x4.c	2012-03-13 13:15:36.096097939 +0100
@@ -46,6 +46,7 @@
 #include <sound/initval.h>
 #include <sound/rawmidi.h>
 #include <sound/control.h>
+#include <asm/local.h>
 
 #define CARD_NAME "Portman 2x4"
 #define DRIVER_NAME "portman"
@@ -83,7 +84,7 @@ struct portman {
 	struct pardevice *pardev;
 	int pardev_claimed;
 
-	int open_count;
+	local_t open_count;
 	int mode[PORTMAN_NUM_INPUT_PORTS];
 	struct snd_rawmidi_substream *midi_input[PORTMAN_NUM_INPUT_PORTS];
 };
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/oss/sb_audio.c linux-2.6.32.60-pax/sound/oss/sb_audio.c
--- linux-2.6.32.60/sound/oss/sb_audio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/oss/sb_audio.c	2012-03-13 13:15:36.096097939 +0100
@@ -901,7 +901,7 @@ sb16_copy_from_user(int dev,
 		buf16 = (signed short *)(localbuf + localoffs);
 		while (c)
 		{
-			locallen = (c >= LBUFCOPYSIZE ? LBUFCOPYSIZE : c);
+			locallen = ((unsigned)c >= LBUFCOPYSIZE ? LBUFCOPYSIZE : c);
 			if (copy_from_user(lbuf8,
 					   userbuf+useroffs + p,
 					   locallen))
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/oss/swarm_cs4297a.c linux-2.6.32.60-pax/sound/oss/swarm_cs4297a.c
--- linux-2.6.32.60/sound/oss/swarm_cs4297a.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/oss/swarm_cs4297a.c	2012-03-13 13:15:36.100097938 +0100
@@ -2577,7 +2577,6 @@ static int __init cs4297a_init(void)
 {
 	struct cs4297a_state *s;
 	u32 pwr, id;
-	mm_segment_t fs;
 	int rval;
 #ifndef CONFIG_BCM_CS4297A_CSWARM
 	u64 cfg;
@@ -2667,22 +2666,23 @@ static int __init cs4297a_init(void)
         if (!rval) {
 		char *sb1250_duart_present;
 
+#if 0
+                mm_segment_t fs;
                 fs = get_fs();
                 set_fs(KERNEL_DS);
-#if 0
                 val = SOUND_MASK_LINE;
                 mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long) &val);
                 for (i = 0; i < ARRAY_SIZE(initvol); i++) {
                         val = initvol[i].vol;
                         mixer_ioctl(s, initvol[i].mixch, (unsigned long) &val);
                 }
+                set_fs(fs);
 //                cs4297a_write_ac97(s, 0x18, 0x0808);
 #else
                 //                cs4297a_write_ac97(s, 0x5e, 0x180);
                 cs4297a_write_ac97(s, 0x02, 0x0808);
                 cs4297a_write_ac97(s, 0x18, 0x0808);
 #endif
-                set_fs(fs);
 
                 list_add(&s->list, &cs4297a_devs);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/hda/patch_atihdmi.c linux-2.6.32.60-pax/sound/pci/hda/patch_atihdmi.c
--- linux-2.6.32.60/sound/pci/hda/patch_atihdmi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/hda/patch_atihdmi.c	2012-03-13 13:15:36.104097938 +0100
@@ -177,7 +177,7 @@ static int patch_atihdmi(struct hda_code
 	 */
 	spec->multiout.dig_out_nid = CVT_NID;
 
-	codec->patch_ops = atihdmi_patch_ops;
+	memcpy((void *)&codec->patch_ops, &atihdmi_patch_ops, sizeof(atihdmi_patch_ops));
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/hda/patch_intelhdmi.c linux-2.6.32.60-pax/sound/pci/hda/patch_intelhdmi.c
--- linux-2.6.32.60/sound/pci/hda/patch_intelhdmi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/hda/patch_intelhdmi.c	2012-03-13 13:15:36.104097938 +0100
@@ -511,10 +511,10 @@ static void hdmi_non_intrinsic_event(str
 		cp_ready);
 
 	/* TODO */
-	if (cp_state)
-		;
-	if (cp_ready)
-		;
+	if (cp_state) {
+	}
+	if (cp_ready) {
+	}
 }
 
 
@@ -656,7 +656,7 @@ static int do_patch_intel_hdmi(struct hd
 	spec->multiout.dig_out_nid = cvt_nid;
 
 	codec->spec = spec;
-	codec->patch_ops = intel_hdmi_patch_ops;
+	memcpy((void *)&codec->patch_ops, &intel_hdmi_patch_ops, sizeof(intel_hdmi_patch_ops));
 
 	snd_hda_eld_proc_new(codec, &spec->sink_eld);
 
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/hda/patch_nvhdmi.c linux-2.6.32.60-pax/sound/pci/hda/patch_nvhdmi.c
--- linux-2.6.32.60/sound/pci/hda/patch_nvhdmi.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/hda/patch_nvhdmi.c	2012-03-13 13:15:36.104097938 +0100
@@ -367,7 +367,7 @@ static int patch_nvhdmi_8ch(struct hda_c
 	spec->multiout.max_channels = 8;
 	spec->multiout.dig_out_nid = Nv_Master_Convert_nid;
 
-	codec->patch_ops = nvhdmi_patch_ops_8ch;
+	memcpy((void *)&codec->patch_ops, &nvhdmi_patch_ops_8ch, sizeof(nvhdmi_patch_ops_8ch));
 
 	return 0;
 }
@@ -386,7 +386,7 @@ static int patch_nvhdmi_2ch(struct hda_c
 	spec->multiout.max_channels = 2;
 	spec->multiout.dig_out_nid = Nv_Master_Convert_nid;
 
-	codec->patch_ops = nvhdmi_patch_ops_2ch;
+	memcpy((void *)&codec->patch_ops, &nvhdmi_patch_ops_2ch, sizeof(nvhdmi_patch_ops_2ch));
 
 	return 0;
 }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/hda/patch_sigmatel.c linux-2.6.32.60-pax/sound/pci/hda/patch_sigmatel.c
--- linux-2.6.32.60/sound/pci/hda/patch_sigmatel.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/hda/patch_sigmatel.c	2012-03-13 13:15:36.108097938 +0100
@@ -5220,7 +5220,7 @@ again:
 	snd_hda_codec_write_cache(codec, nid, 0,
 			AC_VERB_SET_CONNECT_SEL, num_dacs);
 
-	codec->patch_ops = stac92xx_patch_ops;
+	memcpy((void *)&codec->patch_ops, &stac92xx_patch_ops, sizeof(stac92xx_patch_ops));
 
 	codec->proc_widget_hook = stac92hd_proc_hook;
 
@@ -5294,7 +5294,7 @@ static int patch_stac92hd71bxx(struct hd
 		return -ENOMEM;
 
 	codec->spec = spec;
-	codec->patch_ops = stac92xx_patch_ops;
+	memcpy((void *)&codec->patch_ops, &stac92xx_patch_ops, sizeof(stac92xx_patch_ops));
 	spec->num_pins = STAC92HD71BXX_NUM_PINS;
 	switch (codec->vendor_id) {
 	case 0x111d76b6:
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/intel8x0m.c linux-2.6.32.60-pax/sound/pci/intel8x0m.c
--- linux-2.6.32.60/sound/pci/intel8x0m.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/intel8x0m.c	2012-03-13 13:15:36.112097938 +0100
@@ -1264,7 +1264,7 @@ static struct shortname_table {
 	{ 0x5455, "ALi M5455" },
 	{ 0x746d, "AMD AMD8111" },
 #endif
-	{ 0 },
+	{ 0, },
 };
 
 static int __devinit snd_intel8x0m_probe(struct pci_dev *pci,
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/pci/ymfpci/ymfpci_main.c linux-2.6.32.60-pax/sound/pci/ymfpci/ymfpci_main.c
--- linux-2.6.32.60/sound/pci/ymfpci/ymfpci_main.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/pci/ymfpci/ymfpci_main.c	2012-03-13 13:15:36.116097937 +0100
@@ -202,8 +202,8 @@ static void snd_ymfpci_hw_stop(struct sn
 		if ((snd_ymfpci_readl(chip, YDSXGR_STATUS) & 2) == 0)
 			break;
 	}
-	if (atomic_read(&chip->interrupt_sleep_count)) {
-		atomic_set(&chip->interrupt_sleep_count, 0);
+	if (atomic_read_unchecked(&chip->interrupt_sleep_count)) {
+		atomic_set_unchecked(&chip->interrupt_sleep_count, 0);
 		wake_up(&chip->interrupt_sleep);
 	}
       __end:
@@ -787,7 +787,7 @@ static void snd_ymfpci_irq_wait(struct s
 		 	continue;
 		init_waitqueue_entry(&wait, current);
 		add_wait_queue(&chip->interrupt_sleep, &wait);
-		atomic_inc(&chip->interrupt_sleep_count);
+		atomic_inc_unchecked(&chip->interrupt_sleep_count);
 		schedule_timeout_uninterruptible(msecs_to_jiffies(50));
 		remove_wait_queue(&chip->interrupt_sleep, &wait);
 	}
@@ -825,8 +825,8 @@ static irqreturn_t snd_ymfpci_interrupt(
 		snd_ymfpci_writel(chip, YDSXGR_MODE, mode);
 		spin_unlock(&chip->reg_lock);
 
-		if (atomic_read(&chip->interrupt_sleep_count)) {
-			atomic_set(&chip->interrupt_sleep_count, 0);
+		if (atomic_read_unchecked(&chip->interrupt_sleep_count)) {
+			atomic_set_unchecked(&chip->interrupt_sleep_count, 0);
 			wake_up(&chip->interrupt_sleep);
 		}
 	}
@@ -2369,7 +2369,7 @@ int __devinit snd_ymfpci_create(struct s
 	spin_lock_init(&chip->reg_lock);
 	spin_lock_init(&chip->voice_lock);
 	init_waitqueue_head(&chip->interrupt_sleep);
-	atomic_set(&chip->interrupt_sleep_count, 0);
+	atomic_set_unchecked(&chip->interrupt_sleep_count, 0);
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/soc/soc-core.c linux-2.6.32.60-pax/sound/soc/soc-core.c
--- linux-2.6.32.60/sound/soc/soc-core.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/soc/soc-core.c	2013-01-22 16:53:47.036686532 +0100
@@ -1107,13 +1107,15 @@ static int soc_new_pcm(struct snd_soc_de
 
 	dai_link->pcm = pcm;
 	pcm->private_data = rtd;
-	soc_pcm_ops.mmap = platform->pcm_ops->mmap;
-	soc_pcm_ops.pointer = platform->pcm_ops->pointer;
-	soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
-	soc_pcm_ops.copy = platform->pcm_ops->copy;
-	soc_pcm_ops.silence = platform->pcm_ops->silence;
-	soc_pcm_ops.ack = platform->pcm_ops->ack;
-	soc_pcm_ops.page = platform->pcm_ops->page;
+	pax_open_kernel();
+	*(void **)&soc_pcm_ops.mmap = platform->pcm_ops->mmap;
+	*(void **)&soc_pcm_ops.pointer = platform->pcm_ops->pointer;
+	*(void **)&soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
+	*(void **)&soc_pcm_ops.copy = platform->pcm_ops->copy;
+	*(void **)&soc_pcm_ops.silence = platform->pcm_ops->silence;
+	*(void **)&soc_pcm_ops.ack = platform->pcm_ops->ack;
+	*(void **)&soc_pcm_ops.page = platform->pcm_ops->page;
+	pax_close_kernel();
 
 	if (playback)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/sound/usb/usbaudio.c linux-2.6.32.60-pax/sound/usb/usbaudio.c
--- linux-2.6.32.60/sound/usb/usbaudio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/sound/usb/usbaudio.c	2013-02-17 19:27:26.903747856 +0100
@@ -2228,9 +2228,9 @@ static void init_substream(struct snd_us
 	subs->direction = stream;
 	subs->dev = as->chip->dev;
 	if (snd_usb_get_speed(subs->dev) == USB_SPEED_FULL) {
-		subs->ops = audio_urb_ops[stream];
+		memcpy((void *)&subs->ops, &audio_urb_ops[stream], sizeof(subs->ops));
 	} else {
-		subs->ops = audio_urb_ops_high_speed[stream];
+		memcpy((void *)&subs->ops, &audio_urb_ops_high_speed[stream], sizeof(subs->ops));
 		switch (as->chip->usb_id) {
 		case USB_ID(0x041e, 0x3f02): /* E-Mu 0202 USB */
 		case USB_ID(0x041e, 0x3f04): /* E-Mu 0404 USB */
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/checker_plugin.c linux-2.6.32.60-pax/tools/gcc/checker_plugin.c
--- linux-2.6.32.60/tools/gcc/checker_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/checker_plugin.c	2012-03-13 13:15:36.120097937 +0100
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2011 by the PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to implement various sparse (source code checker) features
+ *
+ * TODO:
+ * - define separate __iomem, __percpu and __rcu address spaces (lots of code to patch)
+ *
+ * BUGS:
+ * - none known
+ */
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+//#include "expr.h" where are you...
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+#include "tree-flow.h"
+#include "target.h"
+
+extern void c_register_addr_space (const char *str, addr_space_t as);
+extern enum machine_mode default_addr_space_pointer_mode (addr_space_t);
+extern enum machine_mode default_addr_space_address_mode (addr_space_t);
+extern bool default_addr_space_valid_pointer_mode(enum machine_mode mode, addr_space_t as);
+extern bool default_addr_space_legitimate_address_p(enum machine_mode mode, rtx mem, bool strict, addr_space_t as);
+extern rtx default_addr_space_legitimize_address(rtx x, rtx oldx, enum machine_mode mode, addr_space_t as);
+
+extern void print_gimple_stmt(FILE *, gimple, int, int);
+extern rtx emit_move_insn(rtx x, rtx y);
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info checker_plugin_info = {
+	.version	= "201111150100",
+};
+
+#define ADDR_SPACE_KERNEL		0
+#define ADDR_SPACE_FORCE_KERNEL		1
+#define ADDR_SPACE_USER			2
+#define ADDR_SPACE_FORCE_USER		3
+#define ADDR_SPACE_IOMEM		0
+#define ADDR_SPACE_FORCE_IOMEM		0
+#define ADDR_SPACE_PERCPU		0
+#define ADDR_SPACE_FORCE_PERCPU		0
+#define ADDR_SPACE_RCU			0
+#define ADDR_SPACE_FORCE_RCU		0
+
+static enum machine_mode checker_addr_space_pointer_mode(addr_space_t addrspace)
+{
+	return default_addr_space_pointer_mode(ADDR_SPACE_GENERIC);
+}
+
+static enum machine_mode checker_addr_space_address_mode(addr_space_t addrspace)
+{
+	return default_addr_space_address_mode(ADDR_SPACE_GENERIC);
+}
+
+static bool checker_addr_space_valid_pointer_mode(enum machine_mode mode, addr_space_t as)
+{
+	return default_addr_space_valid_pointer_mode(mode, as);
+}
+
+static bool checker_addr_space_legitimate_address_p(enum machine_mode mode, rtx mem, bool strict, addr_space_t as)
+{
+	return default_addr_space_legitimate_address_p(mode, mem, strict, ADDR_SPACE_GENERIC);
+}
+
+static rtx checker_addr_space_legitimize_address(rtx x, rtx oldx, enum machine_mode mode, addr_space_t as)
+{
+	return default_addr_space_legitimize_address(x, oldx, mode, as);
+}
+
+static bool checker_addr_space_subset_p(addr_space_t subset, addr_space_t superset)
+{
+	if (subset == ADDR_SPACE_FORCE_KERNEL && superset == ADDR_SPACE_KERNEL)
+		return true;
+
+	if (subset == ADDR_SPACE_FORCE_USER && superset == ADDR_SPACE_USER)
+		return true;
+
+	if (subset == ADDR_SPACE_FORCE_IOMEM && superset == ADDR_SPACE_IOMEM)
+		return true;
+
+	if (subset == ADDR_SPACE_KERNEL && superset == ADDR_SPACE_FORCE_USER)
+		return true;
+
+	if (subset == ADDR_SPACE_KERNEL && superset == ADDR_SPACE_FORCE_IOMEM)
+		return true;
+
+	if (subset == ADDR_SPACE_USER && superset == ADDR_SPACE_FORCE_KERNEL)
+		return true;
+
+	if (subset == ADDR_SPACE_IOMEM && superset == ADDR_SPACE_FORCE_KERNEL)
+		return true;
+
+	return subset == superset;
+}
+
+static rtx checker_addr_space_convert(rtx op, tree from_type, tree to_type)
+{
+//	addr_space_t from_as = TYPE_ADDR_SPACE(TREE_TYPE(from_type));
+//	addr_space_t to_as = TYPE_ADDR_SPACE(TREE_TYPE(to_type));
+
+	return op;
+}
+
+static void register_checker_address_spaces(void *event_data, void *data)
+{
+	c_register_addr_space("__kernel", ADDR_SPACE_KERNEL);
+	c_register_addr_space("__force_kernel", ADDR_SPACE_FORCE_KERNEL);
+	c_register_addr_space("__user", ADDR_SPACE_USER);
+	c_register_addr_space("__force_user", ADDR_SPACE_FORCE_USER);
+//	c_register_addr_space("__iomem", ADDR_SPACE_IOMEM);
+//	c_register_addr_space("__force_iomem", ADDR_SPACE_FORCE_IOMEM);
+//	c_register_addr_space("__percpu", ADDR_SPACE_PERCPU);
+//	c_register_addr_space("__force_percpu", ADDR_SPACE_FORCE_PERCPU);
+//	c_register_addr_space("__rcu", ADDR_SPACE_RCU);
+//	c_register_addr_space("__force_rcu", ADDR_SPACE_FORCE_RCU);
+
+	targetm.addr_space.pointer_mode		= checker_addr_space_pointer_mode;
+	targetm.addr_space.address_mode		= checker_addr_space_address_mode;
+	targetm.addr_space.valid_pointer_mode	= checker_addr_space_valid_pointer_mode;
+	targetm.addr_space.legitimate_address_p	= checker_addr_space_legitimate_address_p;
+//	targetm.addr_space.legitimize_address	= checker_addr_space_legitimize_address;
+	targetm.addr_space.subset_p		= checker_addr_space_subset_p;
+	targetm.addr_space.convert		= checker_addr_space_convert;
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &checker_plugin_info);
+
+	for (i = 0; i < argc; ++i)
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+
+	if (TARGET_64BIT == 0)
+		return 0;
+
+	register_callback(plugin_name, PLUGIN_PRAGMAS, register_checker_address_spaces, NULL);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/colorize_plugin.c linux-2.6.32.60-pax/tools/gcc/colorize_plugin.c
--- linux-2.6.32.60/tools/gcc/colorize_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/colorize_plugin.c	2013-02-17 17:20:34.384154306 +0100
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2012-2013 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to colorize diagnostic output
+ *
+ */
+
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info colorize_plugin_info = {
+	.version	= "201302112000",
+	.help		= NULL,
+};
+
+#define GREEN		"\033[32m\033[2m"
+#define LIGHTGREEN	"\033[32m\033[1m"
+#define YELLOW		"\033[33m\033[2m"
+#define LIGHTYELLOW	"\033[33m\033[1m"
+#define RED		"\033[31m\033[2m"
+#define LIGHTRED	"\033[31m\033[1m"
+#define BLUE		"\033[34m\033[2m"
+#define LIGHTBLUE	"\033[34m\033[1m"
+#define BRIGHT		"\033[m\033[1m"
+#define NORMAL		"\033[m"
+
+static diagnostic_starter_fn old_starter;
+static diagnostic_finalizer_fn old_finalizer;
+
+static void start_colorize(diagnostic_context *context, diagnostic_info *diagnostic)
+{
+	const char *color;
+	char *newprefix;
+
+	switch (diagnostic->kind) {
+	case DK_NOTE:
+		color = LIGHTBLUE;
+		break;
+
+	case DK_PEDWARN:
+	case DK_WARNING:
+		color = LIGHTYELLOW;
+		break;
+
+	case DK_ERROR:
+	case DK_FATAL:
+	case DK_ICE:
+	case DK_PERMERROR:
+	case DK_SORRY:
+		color = LIGHTRED;
+		break;
+
+	default:
+		color = NORMAL;
+	}
+
+	old_starter(context, diagnostic);
+	if (-1 == asprintf(&newprefix, "%s%s" NORMAL, color, context->printer->prefix))
+		return;
+	pp_destroy_prefix(context->printer);
+	pp_set_prefix(context->printer, newprefix);
+}
+
+static void finalize_colorize(diagnostic_context *context, diagnostic_info *diagnostic)
+{
+	old_finalizer(context, diagnostic);
+}
+
+static void colorize_arm(void)
+{
+	old_starter = diagnostic_starter(global_dc);
+	old_finalizer = diagnostic_finalizer(global_dc);
+
+	diagnostic_starter(global_dc) = start_colorize;
+	diagnostic_finalizer(global_dc) = finalize_colorize;
+}
+
+static unsigned int execute_colorize_rearm(void)
+{
+	if (diagnostic_starter(global_dc) == start_colorize)
+		return 0;
+
+	colorize_arm();
+	return 0;
+}
+
+struct simple_ipa_opt_pass pass_ipa_colorize_rearm = {
+	.pass = {
+		.type			= SIMPLE_IPA_PASS,
+		.name			= "colorize_rearm",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= NULL,
+		.execute		= execute_colorize_rearm,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= 0
+	}
+};
+
+static void colorize_start_unit(void *gcc_data, void *user_data)
+{
+	colorize_arm();
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	struct register_pass_info colorize_rearm_pass_info = {
+		.pass				= &pass_ipa_colorize_rearm.pass,
+		.reference_pass_name		= "*free_lang_data",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_AFTER
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &colorize_plugin_info);
+	register_callback(plugin_name, PLUGIN_START_UNIT, &colorize_start_unit, NULL);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &colorize_rearm_pass_info);
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/constify_plugin.c linux-2.6.32.60-pax/tools/gcc/constify_plugin.c
--- linux-2.6.32.60/tools/gcc/constify_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/constify_plugin.c	2013-02-17 17:20:34.388154306 +0100
@@ -0,0 +1,359 @@
+/*
+ * Copyright 2011 by Emese Revfy <re.emese@gmail.com>
+ * Copyright 2011-2013 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2, or (at your option) v3
+ *
+ * This gcc plugin constifies all structures which contain only function pointers or are explicitly marked for constification.
+ *
+ * Homepage:
+ * http://www.grsecurity.net/~ephox/const_plugin/
+ *
+ * Usage:
+ * $ gcc -I`gcc -print-file-name=plugin`/include -fPIC -shared -O2 -o constify_plugin.so constify_plugin.c
+ * $ gcc -fplugin=constify_plugin.so test.c -O2
+ */
+
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+#include "tree-flow.h"
+
+#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1(TYPE)
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info const_plugin_info = {
+	.version	= "201302112000",
+	.help		= "no-constify\tturn off constification\n",
+};
+
+static tree get_field_type(tree field)
+{
+	return strip_array_types(TREE_TYPE(field));
+}
+
+static bool walk_struct(tree node);
+static void deconstify_tree(tree node);
+
+static void deconstify_type(tree type)
+{
+	tree field;
+
+	for (field = TYPE_FIELDS(type); field; field = TREE_CHAIN(field)) {
+		tree fieldtype = get_field_type(field);
+
+		if (TREE_CODE(fieldtype) != RECORD_TYPE && TREE_CODE(fieldtype) != UNION_TYPE)
+			continue;
+		if (!TYPE_READONLY(fieldtype))
+			continue;
+		if (!walk_struct(fieldtype))
+			continue;
+
+		deconstify_tree(field);
+		TREE_READONLY(field) = 0;
+	}
+	TYPE_READONLY(type) = 0;
+	C_TYPE_FIELDS_READONLY(type) = 0;
+}
+
+static void deconstify_tree(tree node)
+{
+	tree old_type, new_type, field;
+
+//	TREE_READONLY(node) = 0;
+	old_type = TREE_TYPE(node);
+	while (TREE_CODE(old_type) == ARRAY_TYPE && TREE_CODE(TREE_TYPE(old_type)) != ARRAY_TYPE) {
+		node = old_type;
+		old_type = TREE_TYPE(old_type);
+	}
+
+	gcc_assert(TREE_CODE(old_type) == RECORD_TYPE || TREE_CODE(old_type) == UNION_TYPE);
+	gcc_assert(TYPE_READONLY(old_type) && (TYPE_QUALS(old_type) & TYPE_QUAL_CONST));
+
+	new_type = build_qualified_type(old_type, TYPE_QUALS(old_type) & ~TYPE_QUAL_CONST);
+	TYPE_FIELDS(new_type) = copy_list(TYPE_FIELDS(new_type));
+	for (field = TYPE_FIELDS(new_type); field; field = TREE_CHAIN(field))
+		DECL_FIELD_CONTEXT(field) = new_type;
+
+	deconstify_type(new_type);
+
+	TREE_TYPE(node) = new_type;
+}
+
+static tree handle_no_const_attribute(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	tree type;
+
+	*no_add_attrs = true;
+	if (TREE_CODE(*node) == FUNCTION_DECL) {
+		error("%qE attribute does not apply to functions", name);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) == VAR_DECL) {
+		error("%qE attribute does not apply to variables", name);
+		return NULL_TREE;
+	}
+
+	if (TYPE_P(*node)) {
+		if (TREE_CODE(*node) == RECORD_TYPE || TREE_CODE(*node) == UNION_TYPE)
+			*no_add_attrs = false;
+		else
+			error("%qE attribute applies to struct and union types only", name);
+		return NULL_TREE;
+	}
+
+	type = TREE_TYPE(*node);
+
+	if (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE) {
+		error("%qE attribute applies to struct and union types only", name);
+		return NULL_TREE;
+	}
+
+	if (lookup_attribute(IDENTIFIER_POINTER(name), TYPE_ATTRIBUTES(type))) {
+		error("%qE attribute is already applied to the type", name);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) == TYPE_DECL && !TYPE_READONLY(type)) {
+		error("%qE attribute used on type that is not constified", name);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) == TYPE_DECL) {
+		deconstify_tree(*node);
+		return NULL_TREE;
+	}
+
+	return NULL_TREE;
+}
+
+static void constify_type(tree type)
+{
+	TYPE_READONLY(type) = 1;
+	C_TYPE_FIELDS_READONLY(type) = 1;
+}
+
+static tree handle_do_const_attribute(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	*no_add_attrs = true;
+	if (!TYPE_P(*node)) {
+		error("%qE attribute applies to types only", name);
+		return NULL_TREE;
+	}
+
+	if (TREE_CODE(*node) != RECORD_TYPE && TREE_CODE(*node) != UNION_TYPE) {
+		error("%qE attribute applies to struct and union types only", name);
+		return NULL_TREE;
+	}
+
+	*no_add_attrs = false;
+	constify_type(*node);
+	return NULL_TREE;
+}
+
+static struct attribute_spec no_const_attr = {
+	.name			= "no_const",
+	.min_length		= 0,
+	.max_length		= 0,
+	.decl_required		= false,
+	.type_required		= false,
+	.function_type_required	= false,
+	.handler		= handle_no_const_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity	= true
+#endif
+};
+
+static struct attribute_spec do_const_attr = {
+	.name			= "do_const",
+	.min_length		= 0,
+	.max_length		= 0,
+	.decl_required		= false,
+	.type_required		= false,
+	.function_type_required	= false,
+	.handler		= handle_do_const_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity	= true
+#endif
+};
+
+static void register_attributes(void *event_data, void *data)
+{
+	register_attribute(&no_const_attr);
+	register_attribute(&do_const_attr);
+}
+
+static bool is_fptr(tree field)
+{
+	tree ptr = get_field_type(field);
+
+	if (TREE_CODE(ptr) != POINTER_TYPE)
+		return false;
+
+	return TREE_CODE(TREE_TYPE(ptr)) == FUNCTION_TYPE;
+}
+
+static bool walk_struct(tree node)
+{
+	tree field;
+
+	if (TYPE_FIELDS(node) == NULL_TREE)
+		return false;
+
+	if (lookup_attribute("do_const", TYPE_ATTRIBUTES(node)))
+		return true;
+
+	if (lookup_attribute("no_const", TYPE_ATTRIBUTES(node))) {
+		gcc_assert(!TYPE_READONLY(node));
+		deconstify_type(node);
+		return false;
+	}
+
+	for (field = TYPE_FIELDS(node); field; field = TREE_CHAIN(field)) {
+		tree type = get_field_type(field);
+		enum tree_code code = TREE_CODE(type);
+
+		if (node == type)
+			return false;
+		if (code == RECORD_TYPE || code == UNION_TYPE) {
+			if (!(walk_struct(type)))
+				return false;
+		} else if (!is_fptr(field) && !TREE_READONLY(field))
+			return false;
+	}
+	return true;
+}
+
+static void finish_type(void *event_data, void *data)
+{
+	tree type = (tree)event_data;
+
+	if (type == NULL_TREE || type == error_mark_node)
+		return;
+
+	if (TYPE_READONLY(type))
+		return;
+
+	if (walk_struct(type))
+		constify_type(type);
+	else
+		deconstify_type(type);
+}
+
+static unsigned int check_local_variables(void)
+{
+	unsigned int ret = 0;
+	tree var;
+
+#if BUILDING_GCC_VERSION == 4005
+	tree vars;
+#else
+	unsigned int i;
+#endif
+
+#if BUILDING_GCC_VERSION == 4005
+	for (vars = cfun->local_decls; vars; vars = TREE_CHAIN(vars)) {
+		var = TREE_VALUE(vars);
+#else
+	FOR_EACH_LOCAL_DECL(cfun, i, var) {
+#endif
+		tree type = TREE_TYPE(var);
+
+		gcc_assert(DECL_P(var));
+		if (is_global_var(var))
+			continue;
+
+		if (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)
+			continue;
+
+		if (!TYPE_READONLY(type))
+			continue;
+
+//		if (lookup_attribute("no_const", DECL_ATTRIBUTES(var)))
+//			continue;
+
+		if (lookup_attribute("no_const", TYPE_ATTRIBUTES(type)))
+			continue;
+
+		if (walk_struct(type)) {
+			error_at(DECL_SOURCE_LOCATION(var), "constified variable %qE cannot be local", var);
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+struct gimple_opt_pass pass_local_variable = {
+	{
+		.type			= GIMPLE_PASS,
+		.name			= "check_local_variables",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= NULL,
+		.execute		= check_local_variables,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= 0
+	}
+};
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+	bool constify = true;
+
+	struct register_pass_info local_variable_pass_info = {
+		.pass				= &pass_local_variable.pass,
+		.reference_pass_name		= "ssa",
+		.ref_pass_instance_number	= 1,
+		.pos_op				= PASS_POS_INSERT_BEFORE
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	for (i = 0; i < argc; ++i) {
+		if (!(strcmp(argv[i].key, "no-constify"))) {
+			constify = false;
+			continue;
+		}
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &const_plugin_info);
+	if (constify) {
+		register_callback(plugin_name, PLUGIN_FINISH_TYPE, finish_type, NULL);
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &local_variable_pass_info);
+	}
+	register_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/generate_size_overflow_hash.sh linux-2.6.32.60-pax/tools/gcc/generate_size_overflow_hash.sh
--- linux-2.6.32.60/tools/gcc/generate_size_overflow_hash.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/generate_size_overflow_hash.sh	2012-12-12 16:46:55.048275630 +0100
@@ -0,0 +1,94 @@
+#!/bin/bash
+
+# This script generates the hash table (size_overflow_hash.h) for the size_overflow gcc plugin (size_overflow_plugin.c).
+
+header1="size_overflow_hash.h"
+database="size_overflow_hash.data"
+n=65536
+
+usage() {
+cat <<EOF
+usage: $0 options
+OPTIONS:
+        -h|--help               help
+	-o			header file
+	-d			database file
+	-n			hash array size
+EOF
+    return 0
+}
+
+while true
+do
+    case "$1" in
+    -h|--help)	usage && exit 0;;
+    -n)		n=$2; shift 2;;
+    -o)		header1="$2"; shift 2;;
+    -d)		database="$2"; shift 2;;
+    --)		shift 1; break ;;
+     *)		break ;;
+    esac
+done
+
+create_defines() {
+	for i in `seq 0 31`
+	do
+		echo -e "#define PARAM"$i" (1U << "$i")" >> "$header1"
+	done
+	echo >> "$header1"
+}
+
+create_structs() {
+	rm -f "$header1"
+
+	create_defines
+
+	cat "$database" | while read data
+	do
+		data_array=($data)
+		struct_hash_name="${data_array[0]}"
+		funcn="${data_array[1]}"
+		params="${data_array[2]}"
+		next="${data_array[4]}"
+
+		echo "const struct size_overflow_hash $struct_hash_name = {" >> "$header1"
+
+		echo -e "\t.next\t= $next,\n\t.name\t= \"$funcn\"," >> "$header1"
+		echo -en "\t.param\t= " >> "$header1"
+		line=
+		for param_num in ${params//-/ };
+		do
+			line="${line}PARAM"$param_num"|"
+		done
+
+		echo -e "${line%?},\n};\n" >> "$header1"
+	done
+}
+
+create_headers() {
+	echo "const struct size_overflow_hash * const size_overflow_hash[$n] = {" >> "$header1"
+}
+
+create_array_elements() {
+	index=0
+	grep -v "nohasharray" $database | sort -n -k 4 | while read data
+	do
+		data_array=($data)
+		i="${data_array[3]}"
+		hash="${data_array[0]}"
+		while [[ $index -lt $i ]]
+		do
+			echo -e "\t["$index"]\t= NULL," >> "$header1"
+			index=$(($index + 1))
+		done
+		index=$(($index + 1))
+		echo -e "\t["$i"]\t= &"$hash"," >> "$header1"
+	done
+	echo '};' >> $header1
+}
+
+create_structs
+create_headers
+create_array_elements
+
+exit 0
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/.gitignore linux-2.6.32.60-pax/tools/gcc/.gitignore
--- linux-2.6.32.60/tools/gcc/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/.gitignore	2012-07-21 11:42:11.625097017 +0200
@@ -0,0 +1 @@
+size_overflow_hash.h
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/kallocstat_plugin.c linux-2.6.32.60-pax/tools/gcc/kallocstat_plugin.c
--- linux-2.6.32.60/tools/gcc/kallocstat_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/kallocstat_plugin.c	2013-02-17 17:20:34.388154306 +0100
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2011-2013 by the PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to find the distribution of k*alloc sizes
+ *
+ * TODO:
+ *
+ * BUGS:
+ * - none known
+ */
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+//#include "expr.h" where are you...
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+
+extern void print_gimple_stmt(FILE *, gimple, int, int);
+
+int plugin_is_GPL_compatible;
+
+static const char * const kalloc_functions[] = {
+	"__kmalloc",
+	"kmalloc",
+	"kmalloc_large",
+	"kmalloc_node",
+	"kmalloc_order",
+	"kmalloc_order_trace",
+	"kmalloc_slab",
+	"kzalloc",
+	"kzalloc_node",
+};
+
+static struct plugin_info kallocstat_plugin_info = {
+	.version	= "201302112000",
+};
+
+static unsigned int execute_kallocstat(void);
+
+static struct gimple_opt_pass kallocstat_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "kallocstat",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= NULL,
+		.execute		= execute_kallocstat,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= 0
+	}
+};
+
+static bool is_kalloc(const char *fnname)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(kalloc_functions); i++)
+		if (!strcmp(fnname, kalloc_functions[i]))
+			return true;
+	return false;
+}
+
+static unsigned int execute_kallocstat(void)
+{
+	basic_block bb;
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB(bb) {
+		gimple_stmt_iterator gsi;
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: 
+			tree fndecl, size;
+			gimple call_stmt;
+			const char *fnname;
+
+			// is it a call
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+			fndecl = gimple_call_fndecl(call_stmt);
+			if (fndecl == NULL_TREE)
+				continue;
+			if (TREE_CODE(fndecl) != FUNCTION_DECL)
+				continue;
+
+			// is it a call to k*alloc
+			fnname = IDENTIFIER_POINTER(DECL_NAME(fndecl));
+			if (!is_kalloc(fnname))
+				continue;
+
+			// is the size arg the result of a simple const assignment
+			size = gimple_call_arg(call_stmt, 0);
+			while (true) {
+				gimple def_stmt;
+				expanded_location xloc;
+				size_t size_val;
+
+				if (TREE_CODE(size) != SSA_NAME)
+					break;
+				def_stmt = SSA_NAME_DEF_STMT(size);
+				if (!def_stmt || !is_gimple_assign(def_stmt))
+					break;
+				if (gimple_num_ops(def_stmt) != 2)
+					break;
+				size = gimple_assign_rhs1(def_stmt);
+				if (!TREE_CONSTANT(size))
+					continue;
+				xloc = expand_location(gimple_location(def_stmt));
+				if (!xloc.file)
+					xloc = expand_location(DECL_SOURCE_LOCATION(current_function_decl));
+				size_val = TREE_INT_CST_LOW(size);
+				fprintf(stderr, "kallocsize: %8zu %8zx %s %s:%u\n", size_val, size_val, fnname, xloc.file, xloc.line);
+				break;
+			}
+//print_gimple_stmt(stderr, call_stmt, 0, TDF_LINENO);
+//debug_tree(gimple_call_fn(call_stmt));
+//print_node(stderr, "pax", fndecl, 4);
+		}
+	}
+
+	return 0;
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	struct register_pass_info kallocstat_pass_info = {
+		.pass				= &kallocstat_pass.pass,
+		.reference_pass_name		= "ssa",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_AFTER
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &kallocstat_plugin_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &kallocstat_pass_info);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/kernexec_plugin.c linux-2.6.32.60-pax/tools/gcc/kernexec_plugin.c
--- linux-2.6.32.60/tools/gcc/kernexec_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/kernexec_plugin.c	2013-02-17 17:20:34.392154305 +0100
@@ -0,0 +1,465 @@
+/*
+ * Copyright 2011-2013 by the PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to make KERNEXEC/amd64 almost as good as it is on i386
+ *
+ * TODO:
+ *
+ * BUGS:
+ * - none known
+ */
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+//#include "expr.h" where are you...
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+#include "tree-flow.h"
+
+extern void print_gimple_stmt(FILE *, gimple, int, int);
+extern rtx emit_move_insn(rtx x, rtx y);
+
+#if BUILDING_GCC_VERSION <= 4006
+#define ANY_RETURN_P(rtx) (GET_CODE(rtx) == RETURN)
+#endif
+
+#if BUILDING_GCC_VERSION >= 4008
+#define TODO_dump_func 0
+#endif
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info kernexec_plugin_info = {
+	.version	= "201302112000",
+	.help		= "method=[bts|or]\tinstrumentation method\n"
+};
+
+static unsigned int execute_kernexec_reload(void);
+static unsigned int execute_kernexec_fptr(void);
+static unsigned int execute_kernexec_retaddr(void);
+static bool kernexec_cmodel_check(void);
+
+static void (*kernexec_instrument_fptr)(gimple_stmt_iterator *);
+static void (*kernexec_instrument_retaddr)(rtx);
+
+static struct gimple_opt_pass kernexec_reload_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "kernexec_reload",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= kernexec_cmodel_check,
+		.execute		= execute_kernexec_reload,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa_no_phi
+	}
+};
+
+static struct gimple_opt_pass kernexec_fptr_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "kernexec_fptr",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= kernexec_cmodel_check,
+		.execute		= execute_kernexec_fptr,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa_no_phi
+	}
+};
+
+static struct rtl_opt_pass kernexec_retaddr_pass = {
+	.pass = {
+		.type			= RTL_PASS,
+		.name			= "kernexec_retaddr",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= kernexec_cmodel_check,
+		.execute		= execute_kernexec_retaddr,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= TODO_dump_func | TODO_ggc_collect
+	}
+};
+
+static bool kernexec_cmodel_check(void)
+{
+	tree section;
+
+	if (ix86_cmodel != CM_KERNEL)
+		return false;
+
+	section = lookup_attribute("section", DECL_ATTRIBUTES(current_function_decl));
+	if (!section || !TREE_VALUE(section))
+		return true;
+
+	section = TREE_VALUE(TREE_VALUE(section));
+	if (strncmp(TREE_STRING_POINTER(section), ".vsyscall_", 10))
+		return true;
+
+	return false;
+}
+
+/*
+ * add special KERNEXEC instrumentation: reload %r10 after it has been clobbered
+ */
+static void kernexec_reload_fptr_mask(gimple_stmt_iterator *gsi)
+{
+	gimple asm_movabs_stmt;
+
+	// build asm volatile("movabs $0x8000000000000000, %%r10\n\t" : : : );
+	asm_movabs_stmt = gimple_build_asm_vec("movabs $0x8000000000000000, %%r10\n\t", NULL, NULL, NULL, NULL);
+	gimple_asm_set_volatile(asm_movabs_stmt, true);
+	gsi_insert_after(gsi, asm_movabs_stmt, GSI_CONTINUE_LINKING);
+	update_stmt(asm_movabs_stmt);
+}
+
+/*
+ * find all asm() stmts that clobber r10 and add a reload of r10
+ */
+static unsigned int execute_kernexec_reload(void)
+{
+	basic_block bb;
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB(bb) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: __asm__ ("" :  :  : "r10");
+			gimple asm_stmt;
+			size_t nclobbers;
+
+			// is it an asm ...
+			asm_stmt = gsi_stmt(gsi);
+			if (gimple_code(asm_stmt) != GIMPLE_ASM)
+				continue;
+
+			// ... clobbering r10
+			nclobbers = gimple_asm_nclobbers(asm_stmt);
+			while (nclobbers--) {
+				tree op = gimple_asm_clobber_op(asm_stmt, nclobbers);
+				if (strcmp(TREE_STRING_POINTER(TREE_VALUE(op)), "r10"))
+					continue;
+				kernexec_reload_fptr_mask(&gsi);
+//print_gimple_stmt(stderr, asm_stmt, 0, TDF_LINENO);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * add special KERNEXEC instrumentation: force MSB of fptr to 1, which will produce
+ * a non-canonical address from a userland ptr and will just trigger a GPF on dereference
+ */
+static void kernexec_instrument_fptr_bts(gimple_stmt_iterator *gsi)
+{
+	gimple assign_intptr, assign_new_fptr, call_stmt;
+	tree intptr, old_fptr, new_fptr, kernexec_mask;
+
+	call_stmt = gsi_stmt(*gsi);
+	old_fptr = gimple_call_fn(call_stmt);
+
+	// create temporary unsigned long variable used for bitops and cast fptr to it
+	intptr = create_tmp_var(long_unsigned_type_node, "kernexec_bts");
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(intptr);
+	mark_sym_for_renaming(intptr);
+#endif
+	assign_intptr = gimple_build_assign(intptr, fold_convert(long_unsigned_type_node, old_fptr));
+	gsi_insert_before(gsi, assign_intptr, GSI_SAME_STMT);
+	update_stmt(assign_intptr);
+
+	// apply logical or to temporary unsigned long and bitmask
+	kernexec_mask = build_int_cstu(long_long_unsigned_type_node, 0x8000000000000000LL);
+//	kernexec_mask = build_int_cstu(long_long_unsigned_type_node, 0xffffffff80000000LL);
+	assign_intptr = gimple_build_assign(intptr, fold_build2(BIT_IOR_EXPR, long_long_unsigned_type_node, intptr, kernexec_mask));
+	gsi_insert_before(gsi, assign_intptr, GSI_SAME_STMT);
+	update_stmt(assign_intptr);
+
+	// cast temporary unsigned long back to a temporary fptr variable
+	new_fptr = create_tmp_var(TREE_TYPE(old_fptr), "kernexec_fptr");
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(new_fptr);
+	mark_sym_for_renaming(new_fptr);
+#endif
+	assign_new_fptr = gimple_build_assign(new_fptr, fold_convert(TREE_TYPE(old_fptr), intptr));
+	gsi_insert_before(gsi, assign_new_fptr, GSI_SAME_STMT);
+	update_stmt(assign_new_fptr);
+
+	// replace call stmt fn with the new fptr
+	gimple_call_set_fn(call_stmt, new_fptr);
+	update_stmt(call_stmt);
+}
+
+static void kernexec_instrument_fptr_or(gimple_stmt_iterator *gsi)
+{
+	gimple asm_or_stmt, call_stmt;
+	tree old_fptr, new_fptr, input, output;
+#if BUILDING_GCC_VERSION <= 4007
+	VEC(tree, gc) *inputs = NULL;
+	VEC(tree, gc) *outputs = NULL;
+#else
+	vec<tree, va_gc> *inputs = NULL;
+	vec<tree, va_gc> *outputs = NULL;
+#endif
+
+	call_stmt = gsi_stmt(*gsi);
+	old_fptr = gimple_call_fn(call_stmt);
+
+	// create temporary fptr variable
+	new_fptr = create_tmp_var(TREE_TYPE(old_fptr), "kernexec_or");
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(new_fptr);
+	mark_sym_for_renaming(new_fptr);
+#endif
+
+	// build asm volatile("orq %%r10, %0\n\t" : "=r"(new_fptr) : "0"(old_fptr));
+	input = build_tree_list(NULL_TREE, build_string(2, "0"));
+	input = chainon(NULL_TREE, build_tree_list(input, old_fptr));
+	output = build_tree_list(NULL_TREE, build_string(3, "=r"));
+	output = chainon(NULL_TREE, build_tree_list(output, new_fptr));
+#if BUILDING_GCC_VERSION <= 4007
+	VEC_safe_push(tree, gc, inputs, input);
+	VEC_safe_push(tree, gc, outputs, output);
+#else
+	vec_safe_push(inputs, input);
+	vec_safe_push(outputs, output);
+#endif
+	asm_or_stmt = gimple_build_asm_vec("orq %%r10, %0\n\t", inputs, outputs, NULL, NULL);
+	gimple_asm_set_volatile(asm_or_stmt, true);
+	gsi_insert_before(gsi, asm_or_stmt, GSI_SAME_STMT);
+	update_stmt(asm_or_stmt);
+
+	// replace call stmt fn with the new fptr
+	gimple_call_set_fn(call_stmt, new_fptr);
+	update_stmt(call_stmt);
+}
+
+/*
+ * find all C level function pointer dereferences and forcibly set the highest bit of the pointer
+ */
+static unsigned int execute_kernexec_fptr(void)
+{
+	basic_block bb;
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB(bb) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: h_1 = get_fptr (); D.2709_3 = h_1 (x_2(D));
+			tree fn;
+			gimple call_stmt;
+
+			// is it a call ...
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+			fn = gimple_call_fn(call_stmt);
+			if (TREE_CODE(fn) == ADDR_EXPR)
+				continue;
+			if (TREE_CODE(fn) != SSA_NAME)
+				gcc_unreachable();
+
+			// ... through a function pointer
+			if (SSA_NAME_VAR(fn) != NULL_TREE) {
+				fn = SSA_NAME_VAR(fn);
+				if (TREE_CODE(fn) != VAR_DECL && TREE_CODE(fn) != PARM_DECL) {
+					debug_tree(fn);
+					gcc_unreachable();
+				}
+			}
+			fn = TREE_TYPE(fn);
+			if (TREE_CODE(fn) != POINTER_TYPE)
+				continue;
+			fn = TREE_TYPE(fn);
+			if (TREE_CODE(fn) != FUNCTION_TYPE)
+				continue;
+
+			kernexec_instrument_fptr(&gsi);
+
+//debug_tree(gimple_call_fn(call_stmt));
+//print_gimple_stmt(stderr, call_stmt, 0, TDF_LINENO);
+		}
+	}
+
+	return 0;
+}
+
+// add special KERNEXEC instrumentation: btsq $63,(%rsp) just before retn
+static void kernexec_instrument_retaddr_bts(rtx insn)
+{
+	rtx btsq;
+	rtvec argvec, constraintvec, labelvec;
+	int line;
+
+	// create asm volatile("btsq $63,(%%rsp)":::)
+	argvec = rtvec_alloc(0);
+	constraintvec = rtvec_alloc(0);
+	labelvec = rtvec_alloc(0);
+	line = expand_location(RTL_LOCATION(insn)).line;
+	btsq = gen_rtx_ASM_OPERANDS(VOIDmode, "btsq $63,(%%rsp)", empty_string, 0, argvec, constraintvec, labelvec, line);
+	MEM_VOLATILE_P(btsq) = 1;
+//	RTX_FRAME_RELATED_P(btsq) = 1; // not for ASM_OPERANDS
+	emit_insn_before(btsq, insn);
+}
+
+// add special KERNEXEC instrumentation: orq %r10,(%rsp) just before retn
+static void kernexec_instrument_retaddr_or(rtx insn)
+{
+	rtx orq;
+	rtvec argvec, constraintvec, labelvec;
+	int line;
+
+	// create asm volatile("orq %%r10,(%%rsp)":::)
+	argvec = rtvec_alloc(0);
+	constraintvec = rtvec_alloc(0);
+	labelvec = rtvec_alloc(0);
+	line = expand_location(RTL_LOCATION(insn)).line;
+	orq = gen_rtx_ASM_OPERANDS(VOIDmode, "orq %%r10,(%%rsp)", empty_string, 0, argvec, constraintvec, labelvec, line);
+	MEM_VOLATILE_P(orq) = 1;
+//	RTX_FRAME_RELATED_P(orq) = 1; // not for ASM_OPERANDS
+	emit_insn_before(orq, insn);
+}
+
+/*
+ * find all asm level function returns and forcibly set the highest bit of the return address
+ */
+static unsigned int execute_kernexec_retaddr(void)
+{
+	rtx insn;
+
+	// 1. find function returns
+	for (insn = get_insns(); insn; insn = NEXT_INSN(insn)) {
+		// rtl match: (jump_insn 41 40 42 2 (return) fptr.c:42 634 {return_internal} (nil))
+		//            (jump_insn 12 9 11 2 (parallel [ (return) (unspec [ (0) ] UNSPEC_REP) ]) fptr.c:46 635 {return_internal_long} (nil))
+		//            (jump_insn 97 96 98 6 (simple_return) fptr.c:50 -1 (nil) -> simple_return)
+		rtx body;
+
+		// is it a retn
+		if (!JUMP_P(insn))
+			continue;
+		body = PATTERN(insn);
+		if (GET_CODE(body) == PARALLEL)
+			body = XVECEXP(body, 0, 0);
+		if (!ANY_RETURN_P(body))
+			continue;
+		kernexec_instrument_retaddr(insn);
+	}
+
+//	print_simple_rtl(stderr, get_insns());
+//	print_rtl(stderr, get_insns());
+
+	return 0;
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+	struct register_pass_info kernexec_reload_pass_info = {
+		.pass				= &kernexec_reload_pass.pass,
+		.reference_pass_name		= "ssa",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_AFTER
+	};
+	struct register_pass_info kernexec_fptr_pass_info = {
+		.pass				= &kernexec_fptr_pass.pass,
+		.reference_pass_name		= "ssa",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_AFTER
+	};
+	struct register_pass_info kernexec_retaddr_pass_info = {
+		.pass				= &kernexec_retaddr_pass.pass,
+		.reference_pass_name		= "pro_and_epilogue",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_AFTER
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &kernexec_plugin_info);
+
+	if (TARGET_64BIT == 0)
+		return 0;
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "method")) {
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+			if (!strcmp(argv[i].value, "bts")) {
+				kernexec_instrument_fptr = kernexec_instrument_fptr_bts;
+				kernexec_instrument_retaddr = kernexec_instrument_retaddr_bts;
+			} else if (!strcmp(argv[i].value, "or")) {
+				kernexec_instrument_fptr = kernexec_instrument_fptr_or;
+				kernexec_instrument_retaddr = kernexec_instrument_retaddr_or;
+				fix_register("r10", 1, 1);
+			} else
+				error(G_("invalid option argument '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, argv[i].value);
+			continue;
+		}
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+	if (!kernexec_instrument_fptr || !kernexec_instrument_retaddr)
+		error(G_("no instrumentation method was selected via '-fplugin-arg-%s-method'"), plugin_name);
+
+	if (kernexec_instrument_fptr == kernexec_instrument_fptr_or)
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &kernexec_reload_pass_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &kernexec_fptr_pass_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &kernexec_retaddr_pass_info);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/latent_entropy_plugin.c linux-2.6.32.60-pax/tools/gcc/latent_entropy_plugin.c
--- linux-2.6.32.60/tools/gcc/latent_entropy_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/latent_entropy_plugin.c	2013-02-17 17:20:34.392154305 +0100
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2012-2013 by the PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to help generate a little bit of entropy from program state,
+ * used during boot in the kernel
+ *
+ * TODO:
+ * - add ipa pass to identify not explicitly marked candidate functions
+ * - mix in more program state (function arguments/return values, loop variables, etc)
+ * - more instrumentation control via attribute parameters
+ *
+ * BUGS:
+ * - LTO needs -flto-partition=none for now
+ */
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+//#include "expr.h" where are you...
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+#include "tree-flow.h"
+
+#if BUILDING_GCC_VERSION >= 4008
+#define TODO_dump_func 0
+#endif
+
+int plugin_is_GPL_compatible;
+
+static tree latent_entropy_decl;
+
+static struct plugin_info latent_entropy_plugin_info = {
+	.version	= "201302112000",
+	.help		= NULL
+};
+
+static unsigned int execute_latent_entropy(void);
+static bool gate_latent_entropy(void);
+
+static struct gimple_opt_pass latent_entropy_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "latent_entropy",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= gate_latent_entropy,
+		.execute		= execute_latent_entropy,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= PROP_gimple_leh | PROP_cfg,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0, //TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts,
+		.todo_flags_finish	= TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_update_ssa
+	}
+};
+
+static tree handle_latent_entropy_attribute(tree *node, tree name, tree args, int flags, bool *no_add_attrs)
+{
+	if (TREE_CODE(*node) != FUNCTION_DECL) {
+		*no_add_attrs = true;
+		error("%qE attribute only applies to functions", name);
+	}
+	return NULL_TREE;
+}
+
+static struct attribute_spec latent_entropy_attr = {
+	.name				= "latent_entropy",
+	.min_length			= 0,
+	.max_length			= 0,
+	.decl_required			= true,
+	.type_required			= false,
+	.function_type_required		= false,
+	.handler			= handle_latent_entropy_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity		= false
+#endif
+};
+
+static void register_attributes(void *event_data, void *data)
+{
+	register_attribute(&latent_entropy_attr);
+}
+
+static bool gate_latent_entropy(void)
+{
+	tree latent_entropy_attr;
+
+	latent_entropy_attr = lookup_attribute("latent_entropy", DECL_ATTRIBUTES(current_function_decl));
+	return latent_entropy_attr != NULL_TREE;
+}
+
+static unsigned HOST_WIDE_INT seed;
+static unsigned HOST_WIDE_INT get_random_const(void)
+{
+	seed = (seed >> 1U) ^ (-(seed & 1ULL) & 0xD800000000000000ULL);
+	return seed;
+}
+
+static enum tree_code get_op(tree *rhs)
+{
+	static enum tree_code op;
+	unsigned HOST_WIDE_INT random_const;
+
+	random_const = get_random_const();
+
+	switch (op) {
+	case BIT_XOR_EXPR:
+		op = PLUS_EXPR;
+		break;
+
+	case PLUS_EXPR:
+		if (rhs) {
+			op = LROTATE_EXPR;
+			random_const &= HOST_BITS_PER_WIDE_INT - 1;
+			break;
+		}
+
+	case LROTATE_EXPR:
+	default:
+		op = BIT_XOR_EXPR;
+		break;
+	}
+	if (rhs)
+		*rhs = build_int_cstu(unsigned_intDI_type_node, random_const);
+	return op;
+}
+
+static void perturb_local_entropy(basic_block bb, tree local_entropy)
+{
+	gimple_stmt_iterator gsi;
+	gimple assign;
+	tree addxorrol, rhs;
+	enum tree_code op;
+
+	op = get_op(&rhs);
+	addxorrol = fold_build2_loc(UNKNOWN_LOCATION, op, unsigned_intDI_type_node, local_entropy, rhs);
+	assign = gimple_build_assign(local_entropy, addxorrol);
+#if BUILDING_GCC_VERSION <= 4007
+	find_referenced_vars_in(assign);
+#endif
+//debug_bb(bb);
+	gsi = gsi_after_labels(bb);
+	gsi_insert_before(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+}
+
+static void perturb_latent_entropy(basic_block bb, tree rhs)
+{
+	gimple_stmt_iterator gsi;
+	gimple assign;
+	tree addxorrol, temp;
+
+	// 1. create temporary copy of latent_entropy
+	temp = create_tmp_var(unsigned_intDI_type_node, "temp_latent_entropy");
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(temp);
+	mark_sym_for_renaming(temp);
+#endif
+
+	// 2. read...
+	assign = gimple_build_assign(temp, latent_entropy_decl);
+#if BUILDING_GCC_VERSION <= 4007
+	find_referenced_vars_in(assign);
+#endif
+	gsi = gsi_after_labels(bb);
+	gsi_insert_after(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+
+	// 3. ...modify...
+	addxorrol = fold_build2_loc(UNKNOWN_LOCATION, get_op(NULL), unsigned_intDI_type_node, temp, rhs);
+	assign = gimple_build_assign(temp, addxorrol);
+#if BUILDING_GCC_VERSION <= 4007
+	find_referenced_vars_in(assign);
+#endif
+	gsi_insert_after(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+
+	// 4. ...write latent_entropy
+	assign = gimple_build_assign(latent_entropy_decl, temp);
+#if BUILDING_GCC_VERSION <= 4007
+	find_referenced_vars_in(assign);
+#endif
+	gsi_insert_after(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+}
+
+static unsigned int execute_latent_entropy(void)
+{
+	basic_block bb;
+	gimple assign;
+	gimple_stmt_iterator gsi;
+	tree local_entropy;
+
+	if (!latent_entropy_decl) {
+		struct varpool_node *node;
+
+#if BUILDING_GCC_VERSION <= 4007
+		for (node = varpool_nodes; node; node = node->next) {
+			tree var = node->decl;
+#else
+		FOR_EACH_VARIABLE(node) {
+			tree var = node->symbol.decl;
+#endif
+			if (strcmp(IDENTIFIER_POINTER(DECL_NAME(var)), "latent_entropy"))
+				continue;
+			latent_entropy_decl = var;
+//			debug_tree(var);
+			break;
+		}
+		if (!latent_entropy_decl) {
+//			debug_tree(current_function_decl);
+			return 0;
+		}
+	}
+
+//fprintf(stderr, "latent_entropy: %s\n", IDENTIFIER_POINTER(DECL_NAME(current_function_decl)));
+
+	// 1. create local entropy variable
+	local_entropy = create_tmp_var(unsigned_intDI_type_node, "local_entropy");
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(local_entropy);
+	mark_sym_for_renaming(local_entropy);
+#endif
+
+	// 2. initialize local entropy variable
+	bb = split_block_after_labels(ENTRY_BLOCK_PTR)->dest;
+	if (dom_info_available_p(CDI_DOMINATORS))
+		set_immediate_dominator(CDI_DOMINATORS, bb, ENTRY_BLOCK_PTR);
+	gsi = gsi_start_bb(bb);
+
+	assign = gimple_build_assign(local_entropy, build_int_cstu(unsigned_intDI_type_node, get_random_const()));
+//	gimple_set_location(assign, loc);
+#if BUILDING_GCC_VERSION <= 4007
+	find_referenced_vars_in(assign);
+#endif
+	gsi_insert_after(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+	bb = bb->next_bb;
+
+	// 3. instrument each BB with an operation on the local entropy variable
+	while (bb != EXIT_BLOCK_PTR) {
+		perturb_local_entropy(bb, local_entropy);
+		bb = bb->next_bb;
+	};
+
+	// 4. mix local entropy into the global entropy variable
+	perturb_latent_entropy(EXIT_BLOCK_PTR->prev_bb, local_entropy);
+	return 0;
+}
+
+static void start_unit_callback(void *gcc_data, void *user_data)
+{
+#if BUILDING_GCC_VERSION >= 4007
+	seed = get_random_seed(false);
+#else
+	sscanf(get_random_seed(false), "%" HOST_WIDE_INT_PRINT "x", &seed);
+	seed *= seed;
+#endif
+
+	if (in_lto_p)
+		return;
+
+	// extern u64 latent_entropy
+	latent_entropy_decl = build_decl(UNKNOWN_LOCATION, VAR_DECL, get_identifier("latent_entropy"), unsigned_intDI_type_node);
+
+	TREE_STATIC(latent_entropy_decl) = 1;
+	TREE_PUBLIC(latent_entropy_decl) = 1;
+	TREE_USED(latent_entropy_decl) = 1;
+	TREE_THIS_VOLATILE(latent_entropy_decl) = 1;
+	DECL_EXTERNAL(latent_entropy_decl) = 1;
+	DECL_ARTIFICIAL(latent_entropy_decl) = 0;
+	DECL_INITIAL(latent_entropy_decl) = NULL;
+//	DECL_ASSEMBLER_NAME(latent_entropy_decl);
+//	varpool_finalize_decl(latent_entropy_decl);
+//	varpool_mark_needed_node(latent_entropy_decl);
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	struct register_pass_info latent_entropy_pass_info = {
+		.pass				= &latent_entropy_pass.pass,
+		.reference_pass_name		= "optimized",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_BEFORE
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &latent_entropy_plugin_info);
+	register_callback ("start_unit", PLUGIN_START_UNIT, &start_unit_callback, NULL);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &latent_entropy_pass_info);
+	register_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/Makefile linux-2.6.32.60-pax/tools/gcc/Makefile
--- linux-2.6.32.60/tools/gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/Makefile	2012-07-27 21:50:49.230341385 +0200
@@ -0,0 +1,43 @@
+#CC := gcc
+#PLUGIN_SOURCE_FILES := pax_plugin.c
+#PLUGIN_OBJECT_FILES := $(patsubst %.c,%.o,$(PLUGIN_SOURCE_FILES))
+GCCPLUGINS_DIR := $(shell $(CC) -print-file-name=plugin)
+#CFLAGS += -I$(GCCPLUGINS_DIR)/include -fPIC -O2 -Wall -W -std=gnu99
+
+ifeq ($(PLUGINCC),$(HOSTCC))
+HOSTLIBS := hostlibs
+HOST_EXTRACFLAGS += -I$(GCCPLUGINS_DIR)/include -I$(GCCPLUGINS_DIR)/include/c-family -std=gnu99 -ggdb
+else
+HOSTLIBS := hostcxxlibs
+HOST_EXTRACXXFLAGS += -I$(GCCPLUGINS_DIR)/include -I$(GCCPLUGINS_DIR)/include/c-family -std=gnu++98 -ggdb -Wno-unused-parameter
+endif
+
+$(HOSTLIBS)-$(CONFIG_PAX_CONSTIFY_PLUGIN) := constify_plugin.so
+$(HOSTLIBS)-$(CONFIG_PAX_MEMORY_STACKLEAK) += stackleak_plugin.so
+$(HOSTLIBS)-$(CONFIG_KALLOCSTAT_PLUGIN) += kallocstat_plugin.so
+$(HOSTLIBS)-$(CONFIG_PAX_KERNEXEC_PLUGIN) += kernexec_plugin.so
+$(HOSTLIBS)-$(CONFIG_CHECKER_PLUGIN) += checker_plugin.so
+$(HOSTLIBS)-y += colorize_plugin.so
+$(HOSTLIBS)-$(CONFIG_PAX_SIZE_OVERFLOW) += size_overflow_plugin.so
+$(HOSTLIBS)-$(CONFIG_PAX_LATENT_ENTROPY) += latent_entropy_plugin.so
+
+always := $($(HOSTLIBS)-y)
+
+constify_plugin-objs := constify_plugin.o
+stackleak_plugin-objs := stackleak_plugin.o
+kallocstat_plugin-objs := kallocstat_plugin.o
+kernexec_plugin-objs := kernexec_plugin.o
+checker_plugin-objs := checker_plugin.o
+colorize_plugin-objs := colorize_plugin.o
+size_overflow_plugin-objs := size_overflow_plugin.o
+latent_entropy_plugin-objs := latent_entropy_plugin.o
+
+$(obj)/size_overflow_plugin.o: $(objtree)/$(obj)/size_overflow_hash.h
+
+quiet_cmd_build_size_overflow_hash = GENHASH  $@
+      cmd_build_size_overflow_hash = \
+	$(CONFIG_SHELL) $(srctree)/$(src)/generate_size_overflow_hash.sh -d $< -o $@
+$(objtree)/$(obj)/size_overflow_hash.h: $(src)/size_overflow_hash.data FORCE
+	$(call if_changed,build_size_overflow_hash)
+
+targets += size_overflow_hash.h
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/size_overflow_hash.data linux-2.6.32.60-pax/tools/gcc/size_overflow_hash.data
--- linux-2.6.32.60/tools/gcc/size_overflow_hash.data	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/size_overflow_hash.data	2012-12-14 22:33:41.104029256 +0100
@@ -0,0 +1,2565 @@
+ipw_queue_tx_init_49161 ipw_queue_tx_init 3 49161 NULL
+scsi_nl_send_vendor_msg_16394 scsi_nl_send_vendor_msg 5 16394 NULL
+acpi_video_bus_write_POST_30039 acpi_video_bus_write_POST 3 30039 NULL
+recent_mt_proc_write_8206 recent_mt_proc_write 3 8206 NULL
+alloc_trdev_16399 alloc_trdev 1 16399 NULL
+rds_sendmsg_40976 rds_sendmsg 4 40976 NULL
+econet_recvmsg_40978 econet_recvmsg 4 40978 NULL
+rt2x00debug_write_bbp_8212 rt2x00debug_write_bbp 3 8212 NULL
+diva_os_malloc_16406 diva_os_malloc 2 16406 NULL
+compat_sock_setsockopt_23 compat_sock_setsockopt 5 23 NULL
+play_iframe_8219 play_iframe 3 8219 NULL
+rxrpc_server_keyring_16431 rxrpc_server_keyring 3 16431 NULL
+usbvideo_rvmalloc_17758 usbvideo_rvmalloc 1 17758 NULL
+sel_read_policyvers_55 sel_read_policyvers 3 55 NULL nohasharray
+padzero_55 padzero 1 55 &sel_read_policyvers_55
+cfg80211_disconnected_57 cfg80211_disconnected 4 57 NULL
+read_file_blob_57406 read_file_blob 3 57406 NULL
+sctp_getsockopt_primary_addr_24639 sctp_getsockopt_primary_addr 2 24639 NULL
+hpsb_write_49217 hpsb_write 6 49217 NULL
+enclosure_register_57412 enclosure_register 3 57412 NULL
+t3_init_l2t_8261 t3_init_l2t 1 8261 NULL
+_req_append_segment_41031 _req_append_segment 2 41031 NULL
+netlink_change_ngroups_16457 netlink_change_ngroups 2 16457 NULL
+mISDN_sock_sendmsg_41035 mISDN_sock_sendmsg 4 41035 NULL
+DepcaSignature_80 DepcaSignature 2 80 NULL nohasharray
+crypto_authenc_setkey_80 crypto_authenc_setkey 3 80 &DepcaSignature_80
+init_cdev_8274 init_cdev 1 8274 NULL
+__mwl8k_cmd_mac_multicast_adr_57427 __mwl8k_cmd_mac_multicast_adr 2 57427 NULL
+copy_to_user_fromio_57432 copy_to_user_fromio 3 57432 NULL
+i2400m_queue_work_41051 i2400m_queue_work 5 41051 NULL
+snd_korg1212_copy_to_92 snd_korg1212_copy_to 6 92 NULL
+load_msg_95 load_msg 2 95 NULL
+sctp_tsnmap_grow_32784 sctp_tsnmap_grow 2 32784 NULL
+new_tape_buffer_32866 new_tape_buffer 2 32866 NULL
+wm8400_i2c_write_49251 wm8400_i2c_write 3 49251 NULL
+sctp_make_fwdtsn_53265 sctp_make_fwdtsn 3 53265 NULL
+sys_pselect6_57449 sys_pselect6 1 57449 NULL
+biovec_create_pools_9575 biovec_create_pools 2 9575 NULL
+tracing_readme_read_16493 tracing_readme_read 3 16493 NULL
+acpi_system_write_sleep_57456 acpi_system_write_sleep 3 57456 NULL
+ieee80211_send_probe_req_49265 ieee80211_send_probe_req 6 49265 NULL
+cfg80211_inform_bss_frame_41078 cfg80211_inform_bss_frame 4 41078 NULL
+sisusb_clear_vram_57466 sisusb_clear_vram 2-3 57466 NULL
+snd_cs4281_BA0_read_6847 snd_cs4281_BA0_read 5-6 6847 NULL
+osd_req_add_get_attr_list_49278 osd_req_add_get_attr_list 3 49278 NULL
+sysctl_string_modpriv_32895 sysctl_string_modpriv 5 32895 NULL
+construct_key_and_link_8321 construct_key_and_link 4 8321 NULL
+leaf_dealloc_24706 leaf_dealloc 3 24706 NULL
+init_q_132 init_q 4 132 NULL
+ipwireless_send_packet_8328 ipwireless_send_packet 4 8328 NULL
+memstick_alloc_host_142 memstick_alloc_host 1 142 NULL
+uio_read_49300 uio_read 3 49300 NULL
+btrfs_mksubvol_150 btrfs_mksubvol 3 150 NULL
+tracing_entries_read_8345 tracing_entries_read 3 8345 NULL
+oom_adjust_write_41116 oom_adjust_write 3 41116 NULL
+copy_in_user_57502 copy_in_user 3 57502 NULL
+simple_attr_read_24738 simple_attr_read 3 24738 NULL
+ath_rxbuf_alloc_24745 ath_rxbuf_alloc 2 24745 NULL
+init_tag_map_57515 init_tag_map 3 57515 NULL
+cmm_read_57520 cmm_read 3 57520 NULL
+kgdb_hex2mem_24755 kgdb_hex2mem 3 24755 NULL
+lpfc_debugfs_read_16566 lpfc_debugfs_read 3 16566 NULL
+DoC_Probe_57534 DoC_Probe 1 57534 NULL
+pcpu_embed_first_chunk_24224 pcpu_embed_first_chunk 3 24224 NULL
+agp_allocate_memory_wrap_16576 agp_allocate_memory_wrap 1 16576 NULL nohasharray
+new_partial_datagram_16576 new_partial_datagram 4 16576 &agp_allocate_memory_wrap_16576
+mI_alloc_skb_24770 mI_alloc_skb 1 24770 NULL
+iscsi_session_setup_196 iscsi_session_setup 4-5 196 NULL
+decode_asn1_bitstring_198 decode_asn1_bitstring 4 198 NULL
+xdi_copy_from_user_8395 xdi_copy_from_user 4 8395 NULL
+joydev_ioctl_common_49359 joydev_ioctl_common 2 49359 NULL
+dvb_ca_write_41171 dvb_ca_write 3 41171 NULL
+cache_read_24790 cache_read 3 24790 NULL
+store_cpufv_215 store_cpufv 4 215 NULL
+compat_filldir_32999 compat_filldir 3 32999 NULL
+ieee80211_if_read_auto_open_plinks_38268 ieee80211_if_read_auto_open_plinks 3 38268 NULL nohasharray
+mthca_alloc_icm_table_38268 mthca_alloc_icm_table 3-4 38268 &ieee80211_if_read_auto_open_plinks_38268
+iscsi_alloc_session_49390 iscsi_alloc_session 3 49390 NULL
+xfs_readdir_41200 xfs_readdir 3 41200 NULL
+wl1271_rx_handle_data_47827 wl1271_rx_handle_data 2 47827 NULL
+dvb_usercopy_16640 dvb_usercopy 3 16640 NULL
+proc_scsi_write_proc_267 proc_scsi_write_proc 3 267 NULL
+ip_append_data_41234 ip_append_data 4-5 41234 NULL
+platform_device_register_data_16660 platform_device_register_data 5 16660 NULL
+sk_stream_alloc_skb_57622 sk_stream_alloc_skb 2 57622 NULL
+iwl_dbgfs_ucode_general_stats_read_49199 iwl_dbgfs_ucode_general_stats_read 3 49199 NULL
+probe_kernel_read_49437 probe_kernel_read 3 49437 NULL
+sisusbcon_putcs_57630 sisusbcon_putcs 3 57630 NULL
+hpsb_make_readpacket_34181 hpsb_make_readpacket 4 34181 NULL
+pnp_alloc_24869 pnp_alloc 1 24869 NULL
+hiddev_compat_ioctl_41255 hiddev_compat_ioctl 2 41255 NULL
+stats_dot11RTSSuccessCount_read_33065 stats_dot11RTSSuccessCount_read 3 33065 NULL
+sel_read_checkreqprot_33068 sel_read_checkreqprot 3 33068 NULL
+queues_read_24877 queues_read 3 24877 NULL
+dlm_new_lockspace_16688 dlm_new_lockspace 2 16688 NULL
+platform_device_add_data_310 platform_device_add_data 3 310 NULL
+agp_3_5_isochronous_node_enable_49465 agp_3_5_isochronous_node_enable 3 49465 NULL
+iwl_dbgfs_tx_statistics_read_314 iwl_dbgfs_tx_statistics_read 3 314 NULL nohasharray
+dn_setsockopt_314 dn_setsockopt 5 314 &iwl_dbgfs_tx_statistics_read_314
+sys_mq_timedsend_57661 sys_mq_timedsend 3 57661 NULL
+r3964_write_57662 r3964_write 4 57662 NULL
+xfs_iformat_local_49472 xfs_iformat_local 4 49472 NULL
+dn_nsp_do_disc_49474 dn_nsp_do_disc 2-6 49474 NULL
+alloc_context_41283 alloc_context 1 41283 NULL
+__lgwrite_57669 __lgwrite 4 57669 NULL
+sctp_recvmsg_23265 sctp_recvmsg 4 23265 NULL
+acpi_processor_write_throttling_16712 acpi_processor_write_throttling 3 16712 NULL
+isr_decrypt_done_read_49490 isr_decrypt_done_read 3 49490 NULL
+ieee80211_fragment_33112 ieee80211_fragment 4 33112 NULL
+write_node_33121 write_node 4 33121 NULL
+ip_vs_icmp_xmit_57701 ip_vs_icmp_xmit 4 57701 NULL
+i2400m_rx_stats_read_57706 i2400m_rx_stats_read 3 57706 NULL
+CIFSSMBWrite_33131 CIFSSMBWrite 4 33131 NULL
+iscsi_recv_pdu_16755 iscsi_recv_pdu 4 16755 NULL
+user_update_41332 user_update 3 41332 NULL
+cmtp_send_interopmsg_376 cmtp_send_interopmsg 7 376 NULL
+cache_slow_downcall_8570 cache_slow_downcall 2 8570 NULL
+lbs_getscantable_24955 lbs_getscantable 3 24955 NULL
+isr_dma0_done_read_8574 isr_dma0_done_read 3 8574 NULL
+nfs4_init_slot_table_33152 nfs4_init_slot_table 2 33152 NULL
+sys_rt_sigpending_24961 sys_rt_sigpending 2 24961 NULL
+ip_nat_sip_expect_57732 ip_nat_sip_expect 6 57732 NULL
+add_rx_skb_8257 add_rx_skb 3 8257 NULL
+do_fcntl_31468 do_fcntl 3 31468 NULL
+compat_sys_set_mempolicy_57742 compat_sys_set_mempolicy 3 57742 NULL nohasharray
+pppol2tp_recvmsg_57742 pppol2tp_recvmsg 4 57742 &compat_sys_set_mempolicy_57742
+sctp_make_op_error_space_5528 sctp_make_op_error_space 3 5528 NULL
+tun_get_user_33178 tun_get_user 3 33178 NULL
+llc_ui_sendmsg_24987 llc_ui_sendmsg 4 24987 NULL
+kmp_init_41373 kmp_init 2 41373 NULL
+lbs_rdmac_read_418 lbs_rdmac_read 3 418 NULL
+ntfs_malloc_nofs_49572 ntfs_malloc_nofs 1 49572 NULL
+alloc_chunk_49575 alloc_chunk 1 49575 NULL
+sctp_setsockopt_default_send_param_49578 sctp_setsockopt_default_send_param 3 49578 NULL nohasharray
+hidraw_report_event_49578 hidraw_report_event 3 49578 &sctp_setsockopt_default_send_param_49578
+key_conf_hw_key_idx_read_25003 key_conf_hw_key_idx_read 3 25003 NULL
+shash_setkey_unaligned_8620 shash_setkey_unaligned 3 8620 NULL
+dm_vcalloc_16814 dm_vcalloc 1-2 16814 NULL
+dataflash_read_fact_otp_33204 dataflash_read_fact_otp 3-2 33204 NULL
+isr_commands_read_41398 isr_commands_read 3 41398 NULL
+pp_read_33210 pp_read 3 33210 NULL
+sys_flistxattr_41407 sys_flistxattr 3 41407 NULL
+scsi_mode_sense_16835 scsi_mode_sense 5 16835 NULL
+ivtv_read_57796 ivtv_read 3 57796 NULL
+isr_wakeups_read_49607 isr_wakeups_read 3 49607 NULL
+xfs_iext_add_41422 xfs_iext_add 3 41422 NULL
+heap_init_49617 heap_init 2 49617 NULL
+isdn_ppp_fill_rq_41428 isdn_ppp_fill_rq 2 41428 NULL
+smk_write_doi_49621 smk_write_doi 3 49621 NULL
+_alloc_get_attr_desc_470 _alloc_get_attr_desc 2 470 NULL
+lbs_rdrf_read_41431 lbs_rdrf_read 3 41431 NULL
+receive_packet_12367 receive_packet 2 12367 NULL
+ntfs_file_buffered_write_41442 ntfs_file_buffered_write 4-6 41442 NULL
+pcpu_build_alloc_info_41443 pcpu_build_alloc_info 3 41443 NULL
+lbs_bcnmiss_read_8678 lbs_bcnmiss_read 3 8678 NULL
+st_write_16874 st_write 3 16874 NULL
+copy_to_user_57835 copy_to_user 3 57835 NULL
+pidlist_resize_496 pidlist_resize 2 496 NULL
+mangle_eprt_packet_16882 mangle_eprt_packet 5 16882 NULL
+flash_read_57843 flash_read 3 57843 NULL
+cachefiles_cook_key_33274 cachefiles_cook_key 2 33274 NULL
+rds_message_map_pages_31487 rds_message_map_pages 2 31487 NULL
+arcfb_write_8702 arcfb_write 3 8702 NULL
+cxio_hal_init_rhdl_resource_25104 cxio_hal_init_rhdl_resource 1 25104 NULL
+sock_wmalloc_16472 sock_wmalloc 2 16472 NULL
+snd_rawmidi_kernel_write_25106 snd_rawmidi_kernel_write 3 25106 NULL
+wep_interrupt_read_41492 wep_interrupt_read 3 41492 NULL
+tracing_max_lat_write_8728 tracing_max_lat_write 3 8728 NULL
+hpfs_translate_name_41497 hpfs_translate_name 3 41497 NULL
+mcs7830_get_reg_33308 mcs7830_get_reg 3 33308 NULL
+snd_gf1_mem_proc_dump_16926 snd_gf1_mem_proc_dump 5-6 16926 NULL
+dn_def_dev_strategy_51973 dn_def_dev_strategy 5 51973 NULL
+sys_gethostname_49698 sys_gethostname 2 49698 NULL
+vhci_read_47878 vhci_read 3 47878 NULL
+devres_alloc_551 devres_alloc 2 551 NULL
+xt_alloc_table_info_57903 xt_alloc_table_info 1 57903 NULL
+em28xx_init_isoc_8755 em28xx_init_isoc 2-3 8755 NULL
+emi26_writememory_57908 emi26_writememory 4 57908 NULL
+hpsb_create_hostinfo_49717 hpsb_create_hostinfo 3 49717 NULL
+joydev_compat_ioctl_8765 joydev_compat_ioctl 2 8765 NULL
+joydev_ioctl_33343 joydev_ioctl 2 33343 NULL
+compat_sys_preadv_583 compat_sys_preadv 3 583 NULL
+sys_fsetxattr_49736 sys_fsetxattr 4 49736 NULL
+create_xattr_datum_33356 create_xattr_datum 5 33356 NULL
+sel_read_handle_unknown_57933 sel_read_handle_unknown 3 57933 NULL
+sys_fgetxattr_25166 sys_fgetxattr 4 25166 NULL
+ipath_init_qp_table_25167 ipath_init_qp_table 2 25167 NULL
+zd_usb_iowrite16v_49744 zd_usb_iowrite16v 3 49744 NULL
+cache_do_downcall_6926 cache_do_downcall 3 6926 NULL
+rx_57944 rx 4 57944 NULL
+sctp_getsockopt_local_addrs_25178 sctp_getsockopt_local_addrs 2 25178 NULL
+key_conf_keylen_read_49758 key_conf_keylen_read 3 49758 NULL
+cpuset_common_file_read_8800 cpuset_common_file_read 5 8800 NULL
+sctp_ulpevent_new_33377 sctp_ulpevent_new 1 33377 NULL
+fuse_conn_waiting_read_49762 fuse_conn_waiting_read 3 49762 NULL
+ieee80211_if_read_dropped_frames_no_route_33383 ieee80211_if_read_dropped_frames_no_route 3 33383 NULL
+viafb_dfpl_proc_write_627 viafb_dfpl_proc_write 3 627 NULL
+hfc_empty_fifo_57972 hfc_empty_fifo 2 57972 NULL
+metronomefb_write_8823 metronomefb_write 3 8823 NULL
+tw_change_queue_depth_57980 tw_change_queue_depth 2 57980 NULL
+iwm_if_alloc_17027 iwm_if_alloc 1 17027 NULL
+hpsb_alloc_packet_49798 hpsb_alloc_packet 1 49798 NULL
+sys_dup3_33421 sys_dup3 2 33421 NULL
+nfs4_acl_new_49806 nfs4_acl_new 1 49806 NULL
+rx_reset_counter_read_58001 rx_reset_counter_read 3 58001 NULL
+mon_stat_read_25238 mon_stat_read 3 25238 NULL
+wa_nep_queue_8858 wa_nep_queue 2 8858 NULL
+ntfs_copy_from_user_iovec_49829 ntfs_copy_from_user_iovec 3-6 49829 NULL
+iwl_dbgfs_ucode_rx_stats_read_58023 iwl_dbgfs_ucode_rx_stats_read 3 58023 NULL
+read_cis_cache_17069 read_cis_cache 4 17069 NULL
+sta_tx_fragments_read_49841 sta_tx_fragments_read 3 49841 NULL
+mempool_create_kmalloc_pool_41650 mempool_create_kmalloc_pool 1 41650 NULL
+simple_transaction_read_17076 simple_transaction_read 3 17076 NULL
+squashfs_cache_init_41656 squashfs_cache_init 2 41656 NULL
+tracing_max_lat_read_8890 tracing_max_lat_read 3 8890 NULL
+crypto_alloc_instance2_25277 crypto_alloc_instance2 3 25277 NULL
+vfs_writev_25278 vfs_writev 3 25278 NULL
+alloc_async_14208 alloc_async 1 14208 NULL
+sys_dup2_25284 sys_dup2 2 25284 NULL
+create_entry_33479 create_entry 2 33479 NULL
+ipath_resize_cq_712 ipath_resize_cq 2 712 NULL
+sys_preadv_17100 sys_preadv 3 17100 NULL
+sctp_setsockopt_bindx_49870 sctp_setsockopt_bindx 3 49870 NULL
+ip_setsockopt_33487 ip_setsockopt 5 33487 NULL
+rds_message_copy_from_user_41682 rds_message_copy_from_user 2 41682 NULL
+xfs_da_buf_make_25303 xfs_da_buf_make 1 25303 NULL
+write_mem_17114 write_mem 3 17114 NULL
+res_counter_read_33499 res_counter_read 4 33499 NULL
+sctp_setsockopt_peer_addr_params_734 sctp_setsockopt_peer_addr_params 3 734 NULL
+cm4040_write_58079 cm4040_write 3 58079 NULL
+fb_read_33506 fb_read 3 33506 NULL
+rfcomm_wmalloc_58090 rfcomm_wmalloc 2 58090 NULL
+fast_shmem_write_8942 fast_shmem_write 5 8942 NULL
+ahash_setkey_unaligned_33521 ahash_setkey_unaligned 3 33521 NULL
+dvb_video_write_754 dvb_video_write 3 754 NULL
+bdx_tx_db_init_41719 bdx_tx_db_init 2 41719 NULL
+alloc_ldt_21972 alloc_ldt 2 21972 NULL
+sys_pwritev_41722 sys_pwritev 3 41722 NULL
+ib_send_cm_mra_60202 ib_send_cm_mra 4 60202 NULL
+deliver_packet_767 deliver_packet 3 767 NULL
+sel_write_member_28800 sel_write_member 3 28800 NULL
+usb_allocate_stream_buffers_8964 usb_allocate_stream_buffers 3 8964 NULL
+drm_mode_crtc_set_gamma_size_54742 drm_mode_crtc_set_gamma_size 2 54742 NULL
+venus_mkdir_8967 venus_mkdir 4 8967 NULL
+vol_cdev_read_8968 vol_cdev_read 3 8968 NULL nohasharray
+seq_open_net_8968 seq_open_net 4 8968 &vol_cdev_read_8968
+befs_nls2utf_17163 befs_nls2utf 3 17163 NULL
+savemem_58129 savemem 3 58129 NULL
+fillonedir_41746 fillonedir 3 41746 NULL
+ipv6_flowlabel_opt_58135 ipv6_flowlabel_opt 3 58135 NULL nohasharray
+slhc_init_58135 slhc_init 1-2 58135 &ipv6_flowlabel_opt_58135
+sel_read_mls_25369 sel_read_mls 3 25369 NULL
+if_writecmd_815 if_writecmd 2 815 NULL
+rtl8169_alloc_rx_skb_25392 rtl8169_alloc_rx_skb 4-5 25392 NULL
+viafb_dfph_proc_write_49288 viafb_dfph_proc_write 3 49288 NULL
+sctp_getsockopt_associnfo_58169 sctp_getsockopt_associnfo 2 58169 NULL
+read_fifo_826 read_fifo 3 826 NULL
+jffs2_do_create_25404 jffs2_do_create 6 25404 NULL
+dn_recvmsg_17213 dn_recvmsg 4 17213 NULL
+enic_rq_alloc_skb_17220 enic_rq_alloc_skb 2 17220 NULL
+et61x251_read_25420 et61x251_read 3 25420 NULL
+garmin_write_bulk_58191 garmin_write_bulk 3 58191 NULL
+asix_write_cmd_58192 asix_write_cmd 5 58192 NULL
+um_idi_read_850 um_idi_read 3 850 NULL
+__module_alloc_50004 __module_alloc 1 50004 NULL
+cxio_init_resource_fifo_25429 cxio_init_resource_fifo 3 25429 NULL
+sco_send_frame_41815 sco_send_frame 3 41815 NULL
+isdn_read_50021 isdn_read 3 50021 NULL
+snd_gus_dram_peek_9062 snd_gus_dram_peek 4 9062 NULL
+o2net_send_message_vec_879 o2net_send_message_vec 4 879 NULL
+alloc_ep_17269 alloc_ep 1 17269 NULL
+ieee80211_if_read_aid_9705 ieee80211_if_read_aid 3 9705 NULL
+generic_file_buffered_write_25464 generic_file_buffered_write 4 25464 NULL
+do_ip_setsockopt_41852 do_ip_setsockopt 5 41852 NULL
+raw_recvmsg_17277 raw_recvmsg 4 17277 NULL
+alloc_ebda_hpc_50046 alloc_ebda_hpc 1-2 50046 NULL
+keyctl_instantiate_key_41855 keyctl_instantiate_key 3 41855 NULL
+create_queues_9088 create_queues 2-3 9088 NULL
+ldm_frag_add_5611 ldm_frag_add 2 5611 NULL
+f_audio_buffer_alloc_41110 f_audio_buffer_alloc 1 41110 NULL
+minstrel_stats_read_17290 minstrel_stats_read 3 17290 NULL
+fuse_conn_max_background_write_50061 fuse_conn_max_background_write 3 50061 NULL
+read_file_debug_58256 read_file_debug 3 58256 NULL
+sys_fcntl_19267 sys_fcntl 3 19267 NULL
+skb_pad_17302 skb_pad 2 17302 NULL
+tracing_trace_options_write_153 tracing_trace_options_write 3 153 NULL
+btmrvl_hsstate_read_920 btmrvl_hsstate_read 3 920 NULL
+ivtv_buf_copy_from_user_25502 ivtv_buf_copy_from_user 4 25502 NULL
+acpi_ds_build_internal_package_obj_58271 acpi_ds_build_internal_package_obj 3 58271 NULL
+snd_pcm_plugin_build_25505 snd_pcm_plugin_build 5 25505 NULL
+dev_set_alias_50084 dev_set_alias 3 50084 NULL
+tcp_mark_head_lost_50087 tcp_mark_head_lost 2 50087 NULL
+iwm_umac_set_config_var_17320 iwm_umac_set_config_var 4 17320 NULL
+sys_keyctl_33708 sys_keyctl 4 33708 NULL nohasharray
+netlink_sendmsg_33708 netlink_sendmsg 4 33708 &sys_keyctl_33708
+ata_host_alloc_pinfo_17325 ata_host_alloc_pinfo 3 17325 NULL
+get_free_de_33714 get_free_de 2 33714 NULL
+pvr2_stream_buffer_count_33719 pvr2_stream_buffer_count 2 33719 NULL
+get_packet_41914 get_packet 3 41914 NULL
+get_fdb_entries_41916 get_fdb_entries 3 41916 NULL
+sctp_make_heartbeat_958 sctp_make_heartbeat 4 958 NULL
+sys_msgrcv_959 sys_msgrcv 3 959 NULL
+csr1212_new_leaf_50112 csr1212_new_leaf 3 50112 NULL
+ieee80211_if_read_dot11MeshTTL_58307 ieee80211_if_read_dot11MeshTTL 3 58307 NULL
+serverworks_create_gatt_pages_46582 serverworks_create_gatt_pages 1 46582 NULL
+ieee80211_if_read_path_refresh_time_25545 ieee80211_if_read_path_refresh_time 3 25545 NULL
+hpsb_iso_xmit_init_19277 hpsb_iso_xmit_init 3 19277 NULL
+dispatch_write_17361 dispatch_write 3 17361 NULL
+copy_items_50140 copy_items 6 50140 NULL
+isr_irqs_read_9181 isr_irqs_read 3 9181 NULL
+pcim_iomap_58334 pcim_iomap 3 58334 NULL
+diva_init_dma_map_58336 diva_init_dma_map 3 58336 NULL
+xfs_buf_associate_memory_17915 xfs_buf_associate_memory 3 17915 NULL
+zd_rfwrite_locked_17381 zd_rfwrite_locked 3 17381 NULL
+hashtab_create_33769 hashtab_create 3 33769 NULL
+alloc_group_attrs_9194 alloc_group_attrs 2 9194 NULL
+alloc_fdtable_17389 alloc_fdtable 1 17389 NULL
+xfrm_dst_alloc_copy_3034 xfrm_dst_alloc_copy 3 3034 NULL
+vmalloc_to_sg_58354 vmalloc_to_sg 2 58354 NULL
+aac_nark_ioremap_50163 aac_nark_ioremap 2 50163 NULL nohasharray
+kmalloc_node_50163 kmalloc_node 1 50163 &aac_nark_ioremap_50163
+cx24116_writeregN_41975 cx24116_writeregN 4 41975 NULL
+usbtmc_write_64340 usbtmc_write 3 64340 NULL
+ubi_resize_volume_50172 ubi_resize_volume 2 50172 NULL
+__devres_alloc_25598 __devres_alloc 2 25598 NULL
+l2cap_create_connless_pdu_9222 l2cap_create_connless_pdu 3 9222 NULL
+ib_send_cm_drep_50186 ib_send_cm_drep 3 50186 NULL
+sctp_getsockopt_delayed_ack_9232 sctp_getsockopt_delayed_ack 2 9232 NULL
+mwl8k_prepare_multicast_42499 mwl8k_prepare_multicast 2 42499 NULL
+proc_coredump_filter_write_25625 proc_coredump_filter_write 3 25625 NULL
+pool_allocate_42012 pool_allocate 3 42012 NULL
+l2cap_sock_setsockopt_50207 l2cap_sock_setsockopt 5 50207 NULL
+sctp_make_init_58401 sctp_make_init 4 58401 NULL
+ieee80211_skb_resize_50211 ieee80211_skb_resize 3 50211 NULL
+gigaset_initdriver_1060 gigaset_initdriver 2 1060 NULL
+islpci_mgt_transmit_34133 islpci_mgt_transmit 5 34133 NULL
+ieee80211_if_read_peer_45233 ieee80211_if_read_peer 3 45233 NULL
+acpi_ut_create_buffer_object_42030 acpi_ut_create_buffer_object 1 42030 NULL
+agp_create_memory_1075 agp_create_memory 1 1075 NULL
+__hwahc_op_set_gtk_42038 __hwahc_op_set_gtk 4 42038 NULL
+iscsi_offload_mesg_58425 iscsi_offload_mesg 5 58425 NULL
+mon_bin_compat_ioctl_50234 mon_bin_compat_ioctl 3 50234 NULL
+probe_bios_17467 probe_bios 1 17467 NULL
+irda_sendmsg_ultra_42047 irda_sendmsg_ultra 4 42047 NULL
+jffs2_do_link_42048 jffs2_do_link 6 42048 NULL
+stats_transmitted_frame_count_read_33861 stats_transmitted_frame_count_read 3 33861 NULL
+afs_extract_data_50261 afs_extract_data 5 50261 NULL
+compat_sys_select_16131 compat_sys_select 1 16131 NULL
+sta_inactive_ms_read_25690 sta_inactive_ms_read 3 25690 NULL
+iwl_dbgfs_stations_read_9309 iwl_dbgfs_stations_read 3 9309 NULL
+compat_do_ipt_set_ctl_58466 compat_do_ipt_set_ctl 4 58466 NULL
+scsi_execute_req_42088 scsi_execute_req 5 42088 NULL
+dm_table_create_35687 dm_table_create 3 35687 NULL
+rxrpc_setsockopt_50286 rxrpc_setsockopt 5 50286 NULL
+vmalloc_32_1135 vmalloc_32 1 1135 NULL
+ibmasm_new_command_25714 ibmasm_new_command 2 25714 NULL
+snd_rme96_capture_copy_58484 snd_rme96_capture_copy 5 58484 NULL
+restore_i387_fxsave_17528 restore_i387_fxsave 2 17528 NULL
+submit_inquiry_42108 submit_inquiry 3 42108 NULL
+sel_write_context_25726 sel_write_context 3 25726 NULL nohasharray
+__alloc_bootmem_low_node_25726 __alloc_bootmem_low_node 2 25726 &sel_write_context_25726
+sysfs_read_file_42113 sysfs_read_file 3 42113 NULL
+mcs_unwrap_fir_25733 mcs_unwrap_fir 3 25733 NULL
+nfs_pagein_one_58502 nfs_pagein_one 3 58502 NULL
+xlog_do_log_recovery_17550 xlog_do_log_recovery 3 17550 NULL
+__copy_to_user_17551 __copy_to_user 3 17551 NULL
+ipv6_renew_options_28867 ipv6_renew_options 5 28867 NULL
+vc_resize_3585 vc_resize 2-3 3585 NULL
+sel_read_avc_cache_threshold_33942 sel_read_avc_cache_threshold 3 33942 NULL
+copy_from_user_17559 copy_from_user 3 17559 NULL
+ipc_alloc_1192 ipc_alloc 1 1192 NULL
+ib_create_send_mad_1196 ib_create_send_mad 5 1196 NULL
+rndis_add_response_58544 rndis_add_response 2 58544 NULL
+efx_tsoh_heap_alloc_58545 efx_tsoh_heap_alloc 2 58545 NULL
+isdn_ppp_read_50356 isdn_ppp_read 4 50356 NULL
+read_9397 read 3 9397 NULL
+i2cdev_read_1206 i2cdev_read 3 1206 NULL
+tracing_buffers_read_11124 tracing_buffers_read 3 11124 NULL
+acpi_ut_create_package_object_17594 acpi_ut_create_package_object 1 17594 NULL
+pmcraid_copy_sglist_38431 pmcraid_copy_sglist 3 38431 NULL
+event_rx_pool_read_25792 event_rx_pool_read 3 25792 NULL
+get_skb_63008 get_skb 2 63008 NULL
+blk_init_tags_30592 blk_init_tags 1 30592 NULL
+oprofilefs_str_to_user_42182 oprofilefs_str_to_user 3 42182 NULL
+sg_read_25799 sg_read 3 25799 NULL
+sl_alloc_bufs_50380 sl_alloc_bufs 2 50380 NULL
+ipw_packet_received_skb_1230 ipw_packet_received_skb 2 1230 NULL
+sys32_rt_sigpending_25814 sys32_rt_sigpending 2 25814 NULL
+xlog_recover_add_to_cont_trans_58583 xlog_recover_add_to_cont_trans 3 58583 NULL
+realloc_buffer_25816 realloc_buffer 2 25816 NULL
+skb_make_writable_24783 skb_make_writable 2 24783 NULL
+pwr_missing_bcns_read_25824 pwr_missing_bcns_read 3 25824 NULL
+gdth_search_isa_58595 gdth_search_isa 1 58595 NULL
+__ntfs_malloc_34022 __ntfs_malloc 1 34022 NULL
+iwl3945_sta_dbgfs_stats_table_read_28882 iwl3945_sta_dbgfs_stats_table_read 3 28882 NULL
+mcs_unwrap_mir_9455 mcs_unwrap_mir 3 9455 NULL
+ppp_write_34034 ppp_write 3 34034 NULL
+ioctl_private_iw_point_1273 ioctl_private_iw_point 7 1273 NULL
+packet_setsockopt_17662 packet_setsockopt 5 17662 NULL
+module_alloc_update_bounds_rx_58634 module_alloc_update_bounds_rx 1 58634 NULL
+btmrvl_hsmode_write_42252 btmrvl_hsmode_write 3 42252 NULL
+dsp_tone_hw_message_17678 dsp_tone_hw_message 3 17678 NULL
+ulog_alloc_skb_23427 ulog_alloc_skb 1 23427 NULL
+pgctrl_write_50453 pgctrl_write 3 50453 NULL
+pwr_enable_ps_read_17686 pwr_enable_ps_read 3 17686 NULL
+lp_write_9511 lp_write 3 9511 NULL
+venus_rename_17707 venus_rename 4-5 17707 NULL
+neigh_hash_grow_1324 neigh_hash_grow 2 1324 NULL
+cdrom_read_cdda_50478 cdrom_read_cdda 4 50478 NULL
+scsi_tgt_kspace_exec_9522 scsi_tgt_kspace_exec 8 9522 NULL
+zd_usb_ioread16v_17715 zd_usb_ioread16v 4 17715 NULL
+do_jffs2_setxattr_25910 do_jffs2_setxattr 5 25910 NULL
+read_file_dma_9530 read_file_dma 3 9530 NULL
+zd_usb_rfwrite_42300 zd_usb_rfwrite 3 42300 NULL
+sel_read_perm_42302 sel_read_perm 3 42302 NULL
+write_int_38453 write_int 3 38453 NULL
+sctp_setsockopt_del_key_42304 sctp_setsockopt_del_key 3 42304 NULL nohasharray
+ulong_read_file_42304 ulong_read_file 3 42304 &sctp_setsockopt_del_key_42304
+pwr_rcvd_awake_beacons_read_50505 pwr_rcvd_awake_beacons_read 3 50505 NULL
+snd_es1938_capture_copy_25930 snd_es1938_capture_copy 5 25930 NULL
+key_flags_read_25931 key_flags_read 3 25931 NULL
+audit_log_n_untrustedstring_9548 audit_log_n_untrustedstring 3 9548 NULL
+ipx_sendmsg_1362 ipx_sendmsg 4 1362 NULL
+init_exception_table_34132 init_exception_table 2 34132 NULL
+sctp_make_op_error_25941 sctp_make_op_error 5 25941 NULL
+fw_node_create_9559 fw_node_create 2 9559 NULL
+sctp_getsockopt_nodelay_9560 sctp_getsockopt_nodelay 2 9560 NULL
+kobj_map_9566 kobj_map 2-3 9566 NULL
+btrfs_copy_from_user_9568 btrfs_copy_from_user 3-1 9568 NULL
+ip_nat_sdp_port_17763 ip_nat_sdp_port 5 17763 NULL
+cxgb3i_ddp_make_gl_34150 cxgb3i_ddp_make_gl 1 34150 NULL
+sctp_setsockopt_initmsg_1383 sctp_setsockopt_initmsg 3 1383 NULL
+do_msgsnd_1387 do_msgsnd 4 1387 NULL
+cosa_read_25966 cosa_read 3 25966 NULL
+ide_raw_taskfile_42355 ide_raw_taskfile 4 42355 NULL
+rngapi_reset_34366 rngapi_reset 3 34366 NULL nohasharray
+p54_alloc_skb_34366 p54_alloc_skb 3 34366 &rngapi_reset_34366
+file_read_actor_1401 file_read_actor 4 1401 NULL
+av7110_ipack_init_46655 av7110_ipack_init 2 46655 NULL
+hci_si_event_1404 hci_si_event 3 1404 NULL
+udp_setsockopt_25985 udp_setsockopt 5 25985 NULL
+do_sync_9604 do_sync 1 9604 NULL
+snd_emu10k1_fx8010_read_9605 snd_emu10k1_fx8010_read 5-6 9605 NULL nohasharray
+sysprof_sample_read_9605 sysprof_sample_read 3 9605 &snd_emu10k1_fx8010_read_9605
+compat_readv_30273 compat_readv 3 30273 NULL
+agp_allocate_memory_58761 agp_allocate_memory 2 58761 NULL
+fz_hash_alloc_50580 fz_hash_alloc 1 50580 NULL
+pep_reply_50582 pep_reply 5 50582 NULL
+mtd_write_34207 mtd_write 3 34207 NULL
+sge_rx_50594 sge_rx 3 50594 NULL
+stack_max_size_read_1445 stack_max_size_read 3 1445 NULL
+xlog_find_verify_log_record_18870 xlog_find_verify_log_record 2 18870 NULL
+__videobuf_copy_to_user_1454 __videobuf_copy_to_user 3 1454 NULL
+selinux_inode_post_setxattr_26037 selinux_inode_post_setxattr 4 26037 NULL
+tx_queue_len_read_1463 tx_queue_len_read 3 1463 NULL
+uvc_alloc_buffers_9656 uvc_alloc_buffers 2-3 9656 NULL
+queue_received_packet_9657 queue_received_packet 5 9657 NULL
+sctp_getsockopt_initmsg_26042 sctp_getsockopt_initmsg 2 26042 NULL
+ep_read_58813 ep_read 3 58813 NULL
+netpoll_send_udp_58955 netpoll_send_udp 3 58955 NULL
+snd_opl4_mem_proc_write_9670 snd_opl4_mem_proc_write 5-6 9670 NULL
+pci_enable_sriov_35745 pci_enable_sriov 2 35745 NULL
+sisusb_send_bulk_msg_17864 sisusb_send_bulk_msg 3 17864 NULL
+simple_transaction_get_50633 simple_transaction_get 3 50633 NULL
+key_conf_keyidx_read_42443 key_conf_keyidx_read 3 42443 NULL
+alloc_sja1000dev_17868 alloc_sja1000dev 1 17868 NULL
+keyctl_update_key_26061 keyctl_update_key 3 26061 NULL
+sta_num_ps_buf_frames_read_1488 sta_num_ps_buf_frames_read 3 1488 NULL
+orinoco_set_key_17878 orinoco_set_key 5-7 17878 NULL
+cifs_write_9687 cifs_write 3 9687 NULL
+command_write_58841 command_write 3 58841 NULL
+compat_sys_pwritev_17886 compat_sys_pwritev 3 17886 NULL
+ocfs2_readlink_50656 ocfs2_readlink 3 50656 NULL
+sys_readv_50664 sys_readv 3 50664 NULL
+ps_upsd_timeouts_read_28924 ps_upsd_timeouts_read 3 28924 NULL
+recover_peb_29238 recover_peb 6-7 29238 NULL
+snd_usb_ctl_msg_26092 snd_usb_ctl_msg 8 26092 NULL
+udp_manip_pkt_50770 udp_manip_pkt 2 50770 NULL
+recover_head_17904 recover_head 3 17904 NULL
+iwl_dbgfs_traffic_log_read_58870 iwl_dbgfs_traffic_log_read 3 58870 NULL
+dabusb_read_58873 dabusb_read 3 58873 NULL
+dccp_feat_register_sp_17914 dccp_feat_register_sp 5 17914 NULL
+btmrvl_psstate_read_50683 btmrvl_psstate_read 3 50683 NULL
+srp_iu_pool_alloc_17920 srp_iu_pool_alloc 2 17920 NULL
+tun_alloc_skb_41216 tun_alloc_skb 2-4-3 41216 NULL
+gs_alloc_req_58883 gs_alloc_req 2 58883 NULL
+cs553x_init_one_58886 cs553x_init_one 3 58886 NULL
+sysctl_tcp_congestion_control_27564 sysctl_tcp_congestion_control 5 27564 NULL
+tsf_read_58892 tsf_read 3 58892 NULL
+user_instantiate_26131 user_instantiate 3 26131 NULL
+vmalloc_node_58700 vmalloc_node 1 58700 NULL
+skb_cow_26138 skb_cow 2 26138 NULL
+smk_write_netlbladdr_42525 smk_write_netlbladdr 3 42525 NULL
+__alloc_percpu_9764 __alloc_percpu 1 9764 NULL
+snd_emux_create_port_42533 snd_emux_create_port 3 42533 NULL
+do_sigpending_9766 do_sigpending 2 9766 NULL
+iwl_dbgfs_disable_ht40_read_35761 iwl_dbgfs_disable_ht40_read 3 35761 NULL
+kgdb_mem2hex_1578 kgdb_mem2hex 3 1578 NULL
+__blk_queue_init_tags_9778 __blk_queue_init_tags 2 9778 NULL
+copy_oldmem_page_26164 copy_oldmem_page 3-1 26164 NULL
+ieee80211_if_read_dot11MeshHWMPnetDiameterTraversalTime_1589 ieee80211_if_read_dot11MeshHWMPnetDiameterTraversalTime 3 1589 NULL
+snd_mem_proc_write_9786 snd_mem_proc_write 3 9786 NULL
+fc_frame_alloc_1596 fc_frame_alloc 2 1596 NULL
+udp_recvmsg_42558 udp_recvmsg 4 42558 NULL
+smk_write_cipso_17989 smk_write_cipso 3 17989 NULL
+skb_padto_50759 skb_padto 2 50759 NULL
+reiserfs_resize_34377 reiserfs_resize 2 34377 NULL
+get_registers_26187 get_registers 3 26187 NULL
+ttm_bo_fbdev_io_9805 ttm_bo_fbdev_io 4 9805 NULL
+btmrvl_hscmd_read_1614 btmrvl_hscmd_read 3 1614 NULL
+av7110_vbi_write_34384 av7110_vbi_write 3 34384 NULL
+usbvision_v4l2_read_34386 usbvision_v4l2_read 3 34386 NULL
+snd_pcm_oss_write2_27332 snd_pcm_oss_write2 3 27332 NULL
+udpv6_recvmsg_9813 udpv6_recvmsg 4 9813 NULL
+pvr2_v4l2_read_18006 pvr2_v4l2_read 3 18006 NULL
+xfs_idata_realloc_26199 xfs_idata_realloc 2 26199 NULL
+mce_write_26201 mce_write 3 26201 NULL
+bio_alloc_map_data_50782 bio_alloc_map_data 1-2 50782 NULL
+ivtv_read_pos_34400 ivtv_read_pos 3 34400 NULL
+__pskb_pull_42602 __pskb_pull 2 42602 NULL
+cifs_write_end_1643 cifs_write_end 5 1643 NULL
+tpm_write_50798 tpm_write 3 50798 NULL
+btmrvl_hsmode_read_1647 btmrvl_hsmode_read 3 1647 NULL
+dvb_dvr_set_buffer_size_9840 dvb_dvr_set_buffer_size 2 9840 NULL
+store_sys_hwmon_26225 store_sys_hwmon 3 26225 NULL
+write_flush_50803 write_flush 3 50803 NULL
+rxrpc_recvmsg_26233 rxrpc_recvmsg 4 26233 NULL
+ikconfig_read_current_1658 ikconfig_read_current 3 1658 NULL
+ip_vs_icmp_xmit_v6_18045 ip_vs_icmp_xmit_v6 4 18045 NULL
+dvb_play_50814 dvb_play 3 50814 NULL
+ep_write_59008 ep_write 3 59008 NULL
+sys_move_pages_42626 sys_move_pages 2 42626 NULL
+sctp_make_heartbeat_ack_34411 sctp_make_heartbeat_ack 4 34411 NULL
+ddebug_proc_write_18055 ddebug_proc_write 3 18055 NULL
+pmcraid_alloc_sglist_9864 pmcraid_alloc_sglist 1 9864 NULL
+sta_tx_retry_count_read_59021 sta_tx_retry_count_read 3 59021 NULL
+scsi_activate_tcq_42640 scsi_activate_tcq 2 42640 NULL
+configfs_read_file_1683 configfs_read_file 3 1683 NULL
+kvm_read_guest_page_18074 kvm_read_guest_page 5 18074 NULL
+sctp_make_abort_34459 sctp_make_abort 3 34459 NULL
+selinux_transaction_write_59038 selinux_transaction_write 3 59038 NULL
+get_vm_area_18080 get_vm_area 1 18080 NULL
+bm_register_write_9893 bm_register_write 3 9893 NULL nohasharray
+snd_midi_event_new_9893 snd_midi_event_new 1 9893 &bm_register_write_9893
+handle_rx_packet_58993 handle_rx_packet 3 58993 NULL
+iwm_rx_packet_alloc_9898 iwm_rx_packet_alloc 3 9898 NULL
+i2o_parm_field_get_34477 i2o_parm_field_get 5 34477 NULL
+pdu_write_u_1710 pdu_write_u 3 1710 NULL
+coda_psdev_write_1711 coda_psdev_write 3 1711 NULL
+iraw_encode_18099 iraw_encode 2-3 18099 NULL
+udf_alloc_i_data_35786 udf_alloc_i_data 2 35786 NULL
+netlink_kernel_create_18110 netlink_kernel_create 3 18110 NULL
+sis190_try_rx_copy_57069 sis190_try_rx_copy 3 57069 NULL
+request_key_and_link_42693 request_key_and_link 4 42693 NULL
+snd_pcm_plug_alloc_42339 snd_pcm_plug_alloc 2 42339 NULL
+pwr_wake_on_host_read_26321 pwr_wake_on_host_read 3 26321 NULL
+snd_pcm_plugin_alloc_12580 snd_pcm_plugin_alloc 2 12580 NULL
+cafe_deliver_buffer_1755 cafe_deliver_buffer 3 1755 NULL
+set_rxd_buffer_pointer_9950 set_rxd_buffer_pointer 8 9950 NULL
+tcp_sacktag_walk_26339 tcp_sacktag_walk 5-6 26339 NULL
+selinux_inode_setsecurity_18148 selinux_inode_setsecurity 4 18148 NULL
+csum_partial_copy_fromiovecend_9957 csum_partial_copy_fromiovecend 3-4 9957 NULL
+tracing_stats_read_34537 tracing_stats_read 3 34537 NULL
+hdpvr_i2c_read_26347 hdpvr_i2c_read 4 26347 NULL
+cosa_write_1774 cosa_write 3 1774 NULL
+set_aoe_iflist_42737 set_aoe_iflist 2 42737 NULL
+hugetlbfs_read_actor_34547 hugetlbfs_read_actor 2-5-4 34547 NULL
+ax25_setsockopt_42740 ax25_setsockopt 5 42740 NULL
+create_rsb_42744 create_rsb 3 42744 NULL
+fc_change_queue_depth_18169 fc_change_queue_depth 2 18169 NULL
+sysctl_uts_string_17797 sysctl_uts_string 5 17797 NULL
+dup_to_netobj_26363 dup_to_netobj 3 26363 NULL
+sock_bindtodevice_50942 sock_bindtodevice 3 50942 NULL
+cryptd_alloc_instance_18048 cryptd_alloc_instance 2-3 18048 NULL
+nfs_readdata_alloc_9990 nfs_readdata_alloc 1 9990 NULL
+asn1_octets_decode_9991 asn1_octets_decode 2 9991 NULL
+framebuffer_alloc_59145 framebuffer_alloc 1 59145 NULL
+sta_tx_packets_read_50955 sta_tx_packets_read 3 50955 NULL
+radeon_compat_ioctl_59150 radeon_compat_ioctl 2 59150 NULL
+velocity_rx_copy_34583 velocity_rx_copy 2 34583 NULL
+x25_recvmsg_42777 x25_recvmsg 4 42777 NULL
+init_send_hfcd_34586 init_send_hfcd 1 34586 NULL
+cryptd_hash_setkey_42781 cryptd_hash_setkey 3 42781 NULL
+kmsg_write_26398 kmsg_write 3 26398 NULL
+orinoco_add_extscan_result_18207 orinoco_add_extscan_result 3 18207 NULL
+do_ipv6_setsockopt_18215 do_ipv6_setsockopt 5 18215 NULL
+setup_window_59178 setup_window 7-5-4-2 59178 NULL
+cx18_copy_buf_to_user_50990 cx18_copy_buf_to_user 4 50990 NULL
+timeout_write_50991 timeout_write 3 50991 NULL
+fw_device_op_compat_ioctl_42804 fw_device_op_compat_ioctl 2 42804 NULL
+sctp_getsockopt_peeloff_59190 sctp_getsockopt_peeloff 2 59190 NULL
+proc_write_51003 proc_write 3 51003 NULL
+set_arg_42824 set_arg 3 42824 NULL
+pagemap_read_26441 pagemap_read 3 26441 NULL
+xfs_iext_realloc_indirect_59211 xfs_iext_realloc_indirect 2 59211 NULL
+rfcomm_sock_setsockopt_18254 rfcomm_sock_setsockopt 5 18254 NULL
+lbs_dev_info_51023 lbs_dev_info 3 51023 NULL
+net_assign_generic_59217 net_assign_generic 2 59217 NULL
+audit_log_n_string_31705 audit_log_n_string 3 31705 NULL
+fuse_conn_congestion_threshold_read_51028 fuse_conn_congestion_threshold_read 3 51028 NULL
+qdisc_class_hash_alloc_18262 qdisc_class_hash_alloc 1 18262 NULL
+write_essid_42840 write_essid 3 42840 NULL
+hidp_queue_report_1881 hidp_queue_report 3 1881 NULL
+dev_config_8506 dev_config 3 8506 NULL
+dump_midi_51040 dump_midi 3 51040 NULL
+tty_prepare_flip_string_flags_59240 tty_prepare_flip_string_flags 4 59240 NULL
+cxacru_cm_get_array_4412 cxacru_cm_get_array 4 4412 NULL
+cxgb3i_alloc_big_mem_18283 cxgb3i_alloc_big_mem 1 18283 NULL
+do_arpt_set_ctl_51053 do_arpt_set_ctl 4 51053 NULL
+pccard_store_cis_10094 pccard_store_cis 5 10094 NULL
+ib_alloc_device_26483 ib_alloc_device 1 26483 NULL
+ulong_write_file_26485 ulong_write_file 3 26485 NULL
+wusb_prf_64_51065 wusb_prf_64 7 51065 NULL
+isr_fiqs_read_34687 isr_fiqs_read 3 34687 NULL
+pskb_expand_head_42881 pskb_expand_head 2-3 42881 NULL
+ip6ip6_err_18308 ip6ip6_err 5 18308 NULL
+read_vmcore_26501 read_vmcore 3 26501 NULL
+hptiop_adjust_disk_queue_depth_34698 hptiop_adjust_disk_queue_depth 2 34698 NULL
+alloc_skb_55439 alloc_skb 1 55439 NULL
+xpc_kmalloc_cacheline_aligned_42895 xpc_kmalloc_cacheline_aligned 1 42895 NULL
+jbd2_journal_init_revoke_51088 jbd2_journal_init_revoke 2 51088 NULL
+ecryptfs_send_message_18322 ecryptfs_send_message 2 18322 NULL
+iwm_rx_handle_24899 iwm_rx_handle 3 24899 NULL
+pcpu_get_vm_areas_26522 pcpu_get_vm_areas 3 26522 NULL
+btmrvl_hscfgcmd_read_56303 btmrvl_hscfgcmd_read 3 56303 NULL
+read_file_wiphy_51103 read_file_wiphy 3 51103 NULL
+ieee80211_if_read_num_sta_ps_34722 ieee80211_if_read_num_sta_ps 3 34722 NULL
+aes_decrypt_packets_read_10155 aes_decrypt_packets_read 3 10155 NULL
+rds_message_inc_copy_to_user_26540 rds_message_inc_copy_to_user 3 26540 NULL
+rx_out_of_mem_read_10157 rx_out_of_mem_read 3 10157 NULL
+reg_w_ixbuf_34736 reg_w_ixbuf 4 34736 NULL
+zd_ioread32v_26545 zd_ioread32v 4 26545 NULL
+pwr_power_save_off_read_18355 pwr_power_save_off_read 3 18355 NULL
+asd_store_update_bios_10165 asd_store_update_bios 4 10165 NULL
+fd_copyout_59323 fd_copyout 3 59323 NULL
+sctp_getsockopt_maxburst_42941 sctp_getsockopt_maxburst 2 42941 NULL
+sel_read_avc_hash_stats_1984 sel_read_avc_hash_stats 3 1984 NULL
+solos_param_store_34755 solos_param_store 4 34755 NULL
+arlan_rx_interrupt_10184 arlan_rx_interrupt 4 10184 NULL
+xfs_trans_get_efd_51148 xfs_trans_get_efd 3 51148 NULL
+xfs_attrmulti_attr_set_59346 xfs_attrmulti_attr_set 4 59346 NULL
+vcc_recvmsg_37198 vcc_recvmsg 4 37198 NULL
+hpsb_make_streampacket_21071 hpsb_make_streampacket 3 21071 NULL
+proc_write_mled_51169 proc_write_mled 3 51169 NULL
+write_flush_pipefs_2021 write_flush_pipefs 3 2021 NULL
+__copy_in_user_34790 __copy_in_user 3 34790 NULL
+snd_nm256_playback_copy_38567 snd_nm256_playback_copy 5 38567 NULL
+tipc_log_resize_34803 tipc_log_resize 1 34803 NULL
+devm_ioremap_nocache_2036 devm_ioremap_nocache 3-2 2036 NULL
+create_snapshot_51195 create_snapshot 4 51195 NULL
+fc_frame_alloc_fill_59394 fc_frame_alloc_fill 2 59394 NULL
+pwr_fix_tsf_ps_read_26627 pwr_fix_tsf_ps_read 3 26627 NULL
+sctp_getsockopt_fragment_interleave_51215 sctp_getsockopt_fragment_interleave 2 51215 NULL
+acpi_video_bus_write_DOS_2064 acpi_video_bus_write_DOS 3 2064 NULL
+isr_rx_mem_overflow_read_43025 isr_rx_mem_overflow_read 3 43025 NULL
+cciss_proc_write_10259 cciss_proc_write 3 10259 NULL
+b43_debugfs_write_34838 b43_debugfs_write 3 34838 NULL
+subbuf_read_actor_2071 subbuf_read_actor 3 2071 NULL
+fuse_perform_write_18457 fuse_perform_write 4 18457 NULL
+regset_tls_set_18459 regset_tls_set 4 18459 NULL
+iwl_dbgfs_current_sleep_command_read_2081 iwl_dbgfs_current_sleep_command_read 3 2081 NULL
+acpi_system_write_wakeup_device_34853 acpi_system_write_wakeup_device 3 34853 NULL
+parse_table_59430 parse_table 6 59430 NULL
+drm_property_create_51239 drm_property_create 4 51239 NULL
+stats_rx_expand_skb_head2_read_59439 stats_rx_expand_skb_head2_read 3 59439 NULL
+idetape_chrdev_read_2097 idetape_chrdev_read 3 2097 NULL
+audit_expand_2098 audit_expand 2 2098 NULL
+st_read_51251 st_read 3 51251 NULL
+udpv6_setsockopt_18487 udpv6_setsockopt 5 18487 NULL
+ecryptfs_encrypt_and_encode_filename_2109 ecryptfs_encrypt_and_encode_filename 6 2109 NULL
+compat_dccp_setsockopt_51263 compat_dccp_setsockopt 5 51263 NULL
+fwnet_pd_new_39947 fwnet_pd_new 4 39947 NULL
+enable_read_2117 enable_read 3 2117 NULL
+dvb_audio_write_51275 dvb_audio_write 3 51275 NULL
+ipwireless_network_packet_received_51277 ipwireless_network_packet_received 4 51277 NULL
+wl1251_build_probe_req_10318 wl1251_build_probe_req 3 10318 NULL
+_xfs_buf_get_pages_59472 _xfs_buf_get_pages 2 59472 NULL
+tomoyo_read_43089 tomoyo_read 3 43089 NULL
+snd_gus_dram_poke_18525 snd_gus_dram_poke 4 18525 NULL
+cdrom_read_cdda_old_27664 cdrom_read_cdda_old 4 27664 NULL
+arcmsr_adjust_disk_queue_depth_34916 arcmsr_adjust_disk_queue_depth 2 34916 NULL
+mlx4_init_icm_table_2151 mlx4_init_icm_table 4-5 2151 NULL
+HDLC_Encode_7186 HDLC_Encode 2-3 7186 NULL
+ib_copy_from_udata_59502 ib_copy_from_udata 3 59502 NULL
+seq_copy_in_user_18543 seq_copy_in_user 3 18543 NULL
+dv1394_write_18547 dv1394_write 3 18547 NULL
+stats_rx_handlers_fragments_read_10356 stats_rx_handlers_fragments_read 3 10356 NULL
+alloc_hippi_dev_51320 alloc_hippi_dev 1 51320 NULL
+fb_sys_write_33130 fb_sys_write 3 33130 NULL
+mthca_buf_alloc_35861 mthca_buf_alloc 2 35861 NULL
+get_scq_2177 get_scq 1 2177 NULL
+alloc_fddidev_15382 alloc_fddidev 1 15382 NULL
+srp_ring_alloc_26760 srp_ring_alloc 2 26760 NULL
+alloc_smp_req_51337 alloc_smp_req 1 51337 NULL
+ecryptfs_decode_and_decrypt_filename_10379 ecryptfs_decode_and_decrypt_filename 5 10379 NULL
+sta_tx_retry_failed_read_10381 sta_tx_retry_failed_read 3 10381 NULL
+skb_gro_header_slow_34958 skb_gro_header_slow 2 34958 NULL
+debug_output_18575 debug_output 3 18575 NULL
+do_compat_pselect_10398 do_compat_pselect 1 10398 NULL
+__netdev_alloc_skb_18595 __netdev_alloc_skb 2 18595 NULL
+slabinfo_write_18600 slabinfo_write 3 18600 NULL
+init_copy_kstat_irqs_34985 init_copy_kstat_irqs 4 34985 NULL
+radeon_kms_compat_ioctl_51371 radeon_kms_compat_ioctl 2 51371 NULL
+iowarrior_write_18604 iowarrior_write 3 18604 NULL
+vhci_write_2224 vhci_write 3 2224 NULL
+nfsd_cache_update_59574 nfsd_cache_update 3 59574 NULL
+l2cap_skbuff_fromiovec_35003 l2cap_skbuff_fromiovec 3-4 35003 NULL
+from_buffer_18625 from_buffer 3 18625 NULL
+uio_write_43202 uio_write 3 43202 NULL
+memdup_user_59590 memdup_user 2 59590 NULL
+alloc_etherdev_mq_compat_2247 alloc_etherdev_mq_compat 1 2247 NULL
+iso_callback_43208 iso_callback 3 43208 NULL
+smk_write_load_26829 smk_write_load 3 26829 NULL
+sel_write_avc_cache_threshold_2256 sel_write_avc_cache_threshold 3 2256 NULL
+coda_psdev_read_35029 coda_psdev_read 3 35029 NULL
+packet_sendmsg_24954 packet_sendmsg 4 24954 NULL
+ecryptfs_miscdev_write_26847 ecryptfs_miscdev_write 3 26847 NULL
+blk_register_region_51424 blk_register_region 1-2 51424 NULL
+mga_ioremap_8571 mga_ioremap 2-1 8571 NULL
+econet_sendmsg_51430 econet_sendmsg 4 51430 NULL
+event_phy_transmit_error_read_10471 event_phy_transmit_error_read 3 10471 NULL
+edge_tty_recv_18667 edge_tty_recv 4 18667 NULL
+btmrvl_gpiogap_write_35053 btmrvl_gpiogap_write 3 35053 NULL
+sel_read_class_12669 sel_read_class 3 12669 NULL
+stats_received_fragment_count_read_59643 stats_received_fragment_count_read 3 59643 NULL
+ubifs_setxattr_59650 ubifs_setxattr 4 59650 NULL nohasharray
+hidraw_read_59650 hidraw_read 3 59650 &ubifs_setxattr_59650
+kvm_clear_guest_page_2308 kvm_clear_guest_page 4 2308 NULL
+sel_write_disable_10511 sel_write_disable 3 10511 NULL
+store_ifalias_35088 store_ifalias 4 35088 NULL
+____alloc_ei_netdev_51475 ____alloc_ei_netdev 1 51475 NULL
+rds_message_alloc_10517 rds_message_alloc 1 10517 NULL
+alloc_dca_provider_59670 alloc_dca_provider 2 59670 NULL
+blk_rq_map_user_iov_16772 blk_rq_map_user_iov 5 16772 NULL
+snmp_mib_init_10526 snmp_mib_init 2 10526 NULL
+get_vm_area_caller_10527 get_vm_area_caller 1 10527 NULL
+capi_write_35104 capi_write 3 35104 NULL
+ide_settings_proc_write_35110 ide_settings_proc_write 3 35110 NULL
+sriov_enable_59689 sriov_enable 2 59689 NULL
+x25_asy_change_mtu_26928 x25_asy_change_mtu 2 26928 NULL
+mic_calc_failure_read_59700 mic_calc_failure_read 3 59700 NULL
+scsi_tgt_copy_sense_26933 scsi_tgt_copy_sense 3 26933 NULL
+pwr_ps_enter_read_26935 pwr_ps_enter_read 3 26935 NULL nohasharray
+sctp_setsockopt_adaptation_layer_26935 sctp_setsockopt_adaptation_layer 3 26935 &pwr_ps_enter_read_26935
+hecubafb_write_26942 hecubafb_write 3 26942 NULL
+wep_packets_read_18751 wep_packets_read 3 18751 NULL
+rose_recvmsg_2368 rose_recvmsg 4 2368 NULL
+perf_mmap_data_alloc_43335 perf_mmap_data_alloc 2 43335 NULL
+unix_stream_sendmsg_61455 unix_stream_sendmsg 4 61455 NULL
+prism2_info_scanresults_59729 prism2_info_scanresults 3 59729 NULL
+iscsi_conn_setup_35159 iscsi_conn_setup 2 35159 NULL
+ieee80211_if_read_bssid_35161 ieee80211_if_read_bssid 3 35161 NULL
+alloc_fcdev_18780 alloc_fcdev 1 18780 NULL
+__alloc_eip_netdev_51549 __alloc_eip_netdev 1 51549 NULL
+compat_sys_move_pages_5861 compat_sys_move_pages 2 5861 NULL
+otp_read_10594 otp_read 2-5-4 10594 NULL
+rxpipe_rx_prep_beacon_drop_read_2403 rxpipe_rx_prep_beacon_drop_read 3 2403 NULL
+isdn_v110_open_2418 isdn_v110_open 3 2418 NULL
+long_retry_limit_read_59766 long_retry_limit_read 3 59766 NULL
+blk_msg_write_13655 blk_msg_write 3 13655 NULL
+ima_show_htable_violations_10619 ima_show_htable_violations 3 10619 NULL
+cxgb3_get_cpl_reply_skb_10620 cxgb3_get_cpl_reply_skb 2 10620 NULL
+sta_agg_status_read_14058 sta_agg_status_read 3 14058 NULL
+venus_remove_59781 venus_remove 4 59781 NULL
+ioremap_nocache_2439 ioremap_nocache 2-1 2439 NULL
+sys_modify_ldt_18824 sys_modify_ldt 3 18824 NULL
+unix_stream_recvmsg_35210 unix_stream_recvmsg 4 35210 NULL
+tty_buffer_find_2443 tty_buffer_find 2 2443 NULL
+xlog_do_recover_59789 xlog_do_recover 3 59789 NULL
+stats_tx_handlers_drop_fragment_read_45464 stats_tx_handlers_drop_fragment_read 3 45464 NULL
+rfcomm_tty_write_51603 rfcomm_tty_write 3 51603 NULL
+ipw_write_59807 ipw_write 3 59807 NULL
+l1oip_socket_parse_4507 l1oip_socket_parse 4 4507 NULL
+scsi_init_shared_tag_map_59812 scsi_init_shared_tag_map 2 59812 NULL
+ni65_alloc_mem_10664 ni65_alloc_mem 3 10664 NULL
+b43legacy_debugfs_read_2473 b43legacy_debugfs_read 3 2473 NULL
+usb_alloc_urb_43436 usb_alloc_urb 1 43436 NULL
+sctp_setsockopt_events_18862 sctp_setsockopt_events 3 18862 NULL
+btmrvl_txdnldready_read_413 btmrvl_txdnldready_read 3 413 NULL
+dns_resolve_server_name_to_ip_51632 dns_resolve_server_name_to_ip 1 51632 NULL
+set_fd_set_35249 set_fd_set 1 35249 NULL
+wiphy_new_2482 wiphy_new 2 2482 NULL
+pl2303_buf_alloc_35251 pl2303_buf_alloc 1 35251 NULL
+ieee80211_if_read_dot11MeshHWMPmaxPREQretries_59829 ieee80211_if_read_dot11MeshHWMPmaxPREQretries 3 59829 NULL
+qla2x00_change_queue_depth_43446 qla2x00_change_queue_depth 2 43446 NULL
+ioapic_setup_resources_35255 ioapic_setup_resources 1 35255 NULL
+tcp_push_10680 tcp_push 3 10680 NULL
+sctp_auth_create_key_51641 sctp_auth_create_key 1 51641 NULL
+c101_run_37279 c101_run 2 37279 NULL
+iscsi_create_session_51647 iscsi_create_session 3 51647 NULL
+___alloc_bootmem_node_18882 ___alloc_bootmem_node 2 18882 NULL
+tun_put_user_59849 tun_put_user 4 59849 NULL
+alloc_fdmem_27083 alloc_fdmem 1 27083 NULL
+irda_recvmsg_stream_35280 irda_recvmsg_stream 4 35280 NULL
+btmrvl_hscmd_write_27089 btmrvl_hscmd_write 3 27089 NULL
+isr_rx_rdys_read_35283 isr_rx_rdys_read 3 35283 NULL
+selinux_inode_setxattr_10708 selinux_inode_setxattr 4 10708 NULL
+ps_upsd_utilization_read_51669 ps_upsd_utilization_read 3 51669 NULL
+alloc_arch_preferred_bootmem_27097 alloc_arch_preferred_bootmem 2 27097 NULL
+pvr2_ioread_read_10720 pvr2_ioread_read 3 10720 NULL nohasharray
+shash_async_setkey_10720 shash_async_setkey 3 10720 &pvr2_ioread_read_10720
+sctp_setsockopt_associnfo_51684 sctp_setsockopt_associnfo 3 51684 NULL
+__iscsi_complete_pdu_10726 __iscsi_complete_pdu 4 10726 NULL
+pvr2_ioread_set_sync_key_59882 pvr2_ioread_set_sync_key 3 59882 NULL
+l2cap_sock_recvmsg_59886 l2cap_sock_recvmsg 4 59886 NULL
+tracing_read_pipe_35312 tracing_read_pipe 3 35312 NULL
+sctp_getsockopt_maxseg_10737 sctp_getsockopt_maxseg 2 10737 NULL
+compat_sys_msgsnd_10738 compat_sys_msgsnd 2 10738 NULL
+sel_write_access_51704 sel_write_access 3 51704 NULL
+dvb_net_ioctl_43516 dvb_net_ioctl 3 43516 NULL
+stats_tx_handlers_queued_read_35325 stats_tx_handlers_queued_read 3 35325 NULL
+do_readlink_43518 do_readlink 2 43518 NULL
+compat_sys_migrate_pages_3157 compat_sys_migrate_pages 2 3157 NULL
+fallback_on_nodma_alloc_35332 fallback_on_nodma_alloc 2 35332 NULL
+drm_compat_ioctl_51717 drm_compat_ioctl 2 51717 NULL
+pms_capture_27142 pms_capture 4 27142 NULL
+btmrvl_hscfgcmd_write_27143 btmrvl_hscfgcmd_write 3 27143 NULL
+gspca_dev_probe_2570 gspca_dev_probe 4 2570 NULL
+sg_read_oxfer_51724 sg_read_oxfer 3 51724 NULL
+kvm_read_guest_atomic_10765 kvm_read_guest_atomic 4 10765 NULL
+cachefiles_daemon_write_43535 cachefiles_daemon_write 3 43535 NULL
+store_pwm1_enable_2577 store_pwm1_enable 4 2577 NULL
+pwc_video_read_51735 pwc_video_read 3 51735 NULL
+hid_parse_report_51737 hid_parse_report 3 51737 NULL
+compat_filldir64_35354 compat_filldir64 3 35354 NULL
+i2400m_net_rx_27170 i2400m_net_rx 5 27170 NULL
+mld_newpack_50950 mld_newpack 2 50950 NULL
+aac_change_queue_depth_51753 aac_change_queue_depth 2 51753 NULL
+ath_rx_init_43564 ath_rx_init 2 43564 NULL
+acpi_video_device_write_brightness_43565 acpi_video_device_write_brightness 3 43565 NULL
+dapm_widget_power_read_file_59950 dapm_widget_power_read_file 3 59950 NULL
+sys_bind_10799 sys_bind 3 10799 NULL
+ip_ufo_append_data_27187 ip_ufo_append_data 5-7-6 27187 NULL
+ioremap_prot_51764 ioremap_prot 2-1 51764 NULL
+rpc_malloc_43573 rpc_malloc 2 43573 NULL
+it821x_firmware_command_8628 it821x_firmware_command 3 8628 NULL
+smk_write_logging_2618 smk_write_logging 3 2618 NULL
+aun_incoming_10814 aun_incoming 3 10814 NULL
+usbvideo_register_59982 usbvideo_register 2 59982 NULL
+send_command_10832 send_command 4 10832 NULL
+lro_gen_skb_2644 lro_gen_skb 6 2644 NULL
+osd_req_read_kern_59990 osd_req_read_kern 5 59990 NULL
+lbs_sleepparams_read_10840 lbs_sleepparams_read 3 10840 NULL
+pppol2tp_sendmsg_56420 pppol2tp_sendmsg 4 56420 NULL
+proc_read_43614 proc_read 3 43614 NULL
+dma_memcpy_pg_to_iovec_1725 dma_memcpy_pg_to_iovec 6 1725 NULL
+rxrpc_request_key_27235 rxrpc_request_key 3 27235 NULL
+fuse_conn_max_background_read_10855 fuse_conn_max_background_read 3 10855 NULL
+mthca_init_cq_60011 mthca_init_cq 2 60011 NULL
+register_device_60015 register_device 3-2 60015 NULL
+snd_pcm_oss_write1_10872 snd_pcm_oss_write1 3 10872 NULL
+osd_req_list_dev_partitions_60027 osd_req_list_dev_partitions 4 60027 NULL
+sys_sched_getaffinity_60033 sys_sched_getaffinity 2 60033 NULL
+do_ip6t_set_ctl_60040 do_ip6t_set_ctl 4 60040 NULL
+do_readv_writev_51849 do_readv_writev 4 51849 NULL
+uhci_debug_read_5911 uhci_debug_read 3 5911 NULL
+pmcraid_change_queue_depth_60044 pmcraid_change_queue_depth 2 60044 NULL
+memcpy_fromiovecend_2707 memcpy_fromiovecend 3-4 2707 NULL
+cgroup_write_string_10900 cgroup_write_string 5 10900 NULL
+pointer_size_read_51863 pointer_size_read 3 51863 NULL
+load_module_60056 load_module 2 60056 NULL
+get_indirect_ea_51869 get_indirect_ea 4 51869 NULL
+compat_writev_60063 compat_writev 3 60063 NULL
+sta_last_seq_ctrl_read_19106 sta_last_seq_ctrl_read 3 19106 NULL
+__copy_from_user_10918 __copy_from_user 3 10918 NULL
+user_read_51881 user_read 3 51881 NULL
+copy_from_buf_27308 copy_from_buf 4-2 27308 NULL
+__xip_file_write_2733 __xip_file_write 3-4 2733 NULL
+proc_write_bluetooth_34589 proc_write_bluetooth 3 34589 NULL
+rxrpc_kernel_send_data_60083 rxrpc_kernel_send_data 3 60083 NULL
+hidp_send_ctrl_message_43702 hidp_send_ctrl_message 4 43702 NULL
+smb_do_alloc_request_43708 smb_do_alloc_request 2 43708 NULL
+iwl_calib_set_10944 iwl_calib_set 3 10944 NULL
+async_setkey_35521 async_setkey 3 35521 NULL
+alloc_irdadev_19140 alloc_irdadev 1 19140 NULL
+gfs2_readlink_10958 gfs2_readlink 3 10958 NULL
+rxpipe_tx_xfr_host_int_trig_rx_data_read_35538 rxpipe_tx_xfr_host_int_trig_rx_data_read 3 35538 NULL
+snd_rme32_playback_copy_43732 snd_rme32_playback_copy 5 43732 NULL
+ttm_bo_kmap_60118 ttm_bo_kmap 3 60118 NULL
+fuse_conn_congestion_threshold_write_43736 fuse_conn_congestion_threshold_write 3 43736 NULL
+alloc_context_3194 alloc_context 1 3194 NULL
+bm_entry_read_10976 bm_entry_read 3 10976 NULL
+pcbit_stat_27364 pcbit_stat 2 27364 NULL
+gigaset_initcs_43753 gigaset_initcs 2 43753 NULL
+sctp_setsockopt_active_key_43755 sctp_setsockopt_active_key 3 43755 NULL
+xfrm_hash_alloc_10997 xfrm_hash_alloc 1 10997 NULL
+lbs_highsnr_read_5931 lbs_highsnr_read 3 5931 NULL
+init_state_60165 init_state 2 60165 NULL
+fast_shmem_read_2823 fast_shmem_read 5 2823 NULL
+sel_read_enforce_2828 sel_read_enforce 3 2828 NULL
+__copy_to_user_inatomic_19214 __copy_to_user_inatomic 3 19214 NULL
+sg_build_sgat_60179 sg_build_sgat 3 60179 NULL nohasharray
+jffs2_alloc_full_dirent_60179 jffs2_alloc_full_dirent 1 60179 &sg_build_sgat_60179
+kernel_readv_35617 kernel_readv 3 35617 NULL
+hci_send_cmd_43810 hci_send_cmd 3 43810 NULL
+sys_lgetxattr_45531 sys_lgetxattr 4 45531 NULL
+cxio_init_resource_fifo_random_43814 cxio_init_resource_fifo_random 3 43814 NULL
+sta_tx_bytes_read_55197 sta_tx_bytes_read 3 55197 NULL
+tda10048_writeregbulk_11050 tda10048_writeregbulk 4 11050 NULL
+skb_copy_datagram_from_iovec_52014 skb_copy_datagram_from_iovec 2-5-4 52014 NULL
+move_addr_to_user_2868 move_addr_to_user 2 2868 NULL
+ieee80211_alloc_hw_43829 ieee80211_alloc_hw 1 43829 NULL
+vxge_rx_alloc_52024 vxge_rx_alloc 3 52024 NULL
+acpi_system_read_dsdt_19261 acpi_system_read_dsdt 3 19261 NULL
+p54_download_eeprom_43842 p54_download_eeprom 4 43842 NULL
+spi_register_board_info_35651 spi_register_board_info 2 35651 NULL
+read_flush_43851 read_flush 3 43851 NULL
+dma_rx_errors_read_52045 dma_rx_errors_read 3 52045 NULL
+cmm_write_2896 cmm_write 3 2896 NULL
+request_lock_35670 request_lock 4 35670 NULL
+vicam_read_2904 vicam_read 3 2904 NULL
+compat_sys_kexec_load_35674 compat_sys_kexec_load 2 35674 NULL
+compat_sys_fcntl64_60256 compat_sys_fcntl64 3 60256 NULL
+qc_capture_19298 qc_capture 3 19298 NULL
+stats_tx_expand_skb_head_cloned_read_11107 stats_tx_expand_skb_head_cloned_read 3 11107 NULL
+gdth_isa_probe_one_48925 gdth_isa_probe_one 1 48925 NULL
+hcd_buffer_alloc_27495 hcd_buffer_alloc 2 27495 NULL
+event_tx_stuck_read_19305 event_tx_stuck_read 3 19305 NULL
+rds_page_copy_user_35691 rds_page_copy_user 4 35691 NULL
+tracing_entries_write_60563 tracing_entries_write 3 60563 NULL
+printer_write_60276 printer_write 3 60276 NULL
+garmin_read_process_27509 garmin_read_process 3 27509 NULL
+alloc_alien_cache_11127 alloc_alien_cache 2 11127 NULL
+nsm_get_handle_52089 nsm_get_handle 4 52089 NULL
+__pskb_pull_tail_60287 __pskb_pull_tail 2 60287 NULL
+gs_buf_alloc_25067 gs_buf_alloc 2 25067 NULL
+cfg80211_inform_bss_19332 cfg80211_inform_bss 8 19332 NULL
+ib_copy_to_udata_27525 ib_copy_to_udata 3 27525 NULL
+dn_nsp_return_disc_60296 dn_nsp_return_disc 2 60296 NULL
+do_xip_mapping_read_60297 do_xip_mapping_read 5 60297 NULL
+prism2_sta_send_mgmt_43916 prism2_sta_send_mgmt 5 43916 NULL
+ppp_cp_event_2965 ppp_cp_event 6 2965 NULL
+acpi_os_map_memory_11161 acpi_os_map_memory 2-1 11161 NULL
+retry_count_read_52129 retry_count_read 3 52129 NULL
+ioremap_default_64667 ioremap_default 2-1 64667 NULL
+ioat2_alloc_ring_11172 ioat2_alloc_ring 2 11172 NULL
+read_zero_19366 read_zero 3 19366 NULL
+stats_dot11RTSFailureCount_read_43948 stats_dot11RTSFailureCount_read 3 43948 NULL
+stats_multiple_retry_count_read_60334 stats_multiple_retry_count_read 3 60334 NULL
+hysdn_conf_write_52145 hysdn_conf_write 3 52145 NULL
+store_cardr_2997 store_cardr 4 2997 NULL
+libipw_alloc_txb_27579 libipw_alloc_txb 1-3-2 27579 NULL
+stats_rx_handlers_drop_passive_scan_read_52160 stats_rx_handlers_drop_passive_scan_read 3 52160 NULL
+uv_ptc_proc_write_19394 uv_ptc_proc_write 3 19394 NULL
+ieee80211_if_read_dot11MeshRetryTimeout_52168 ieee80211_if_read_dot11MeshRetryTimeout 3 52168 NULL
+mga_compat_ioctl_52170 mga_compat_ioctl 2 52170 NULL
+ar9170_rx_copy_data_35787 ar9170_rx_copy_data 2 35787 NULL
+depth_write_3021 depth_write 3 3021 NULL
+dccp_setsockopt_60367 dccp_setsockopt 5 60367 NULL
+store_fan1_input_35793 store_fan1_input 4 35793 NULL
+recent_old_proc_write_43473 recent_old_proc_write 3 43473 NULL
+fast_rx_path_59214 fast_rx_path 3 59214 NULL
+tipc_cfg_reply_alloc_27606 tipc_cfg_reply_alloc 1 27606 NULL
+bcm_recvmsg_43992 bcm_recvmsg 4 43992 NULL
+proc_pid_readlink_52186 proc_pid_readlink 3 52186 NULL
+iwl_dbgfs_sleep_level_override_read_3038 iwl_dbgfs_sleep_level_override_read 3 3038 NULL
+dvbdmx_write_19423 dvbdmx_write 3 19423 NULL
+zd_rfwritev_locked_35812 zd_rfwritev_locked 4 35812 NULL
+cnic_alloc_dma_34641 cnic_alloc_dma 3 34641 NULL
+early_node_mem_52200 early_node_mem 4 52200 NULL
+mthca_alloc_resize_buf_60394 mthca_alloc_resize_buf 3 60394 NULL
+write_flush_procfs_44011 write_flush_procfs 3 44011 NULL
+__videobuf_alloc_11253 __videobuf_alloc 1 11253 NULL
+read_flush_procfs_27642 read_flush_procfs 3 27642 NULL
+iscsi_if_send_reply_52219 iscsi_if_send_reply 7 52219 NULL
+dac960_user_command_proc_write_3071 dac960_user_command_proc_write 3 3071 NULL
+hugetlbfs_read_11268 hugetlbfs_read 3 11268 NULL
+_alloc_mISDN_skb_52232 _alloc_mISDN_skb 3 52232 NULL
+excessive_retries_read_60425 excessive_retries_read 3 60425 NULL
+ip_vs_skb_replace_3083 ip_vs_skb_replace 4-6 3083 NULL
+proc_write_brn_3084 proc_write_brn 3 3084 NULL
+tstats_write_60432 tstats_write 3 60432 NULL nohasharray
+kmalloc_60432 kmalloc 1 60432 &tstats_write_60432
+refill_pool_19477 refill_pool 2 19477 NULL
+fl_create_52248 fl_create 4 52248 NULL
+rx_data_60442 rx_data 4 60442 NULL
+iwm_ntf_rx_packet_60452 iwm_ntf_rx_packet 3 60452 NULL
+sisusbcon_do_font_op_52271 sisusbcon_do_font_op 9 52271 NULL
+uwb_rc_cmd_done_35892 uwb_rc_cmd_done 4 35892 NULL
+l2cap_sar_segment_sdu_27701 l2cap_sar_segment_sdu 3 27701 NULL
+skb_realloc_headroom_19516 skb_realloc_headroom 2 19516 NULL
+atm_alloc_charge_19517 atm_alloc_charge 2 19517 NULL nohasharray
+dev_alloc_skb_19517 dev_alloc_skb 1 19517 &atm_alloc_charge_19517
+mb_cache_create_35903 mb_cache_create 4-5 35903 NULL
+construct_key_11329 construct_key 3 11329 NULL
+crypto_shash_setkey_60483 crypto_shash_setkey 3 60483 NULL
+fill_write_buffer_3142 fill_write_buffer 3 3142 NULL
+disk_expand_part_tbl_30561 disk_expand_part_tbl 2 30561 NULL
+igmpv3_newpack_35912 igmpv3_newpack 2 35912 NULL
+kernel_setsockopt_35913 kernel_setsockopt 5 35913 NULL
+reg_w_buf_27724 reg_w_buf 3 27724 NULL
+dccp_listen_start_35918 dccp_listen_start 2 35918 NULL
+ip6_append_data_60501 ip6_append_data 4-5 60501 NULL
+a4t_cs_init_27734 a4t_cs_init 3 27734 NULL
+dvb_generic_ioctl_3257 dvb_generic_ioctl 3 3257 NULL
+sel_write_create_11353 sel_write_create 3 11353 NULL
+tracing_set_trace_read_44122 tracing_set_trace_read 3 44122 NULL
+put_cmsg_compat_35937 put_cmsg_compat 4 35937 NULL
+drm_vblank_init_11362 drm_vblank_init 2 11362 NULL
+ath_tx_init_60515 ath_tx_init 2 60515 NULL
+bt_skb_alloc_6404 bt_skb_alloc 1 6404 NULL
+ntfs_rl_split_52328 ntfs_rl_split 2-4 52328 NULL
+ocfs2_control_message_19564 ocfs2_control_message 3 19564 NULL
+ieee80211_key_alloc_11373 ieee80211_key_alloc 3 11373 NULL
+compat_do_ip6t_set_ctl_3184 compat_do_ip6t_set_ctl 4 3184 NULL
+cgroup_read_s64_19570 cgroup_read_s64 5 19570 NULL
+hysdn_sched_rx_60533 hysdn_sched_rx 3 60533 NULL
+kcalloc_27770 kcalloc 1-2 27770 NULL
+bm_status_read_19583 bm_status_read 3 19583 NULL
+dev_irnet_write_11398 dev_irnet_write 3 11398 NULL
+acl_alloc_35979 acl_alloc 1 35979 NULL
+copy_entries_to_user_52367 copy_entries_to_user 1 52367 NULL
+___alloc_bootmem_11410 ___alloc_bootmem 1 11410 NULL
+str_to_user_11411 str_to_user 2 11411 NULL
+trace_options_read_11419 trace_options_read 3 11419 NULL
+isdn_writebuf_stub_52383 isdn_writebuf_stub 4 52383 NULL
+kimage_crash_alloc_3233 kimage_crash_alloc 3 3233 NULL
+mptscsih_change_queue_depth_44196 mptscsih_change_queue_depth 2 44196 NULL
+console_store_36007 console_store 4 36007 NULL
+key_key_read_3241 key_key_read 3 3241 NULL
+aer_inject_write_52399 aer_inject_write 3 52399 NULL
+ieee80211_if_read_dot11MeshHWMPactivePathTimeout_7368 ieee80211_if_read_dot11MeshHWMPactivePathTimeout 3 7368 NULL
+snd_hdspm_playback_copy_52405 snd_hdspm_playback_copy 5 52405 NULL
+sta_rx_dropped_read_27830 sta_rx_dropped_read 3 27830 NULL
+sys_listxattr_27833 sys_listxattr 3 27833 NULL
+aac_rx_ioremap_52410 aac_rx_ioremap 2 52410 NULL
+um_idi_write_18293 um_idi_write 3 18293 NULL
+cgroup_file_write_52417 cgroup_file_write 3 52417 NULL
+srp_alloc_iu_44227 srp_alloc_iu 2 44227 NULL
+cifs_partialpagewrite_60612 cifs_partialpagewrite 2-3 60612 NULL
+usbvision_rvmalloc_19655 usbvision_rvmalloc 1 19655 NULL
+LoadBitmap_19658 LoadBitmap 2 19658 NULL
+scsi_track_queue_full_44239 scsi_track_queue_full 2 44239 NULL
+get_new_cssid_51665 get_new_cssid 2 51665 NULL
+read_profile_27859 read_profile 3 27859 NULL
+stats_rx_handlers_drop_read_3284 stats_rx_handlers_drop_read 3 3284 NULL
+acl_alloc_stack_init_60630 acl_alloc_stack_init 1 60630 NULL
+enlarge_skb_44248 enlarge_skb 2 44248 NULL
+sys_init_module_36047 sys_init_module 2 36047 NULL
+ubifs_recover_leb_60639 ubifs_recover_leb 3 60639 NULL
+btmrvl_psmode_read_22395 btmrvl_psmode_read 3 22395 NULL
+stack_max_size_write_36068 stack_max_size_write 3 36068 NULL
+oom_adjust_read_25127 oom_adjust_read 3 25127 NULL
+sd_do_mode_sense_11507 sd_do_mode_sense 5 11507 NULL
+unix_seqpacket_sendmsg_27893 unix_seqpacket_sendmsg 4 27893 NULL
+kmem_zalloc_11510 kmem_zalloc 1 11510 NULL
+ubi_eba_write_leb_st_27896 ubi_eba_write_leb_st 5 27896 NULL
+ieee80211_if_read_dot11MeshConfirmTimeout_60670 ieee80211_if_read_dot11MeshConfirmTimeout 3 60670 NULL
+gluebi_write_27905 gluebi_write 3 27905 NULL
+aac_rkt_ioremap_3333 aac_rkt_ioremap 2 3333 NULL
+sctp_make_init_ack_3335 sctp_make_init_ack 4 3335 NULL
+read_from_oldmem_3337 read_from_oldmem 2 3337 NULL
+sctp_getsockopt_context_52490 sctp_getsockopt_context 2 52490 NULL
+skb_cow_head_52495 skb_cow_head 2 52495 NULL
+vga_arb_write_36112 vga_arb_write 3 36112 NULL
+do_sysctl_strategy_11541 do_sysctl_strategy 6 11541 NULL
+l1oip_socket_recv_56537 l1oip_socket_recv 6 56537 NULL
+memcpy_toiovecend_19736 memcpy_toiovecend 3-4 19736 NULL
+iser_rcv_completion_63364 iser_rcv_completion 2 63364 NULL
+dispatch_proc_write_44320 dispatch_proc_write 3 44320 NULL
+vmalloc_exec_36132 vmalloc_exec 1 36132 NULL
+p9_client_read_19750 p9_client_read 5 19750 NULL
+sctp_getsockopt_peer_addrs_old_11565 sctp_getsockopt_peer_addrs_old 2 11565 NULL nohasharray
+skb_cow_data_11565 skb_cow_data 2 11565 &sctp_getsockopt_peer_addrs_old_11565
+raw_recvmsg_52529 raw_recvmsg 4 52529 NULL
+copy_from_user_toio_31966 copy_from_user_toio 3 31966 NULL
+sctp_make_abort_violation_27959 sctp_make_abort_violation 4 27959 NULL
+tracing_clock_write_27961 tracing_clock_write 3 27961 NULL
+b1_alloc_card_36155 b1_alloc_card 1 36155 NULL
+oprofilefs_ulong_to_user_11582 oprofilefs_ulong_to_user 3 11582 NULL
+start_isoc_chain_565 start_isoc_chain 2 565 NULL
+blk_queue_init_tags_44355 blk_queue_init_tags 2 44355 NULL
+saa7146_vmalloc_build_pgtable_19780 saa7146_vmalloc_build_pgtable 2 19780 NULL
+dccpprobe_read_52549 dccpprobe_read 3 52549 NULL
+snd_korg1212_copy_from_36169 snd_korg1212_copy_from 6 36169 NULL
+fw_device_op_ioctl_11595 fw_device_op_ioctl 2 11595 NULL
+ipx_recvmsg_44366 ipx_recvmsg 4 44366 NULL
+hycapi_rx_capipkt_11602 hycapi_rx_capipkt 3 11602 NULL
+msix_map_region_3411 msix_map_region 3 3411 NULL
+sys_kexec_load_14222 sys_kexec_load 2 14222 NULL
+rts_threshold_read_44384 rts_threshold_read 3 44384 NULL
+pci_add_cap_save_buffer_3426 pci_add_cap_save_buffer 3 3426 NULL
+sel_write_checkreqprot_60774 sel_write_checkreqprot 3 60774 NULL
+opticon_write_60775 opticon_write 4 60775 NULL
+snd_rawmidi_write_28008 snd_rawmidi_write 3 28008 NULL
+acl_alloc_num_60778 acl_alloc_num 1-2 60778 NULL
+aoedev_flush_44398 aoedev_flush 2 44398 NULL
+stats_tx_handlers_drop_not_assoc_read_28015 stats_tx_handlers_drop_not_assoc_read 3 28015 NULL
+irda_setsockopt_19824 irda_setsockopt 5 19824 NULL
+nfs4_write_cached_acl_44402 nfs4_write_cached_acl 3 44402 NULL
+get_packet_pg_28023 get_packet_pg 4 28023 NULL
+osst_do_scsi_44410 osst_do_scsi 4 44410 NULL
+cosa_net_setup_rx_38594 cosa_net_setup_rx 2 38594 NULL
+security_context_to_sid_19839 security_context_to_sid 2 19839 NULL
+sisusb_send_bridge_packet_11649 sisusb_send_bridge_packet 2 11649 NULL
+atomic_stats_read_36228 atomic_stats_read 3 36228 NULL
+sctp_setsockopt_maxburst_28041 sctp_setsockopt_maxburst 3 28041 NULL
+alloc_skb_fclone_3467 alloc_skb_fclone 1 3467 NULL
+proc_fault_inject_write_21058 proc_fault_inject_write 3 21058 NULL
+dlm_lock_19858 dlm_lock 6 19858 NULL
+cx231xx_init_vbi_isoc_28053 cx231xx_init_vbi_isoc 2-3 28053 NULL
+ide_queue_pc_tail_11673 ide_queue_pc_tail 5 11673 NULL
+cfg80211_roamed_28061 cfg80211_roamed 4-6 28061 NULL
+compat_sys_mbind_36256 compat_sys_mbind 5 36256 NULL
+dvb_demux_do_ioctl_38811 dvb_demux_do_ioctl 4 38811 NULL
+security_context_to_sid_default_3492 security_context_to_sid_default 2 3492 NULL nohasharray
+efi_ioremap_3492 efi_ioremap 2-1 3492 &security_context_to_sid_default_3492
+iwm_ntf_calib_res_11686 iwm_ntf_calib_res 3 11686 NULL
+sctp_setsockopt_hmac_ident_11687 sctp_setsockopt_hmac_ident 3 11687 NULL
+edac_pci_alloc_ctl_info_63388 edac_pci_alloc_ctl_info 1 63388 NULL
+sysctl_ipc_registered_data_36266 sysctl_ipc_registered_data 5 36266 NULL
+snd_ctl_elem_user_tlv_11695 snd_ctl_elem_user_tlv 3 11695 NULL
+pwr_tx_with_ps_read_60851 pwr_tx_with_ps_read 3 60851 NULL
+usb_buffer_alloc_36276 usb_buffer_alloc 2 36276 NULL
+codec_reg_read_file_36280 codec_reg_read_file 3 36280 NULL
+iscsi_complete_pdu_48372 iscsi_complete_pdu 4 48372 NULL
+gdth_init_isa_28091 gdth_init_isa 1 28091 NULL
+ql_dump_hw_cb_3518 ql_dump_hw_cb 2 3518 NULL
+ieee80211_send_auth_60865 ieee80211_send_auth 5 60865 NULL
+sctp_getsockopt_rtoinfo_62027 sctp_getsockopt_rtoinfo 2 62027 NULL
+diva_alloc_dma_map_23798 diva_alloc_dma_map 2 23798 NULL
+aes_decrypt_interrupt_read_19910 aes_decrypt_interrupt_read 3 19910 NULL
+ps_upsd_max_apturn_read_19918 ps_upsd_max_apturn_read 3 19918 NULL
+ieee80211_if_read_dropped_frames_ttl_44500 ieee80211_if_read_dropped_frames_ttl 3 44500 NULL
+iwl_dbgfs_sram_read_44505 iwl_dbgfs_sram_read 3 44505 NULL
+get_vm_area_node_44507 get_vm_area_node 1 44507 NULL
+vgacon_adjust_height_28124 vgacon_adjust_height 2 28124 NULL
+spidev_write_44510 spidev_write 3 44510 NULL
+proc_write_wled_592 proc_write_wled 3 592 NULL
+iwl_dbgfs_rx_queue_read_19943 iwl_dbgfs_rx_queue_read 3 19943 NULL
+fat_compat_ioctl_filldir_36328 fat_compat_ioctl_filldir 3 36328 NULL
+iwl_dbgfs_qos_read_11753 iwl_dbgfs_qos_read 3 11753 NULL
+hpsb_alloc_host_3562 hpsb_alloc_host 2 3562 NULL
+alloc_smp_resp_3566 alloc_smp_resp 1 3566 NULL
+jbd2_journal_init_revoke_table_36336 jbd2_journal_init_revoke_table 1 36336 NULL
+zd_ioread32v_locked_19953 zd_ioread32v_locked 4 19953 NULL
+mgt_set_varlen_60916 mgt_set_varlen 4 60916 NULL
+compat_sys_setsockopt_3326 compat_sys_setsockopt 5 3326 NULL
+sys_msgsnd_44537 sys_msgsnd 3 44537 NULL
+stats_dot11FCSErrorCount_read_28154 stats_dot11FCSErrorCount_read 3 28154 NULL
+ax25_send_frame_19964 ax25_send_frame 2 19964 NULL
+blkcipher_next_slow_52733 blkcipher_next_slow 4-3 52733 NULL
+relay_alloc_page_array_52735 relay_alloc_page_array 1 52735 NULL
+xfs_buf_get_noaddr_52736 xfs_buf_get_noaddr 1 52736 NULL
+v9fs_file_readn_36353 v9fs_file_readn 4 36353 NULL
+ivtv_v4l2_read_1964 ivtv_v4l2_read 3 1964 NULL
+iscsi_nop_out_rsp_51117 iscsi_nop_out_rsp 4 51117 NULL
+attach_hdlc_protocol_19986 attach_hdlc_protocol 3 19986 NULL
+mtd_do_writeoob_36373 mtd_do_writeoob 4 36373 NULL
+vring_new_virtqueue_36374 vring_new_virtqueue 1 36374 NULL
+sctp_getsockopt_events_3607 sctp_getsockopt_events 2 3607 NULL
+sctp_getsockopt_partial_delivery_point_60952 sctp_getsockopt_partial_delivery_point 2 60952 NULL
+key_algorithm_read_57946 key_algorithm_read 3 57946 NULL
+cafe_v4l_read_52766 cafe_v4l_read 3 52766 NULL
+proc_fdinfo_read_62043 proc_fdinfo_read 3 62043 NULL
+sctp_make_datafrag_empty_34737 sctp_make_datafrag_empty 3 34737 NULL
+ppp_tx_cp_62044 ppp_tx_cp 5 62044 NULL
+pcpu_fc_alloc_11818 pcpu_fc_alloc 2 11818 NULL
+aligned_kmalloc_3628 aligned_kmalloc 1 3628 NULL
+afs_alloc_flat_call_36399 afs_alloc_flat_call 2-3 36399 NULL
+snd_pcm_alloc_vmalloc_buffer_44595 snd_pcm_alloc_vmalloc_buffer 2 44595 NULL
+sctp_setsockopt_maxseg_11829 sctp_setsockopt_maxseg 3 11829 NULL
+dsp_cmx_send_member_15625 dsp_cmx_send_member 2 15625 NULL
+cm_copy_private_data_3649 cm_copy_private_data 2 3649 NULL
+i915_compat_ioctl_3656 i915_compat_ioctl 2 3656 NULL
+sctp_getsockopt_mappedv4_20044 sctp_getsockopt_mappedv4 2 20044 NULL
+compat_udp_setsockopt_38840 compat_udp_setsockopt 5 38840 NULL
+send_video_command_6073 send_video_command 4 6073 NULL nohasharray
+sctp_setsockopt_connectx_6073 sctp_setsockopt_connectx 3 6073 &send_video_command_6073
+ecryptfs_copy_filename_11868 ecryptfs_copy_filename 4 11868 NULL
+sctp_tsnmap_init_36446 sctp_tsnmap_init 2 36446 NULL
+alloc_ieee80211_20063 alloc_ieee80211 1 20063 NULL
+pwr_rcvd_beacons_read_52836 pwr_rcvd_beacons_read 3 52836 NULL
+_l2_alloc_skb_11883 _l2_alloc_skb 1 11883 NULL
+stats_tx_handlers_drop_read_44654 stats_tx_handlers_drop_read 3 44654 NULL
+proc_pid_attr_read_10173 proc_pid_attr_read 3 10173 NULL
+rawv6_sendmsg_20080 rawv6_sendmsg 4 20080 NULL
+fuse_conn_limit_read_20084 fuse_conn_limit_read 3 20084 NULL
+btmrvl_psmode_write_3703 btmrvl_psmode_write 3 3703 NULL
+symtab_init_61050 symtab_init 2 61050 NULL
+alloc_ctrl_packet_44667 alloc_ctrl_packet 1 44667 NULL
+mon_bin_get_event_52863 mon_bin_get_event 4 52863 NULL
+tower_write_8580 tower_write 3 8580 NULL
+kmalloc_slab_11917 kmalloc_slab 1 11917 NULL
+__hidp_send_ctrl_message_28303 __hidp_send_ctrl_message 4 28303 NULL
+edge_buf_alloc_36498 edge_buf_alloc 1 36498 NULL
+buf_acquire_3736 buf_acquire 1 3736 NULL
+ci_ll_write_3740 ci_ll_write 4 3740 NULL
+snd_pcm_oss_read_28317 snd_pcm_oss_read 3 28317 NULL
+__hwahc_op_set_ptk_36510 __hwahc_op_set_ptk 5 36510 NULL
+dccp_feat_clone_sp_val_11942 dccp_feat_clone_sp_val 3 11942 NULL
+pms_read_53873 pms_read 3 53873 NULL
+ieee80211_if_read_fwded_frames_36520 ieee80211_if_read_fwded_frames 3 36520 NULL
+mempool_create_node_44715 mempool_create_node 1 44715 NULL
+replay_bud_56605 replay_bud 3 56605 NULL
+__alloc_bootmem_node_1992 __alloc_bootmem_node 2 1992 NULL
+bm_entry_write_28338 bm_entry_write 3 28338 NULL
+_zd_iowrite32v_locked_44725 _zd_iowrite32v_locked 3 44725 NULL
+tcp_copy_to_iovec_28344 tcp_copy_to_iovec 3 28344 NULL
+clusterip_proc_write_44729 clusterip_proc_write 3 44729 NULL
+cpu_type_read_36540 cpu_type_read 3 36540 NULL
+hpsb_node_write_52928 hpsb_node_write 4 52928 NULL
+snd_seq_oss_readq_new_14283 snd_seq_oss_readq_new 2 14283 NULL
+key_tx_rx_count_read_44742 key_tx_rx_count_read 3 44742 NULL
+xfs_dir2_leaf_getdents_23841 xfs_dir2_leaf_getdents 3 23841 NULL
+read_flush_pipefs_20171 read_flush_pipefs 3 20171 NULL
+wep_addr_key_count_read_20174 wep_addr_key_count_read 3 20174 NULL
+sctp_setsockopt_auth_key_3793 sctp_setsockopt_auth_key 3 3793 NULL
+afs_proc_cells_write_61139 afs_proc_cells_write 3 61139 NULL
+store_disp_52952 store_disp 4 52952 NULL
+mangle_epsv_packet_36571 mangle_epsv_packet 5 36571 NULL
+sys_writev_28384 sys_writev 3 28384 NULL
+dlmfs_file_read_28385 dlmfs_file_read 3 28385 NULL
+ssb_bus_scan_36578 ssb_bus_scan 2 36578 NULL
+ncp_file_write_3813 ncp_file_write 3 3813 NULL
+put_cmsg_36589 put_cmsg 4 36589 NULL
+__vmalloc_61168 __vmalloc 1 61168 NULL
+llc_ui_recvmsg_3826 llc_ui_recvmsg 4 3826 NULL
+sctp_setsockopt_44788 sctp_setsockopt 5 44788 NULL
+pcnet32_realloc_rx_ring_36598 pcnet32_realloc_rx_ring 3 36598 NULL
+event_oom_late_read_61175 event_oom_late_read 3 61175 NULL
+sys_lsetxattr_61177 sys_lsetxattr 4 61177 NULL
+rx_dropped_read_44799 rx_dropped_read 3 44799 NULL
+fat_ioctl_filldir_36621 fat_ioctl_filldir 3 36621 NULL
+smk_read_onlycap_3855 smk_read_onlycap 3 3855 NULL
+rose_sendmsg_20249 rose_sendmsg 4 20249 NULL
+get_fd_set_3866 get_fd_set 1 3866 NULL
+jffs2_security_setxattr_20253 jffs2_security_setxattr 4 20253 NULL
+ubi_dbg_dump_flash_3870 ubi_dbg_dump_flash 4 3870 NULL
+sisusb_write_44834 sisusb_write 3 44834 NULL
+sta_rx_fragments_read_44835 sta_rx_fragments_read 3 44835 NULL
+acpi_system_read_fadt_3876 acpi_system_read_fadt 3 3876 NULL
+mlx4_init_cmpt_table_11569 mlx4_init_cmpt_table 3 11569 NULL
+ubifs_leb_write_61226 ubifs_leb_write 5-4 61226 NULL
+garp_attr_create_3883 garp_attr_create 3 3883 NULL
+cpia_write_proc_20268 cpia_write_proc 3 20268 NULL
+ubifs_recover_log_leb_12079 ubifs_recover_log_leb 3 12079 NULL
+uea_send_modem_cmd_3888 uea_send_modem_cmd 3 3888 NULL
+nvram_write_3894 nvram_write 3 3894 NULL
+osd_req_list_collection_objects_36664 osd_req_list_collection_objects 5 36664 NULL
+sysctl_ipc_data_3903 sysctl_ipc_data 5 3903 NULL
+vcs_write_3910 vcs_write 3 3910 NULL
+compat_sys_msgrcv_7482 compat_sys_msgrcv 2 7482 NULL
+compat_udpv6_setsockopt_42981 compat_udpv6_setsockopt 5 42981 NULL
+do_tty_write_44896 do_tty_write 5 44896 NULL
+snd_cs4281_BA1_read_20323 snd_cs4281_BA1_read 5-6 20323 NULL
+_scsih_change_queue_depth_44902 _scsih_change_queue_depth 2 44902 NULL
+xfs_handle_to_dentry_12135 xfs_handle_to_dentry 3 12135 NULL
+sys_add_key_61288 sys_add_key 4 61288 NULL
+rawv6_seticmpfilter_12137 rawv6_seticmpfilter 5 12137 NULL
+platform_device_register_simple_61290 platform_device_register_simple 4 61290 NULL
+proc_write_tled_3947 proc_write_tled 3 3947 NULL
+i2400m_tx_stats_read_28527 i2400m_tx_stats_read 3 28527 NULL
+btmrvl_sdio_host_to_card_12152 btmrvl_sdio_host_to_card 3 12152 NULL
+gfs2_glock_nq_m_20347 gfs2_glock_nq_m 1 20347 NULL
+l2cap_send_cmd_3678 l2cap_send_cmd 4 3678 NULL
+sel_read_policycap_28544 sel_read_policycap 3 28544 NULL
+mptctl_getiocinfo_28545 mptctl_getiocinfo 2 28545 NULL
+snd_rawmidi_kernel_read1_36740 snd_rawmidi_kernel_read1 4 36740 NULL
+b43legacy_debugfs_write_28556 b43legacy_debugfs_write 3 28556 NULL
+dma_memcpy_to_iovec_12173 dma_memcpy_to_iovec 5 12173 NULL
+pcpu_mem_alloc_3987 pcpu_mem_alloc 1 3987 NULL
+inet_dccp_listen_28565 inet_dccp_listen 2 28565 NULL
+do_add_counters_3992 do_add_counters 3 3992 NULL
+mic_rx_pkts_read_27972 mic_rx_pkts_read 3 27972 NULL
+ip_generic_getfrag_12187 ip_generic_getfrag 3-4 12187 NULL
+st5481_setup_isocpipes_61340 st5481_setup_isocpipes 6-4 61340 NULL
+acpi_video_device_write_state_61342 acpi_video_device_write_state 3 61342 NULL
+ip4ip6_err_36772 ip4ip6_err 5 36772 NULL
+ieee80211_if_read_dot11MeshMaxPeerLinks_23878 ieee80211_if_read_dot11MeshMaxPeerLinks 3 23878 NULL
+snd_hdsp_capture_copy_4011 snd_hdsp_capture_copy 5 4011 NULL
+nfsd_read_20406 nfsd_read 6 20406 NULL
+receive_copy_12216 receive_copy 3 12216 NULL
+proc_fault_inject_read_36802 proc_fault_inject_read 3 36802 NULL
+stats_tx_expand_skb_head_read_53188 stats_tx_expand_skb_head_read 3 53188 NULL
+change_xattr_61390 change_xattr 5 61390 NULL
+find_skb_20431 find_skb 2 20431 NULL
+hiddev_ioctl_36816 hiddev_ioctl 2 36816 NULL
+tcp_fragment_20436 tcp_fragment 3 20436 NULL
+ib_uverbs_unmarshall_recv_12251 ib_uverbs_unmarshall_recv 5 12251 NULL
+vstusb_write_45021 vstusb_write 3 45021 NULL nohasharray
+ptrace_writedata_45021 ptrace_writedata 4 45021 &vstusb_write_45021
+simple_alloc_urb_60420 simple_alloc_urb 3 60420 NULL
+sys_sethostname_42962 sys_sethostname 2 42962 NULL
+shash_compat_setkey_12267 shash_compat_setkey 3 12267 NULL
+add_sctp_bind_addr_12269 add_sctp_bind_addr 3 12269 NULL
+sctp_make_asconf_4078 sctp_make_asconf 3 4078 NULL
+vhci_get_user_45039 vhci_get_user 3 45039 NULL
+compat_ipv6_setsockopt_20468 compat_ipv6_setsockopt 5 20468 NULL
+keyctl_describe_key_36853 keyctl_describe_key 3 36853 NULL
+blk_queue_resize_tags_28670 blk_queue_resize_tags 2 28670 NULL
+sel_write_user_45060 sel_write_user 3 45060 NULL
+sbp2util_node_write_no_wait_7510 sbp2util_node_write_no_wait 4 7510 NULL
+iwm_notif_send_12295 iwm_notif_send 6 12295 NULL
+__dev_alloc_skb_28681 __dev_alloc_skb 1 28681 NULL
+__videobuf_copy_stream_20490 __videobuf_copy_stream 3 20490 NULL
+svc_setsockopt_36876 svc_setsockopt 5 36876 NULL
+snd_mixart_BA0_read_45069 snd_mixart_BA0_read 5-6 45069 NULL
+fast_user_write_20494 fast_user_write 5 20494 NULL
+ipr_change_queue_depth_53263 ipr_change_queue_depth 2 53263 NULL
+allocate_buffers_4113 allocate_buffers 2 4113 NULL
+ib_ucm_alloc_data_36885 ib_ucm_alloc_data 3 36885 NULL
+bt_sock_recvmsg_12316 bt_sock_recvmsg 4 12316 NULL
+selinux_inode_notifysecctx_36896 selinux_inode_notifysecctx 3 36896 NULL
+user_dlm_lock_56667 user_dlm_lock 6 56667 NULL
+pwc_rvmalloc_12325 pwc_rvmalloc 1 12325 NULL
+dvb_dvr_read_17073 dvb_dvr_read 3 17073 NULL
+xfs_iext_realloc_direct_20521 xfs_iext_realloc_direct 2 20521 NULL
+sctp_getsockopt_disable_fragments_12330 sctp_getsockopt_disable_fragments 2 12330 NULL
+pcbit_writecmd_12332 pcbit_writecmd 2 12332 NULL
+__get_vm_area_node_55305 __get_vm_area_node 1 55305 NULL
+amd_create_gatt_pages_20537 amd_create_gatt_pages 1 20537 NULL
+usbdev_read_45114 usbdev_read 3 45114 NULL
+spi_execute_28736 spi_execute 5 28736 NULL
+snd_pcm_aio_write_28738 snd_pcm_aio_write 3 28738 NULL
+mptctl_ioctl_12355 mptctl_ioctl 2 12355 NULL
+get_alua_req_4166 get_alua_req 3 4166 NULL
+blk_dropped_read_4168 blk_dropped_read 3 4168 NULL
+venus_create_20555 venus_create 4 20555 NULL
+ftrace_profile_write_53327 ftrace_profile_write 3 53327 NULL
+expand_files_17080 expand_files 2 17080 NULL
+read_file_bool_4180 read_file_bool 3 4180 NULL
+send_to_tty_45141 send_to_tty 3 45141 NULL
+write_leb_36957 write_leb 5 36957 NULL
+xfs_iext_inline_to_direct_12384 xfs_iext_inline_to_direct 2 12384 NULL
+stats_transmitted_fragment_count_read_28770 stats_transmitted_fragment_count_read 3 28770 NULL
+device_write_45156 device_write 3 45156 NULL
+_osd_req_list_objects_4204 _osd_req_list_objects 6 4204 NULL
+trace_options_core_write_61551 trace_options_core_write 3 61551 NULL
+dvb_net_sec_callback_28786 dvb_net_sec_callback 2 28786 NULL
+gem_alloc_skb_59411 gem_alloc_skb 1 59411 NULL
+sctp_getsockopt_local_addrs_old_4220 sctp_getsockopt_local_addrs_old 2 4220 NULL
+vring_add_indirect_4224 vring_add_indirect 3-4 4224 NULL
+pwr_disable_ps_read_13176 pwr_disable_ps_read 3 13176 NULL
+cgroup_file_read_28804 cgroup_file_read 3 28804 NULL
+snd_sb_csp_load_user_45190 snd_sb_csp_load_user 3 45190 NULL
+setxattr_37006 setxattr 4 37006 NULL
+add_child_45201 add_child 4 45201 NULL
+seq_open_private_61589 seq_open_private 3 61589 NULL
+__get_vm_area_61599 __get_vm_area 1 61599 NULL
+netlink_recvmsg_61600 netlink_recvmsg 4 61600 NULL
+store_lssw_43035 store_lssw 4 43035 NULL nohasharray
+wep_default_key_count_read_43035 wep_default_key_count_read 3 43035 &store_lssw_43035
+spi_alloc_master_45223 spi_alloc_master 2 45223 NULL
+ubi_eba_write_leb_19826 ubi_eba_write_leb 6-5 19826 NULL
+vp_request_msix_vectors_28849 vp_request_msix_vectors 2 28849 NULL
+configfs_write_file_61621 configfs_write_file 3 61621 NULL
+event_enable_write_45238 event_enable_write 3 45238 NULL
+ieee80211_if_read_drop_unencrypted_37053 ieee80211_if_read_drop_unencrypted 3 37053 NULL
+ieee80211_rx_bss_info_61630 ieee80211_rx_bss_info 3 61630 NULL
+isr_cmd_cmplt_read_53439 isr_cmd_cmplt_read 3 53439 NULL
+_fc_frame_alloc_28865 _fc_frame_alloc 2 28865 NULL
+i2o_parm_table_get_61635 i2o_parm_table_get 6 61635 NULL
+snd_hdsp_playback_copy_20676 snd_hdsp_playback_copy 5 20676 NULL
+x25_sendmsg_12487 x25_sendmsg 4 12487 NULL
+dvb_dmxdev_buffer_read_20682 dvb_dmxdev_buffer_read 4 20682 NULL
+pipe_iov_copy_to_user_3447 pipe_iov_copy_to_user 3 3447 NULL
+dvb_ringbuffer_pkt_read_user_4303 dvb_ringbuffer_pkt_read_user 3-5-2 4303 NULL
+resize_stripes_61650 resize_stripes 2 61650 NULL
+n2_run_53459 n2_run 3 53459 NULL
+packet_sendmsg_spkt_28885 packet_sendmsg_spkt 4 28885 NULL
+parse_command_37079 parse_command 2 37079 NULL
+hpsb_make_writepacket_61656 hpsb_make_writepacket 5 61656 NULL
+drm_agp_allocate_memory_15738 drm_agp_allocate_memory 2 15738 NULL
+rds_tcp_data_recv_53476 rds_tcp_data_recv 3 53476 NULL
+ftdi_write_20710 ftdi_write 4 20710 NULL
+snd_rawmidi_kernel_read_4328 snd_rawmidi_kernel_read 3 4328 NULL
+iowarrior_read_53483 iowarrior_read 3 53483 NULL
+osd_req_write_kern_53486 osd_req_write_kern 5 53486 NULL
+snd_pcm_oss_sync1_45298 snd_pcm_oss_sync1 2 45298 NULL
+security_context_to_sid_force_20724 security_context_to_sid_force 2 20724 NULL
+tso_fragment_12539 tso_fragment 3 12539 NULL
+filter_read_61692 filter_read 3 61692 NULL
+ar9170_alloc_4355 ar9170_alloc 1 4355 NULL
+__copy_from_user_inatomic_4365 __copy_from_user_inatomic 3 4365 NULL
+vol_cdev_direct_write_20751 vol_cdev_direct_write 3 20751 NULL
+ipc_rcu_alloc_21208 ipc_rcu_alloc 1 21208 NULL nohasharray
+frame_alloc_21208 frame_alloc 2 21208 &ipc_rcu_alloc_21208
+zc0301_read_53524 zc0301_read 3 53524 NULL
+sys_setdomainname_4373 sys_setdomainname 2 4373 NULL
+fragmentation_threshold_read_61718 fragmentation_threshold_read 3 61718 NULL
+snd_rme9652_capture_copy_10287 snd_rme9652_capture_copy 5 10287 NULL
+copy_vm86_regs_from_user_45340 copy_vm86_regs_from_user 3 45340 NULL
+se401_read_58074 se401_read 3 58074 NULL
+hvc_alloc_12579 hvc_alloc 4 12579 NULL
+irda_sendmsg_4388 irda_sendmsg 4 4388 NULL
+pcpu_extend_area_map_12589 pcpu_extend_area_map 2 12589 NULL
+read_file_interrupt_61742 read_file_interrupt 3 61742 NULL
+vhci_put_user_12604 vhci_put_user 4 12604 NULL
+sctp_getsockopt_adaptation_layer_45375 sctp_getsockopt_adaptation_layer 2 45375 NULL
+hci_sock_setsockopt_28993 hci_sock_setsockopt 5 28993 NULL
+neigh_hash_alloc_52619 neigh_hash_alloc 1 52619 NULL
+sys_sendto_20809 sys_sendto 6 20809 NULL
+w9968cf_read_53582 w9968cf_read 3 53582 NULL nohasharray
+set_registers_53582 set_registers 3 53582 &w9968cf_read_53582
+stats_rx_handlers_drop_short_read_45391 stats_rx_handlers_drop_short_read 3 45391 NULL
+do_pages_stat_4437 do_pages_stat 2 4437 NULL
+lane2_associate_req_45398 lane2_associate_req 4 45398 NULL
+ieee80211_rx_mgmt_probe_resp_12634 ieee80211_rx_mgmt_probe_resp 4 12634 NULL
+pn_sendmsg_12640 pn_sendmsg 4 12640 NULL
+pfkey_recvmsg_53604 pfkey_recvmsg 4 53604 NULL
+sys_fcntl64_29031 sys_fcntl64 3 29031 NULL
+nr_recvmsg_12649 nr_recvmsg 4 12649 NULL
+__do_replace_37227 __do_replace 5 37227 NULL
+dn_alloc_send_pskb_4465 dn_alloc_send_pskb 2 4465 NULL
+at76_set_card_command_4471 at76_set_card_command 4 4471 NULL
+hdpvr_i2c_write_61816 hdpvr_i2c_write 4 61816 NULL
+rxrpc_sendmsg_29049 rxrpc_sendmsg 4 29049 NULL nohasharray
+hpsb_read_29049 hpsb_read 6 29049 &rxrpc_sendmsg_29049
+___alloc_bootmem_nopanic_53626 ___alloc_bootmem_nopanic 1 53626 NULL
+recv_control_msg_4476 recv_control_msg 5 4476 NULL
+tty_buffer_alloc_45437 tty_buffer_alloc 2 45437 NULL
+sys_semtimedop_4486 sys_semtimedop 3 4486 NULL
+udp_sendmsg_4492 udp_sendmsg 4 4492 NULL
+sctp_getsockopt_peer_addr_params_53645 sctp_getsockopt_peer_addr_params 2 53645 NULL
+nr_sendmsg_53656 nr_sendmsg 4 53656 NULL
+rb_simple_write_20890 rb_simple_write 3 20890 NULL
+sisusb_send_packet_20891 sisusb_send_packet 2 20891 NULL
+tracing_read_dyn_info_45468 tracing_read_dyn_info 3 45468 NULL
+key_icverrors_read_20895 key_icverrors_read 3 20895 NULL
+srp_target_alloc_37288 srp_target_alloc 3 37288 NULL
+sctp_getsockopt_active_key_45483 sctp_getsockopt_active_key 2 45483 NULL
+ieee80211_if_read_num_buffered_multicast_12716 ieee80211_if_read_num_buffered_multicast 3 12716 NULL
+compat_sys_readv_20911 compat_sys_readv 3 20911 NULL
+fuse_fill_write_pages_53682 fuse_fill_write_pages 4 53682 NULL
+sys_llistxattr_4532 sys_llistxattr 3 4532 NULL
+isdn_ppp_write_29109 isdn_ppp_write 4 29109 NULL
+jffs2_write_dirent_37311 jffs2_write_dirent 5 37311 NULL
+key_rx_spec_read_12736 key_rx_spec_read 3 12736 NULL
+kmem_zalloc_greedy_45507 kmem_zalloc_greedy 2-3 45507 NULL
+videobuf_vmalloc_to_sg_4548 videobuf_vmalloc_to_sg 2 4548 NULL
+clear_refs_write_61904 clear_refs_write 3 61904 NULL
+scsi_mode_select_37330 scsi_mode_select 6 37330 NULL
+rxrpc_server_sendmsg_37331 rxrpc_server_sendmsg 4 37331 NULL
+ieee80211_if_read_dot11MeshMaxRetries_12756 ieee80211_if_read_dot11MeshMaxRetries 3 12756 NULL
+hpsb_iso_common_init_45525 hpsb_iso_common_init 4 45525 NULL
+proc_scsi_write_29142 proc_scsi_write 3 29142 NULL
+reshape_ring_29147 reshape_ring 2 29147 NULL
+cgroup_read_u64_45532 cgroup_read_u64 5 45532 NULL
+au0828_init_isoc_61917 au0828_init_isoc 2-3 61917 NULL
+copy_macs_45534 copy_macs 4 45534 NULL
+sctp_sendmsg_61919 sctp_sendmsg 4 61919 NULL
+listxattr_12769 listxattr 3 12769 NULL
+wdm_write_53735 wdm_write 3 53735 NULL
+snd_rme9652_playback_copy_20970 snd_rme9652_playback_copy 5 20970 NULL
+send_bulk_static_data_61932 send_bulk_static_data 3 61932 NULL
+mempool_create_29437 mempool_create 1 29437 NULL
+sock_alloc_send_pskb_21246 sock_alloc_send_pskb 2 21246 NULL
+stats_dot11ACKFailureCount_read_45558 stats_dot11ACKFailureCount_read 3 45558 NULL
+venus_rmdir_45564 venus_rmdir 4 45564 NULL
+scsi_adjust_queue_depth_12802 scsi_adjust_queue_depth 3 12802 NULL
+__copy_from_user_inatomic_nocache_49921 __copy_from_user_inatomic_nocache 3 49921 NULL
+xfs_inumbers_fmt_12817 xfs_inumbers_fmt 3 12817 NULL
+ipath_create_cq_45586 ipath_create_cq 2 45586 NULL
+wusb_prf_256_29203 wusb_prf_256 7 29203 NULL
+rdma_set_ib_paths_45592 rdma_set_ib_paths 3 45592 NULL
+iwl_dbgfs_tx_queue_read_4635 iwl_dbgfs_tx_queue_read 3 4635 NULL
+rds_iw_inc_copy_to_user_29214 rds_iw_inc_copy_to_user 3 29214 NULL
+sys_getxattr_37418 sys_getxattr 4 37418 NULL
+hci_sock_sendmsg_37420 hci_sock_sendmsg 4 37420 NULL
+bnx2i_send_nl_mesg_48562 bnx2i_send_nl_mesg 4 48562 NULL
+spidev_ioctl_12846 spidev_ioctl 2 12846 NULL
+audit_log_n_hex_45617 audit_log_n_hex 3 45617 NULL
+devm_ioremap_29235 devm_ioremap 3-2 29235 NULL nohasharray
+squashfs_read_table_29235 squashfs_read_table 4 29235 &devm_ioremap_29235
+lbs_threshold_read_21046 lbs_threshold_read 5 21046 NULL
+xfs_iext_insert_53815 xfs_iext_insert 3 53815 NULL
+saa_write_45625 saa_write 3 45625 NULL
+security_context_to_sid_core_29248 security_context_to_sid_core 2 29248 NULL
+node_read_45634 node_read 4 45634 NULL
+jffs2_do_unlink_62020 jffs2_do_unlink 4 62020 NULL
+mempool_kmalloc_53831 mempool_kmalloc 2 53831 NULL
+cx18_read_pos_4683 cx18_read_pos 3 4683 NULL
+gru_alloc_gts_37453 gru_alloc_gts 2-3 37453 NULL
+short_retry_limit_read_4687 short_retry_limit_read 3 4687 NULL
+pmcraid_build_passthrough_ioadls_62034 pmcraid_build_passthrough_ioadls 2 62034 NULL
+videobuf_pages_to_sg_53849 videobuf_pages_to_sg 2 53849 NULL
+event_calibration_read_21083 event_calibration_read 3 21083 NULL
+acpi_thermal_write_polling_45660 acpi_thermal_write_polling 3 45660 NULL
+prism2_set_genericelement_29277 prism2_set_genericelement 3 29277 NULL
+sctp_user_addto_chunk_62047 sctp_user_addto_chunk 2-3 62047 NULL
+compat_mpctl_ioctl_45671 compat_mpctl_ioctl 2 45671 NULL
+iscsi_change_queue_depth_37480 iscsi_change_queue_depth 2 37480 NULL
+do_pselect_62061 do_pselect 1 62061 NULL
+btmrvl_gpiogap_read_4718 btmrvl_gpiogap_read 3 4718 NULL
+dgram_sendmsg_45679 dgram_sendmsg 4 45679 NULL
+kmem_realloc_37489 kmem_realloc 2 37489 NULL
+ati_create_gatt_pages_4722 ati_create_gatt_pages 1 4722 NULL nohasharray
+show_header_4722 show_header 3 4722 &ati_create_gatt_pages_4722
+groups_alloc_7614 groups_alloc 1 7614 NULL
+sn9c102_read_29305 sn9c102_read 3 29305 NULL
+pcpu_alloc_bootmem_62074 pcpu_alloc_bootmem 2 62074 NULL
+smk_write_ambient_45691 smk_write_ambient 3 45691 NULL
+ci_ll_init_12930 ci_ll_init 3 12930 NULL
+unix_dgram_sendmsg_45699 unix_dgram_sendmsg 4 45699 NULL
+sg_proc_write_adio_45704 sg_proc_write_adio 3 45704 NULL
+vmalloc_32_user_37519 vmalloc_32_user 1 37519 NULL
+proc_file_read_53905 proc_file_read 3 53905 NULL
+dvb_ca_en50221_init_45718 dvb_ca_en50221_init 4 45718 NULL
+__alloc_ei_netdev_29338 __alloc_ei_netdev 1 29338 NULL
+new_skb_21148 new_skb 1 21148 NULL
+bcsp_prepare_pkt_12961 bcsp_prepare_pkt 3 12961 NULL
+l2cap_sock_setsockopt_old_29346 l2cap_sock_setsockopt_old 4 29346 NULL
+bm_status_write_12964 bm_status_write 3 12964 NULL
+ttm_agp_populate_11718 ttm_agp_populate 2 11718 NULL
+snd_cs46xx_io_read_45734 snd_cs46xx_io_read 5-6 45734 NULL
+usb_serial_generic_write_53927 usb_serial_generic_write 4 53927 NULL
+cxgb_alloc_mem_24007 cxgb_alloc_mem 1 24007 NULL
+rw_copy_check_uvector_45748 rw_copy_check_uvector 3 45748 NULL
+stats_retry_count_read_21177 stats_retry_count_read 3 21177 NULL
+sctp_make_chunk_12986 sctp_make_chunk 4 12986 NULL
+acpi_tb_install_table_12988 acpi_tb_install_table 1 12988 NULL
+tracing_mark_write_62143 tracing_mark_write 3 62143 NULL
+mthca_setup_cmd_doorbells_53954 mthca_setup_cmd_doorbells 2 53954 NULL
+ncp__vol2io_4804 ncp__vol2io 5 4804 NULL
+iwl_tx_queue_init_4807 iwl_tx_queue_init 3 4807 NULL
+hpsb_node_read_53963 hpsb_node_read 4 53963 NULL
+cx18_v4l2_read_21196 cx18_v4l2_read 3 21196 NULL
+mangle_rfc959_packet_21197 mangle_rfc959_packet 5 21197 NULL
+alloc_ts_config_45775 alloc_ts_config 1 45775 NULL
+idetape_chrdev_write_53976 idetape_chrdev_write 3 53976 NULL
+subsystem_filter_write_13022 subsystem_filter_write 3 13022 NULL
+raw_setsockopt_45800 raw_setsockopt 5 45800 NULL
+alloc_upcall_62186 alloc_upcall 2 62186 NULL
+lbs_rdbbp_read_45805 lbs_rdbbp_read 3 45805 NULL
+NCR_700_change_queue_depth_45806 NCR_700_change_queue_depth 2 45806 NULL
+cifs_user_write_29424 cifs_user_write 3 29424 NULL
+ubi_eba_atomic_leb_change_13041 ubi_eba_atomic_leb_change 5 13041 NULL
+pcpu_alloc_alloc_info_45813 pcpu_alloc_alloc_info 1-2 45813 NULL
+input_ff_create_21240 input_ff_create 2 21240 NULL
+sock_kmalloc_62205 sock_kmalloc 2 62205 NULL
+key_tx_spec_read_4862 key_tx_spec_read 3 4862 NULL
+__dn_setsockopt_13060 __dn_setsockopt 5 13060 NULL
+alloc_fd_37637 alloc_fd 1 37637 NULL
+hid_register_field_4874 hid_register_field 2-3 4874 NULL
+tcp_dma_try_early_copy_37651 tcp_dma_try_early_copy 3 37651 NULL
+ipxrtr_route_packet_54036 ipxrtr_route_packet 4 54036 NULL
+vga_arb_read_4886 vga_arb_read 3 4886 NULL
+sys_ipc_4889 sys_ipc 3 4889 NULL
+bio_copy_user_iov_37660 bio_copy_user_iov 4 37660 NULL
+rfcomm_sock_sendmsg_37661 rfcomm_sock_sendmsg 4 37661 NULL
+arm_write_29476 arm_write 6 29476 NULL
+isdn_write_45863 isdn_write 3 45863 NULL
+send_control_msg_62261 send_control_msg 5 62261 NULL
+snd_rme96_playback_copy_13111 snd_rme96_playback_copy 5 13111 NULL
+get_rdac_req_45882 get_rdac_req 3 45882 NULL
+store_cpufv_disabled_43809 store_cpufv_disabled 4 43809 NULL
+btmrvl_pscmd_write_29504 btmrvl_pscmd_write 3 29504 NULL
+ntfs_rl_insert_4931 ntfs_rl_insert 2-4 4931 NULL
+ata_scsi_change_queue_depth_37702 ata_scsi_change_queue_depth 2 37702 NULL
+iwl_dbgfs_led_read_45896 iwl_dbgfs_led_read 3 45896 NULL
+ftrace_profile_read_21327 ftrace_profile_read 3 21327 NULL
+mon_bin_ioctl_21336 mon_bin_ioctl 4 21336 NULL
+sta_last_qual_read_62297 sta_last_qual_read 3 62297 NULL
+create_xattr_54106 create_xattr 5 54106 NULL
+udplite_getfrag_14479 udplite_getfrag 3-4 14479 NULL
+tomoyo_alloc_37728 tomoyo_alloc 1 37728 NULL
+devm_kzalloc_4966 devm_kzalloc 2 4966 NULL
+compat_rawv6_setsockopt_4967 compat_rawv6_setsockopt 5 4967 NULL
+udf_sb_alloc_partition_maps_62313 udf_sb_alloc_partition_maps 2 62313 NULL
+alloc_mr_45935 alloc_mr 1 45935 NULL
+read_enabled_file_bool_37744 read_enabled_file_bool 3 37744 NULL
+hfcpci_empty_bfifo_62323 hfcpci_empty_bfifo 4 62323 NULL
+ocfs2_control_cfu_37750 ocfs2_control_cfu 2 37750 NULL
+isr_host_acknowledges_read_54136 isr_host_acknowledges_read 3 54136 NULL
+idetape_queue_rw_tail_29562 idetape_queue_rw_tail 3 29562 NULL
+alloc_orinocodev_21371 alloc_orinocodev 1 21371 NULL
+handle_eviocgbit_4991 handle_eviocgbit 2 4991 NULL
+ds_ioctl_45954 ds_ioctl 3 45954 NULL
+lbs_lowsnr_read_29571 lbs_lowsnr_read 3 29571 NULL
+dccp_setsockopt_cscov_37766 dccp_setsockopt_cscov 2 37766 NULL
+asn1_oid_decode_4999 asn1_oid_decode 2 4999 NULL
+flash_write_62354 flash_write 3 62354 NULL
+rb_simple_read_45972 rb_simple_read 3 45972 NULL
+mmc_ext_csd_read_13205 mmc_ext_csd_read 3 13205 NULL
+memcpy_toiovec_54166 memcpy_toiovec 3 54166 NULL
+ezusb_writememory_45976 ezusb_writememory 4 45976 NULL
+acpi_os_read_memory_54186 acpi_os_read_memory 3-1 54186 NULL
+smk_read_logging_37804 smk_read_logging 3 37804 NULL
+store_bluetooth_21320 store_bluetooth 4 21320 NULL
+cru_detect_11272 cru_detect 1 11272 NULL
+asix_read_cmd_13245 asix_read_cmd 5 13245 NULL
+init_tid_tabs_13252 init_tid_tabs 2-4-3 13252 NULL
+concat_writev_21451 concat_writev 3 21451 NULL
+sierra_setup_urb_46029 sierra_setup_urb 5 46029 NULL
+__register_chrdev_54223 __register_chrdev 2-3 54223 NULL
+sta_rx_bytes_read_46037 sta_rx_bytes_read 3 46037 NULL
+sctp_make_abort_user_29654 sctp_make_abort_user 3 29654 NULL
+snd_midi_channel_alloc_set_28153 snd_midi_channel_alloc_set 1 28153 NULL
+snd_mixart_BA1_read_5082 snd_mixart_BA1_read 5-6 5082 NULL
+o2hb_debug_read_37851 o2hb_debug_read 3 37851 NULL
+udplite_manip_pkt_62433 udplite_manip_pkt 2 62433 NULL
+netdev_alloc_skb_62437 netdev_alloc_skb 2 62437 NULL
+fwnet_receive_packet_46054 fwnet_receive_packet 10 46054 NULL
+vring_add_buf_36348 vring_add_buf 3-4 36348 NULL
+new_lockspace_29674 new_lockspace 2 29674 NULL
+pn_recvmsg_30887 pn_recvmsg 4 30887 NULL
+dma_tx_errors_read_46060 dma_tx_errors_read 3 46060 NULL
+sound_write_5102 sound_write 3 5102 NULL
+read_file_xmit_21487 read_file_xmit 3 21487 NULL
+wusb_prf_54261 wusb_prf 7 54261 NULL nohasharray
+audio_write_54261 audio_write 4 54261 &wusb_prf_54261
+ssb_bus_ssbbus_register_2217 ssb_bus_ssbbus_register 2 2217 NULL
+sys_setxattr_37880 sys_setxattr 4 37880 NULL
+dvb_net_sec_37884 dvb_net_sec 3 37884 NULL
+sel_commit_bools_write_46077 sel_commit_bools_write 3 46077 NULL
+ps_pspoll_timeouts_read_11776 ps_pspoll_timeouts_read 3 11776 NULL
+sta_last_noise_read_62466 sta_last_noise_read 3 62466 NULL
+dbg_leb_change_19969 dbg_leb_change 4 19969 NULL
+nf_nat_mangle_udp_packet_13321 nf_nat_mangle_udp_packet 5-7 13321 NULL
+dma_skb_copy_datagram_iovec_21516 dma_skb_copy_datagram_iovec 3-5 21516 NULL
+ata_host_alloc_46094 ata_host_alloc 2 46094 NULL
+us122l_ctl_msg_13330 us122l_ctl_msg 8 13330 NULL
+dlm_alloc_pagevec_54296 dlm_alloc_pagevec 1 54296 NULL
+sysprof_sample_write_62489 sysprof_sample_write 3 62489 NULL
+skb_copy_expand_7685 skb_copy_expand 2-3 7685 NULL nohasharray
+acpi_ex_allocate_name_string_7685 acpi_ex_allocate_name_string 2-1 7685 &skb_copy_expand_7685
+mlx4_en_create_rx_ring_62498 mlx4_en_create_rx_ring 3 62498 NULL
+emi62_writememory_29731 emi62_writememory 4 29731 NULL
+mlx4_ib_alloc_fast_reg_page_list_46119 mlx4_ib_alloc_fast_reg_page_list 2 46119 NULL
+pkt_alloc_packet_data_37928 pkt_alloc_packet_data 1 37928 NULL
+rxrpc_send_data_21553 rxrpc_send_data 5 21553 NULL
+iwl_dbgfs_status_read_5171 iwl_dbgfs_status_read 3 5171 NULL
+pn_raw_send_54330 pn_raw_send 2 54330 NULL
+pep_sendmsg_62524 pep_sendmsg 4 62524 NULL
+megaraid_change_queue_depth_13375 megaraid_change_queue_depth 2 13375 NULL
+iso_sched_alloc_13377 iso_sched_alloc 1 13377 NULL nohasharray
+wep_key_not_found_read_13377 wep_key_not_found_read 3 13377 &iso_sched_alloc_13377
+ar9170_handle_mpdu_37956 ar9170_handle_mpdu 3 37956 NULL
+cxio_hal_init_resource_29771 cxio_hal_init_resource 2-7-6 29771 NULL
+__netlink_change_ngroups_46156 __netlink_change_ngroups 2 46156 NULL
+sco_sock_sendmsg_62542 sco_sock_sendmsg 4 62542 NULL
+_osd_realloc_seg_54352 _osd_realloc_seg 3 54352 NULL
+visor_write_37975 visor_write 4 37975 NULL
+tcf_hash_create_54360 tcf_hash_create 4 54360 NULL
+ppp_cp_parse_cr_5214 ppp_cp_parse_cr 4 5214 NULL
+snd_emu10k1_synth_copy_from_user_9061 snd_emu10k1_synth_copy_from_user 3-5 9061 NULL
+vfs_readlink_54368 vfs_readlink 3 54368 NULL
+pep_recvmsg_19402 pep_recvmsg 4 19402 NULL
+ocfs2_acl_from_xattr_21604 ocfs2_acl_from_xattr 2 21604 NULL
+subsystem_filter_read_62310 subsystem_filter_read 3 62310 NULL
+vxge_os_dma_malloc_46184 vxge_os_dma_malloc 2 46184 NULL
+do_dccp_setsockopt_54377 do_dccp_setsockopt 5 54377 NULL
+ssb_ioremap_5228 ssb_ioremap 2 5228 NULL
+xfrm_user_policy_62573 xfrm_user_policy 4 62573 NULL
+xlog_do_recovery_pass_21618 xlog_do_recovery_pass 3 21618 NULL
+snd_pcm_oss_read2_54387 snd_pcm_oss_read2 3 54387 NULL
+isdn_ppp_skb_push_5236 isdn_ppp_skb_push 2 5236 NULL
+vfs_readv_38011 vfs_readv 3 38011 NULL
+keyring_read_13438 keyring_read 3 13438 NULL
+sctp_setsockopt_peer_primary_addr_13440 sctp_setsockopt_peer_primary_addr 3 13440 NULL
+compat_sys_semtimedop_3606 compat_sys_semtimedop 3 3606 NULL
+tcp_update_scoreboard_21639 tcp_update_scoreboard 2 21639 NULL
+dsp_write_46218 dsp_write 2 46218 NULL
+prism2_send_mgmt_62605 prism2_send_mgmt 4 62605 NULL nohasharray
+nfsd_vfs_read_62605 nfsd_vfs_read 6 62605 &prism2_send_mgmt_62605
+store_wlan_38040 store_wlan 4 38040 NULL
+dev_write_7708 dev_write 3 7708 NULL
+nsm_create_handle_38060 nsm_create_handle 4 38060 NULL
+atalk_sendmsg_21677 atalk_sendmsg 4 21677 NULL
+ipv6_setsockopt_29871 ipv6_setsockopt 5 29871 NULL
+sisusb_copy_memory_35016 sisusb_copy_memory 4 35016 NULL
+tomoyo_read_control_21682 tomoyo_read_control 3 21682 NULL
+lpfc_sli4_queue_alloc_62646 lpfc_sli4_queue_alloc 3 62646 NULL
+alloc_ltalkdev_38071 alloc_ltalkdev 1 38071 NULL
+evdev_ioctl_handler_21705 evdev_ioctl_handler 2 21705 NULL
+request_key_auth_new_38092 request_key_auth_new 3 38092 NULL
+drm_sman_init_21710 drm_sman_init 2 21710 NULL
+tracing_trace_options_read_51405 tracing_trace_options_read 3 51405 NULL
+ipath_cdev_init_37752 ipath_cdev_init 1 37752 NULL
+sctp_tsnmap_mark_13527 sctp_tsnmap_mark 2 13527 NULL
+bm_init_13529 bm_init 2 13529 NULL
+check586_29914 check586 2 29914 NULL
+snd_pcm_oss_write_38108 snd_pcm_oss_write 3 38108 NULL
+printer_req_alloc_62687 printer_req_alloc 2 62687 NULL nohasharray
+iwl_dbgfs_rx_statistics_read_62687 iwl_dbgfs_rx_statistics_read 3 62687 &printer_req_alloc_62687
+ccid3_hc_rx_getsockopt_62331 ccid3_hc_rx_getsockopt 3 62331 NULL
+reiserfs_allocate_list_bitmaps_21732 reiserfs_allocate_list_bitmaps 3 21732 NULL
+ioremap_wc_62695 ioremap_wc 2-1 62695 NULL
+pg_read_17276 pg_read 3 17276 NULL
+l2cap_create_basic_pdu_54508 l2cap_create_basic_pdu 3 54508 NULL
+ps_pspoll_utilization_read_5361 ps_pspoll_utilization_read 3 5361 NULL
+cgroup_write_X64_54514 cgroup_write_X64 5 54514 NULL
+rxpipe_descr_host_int_trig_rx_data_read_22001 rxpipe_descr_host_int_trig_rx_data_read 3 22001 NULL
+bioset_integrity_create_62708 bioset_integrity_create 2 62708 NULL
+__hwahc_dev_set_key_46328 __hwahc_dev_set_key 5 46328 NULL
+mthca_alloc_init_21754 mthca_alloc_init 2 21754 NULL
+l2down_create_21755 l2down_create 4 21755 NULL
+csr1212_rom_cache_malloc_46339 csr1212_rom_cache_malloc 2 46339 NULL
+__ntfs_copy_from_user_iovec_inatomic_38153 __ntfs_copy_from_user_iovec_inatomic 3-4 38153 NULL
+aem_read_sensor_21770 aem_read_sensor 5 21770 NULL
+gen_pool_add_21776 gen_pool_add 3 21776 NULL
+squashfs_read_id_index_table_5394 squashfs_read_id_index_table 3 5394 NULL
+iwl_dbgfs_chain_noise_read_46355 iwl_dbgfs_chain_noise_read 3 46355 NULL
+cache_write_13589 cache_write 3 13589 NULL
+mpt_lan_receive_post_turbo_13592 mpt_lan_receive_post_turbo 2 13592 NULL
+key_replays_read_62746 key_replays_read 3 62746 NULL
+smk_write_direct_46363 smk_write_direct 3 46363 NULL
+aac_sa_ioremap_13596 aac_sa_ioremap 2 13596 NULL nohasharray
+irias_new_octseq_value_13596 irias_new_octseq_value 2 13596 &aac_sa_ioremap_13596
+irias_add_octseq_attrib_29983 irias_add_octseq_attrib 4 29983 NULL
+cdev_add_38176 cdev_add 2-3 38176 NULL
+__ioremap_caller_21800 __ioremap_caller 2-1 21800 NULL
+swap_cgroup_swapon_13614 swap_cgroup_swapon 2 13614 NULL
+nfsd_vfs_write_54577 nfsd_vfs_write 6 54577 NULL
+ax25_sendmsg_62770 ax25_sendmsg 4 62770 NULL
+rt2x00debug_write_rf_38195 rt2x00debug_write_rf 3 38195 NULL
+stats_frame_duplicate_count_read_54582 stats_frame_duplicate_count_read 3 54582 NULL nohasharray
+fw_iso_buffer_init_54582 fw_iso_buffer_init 3 54582 &stats_frame_duplicate_count_read_54582
+get_ucode_user_38202 get_ucode_user 3 38202 NULL
+acpi_system_debug_proc_write_43231 acpi_system_debug_proc_write 3 43231 NULL
+fuse_file_aio_write_46399 fuse_file_aio_write 4 46399 NULL
+packet_snd_13634 packet_snd 3 13634 NULL
+osd_req_list_partition_collections_38223 osd_req_list_partition_collections 5 38223 NULL
+sfi_map_table_5462 sfi_map_table 1 5462 NULL
+xfs_efd_init_5463 xfs_efd_init 3 5463 NULL
+scsi_vpd_inquiry_30040 scsi_vpd_inquiry 4 30040 NULL
+inet_csk_listen_start_38233 inet_csk_listen_start 2 38233 NULL
+cache_downcall_13666 cache_downcall 3 13666 NULL
+xfs_efi_init_5476 xfs_efi_init 2 5476 NULL
+mtrr_write_59622 mtrr_write 3 59622 NULL
+acpi_tb_check_xsdt_21862 acpi_tb_check_xsdt 1 21862 NULL
+ip_nat_sdp_media_60740 ip_nat_sdp_media 7 60740 NULL
+cifs_security_flags_proc_write_5484 cifs_security_flags_proc_write 3 5484 NULL
+cp210x_set_config_46447 cp210x_set_config 4 46447 NULL
+cnic_init_id_tbl_21872 cnic_init_id_tbl 2 21872 NULL
+sisusbcon_bmove_21873 sisusbcon_bmove 5-7-6 21873 NULL
+tty_write_5494 tty_write 3 5494 NULL
+rx_fcs_err_read_62844 rx_fcs_err_read 3 62844 NULL
+proc_write_lcd_30077 proc_write_lcd 3 30077 NULL
+teiup_create_43201 teiup_create 3 43201 NULL
+filldir64_46469 filldir64 3 46469 NULL
+snd_midi_channel_init_set_30092 snd_midi_channel_init_set 1 30092 NULL
+spidev_message_5518 spidev_message 3 5518 NULL
+vmemmap_alloc_block_43245 vmemmap_alloc_block 1 43245 NULL
+bio_kmalloc_54672 bio_kmalloc 2 54672 NULL
+event_format_read_54674 event_format_read 3 54674 NULL
+nfs_writedata_alloc_62868 nfs_writedata_alloc 1 62868 NULL
+zd_mac_rx_38296 zd_mac_rx 3 38296 NULL
+dv1394_read_21920 dv1394_read 3 21920 NULL
+aoechr_write_62883 aoechr_write 3 62883 NULL
+resize_info_buffer_62889 resize_info_buffer 2 62889 NULL
+if_spi_host_to_card_62890 if_spi_host_to_card 4 62890 NULL
+addtgt_54703 addtgt 3 54703 NULL
+mthca_alloc_cq_buf_46512 mthca_alloc_cq_buf 3 46512 NULL
+audit_unpack_string_13748 audit_unpack_string 3 13748 NULL
+isr_rx_headers_read_38325 isr_rx_headers_read 3 38325 NULL
+rfkill_fop_read_54711 rfkill_fop_read 3 54711 NULL
+recv_stream_30138 recv_stream 4 30138 NULL
+mempool_create_slab_pool_62907 mempool_create_slab_pool 1 62907 NULL
+getdqbuf_62908 getdqbuf 1 62908 NULL
+bdx_rxdb_create_46525 bdx_rxdb_create 1 46525 NULL
+bioset_create_5580 bioset_create 1 5580 NULL
+ocfs2_control_write_54737 ocfs2_control_write 3 54737 NULL
+fb_sys_read_13778 fb_sys_read 3 13778 NULL
+kzalloc_54740 kzalloc 1 54740 NULL
+ipath_reg_phys_mr_23918 ipath_reg_phys_mr 3 23918 NULL
+do_msgrcv_5590 do_msgrcv 4 5590 NULL
+wep_iv_read_54744 wep_iv_read 3 54744 NULL
+stats_tx_status_drop_read_10279 stats_tx_status_drop_read 3 10279 NULL
+arm_read_46556 arm_read 5 46556 NULL
+agp_create_user_memory_62955 agp_create_user_memory 1 62955 NULL
+sctp_sf_abort_violation_38380 sctp_sf_abort_violation 6 38380 NULL
+mempool_create_page_pool_30189 mempool_create_page_pool 1 30189 NULL
+nf_nat_mangle_tcp_packet_8643 nf_nat_mangle_tcp_packet 5-7 8643 NULL
+sock_setsockopt_50088 sock_setsockopt 5 50088 NULL
+dn_sendmsg_38390 dn_sendmsg 4 38390 NULL
+random_read_13815 random_read 3 13815 NULL
+usblp_ioctl_30203 usblp_ioctl 2 30203 NULL
+stats_multicast_transmitted_frame_count_read_54788 stats_multicast_transmitted_frame_count_read 3 54788 NULL
+_send_control_msg_46598 _send_control_msg 6 46598 NULL
+flexcop_device_kmalloc_54793 flexcop_device_kmalloc 1 54793 NULL
+snd_ac97_pcm_assign_30218 snd_ac97_pcm_assign 2 30218 NULL
+ti_recv_22027 ti_recv 4 22027 NULL
+iwm_wdev_alloc_38415 iwm_wdev_alloc 1 38415 NULL
+ieee80211_if_read_dtim_count_38419 ieee80211_if_read_dtim_count 3 38419 NULL
+dccp_manip_pkt_30229 dccp_manip_pkt 2 30229 NULL
+parse_arg_5657 parse_arg 2 5657 NULL
+evdev_ioctl_compat_13851 evdev_ioctl_compat 2 13851 NULL
+pcnet32_realloc_tx_ring_38428 pcnet32_realloc_tx_ring 3 38428 NULL
+aes_decrypt_fail_read_54815 aes_decrypt_fail_read 3 54815 NULL
+request_key_async_with_auxdata_46624 request_key_async_with_auxdata 4 46624 NULL
+zd_usb_read_fw_22049 zd_usb_read_fw 4 22049 NULL
+atalk_recvmsg_22053 atalk_recvmsg 4 22053 NULL
+ip_send_reply_46635 ip_send_reply 4 46635 NULL
+compat_ip_setsockopt_13870 compat_ip_setsockopt 5 13870 NULL
+generic_perform_write_54832 generic_perform_write 3 54832 NULL
+write_rio_54837 write_rio 3 54837 NULL
+rawv6_recvmsg_30265 rawv6_recvmsg 4 30265 NULL
+gigaset_write_cmd_5693 gigaset_write_cmd 3 5693 NULL
+edac_mc_alloc_54846 edac_mc_alloc 1 54846 NULL
+isr_pci_pm_read_30271 isr_pci_pm_read 3 30271 NULL
+scsi_host_alloc_63041 scsi_host_alloc 2 63041 NULL
+printer_read_54851 printer_read 3 54851 NULL
+alloc_ep_req_54860 alloc_ep_req 2 54860 NULL
+sctp_getsockopt_default_send_param_63056 sctp_getsockopt_default_send_param 2 63056 NULL
+unlink1_63059 unlink1 3 63059 NULL
+qla2x00_get_ctx_sp_13912 qla2x00_get_ctx_sp 3 13912 NULL
+tracing_saved_cmdlines_read_21434 tracing_saved_cmdlines_read 3 21434 NULL
+dispatch_ioctl_32357 dispatch_ioctl 2 32357 NULL
+replay_log_leb_18704 replay_log_leb 3 18704 NULL
+alloc_data_packet_46698 alloc_data_packet 1 46698 NULL
+ath_descdma_setup_22128 ath_descdma_setup 5 22128 NULL
+sysctl_string_13937 sysctl_string 5 13937 NULL
+get_packet_5747 get_packet 3 5747 NULL
+event_rx_mismatch_read_38518 event_rx_mismatch_read 3 38518 NULL
+ieee80211_if_read_min_discovery_timeout_13946 ieee80211_if_read_min_discovery_timeout 3 13946 NULL
+wep_decrypt_fail_read_58567 wep_decrypt_fail_read 3 58567 NULL
+iscsi_pool_init_54913 iscsi_pool_init 2-4 54913 NULL
+iwl_dbgfs_sensitivity_read_63116 iwl_dbgfs_sensitivity_read 3 63116 NULL
+sctp_setsockopt_autoclose_5775 sctp_setsockopt_autoclose 3 5775 NULL
+com90xx_found_13974 com90xx_found 3 13974 NULL
+compat_sys_writev_5784 compat_sys_writev 3 5784 NULL
+qcam_read_13977 qcam_read 3 13977 NULL
+__vxge_hw_blockpool_malloc_5786 __vxge_hw_blockpool_malloc 2 5786 NULL
+dvb_demux_read_13981 dvb_demux_read 3 13981 NULL
+ib_send_cm_rtu_63138 ib_send_cm_rtu 3 63138 NULL
+irda_sendmsg_dgram_38563 irda_sendmsg_dgram 4 38563 NULL
+ieee80211_bss_info_update_13991 ieee80211_bss_info_update 4 13991 NULL
+sys_get_mempolicy_30379 sys_get_mempolicy 3 30379 NULL
+skb_copy_datagram_iovec_5806 skb_copy_datagram_iovec 2-4 5806 NULL
+trace_options_core_read_47390 trace_options_core_read 3 47390 NULL
+c4_add_card_54968 c4_add_card 3 54968 NULL
+__proc_file_read_54978 __proc_file_read 3 54978 NULL
+_queue_data_54983 _queue_data 4 54983 NULL
+smb_alloc_request_46798 smb_alloc_request 2 46798 NULL
+rfcomm_sock_recvmsg_22227 rfcomm_sock_recvmsg 4 22227 NULL
+setup_req_5848 setup_req 3 5848 NULL
+rds_ib_inc_copy_to_user_55007 rds_ib_inc_copy_to_user 3 55007 NULL
+icn_writecmd_38629 icn_writecmd 2 38629 NULL
+xfs_iroot_realloc_46826 xfs_iroot_realloc 2 46826 NULL
+audit_init_entry_38644 audit_init_entry 1 38644 NULL
+dvb_dvr_do_ioctl_46839 dvb_dvr_do_ioctl 4 46839 NULL
+enable_write_30456 enable_write 3 30456 NULL
+urandom_read_30462 urandom_read 3 30462 NULL
+mmc_send_cxd_data_38655 mmc_send_cxd_data 5 38655 NULL
+module_alloc_update_bounds_rw_63233 module_alloc_update_bounds_rw 1 63233 NULL
+smctr_process_rx_packet_13270 smctr_process_rx_packet 2 13270 NULL
+do_proc_readlink_14096 do_proc_readlink 3 14096 NULL
+write_head_30481 write_head 4 30481 NULL
+adu_write_30487 adu_write 3 30487 NULL
+compat_sys_pselect6_14105 compat_sys_pselect6 1 14105 NULL
+__netdev_alloc_skb_ip_align_55067 __netdev_alloc_skb_ip_align 2 55067 NULL
+mesh_table_alloc_22305 mesh_table_alloc 1 22305 NULL
+stats_rx_handlers_queued_read_5922 stats_rx_handlers_queued_read 3 5922 NULL nohasharray
+ttm_bo_kmap_ttm_5922 ttm_bo_kmap_ttm 3 5922 &stats_rx_handlers_queued_read_5922
+iscsi_iser_recv_41948 iscsi_iser_recv 4 41948 NULL
+fcp_request_22315 fcp_request 6 22315 NULL
+udpv6_sendmsg_22316 udpv6_sendmsg 4 22316 NULL
+stats_tx_handlers_drop_unencrypted_read_46898 stats_tx_handlers_drop_unencrypted_read 3 46898 NULL
+edac_device_alloc_ctl_info_5941 edac_device_alloc_ctl_info 1 5941 NULL
+ntfs_rl_replace_14136 ntfs_rl_replace 2-4 14136 NULL
+init_kstat_irqs_18740 init_kstat_irqs 3 18740 NULL
+tcp_collapse_63294 tcp_collapse 5-6 63294 NULL
+isdn_ppp_ccp_xmit_reset_63297 isdn_ppp_ccp_xmit_reset 6 63297 NULL
+rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read_55106 rxpipe_beacon_buffer_thres_host_int_trig_rx_data_read 3 55106 NULL
+tipc_subseq_alloc_5957 tipc_subseq_alloc 1 5957 NULL
+tracing_ctrl_read_46922 tracing_ctrl_read 3 46922 NULL
+fb_write_46924 fb_write 3 46924 NULL
+dns_resolver_instantiate_63314 dns_resolver_instantiate 3 63314 NULL
+alloc_candev_22356 alloc_candev 1 22356 NULL
+btmrvl_curpsmode_read_46939 btmrvl_curpsmode_read 3 46939 NULL
+crypto_ahash_setkey_55134 crypto_ahash_setkey 3 55134 NULL
+hdlcdev_rx_997 hdlcdev_rx 3 997 NULL
+filldir_55137 filldir 3 55137 NULL
+evdev_ioctl_22371 evdev_ioctl 2 22371 NULL
+__sctp_setsockopt_connectx_46949 __sctp_setsockopt_connectx 3 46949 NULL
+do_sysctl_28306 do_sysctl 6 28306 NULL
+proc_info_read_63344 proc_info_read 3 63344 NULL
+sysctl_data_55157 sysctl_data 5 55157 NULL
+platform_device_add_resources_13289 platform_device_add_resources 3 13289 NULL
+tcp_manip_pkt_14202 tcp_manip_pkt 2 14202 NULL
+iwl_dbgfs_thermal_throttling_read_38779 iwl_dbgfs_thermal_throttling_read 3 38779 NULL
+ubifs_leb_change_22399 ubifs_leb_change 4 22399 NULL
+snd_gus_dram_write_38784 snd_gus_dram_write 4 38784 NULL
+gre_manip_pkt_38785 gre_manip_pkt 2 38785 NULL
+ps_upsd_max_sptime_read_63362 ps_upsd_max_sptime_read 3 63362 NULL
+zoran_write_22404 zoran_write 3 22404 NULL
+sctp_getsockopt_peer_addr_info_6024 sctp_getsockopt_peer_addr_info 2 6024 NULL
+xfs_dir2_block_to_sf_37868 xfs_dir2_block_to_sf 3 37868 NULL
+idmouse_read_63374 idmouse_read 3 63374 NULL
+sgl_map_user_pages_30610 sgl_map_user_pages 2 30610 NULL
+sel_write_bool_46996 sel_write_bool 3 46996 NULL
+ntfs_rl_append_6037 ntfs_rl_append 2-4 6037 NULL
+ttm_bo_io_47000 ttm_bo_io 5 47000 NULL
+sel_write_relabel_55195 sel_write_relabel 3 55195 NULL
+blk_rq_map_kern_47004 blk_rq_map_kern 4 47004 NULL
+ipv6_renew_option_38813 ipv6_renew_option 3 38813 NULL
+sched_feat_write_55202 sched_feat_write 3 55202 NULL
+dma_declare_coherent_memory_14244 dma_declare_coherent_memory 4-2 14244 NULL
+ht40allow_map_read_55209 ht40allow_map_read 3 55209 NULL nohasharray
+isdn_net_ciscohdlck_alloc_skb_55209 isdn_net_ciscohdlck_alloc_skb 2 55209 &ht40allow_map_read_55209
+compat_raw_setsockopt_30634 compat_raw_setsockopt 5 30634 NULL
+sys_select_38827 sys_select 1 38827 NULL
+rxpipe_missed_beacon_host_int_trig_rx_data_read_63405 rxpipe_missed_beacon_host_int_trig_rx_data_read 3 63405 NULL
+do_raw_setsockopt_55215 do_raw_setsockopt 5 55215 NULL
+extract_entropy_user_26952 extract_entropy_user 3 26952 NULL
+sctp_abort_pkt_new_55218 sctp_abort_pkt_new 5 55218 NULL
+fib_hash_alloc_63412 fib_hash_alloc 1 63412 NULL
+twa_change_queue_depth_30648 twa_change_queue_depth 2 30648 NULL
+handle_received_packet_22457 handle_received_packet 3 22457 NULL
+noack_read_63419 noack_read 3 63419 NULL
+mtd_do_readoob_30654 mtd_do_readoob 3 30654 NULL
+add_numbered_child_14273 add_numbered_child 5 14273 NULL
+l2cap_sock_sendmsg_63427 l2cap_sock_sendmsg 4 63427 NULL
+icmp_manip_pkt_48801 icmp_manip_pkt 2 48801 NULL
+agp_remap_30665 agp_remap 2 30665 NULL
+extend_mmcfg_14282 extend_mmcfg 1 14282 NULL
+interfaces_38859 interfaces 2 38859 NULL
+iwl_dbgfs_tx_power_read_14285 iwl_dbgfs_tx_power_read 3 14285 NULL
+memcpy_fromiovec_55247 memcpy_fromiovec 3 55247 NULL
+nfsd_symlink_63442 nfsd_symlink 6 63442 NULL
+ieee80211_if_read_dot11MeshHWMPpreqMinInterval_24208 ieee80211_if_read_dot11MeshHWMPpreqMinInterval 3 24208 NULL
+cache_write_procfs_22491 cache_write_procfs 3 22491 NULL
+read_default_ldt_14302 read_default_ldt 2 14302 NULL
+write_62671 write 3 62671 NULL
+dccp_setsockopt_ccid_30701 dccp_setsockopt_ccid 4 30701 NULL
+scsi_deactivate_tcq_47086 scsi_deactivate_tcq 2 47086 NULL nohasharray
+oti6858_buf_alloc_47086 oti6858_buf_alloc 1 47086 &scsi_deactivate_tcq_47086
+snd_info_entry_write_63474 snd_info_entry_write 3 63474 NULL
+ieee80211_if_read_capab_55294 ieee80211_if_read_capab 3 55294 NULL
+read_kcore_63488 read_kcore 3 63488 NULL
+lbs_debugfs_read_30721 lbs_debugfs_read 3 30721 NULL
+__skb_cow_39254 __skb_cow 2 39254 NULL
+strategy_allowed_congestion_control_63497 strategy_allowed_congestion_control 5 63497 NULL
+ivtv_copy_buf_to_user_6159 ivtv_copy_buf_to_user 4 6159 NULL
+pskb_may_pull_22546 pskb_may_pull 2 22546 NULL
+mousedev_read_47123 mousedev_read 3 47123 NULL
+ctrl_out_55321 ctrl_out 3 55321 NULL
+agp_alloc_page_array_22554 agp_alloc_page_array 1 22554 NULL
+vdma_mem_alloc_6171 vdma_mem_alloc 1 6171 NULL
+wl1251_cmd_template_set_6172 wl1251_cmd_template_set 4 6172 NULL
+ether1394_write_6180 ether1394_write 6 6180 NULL
+ses_recv_diag_47143 ses_recv_diag 4 47143 NULL nohasharray
+acpi_ut_initialize_buffer_47143 acpi_ut_initialize_buffer 2 47143 &ses_recv_diag_47143
+sock_rmalloc_59740 sock_rmalloc 2 59740 NULL nohasharray
+ieee80211_if_read_fwded_unicast_59740 ieee80211_if_read_fwded_unicast 3 59740 &sock_rmalloc_59740
+ubi_more_leb_change_data_63534 ubi_more_leb_change_data 4 63534 NULL
+fuse_conn_limit_write_30777 fuse_conn_limit_write 3 30777 NULL
+rs_sta_dbgfs_rate_scale_data_read_47165 rs_sta_dbgfs_rate_scale_data_read 3 47165 NULL
+append_to_buffer_63550 append_to_buffer 3 63550 NULL
+smk_write_onlycap_14400 smk_write_onlycap 3 14400 NULL
+acpi_system_read_event_55362 acpi_system_read_event 3 55362 NULL
+kvm_write_guest_page_63555 kvm_write_guest_page 5 63555 NULL
+isp1760_register_14408 isp1760_register 2-1 14408 NULL
+sd_alloc_ctl_entry_29708 sd_alloc_ctl_entry 1 29708 NULL
+OSDSetBlock_38986 OSDSetBlock 2-4 38986 NULL
+svc_pool_map_alloc_arrays_47181 svc_pool_map_alloc_arrays 2 47181 NULL
+mtd_concat_create_14416 mtd_concat_create 2 14416 NULL
+mqueue_read_file_6228 mqueue_read_file 3 6228 NULL
+ioremap_cache_47189 ioremap_cache 2-1 47189 NULL
+ubi_write_30809 ubi_write 5-4 30809 NULL
+smk_read_doi_30813 smk_read_doi 3 30813 NULL
+get_nodes_39012 get_nodes 3 39012 NULL
+module_alloc_update_bounds_47205 module_alloc_update_bounds 1 47205 NULL
+fbcon_prepare_logo_6246 fbcon_prepare_logo 5 6246 NULL
+sctp_setsockopt_connectx_old_22631 sctp_setsockopt_connectx_old 3 22631 NULL
+pwr_wake_on_timer_exp_read_22640 pwr_wake_on_timer_exp_read 3 22640 NULL
+mthca_map_reg_5664 mthca_map_reg 3-2 5664 NULL
+sctp_setsockopt_auth_chunk_30843 sctp_setsockopt_auth_chunk 3 30843 NULL
+xfs_iext_remove_39040 xfs_iext_remove 3 39040 NULL
+options_write_47243 options_write 3 47243 NULL
+module_alloc_63630 module_alloc 1 63630 NULL
+ntfs_malloc_nofs_nofail_63631 ntfs_malloc_nofs_nofail 1 63631 NULL
+proc_loginuid_write_63648 proc_loginuid_write 3 63648 NULL
+__vxge_hw_channel_allocate_55462 __vxge_hw_channel_allocate 3 55462 NULL
+store_sys_acpi_14503 store_sys_acpi 3 14503 NULL
+rtl8169_try_rx_copy_55465 rtl8169_try_rx_copy 3 55465 NULL
+hidraw_ioctl_63658 hidraw_ioctl 2 63658 NULL
+ocfs2_debug_read_14507 ocfs2_debug_read 3 14507 NULL
+tty_audit_log_47280 tty_audit_log 8 47280 NULL
+fc_host_post_vendor_event_30903 fc_host_post_vendor_event 3 30903 NULL
+rawv6_send_hdrinc_55480 rawv6_send_hdrinc 3 55480 NULL
+i2o_pool_alloc_55485 i2o_pool_alloc 4 55485 NULL
+usb_serial_multi_urb_write_22718 usb_serial_multi_urb_write 4 22718 NULL
+tx_internal_desc_overflow_read_47300 tx_internal_desc_overflow_read 3 47300 NULL
+iommu_map_mmio_space_30919 iommu_map_mmio_space 1 30919 NULL
+dataflash_read_user_otp_14536 dataflash_read_user_otp 3-2 14536 NULL nohasharray
+ep0_write_14536 ep0_write 3 14536 &dataflash_read_user_otp_14536
+ax25_output_22736 ax25_output 2 22736 NULL
+drm_vmalloc_dma_14550 drm_vmalloc_dma 1 14550 NULL
+cmtp_add_msgpart_9252 cmtp_add_msgpart 4 9252 NULL
+sctp_setsockopt_rtoinfo_30941 sctp_setsockopt_rtoinfo 3 30941 NULL
+hfcpci_empty_fifo_2427 hfcpci_empty_fifo 4 2427 NULL
+wv_packet_read_39140 wv_packet_read 3 39140 NULL
+wl1251_hw_scan_61137 wl1251_hw_scan 3 61137 NULL nohasharray
+squashfs_read_fragment_index_table_61137 squashfs_read_fragment_index_table 3 61137 &wl1251_hw_scan_61137
+_proc_do_string_6376 _proc_do_string 2 6376 NULL
+alloc_ring_39151 alloc_ring 2-4 39151 NULL
+sctp_getsockopt_assoc_number_6384 sctp_getsockopt_assoc_number 2 6384 NULL
+proc_coredump_filter_read_39153 proc_coredump_filter_read 3 39153 NULL
+nfqnl_mangle_14583 nfqnl_mangle 2 14583 NULL
+ieee80211_if_read_dot11MeshHoldingTimeout_47356 ieee80211_if_read_dot11MeshHoldingTimeout 3 47356 NULL
+idmap_pipe_downcall_14591 idmap_pipe_downcall 3 14591 NULL
+selinux_secctx_to_secid_63744 selinux_secctx_to_secid 2 63744 NULL
+sta_rx_packets_read_22788 sta_rx_packets_read 3 22788 NULL
+get_info_55681 get_info 3 55681 NULL
+mangle_sdp_packet_30986 mangle_sdp_packet 8 30986 NULL
+__bio_map_kern_47379 __bio_map_kern 2-3 47379 NULL
+ubi_more_update_data_39189 ubi_more_update_data 4 39189 NULL
+snd_pcm_oss_read1_63771 snd_pcm_oss_read1 3 63771 NULL
+xfs_trans_get_efi_7898 xfs_trans_get_efi 2 7898 NULL
+l2up_create_6430 l2up_create 3 6430 NULL
+__alloc_bootmem_node_nopanic_6432 __alloc_bootmem_node_nopanic 2 6432 NULL
+pfkey_sendmsg_47394 pfkey_sendmsg 4 47394 NULL
+ivtv_v4l2_write_39226 ivtv_v4l2_write 3 39226 NULL
+selinux_setprocattr_55611 selinux_setprocattr 4 55611 NULL
+copy_nodes_to_user_63807 copy_nodes_to_user 2 63807 NULL
+befs_utf2nls_25628 befs_utf2nls 3 25628 NULL
+read_file_rcstat_22854 read_file_rcstat 3 22854 NULL
+pktgen_if_write_55628 pktgen_if_write 3 55628 NULL
+acpi_thermal_write_cooling_mode_31053 acpi_thermal_write_cooling_mode 3 31053 NULL
+snd_opl4_mem_proc_read_63774 snd_opl4_mem_proc_read 5-6 63774 NULL
+compat_sys_mq_timedsend_31060 compat_sys_mq_timedsend 3 31060 NULL
+sel_write_load_63830 sel_write_load 3 63830 NULL
+lbs_failcount_read_31063 lbs_failcount_read 3 31063 NULL
+got_frame_16028 got_frame 2 16028 NULL
+dvb_dmxdev_set_buffer_size_55643 dvb_dmxdev_set_buffer_size 2 55643 NULL
+proc_pid_attr_write_63845 proc_pid_attr_write 3 63845 NULL
+expand_fdtable_39273 expand_fdtable 2 39273 NULL
+read_oldmem_55658 read_oldmem 3 55658 NULL
+stats_rx_expand_skb_head_read_47467 stats_rx_expand_skb_head_read 3 47467 NULL
+usblp_new_writeurb_22894 usblp_new_writeurb 2 22894 NULL
+mdc800_device_read_22896 mdc800_device_read 3 22896 NULL
+sctp_setsockopt_context_31091 sctp_setsockopt_context 3 31091 NULL
+tpm_read_50344 tpm_read 3 50344 NULL
+sfi_map_memory_5183 sfi_map_memory 2-1 5183 NULL
+newpart_47485 newpart 6 47485 NULL
+stats_rx_handlers_drop_nullfunc_read_39294 stats_rx_handlers_drop_nullfunc_read 3 39294 NULL
+dvb_dvr_ioctl_39317 dvb_dvr_ioctl 3 39317 NULL
+sg_kmalloc_50240 sg_kmalloc 1 50240 NULL
+inet_listen_14723 inet_listen 2 14723 NULL
+compat_sys_get_mempolicy_31109 compat_sys_get_mempolicy 3 31109 NULL
+core_sys_select_47494 core_sys_select 1 47494 NULL
+store_pwm1_62529 store_pwm1 4 62529 NULL
+depth_read_31112 depth_read 3 31112 NULL
+sisusb_write_mem_bulk_29678 sisusb_write_mem_bulk 4 29678 NULL
+__vmalloc_node_39308 __vmalloc_node 1 39308 NULL
+libfc_host_alloc_7917 libfc_host_alloc 2 7917 NULL
+alloc_arraycache_47505 alloc_arraycache 2 47505 NULL
+unlink_simple_47506 unlink_simple 3 47506 NULL
+rndis_set_oid_6547 rndis_set_oid 4 6547 NULL
+wdm_read_6549 wdm_read 3 6549 NULL
+fb_alloc_cmap_6554 fb_alloc_cmap 2 6554 NULL
+divas_write_63901 divas_write 3 63901 NULL
+store_camera_14751 store_camera 4 14751 NULL
+kimage_normal_alloc_31140 kimage_normal_alloc 3 31140 NULL
+w9966_v4l_read_31148 w9966_v4l_read 3 31148 NULL
+alloc_sglist_22960 alloc_sglist 1-3-2 22960 NULL
+uvc_alloc_urb_buffers_63922 uvc_alloc_urb_buffers 3-2 63922 NULL
+bt_skb_send_alloc_6581 bt_skb_send_alloc 2 6581 NULL
+__copy_from_user_nocache_39351 __copy_from_user_nocache 3 39351 NULL
+__alloc_bootmem_low_43423 __alloc_bootmem_low 1 43423 NULL
+esp_alloc_tmp_55741 esp_alloc_tmp 2 55741 NULL
+sta_dev_read_14782 sta_dev_read 3 14782 NULL
+ch_do_scsi_31171 ch_do_scsi 4 31171 NULL
+afs_send_simple_reply_63940 afs_send_simple_reply 3 63940 NULL
+cycx_setup_47562 cycx_setup 4 47562 NULL
+remote_settings_file_write_22987 remote_settings_file_write 3 22987 NULL
+mangle_packet_47567 mangle_packet 5-7 47567 NULL
+read_ldt_47570 read_ldt 2 47570 NULL
+create_attr_set_22861 create_attr_set 1 22861 NULL
+pci_iomap_47575 pci_iomap 3 47575 NULL
+acpi_ex_system_memory_space_handler_31192 acpi_ex_system_memory_space_handler 2 31192 NULL
+ecryptfs_filldir_6622 ecryptfs_filldir 3 6622 NULL
+scsi_execute_33596 scsi_execute 5 33596 NULL
+dn_alloc_skb_6631 dn_alloc_skb 2 6631 NULL
+do_tune_cpucache_14828 do_tune_cpucache 2 14828 NULL
+viafb_dvp0_proc_write_23023 viafb_dvp0_proc_write 3 23023 NULL
+atm_get_addr_31221 atm_get_addr 3 31221 NULL
+uwb_rc_neh_grok_event_55799 uwb_rc_neh_grok_event 3 55799 NULL
+intel_i810_alloc_by_type_31226 intel_i810_alloc_by_type 1 31226 NULL
+uea_request_47613 uea_request 4 47613 NULL
+cache_read_pipefs_47615 cache_read_pipefs 3 47615 NULL
+alloc_agpphysmem_i8xx_39427 alloc_agpphysmem_i8xx 1 39427 NULL
+tcp_recvmsg_31238 tcp_recvmsg 4 31238 NULL
+lcd_write_14857 lcd_write 3 14857 NULL nohasharray
+__krealloc_14857 __krealloc 2 14857 &lcd_write_14857
+get_user_cpu_mask_14861 get_user_cpu_mask 2 14861 NULL
+kmemdup_64015 kmemdup 2 64015 NULL
+sta_rx_duplicates_read_47633 sta_rx_duplicates_read 3 47633 NULL
+alloc_ringbuf_31251 alloc_ringbuf 1 31251 NULL
+reiserfs_add_entry_23062 reiserfs_add_entry 4 23062 NULL nohasharray
+unix_seqpacket_recvmsg_23062 unix_seqpacket_recvmsg 4 23062 &reiserfs_add_entry_23062
+process_rcvd_data_6679 process_rcvd_data 3 6679 NULL
+sb16_copy_from_user_55836 sb16_copy_from_user 10-7-6 55836 NULL
+frequency_read_64031 frequency_read 3 64031 NULL
+sys_semop_39457 sys_semop 3 39457 NULL
+vm_map_ram_23078 vm_map_ram 2 23078 NULL nohasharray
+raw_sendmsg_23078 raw_sendmsg 4 23078 &vm_map_ram_23078
+ether1394_data_handler_2481 ether1394_data_handler 5 2481 NULL
+sriov_enable_migration_14889 sriov_enable_migration 2 14889 NULL
+ps_pspoll_max_apturn_read_6699 ps_pspoll_max_apturn_read 3 6699 NULL
+isr_tx_procs_read_23084 isr_tx_procs_read 3 23084 NULL
+tracing_set_trace_write_57096 tracing_set_trace_write 3 57096 NULL
+setkey_unaligned_39474 setkey_unaligned 3 39474 NULL
+rt2x00debug_write_eeprom_23091 rt2x00debug_write_eeprom 3 23091 NULL
+hcd_alloc_coherent_55862 hcd_alloc_coherent 5 55862 NULL
+ntfs_ucstonls_23097 ntfs_ucstonls 3-5 23097 NULL
+sky2_receive_13407 sky2_receive 2 13407 NULL
+krealloc_14908 krealloc 2 14908 NULL
+pipe_iov_copy_from_user_23102 pipe_iov_copy_from_user 3 23102 NULL
+jffs2_user_setxattr_39488 jffs2_user_setxattr 4 39488 NULL
+stats_tx_handlers_drop_unauth_port_read_16139 stats_tx_handlers_drop_unauth_port_read 3 16139 NULL
+ip_recv_error_23109 ip_recv_error 3 23109 NULL
+uvc_simplify_fraction_31303 uvc_simplify_fraction 3 31303 NULL
+drm_mode_create_tv_properties_23122 drm_mode_create_tv_properties 2 23122 NULL
+sisusbcon_scroll_31315 sisusbcon_scroll 5-3-2 31315 NULL
+packet_recvmsg_47700 packet_recvmsg 4 47700 NULL
+command_file_write_31318 command_file_write 3 31318 NULL
+lbs_highrssi_read_64089 lbs_highrssi_read 3 64089 NULL
+unix_dgram_recvmsg_14952 unix_dgram_recvmsg 4 14952 NULL
+sfi_check_table_6772 sfi_check_table 1 6772 NULL
+bits_to_user_47733 bits_to_user 3-2 47733 NULL
+netxen_alloc_sds_rings_13417 netxen_alloc_sds_rings 2 13417 NULL
+ftrace_pid_read_14970 ftrace_pid_read 3 14970 NULL
+help_14971 help 4 14971 NULL
+iwl_dbgfs_channels_read_6784 iwl_dbgfs_channels_read 3 6784 NULL
+ieee80211_if_read_6785 ieee80211_if_read 3 6785 NULL
+pp_write_39554 pp_write 3 39554 NULL
+br_send_bpdu_29669 br_send_bpdu 3 29669 NULL
+create_reply_packet_6789 create_reply_packet 3 6789 NULL
+hdlcdrv_register_6792 hdlcdrv_register 2 6792 NULL
+usblp_write_23178 usblp_write 3 23178 NULL
+setkey_14987 setkey 3 14987 NULL
+xprt_rdma_allocate_31372 xprt_rdma_allocate 2 31372 NULL
+gss_pipe_downcall_23182 gss_pipe_downcall 3 23182 NULL
+handle_response_55951 handle_response 5 55951 NULL
+ieee80211_if_read_fwded_mcast_39571 ieee80211_if_read_fwded_mcast 3 39571 NULL
+fix_unclean_leb_23188 fix_unclean_leb 3 23188 NULL
+simple_read_from_buffer_55957 simple_read_from_buffer 2-5 55957 NULL
+handle_response_icmp_39574 handle_response_icmp 7 39574 NULL
+acpi_processor_write_limit_23201 acpi_processor_write_limit 3 23201 NULL
+rvmalloc_46873 rvmalloc 1 46873 NULL
+cistpl_vers_1_15023 cistpl_vers_1 4 15023 NULL
+vmap_15025 vmap 2 15025 NULL
+key_ifindex_read_31411 key_ifindex_read 3 31411 NULL
+mcs7830_set_reg_31413 mcs7830_set_reg 3 31413 NULL
+mon_bin_read_6841 mon_bin_read 3 6841 NULL
+tty_buffer_request_room_23228 tty_buffer_request_room 2 23228 NULL
+xlog_get_bp_23229 xlog_get_bp 2 23229 NULL
+__kmalloc_23231 __kmalloc 1 23231 NULL
+rxrpc_client_sendmsg_23236 rxrpc_client_sendmsg 5 23236 NULL
+ubi_leb_write_41691 ubi_leb_write 5-4 41691 NULL
+store_lslvl_15059 store_lslvl 4 15059 NULL
+ssb_bus_pcmciabus_register_56020 ssb_bus_pcmciabus_register 3 56020 NULL
+smk_read_ambient_61220 smk_read_ambient 3 61220 NULL
+ntfs_copy_from_user_15072 ntfs_copy_from_user 3-5 15072 NULL
+pppoe_recvmsg_15073 pppoe_recvmsg 4 15073 NULL
+find_rsb_39650 find_rsb 3 39650 NULL
+snd_rme32_capture_copy_39653 snd_rme32_capture_copy 5 39653 NULL
+dm_write_2513 dm_write 3 2513 NULL
+raw_seticmpfilter_6888 raw_seticmpfilter 3 6888 NULL
+prism2_info_hostscanresults_39657 prism2_info_hostscanresults 3 39657 NULL
+dlmfs_file_write_6892 dlmfs_file_write 3 6892 NULL
+ubifs_write_node_15088 ubifs_write_node 5-3 15088 NULL
+stv680_read_31473 stv680_read 3 31473 NULL
+tipc_cltr_prepare_routing_msg_56052 tipc_cltr_prepare_routing_msg 1 56052 NULL
+doc_probe_23285 doc_probe 1 23285 NULL
+v4l_stk_read_39672 v4l_stk_read 3 39672 NULL
+dccp_sendmsg_56058 dccp_sendmsg 4 56058 NULL
+proc_sessionid_read_6911 proc_sessionid_read 3 6911 NULL
+ieee80211_rx_mgmt_probe_resp_6918 ieee80211_rx_mgmt_probe_resp 3 6918 NULL
+__alloc_bootmem_31498 __alloc_bootmem 1 31498 NULL
+i2cdev_write_23310 i2cdev_write 3 23310 NULL
+dma_region_alloc_56079 dma_region_alloc 2 56079 NULL
+nl_pid_hash_zalloc_23314 nl_pid_hash_zalloc 1 23314 NULL
+ftrace_pid_write_39710 ftrace_pid_write 3 39710 NULL
+event_id_read_64288 event_id_read 3 64288 NULL nohasharray
+xfs_dir_cilookup_result_64288 xfs_dir_cilookup_result 3 64288 &event_id_read_64288
+nfs_flush_one_23329 nfs_flush_one 3 23329 NULL
+store_gps_42118 store_gps 4 42118 NULL
+timeout_read_47915 timeout_read 3 47915 NULL
+hpsb_iso_recv_init_31535 hpsb_iso_recv_init 3 31535 NULL
+hidraw_write_31536 hidraw_write 3 31536 NULL
+page_readlink_23346 page_readlink 3 23346 NULL
+videobuf_dma_init_kernel_6963 videobuf_dma_init_kernel 3 6963 NULL
+sta_tx_filtered_read_6973 sta_tx_filtered_read 3 6973 NULL
+stats_tx_handlers_drop_wep_read_47944 stats_tx_handlers_drop_wep_read 3 47944 NULL
+sisusbcon_clear_64329 sisusbcon_clear 3-5-4 64329 NULL
+tcp_write_xmit_39755 tcp_write_xmit 2 39755 NULL
+request_key_async_6990 request_key_async 4 6990 NULL
+dccp_setsockopt_service_65336 dccp_setsockopt_service 4 65336 NULL
+dabusb_writemem_39764 dabusb_writemem 4 39764 NULL
+do_write_orph_node_64343 do_write_orph_node 2 64343 NULL
+iscsi_create_endpoint_15193 iscsi_create_endpoint 1 15193 NULL
+osst_write_31581 osst_write 3 31581 NULL
+tracing_cpumask_read_7010 tracing_cpumask_read 3 7010 NULL
+rawv6_setsockopt_56165 rawv6_setsockopt 5 56165 NULL
+diva_xdi_write_63975 diva_xdi_write 4 63975 NULL
+llc_alloc_frame_64366 llc_alloc_frame 4 64366 NULL
+mempool_resize_47983 mempool_resize 2 47983 NULL
+hid_report_raw_event_7024 hid_report_raw_event 4 7024 NULL
+ieee80211_if_read_max_ratectrl_rateidx_64369 ieee80211_if_read_max_ratectrl_rateidx 3 64369 NULL
+ib_umad_write_47993 ib_umad_write 3 47993 NULL
+ilo_write_64378 ilo_write 3 64378 NULL
+iscsi_host_alloc_36671 iscsi_host_alloc 2 36671 NULL
+ipath_get_base_info_7043 ipath_get_base_info 3 7043 NULL
+__fc_frame_alloc_23432 __fc_frame_alloc 1 23432 NULL
+acpi_fan_write_state_39818 acpi_fan_write_state 3 39818 NULL
+sys_migrate_pages_39825 sys_migrate_pages 2 39825 NULL
+pidlist_allocate_64404 pidlist_allocate 1 64404 NULL
+cache_read_procfs_52882 cache_read_procfs 3 52882 NULL
+rx_hdr_overflow_read_64407 rx_hdr_overflow_read 3 64407 NULL
+beiscsi_process_async_pdu_39834 beiscsi_process_async_pdu 7 39834 NULL
+drm_alloc_agp_48031 drm_alloc_agp 2 48031 NULL
+hci_sock_recvmsg_7072 hci_sock_recvmsg 4 7072 NULL
+snd_card_create_64418 snd_card_create 4 64418 NULL nohasharray
+keyctl_get_security_64418 keyctl_get_security 3 64418 &snd_card_create_64418
+cp210x_get_config_56229 cp210x_get_config 4 56229 NULL
+spi_dv_device_echo_buffer_39846 spi_dv_device_echo_buffer 2-3 39846 NULL
+pppoe_sendmsg_48039 pppoe_sendmsg 4 48039 NULL
+zd_ioread16v_locked_7082 zd_ioread16v_locked 4 7082 NULL
+dn_nsp_send_disc_23469 dn_nsp_send_disc 2 23469 NULL
+do_ipt_set_ctl_56238 do_ipt_set_ctl 4 56238 NULL
+store_status_7088 store_status 2 7088 NULL
+__lgread_31668 __lgread 4 31668 NULL
+fd_copyin_56247 fd_copyin 3 56247 NULL
+wpan_phy_alloc_48056 wpan_phy_alloc 1 48056 NULL
+ax25_recvmsg_64441 ax25_recvmsg 4 64441 NULL
+sys_connect_15291 sys_connect 3 15291 NULL nohasharray
+xlate_dev_mem_ptr_15291 xlate_dev_mem_ptr 1 15291 &sys_connect_15291
+linear_conf_23485 linear_conf 2 23485 NULL nohasharray
+divasa_remap_pci_bar_23485 divasa_remap_pci_bar 3-4 23485 &linear_conf_23485
+posix_acl_alloc_48063 posix_acl_alloc 1 48063 NULL
+event_filter_read_23494 event_filter_read 3 23494 NULL
+tpm_tis_init_15304 tpm_tis_init 3-2 15304 NULL
+msnd_fifo_alloc_23179 msnd_fifo_alloc 2 23179 NULL
+sys_setsockopt_35320 sys_setsockopt 5 35320 NULL
+pkt_add_39897 pkt_add 3 39897 NULL
+write_led_23517 write_led 2 23517 NULL
+ip_vs_create_timeout_table_64478 ip_vs_create_timeout_table 2 64478 NULL
+send_mpa_reject_7135 send_mpa_reject 3 7135 NULL
+mmc_alloc_host_48097 mmc_alloc_host 1 48097 NULL
+skb_copy_datagram_const_iovec_48102 skb_copy_datagram_const_iovec 2-5-4 48102 NULL
+dvb_aplay_56296 dvb_aplay 3 56296 NULL
+alloc_large_system_hash_64490 alloc_large_system_hash 2 64490 NULL
+sctp_make_asconf_ack_31726 sctp_make_asconf_ack 3 31726 NULL
+aes_encrypt_interrupt_read_39919 aes_encrypt_interrupt_read 3 39919 NULL
+ima_show_measurements_count_23536 ima_show_measurements_count 3 23536 NULL
+snd_hdspm_capture_copy_48113 snd_hdspm_capture_copy 5 48113 NULL
+squashfs_read_inode_lookup_table_7160 squashfs_read_inode_lookup_table 3 7160 NULL
+get_arg_5694 get_arg 3 5694 NULL
+acpi_ut_create_string_object_15360 acpi_ut_create_string_object 1 15360 NULL
+slow_kernel_write_15362 slow_kernel_write 6 15362 NULL
+snd_seq_device_new_31753 snd_seq_device_new 4 31753 NULL
+journal_init_revoke_table_56331 journal_init_revoke_table 1 56331 NULL
+ses_send_diag_64527 ses_send_diag 4 64527 NULL
+tcp_match_skb_to_sack_23568 tcp_match_skb_to_sack 3-4 23568 NULL
+snd_rawmidi_read_56337 snd_rawmidi_read 3 56337 NULL
+venus_symlink_23570 venus_symlink 4-6 23570 NULL
+tty_prepare_flip_string_39955 tty_prepare_flip_string 3 39955 NULL
+__tcp_push_pending_frames_48148 __tcp_push_pending_frames 2 48148 NULL
+iwl_dbgfs_interrupt_read_23574 iwl_dbgfs_interrupt_read 3 23574 NULL
+ipv6_recv_error_56347 ipv6_recv_error 3 56347 NULL
+vxge_os_dma_malloc_async_56348 vxge_os_dma_malloc_async 3 56348 NULL
+isr_dma1_done_read_48159 isr_dma1_done_read 3 48159 NULL
+strip_change_mtu_33968 strip_change_mtu 2 33968 NULL
+cifs_spnego_key_instantiate_23588 cifs_spnego_key_instantiate 3 23588 NULL
+tracing_clock_read_39975 tracing_clock_read 3 39975 NULL
+broadsheetfb_write_39976 broadsheetfb_write 3 39976 NULL
+sctp_datamsg_from_user_55342 sctp_datamsg_from_user 4 55342 NULL
+iov_iter_copy_from_user_atomic_56368 iov_iter_copy_from_user_atomic 4 56368 NULL
+dev_read_56369 dev_read 3 56369 NULL
+mthca_array_init_39987 mthca_array_init 2 39987 NULL
+diva_os_alloc_message_buffer_64568 diva_os_alloc_message_buffer 1 64568 NULL
+ecryptfs_send_message_locked_31801 ecryptfs_send_message_locked 2 31801 NULL
+islpci_mgt_transaction_23610 islpci_mgt_transaction 5 23610 NULL
+isr_rx_procs_read_31804 isr_rx_procs_read 3 31804 NULL
+node_write_29878 node_write 4 29878 NULL
+sys32_ipc_7238 sys32_ipc 3 7238 NULL
+sta_last_signal_read_31818 sta_last_signal_read 3 31818 NULL
+iwl_dbgfs_ucode_tx_stats_read_31611 iwl_dbgfs_ucode_tx_stats_read 3 31611 NULL
+dvb_ca_en50221_io_write_43533 dvb_ca_en50221_io_write 3 43533 NULL
+ocfs2_control_read_56405 ocfs2_control_read 3 56405 NULL
+ivtvfb_write_40023 ivtvfb_write 3 40023 NULL
+use_pool_64607 use_pool 2 64607 NULL
+__get_vm_area_caller_56416 __get_vm_area_caller 1 56416 NULL nohasharray
+acpi_os_write_memory_56416 acpi_os_write_memory 3-1 56416 &__get_vm_area_caller_56416
+store_msg_56417 store_msg 3 56417 NULL
+__i2400mu_send_barker_23652 __i2400mu_send_barker 3 23652 NULL
+dvb_demux_ioctl_65382 dvb_demux_ioctl 3 65382 NULL
+vmalloc_15464 vmalloc 1 15464 NULL
+r128_compat_ioctl_39250 r128_compat_ioctl 2 39250 NULL
+stats_failed_count_read_9244 stats_failed_count_read 3 9244 NULL
+nfsctl_transaction_read_48250 nfsctl_transaction_read 3 48250 NULL
+stats_rx_handlers_drop_defrag_read_56448 stats_rx_handlers_drop_defrag_read 3 56448 NULL
+cx231xx_init_isoc_56453 cx231xx_init_isoc 2-3 56453 NULL
+xfs_dir2_sf_addname_hard_54254 xfs_dir2_sf_addname_hard 3 54254 NULL
+cache_write_pipefs_48270 cache_write_pipefs 3 48270 NULL
+osd_req_list_partition_objects_56464 osd_req_list_partition_objects 5 56464 NULL
+usbvideo_v4l_read_48274 usbvideo_v4l_read 3 48274 NULL
+cx18_read_23699 cx18_read 3 23699 NULL
+add_partition_15515 add_partition 2 15515 NULL
+pkt_bio_alloc_48284 pkt_bio_alloc 1 48284 NULL
+mtd_read_48289 mtd_read 3 48289 NULL
+sock_alloc_send_skb_23720 sock_alloc_send_skb 2 23720 NULL
+osst_execute_17607 osst_execute 7-6 17607 NULL
+kmem_alloc_31920 kmem_alloc 1 31920 NULL
+sctp_setsockopt_delayed_ack_40129 sctp_setsockopt_delayed_ack 3 40129 NULL
+cfg80211_connect_result_56515 cfg80211_connect_result 4-6 56515 NULL
+iov_iter_copy_from_user_31942 iov_iter_copy_from_user 4 31942 NULL nohasharray
+read_mem_31942 read_mem 3 31942 &iov_iter_copy_from_user_31942
+__feat_register_sp_64712 __feat_register_sp 6 64712 NULL
+pwr_elp_enter_read_5324 pwr_elp_enter_read 3 5324 NULL
+proc_self_readlink_38094 proc_self_readlink 3 38094 NULL
+store_ledd_43312 store_ledd 4 43312 NULL
+iwch_alloc_fastreg_pbl_40153 iwch_alloc_fastreg_pbl 2 40153 NULL
+ip_options_get_56538 ip_options_get 4 56538 NULL
+ep0_read_38095 ep0_read 3 38095 NULL
+sctp_getsockopt_sctp_status_56540 sctp_getsockopt_sctp_status 2 56540 NULL
+vstusb_read_23774 vstusb_read 3 23774 NULL
+pt_write_40159 pt_write 3 40159 NULL
+capinc_tty_write_28539 capinc_tty_write 3 28539 NULL
+sl_change_mtu_7396 sl_change_mtu 2 7396 NULL
+allocate_cnodes_5329 allocate_cnodes 1 5329 NULL
+skb_add_data_48363 skb_add_data 3 48363 NULL
+bio_map_kern_64751 bio_map_kern 3 64751 NULL
+rt2x00debug_write_csr_64753 rt2x00debug_write_csr 3 64753 NULL
+mlx4_en_create_tx_ring_64756 mlx4_en_create_tx_ring 3 64756 NULL
+map_addr_48373 map_addr 5 48373 NULL
+drm_property_create_blob_7414 drm_property_create_blob 2 7414 NULL
+rx_path_reset_read_23801 rx_path_reset_read 3 23801 NULL
+rs_sta_dbgfs_stats_table_read_56573 rs_sta_dbgfs_stats_table_read 3 56573 NULL
+compat_fillonedir_15620 compat_fillonedir 3 15620 NULL
+ipr_alloc_ucode_buffer_40199 ipr_alloc_ucode_buffer 1 40199 NULL
+proc_write_node_15624 proc_write_node 3 15624 NULL
+acpi_os_allocate_14892 acpi_os_allocate 1 14892 NULL
+system_enable_read_25815 system_enable_read 3 25815 NULL
+allocate_probes_40204 allocate_probes 1 40204 NULL
+proc_loginuid_read_15631 proc_loginuid_read 3 15631 NULL
+__earlyonly_bootmem_alloc_23824 __earlyonly_bootmem_alloc 2 23824 NULL
+acpi_battery_write_alarm_1240 acpi_battery_write_alarm 3 1240 NULL
+isr_low_rssi_read_64789 isr_low_rssi_read 3 64789 NULL
+ip_options_get_alloc_7448 ip_options_get_alloc 1 7448 NULL
+joydev_handle_JSIOCSBTNMAP_15643 joydev_handle_JSIOCSBTNMAP 3 15643 NULL
+lbs_debugfs_write_48413 lbs_debugfs_write 3 48413 NULL
+nfsctl_transaction_write_64800 nfsctl_transaction_write 3 64800 NULL
+event_filter_write_56609 event_filter_write 3 56609 NULL
+sctp_manip_pkt_40620 sctp_manip_pkt 2 40620 NULL
+iwl_dbgfs_nvm_read_23845 iwl_dbgfs_nvm_read 3 23845 NULL
+compat_sys_fcntl_15654 compat_sys_fcntl 3 15654 NULL
+pwr_tx_without_ps_read_48423 pwr_tx_without_ps_read 3 48423 NULL
+rfkill_fop_write_64808 rfkill_fop_write 3 64808 NULL
+p54_init_common_23850 p54_init_common 1 23850 NULL
+osst_read_40237 osst_read 3 40237 NULL
+sys_sched_setaffinity_32046 sys_sched_setaffinity 2 32046 NULL
+garp_request_join_7471 garp_request_join 4 7471 NULL
+ecryptfs_send_miscdev_64816 ecryptfs_send_miscdev 2 64816 NULL
+ubi_leb_change_14899 ubi_leb_change 4 14899 NULL
+unix_bind_15668 unix_bind 3 15668 NULL
+dm_read_15674 dm_read 3 15674 NULL
+do_kimage_alloc_64827 do_kimage_alloc 3 64827 NULL
+proc_scsi_devinfo_write_32064 proc_scsi_devinfo_write 3 32064 NULL
+xip_file_read_58592 xip_file_read 3 58592 NULL
+evdev_do_ioctl_24459 evdev_do_ioctl 2 24459 NULL
+rs_sta_dbgfs_scale_table_read_40262 rs_sta_dbgfs_scale_table_read 3 40262 NULL
+reqsk_queue_alloc_40272 reqsk_queue_alloc 2 40272 NULL
+sdhci_alloc_host_7509 sdhci_alloc_host 2 7509 NULL
+dlm_dir_lookup_56662 dlm_dir_lookup 4 56662 NULL
+rx_xfr_hint_trig_read_40283 rx_xfr_hint_trig_read 3 40283 NULL
+iwch_reject_cr_23901 iwch_reject_cr 3 23901 NULL
+ip6_ufo_append_data_40301 ip6_ufo_append_data 5-7-6 40301 NULL
+snd_gus_dram_read_56686 snd_gus_dram_read 4 56686 NULL
+ubi_io_write_data_40305 ubi_io_write_data 5 40305 NULL
+send_control_msg_48498 send_control_msg 6 48498 NULL
+alloc_etherdev_mq_56698 alloc_etherdev_mq 1-2 56698 NULL
+diva_os_copy_to_user_48508 diva_os_copy_to_user 4 48508 NULL
+dvb_ringbuffer_read_user_56702 dvb_ringbuffer_read_user 3 56702 NULL
+dgram_recvmsg_23104 dgram_recvmsg 4 23104 NULL
+__alloc_skb_23940 __alloc_skb 1 23940 NULL
+sta_flags_read_56710 sta_flags_read 3 56710 NULL
+ipv6_getsockopt_sticky_56711 ipv6_getsockopt_sticky 5 56711 NULL
+HiSax_readstatus_15752 HiSax_readstatus 2 15752 NULL
+sg_proc_write_dressz_46316 sg_proc_write_dressz 3 46316 NULL
+alloc_tx_32143 alloc_tx 2 32143 NULL
+compat_do_arpt_set_ctl_12184 compat_do_arpt_set_ctl 4 12184 NULL
+ieee80211_if_read_force_unicast_rateidx_32147 ieee80211_if_read_force_unicast_rateidx 3 32147 NULL
+__wa_xfer_setup_segs_56725 __wa_xfer_setup_segs 2 56725 NULL
+do_test_15766 do_test 1 15766 NULL
+mmio_read_40348 mmio_read 4 40348 NULL
+v9fs_file_read_40858 v9fs_file_read 3 40858 NULL
+sta_wep_weak_iv_count_read_64069 sta_wep_weak_iv_count_read 3 64069 NULL
+nfsd_write_54809 nfsd_write 6 54809 NULL
+venus_link_32165 venus_link 5 32165 NULL
+event_rx_mem_empty_read_40363 event_rx_mem_empty_read 3 40363 NULL
+drm_agp_bind_pages_56748 drm_agp_bind_pages 3 56748 NULL
+ntfs_rl_realloc_nofail_32173 ntfs_rl_realloc_nofail 3 32173 NULL
+ubifs_wbuf_write_nolock_64946 ubifs_wbuf_write_nolock 3 64946 NULL
+smk_read_direct_15803 smk_read_direct 3 15803 NULL
+fwnet_incoming_packet_40380 fwnet_incoming_packet 3 40380 NULL
+ip_options_get_from_user_64958 ip_options_get_from_user 4 64958 NULL
+wusb_ccm_mac_32199 wusb_ccm_mac 7 32199 NULL
+csr1212_append_new_cache_32202 csr1212_append_new_cache 2 32202 NULL
+afs_proc_rootcell_write_15822 afs_proc_rootcell_write 3 15822 NULL
+cciss_allocate_sg_chain_blocks_5368 cciss_allocate_sg_chain_blocks 3-2 5368 NULL
+oprofilefs_ulong_from_user_57251 oprofilefs_ulong_from_user 3 57251 NULL
+iscsi_create_conn_50425 iscsi_create_conn 2 50425 NULL
+alloc_netdev_mq_24028 alloc_netdev_mq 1-4 24028 NULL
+event_enable_read_7074 event_enable_read 3 7074 NULL
+xlog_recover_add_to_trans_48614 xlog_recover_add_to_trans 3 48614 NULL
+pskb_pull_65005 pskb_pull 2 65005 NULL
+lbs_lowrssi_read_32242 lbs_lowrssi_read 3 32242 NULL
+agp_generic_alloc_user_9470 agp_generic_alloc_user 1 9470 NULL
+ubi_io_write_15870 ubi_io_write 5 15870 NULL
+ntfs_rl_realloc_56831 ntfs_rl_realloc 3 56831 NULL
+do_ip_vs_set_ctl_48641 do_ip_vs_set_ctl 4 48641 NULL
+__mptctl_ioctl_15875 __mptctl_ioctl 2 15875 NULL
+proc_write_ledd_48644 proc_write_ledd 3 48644 NULL
+sl_realloc_bufs_64086 sl_realloc_bufs 2 64086 NULL
+insert_dent_65034 insert_dent 7 65034 NULL
+blkcipher_copy_iv_24075 blkcipher_copy_iv 3 24075 NULL
+acpi_os_allocate_zeroed_37422 acpi_os_allocate_zeroed 1 37422 NULL
+snd_rawmidi_kernel_write1_56847 snd_rawmidi_kernel_write1 4 56847 NULL
+stats_multicast_received_frame_count_read_24083 stats_multicast_received_frame_count_read 3 24083 NULL
+l2cap_create_iframe_pdu_51801 l2cap_create_iframe_pdu 3 51801 NULL
+aes_encrypt_packets_read_48666 aes_encrypt_packets_read 3 48666 NULL
+sm501_create_subdev_48668 sm501_create_subdev 3-4 48668 NULL nohasharray
+sys_setgroups_48668 sys_setgroups 1 48668 &sm501_create_subdev_48668
+l3_alloc_skb_32289 l3_alloc_skb 1 32289 NULL
+l2cap_build_cmd_48676 l2cap_build_cmd 4 48676 NULL
+request_key_auth_read_24109 request_key_auth_read 3 24109 NULL
+sbp2util_notify_fetch_agent_40494 sbp2util_notify_fetch_agent 4 40494 NULL
+efivar_create_sysfs_entry_56882 efivar_create_sysfs_entry 1 56882 NULL
+vmalloc_user_32308 vmalloc_user 1 32308 NULL
+hysdn_log_write_48694 hysdn_log_write 3 48694 NULL
+manip_pkt_7741 manip_pkt 3 7741 NULL
+recv_msg_48709 recv_msg 4 48709 NULL
+vxge_device_register_7752 vxge_device_register 4 7752 NULL
+irnet_ctrl_write_24139 irnet_ctrl_write 3 24139 NULL
+revalidate_19043 revalidate 2 19043 NULL
+remap_pci_mem_15966 remap_pci_mem 1-2 15966 NULL
+ima_write_policy_40548 ima_write_policy 3 40548 NULL
+journal_init_revoke_56933 journal_init_revoke 2 56933 NULL
+sel_read_initcon_32362 sel_read_initcon 3 32362 NULL
+dlm_allocate_rsb_56941 dlm_allocate_rsb 2 56941 NULL
+bnx2_nvram_write_7790 bnx2_nvram_write 4-2 7790 NULL
+diva_os_copy_from_user_7792 diva_os_copy_from_user 4 7792 NULL
+adu_read_24177 adu_read 3 24177 NULL
+send_mpa_reply_32372 send_mpa_reply 3 32372 NULL
+usbtmc_read_32377 usbtmc_read 3 32377 NULL
+get_entry_16003 get_entry 4 16003 NULL nohasharray
+alloc_vm_area_16003 alloc_vm_area 1 16003 &get_entry_16003
+event_buffer_read_48772 event_buffer_read 3 48772 NULL
+xfs_iext_add_indirect_multi_32400 xfs_iext_add_indirect_multi 3 32400 NULL
+viafb_vt1636_proc_write_16018 viafb_vt1636_proc_write 3 16018 NULL
+dlm_user_request_8131 dlm_user_request 6 8131 NULL
+skge_rx_get_40598 skge_rx_get 3 40598 NULL
+debug_buffer_read_24220 debug_buffer_read 3 24220 NULL
+ssb_bus_register_65183 ssb_bus_register 3 65183 NULL
+snd_pcm_aio_read_13900 snd_pcm_aio_read 3 13900 NULL
+cypress_buf_alloc_32417 cypress_buf_alloc 1 32417 NULL
+waiters_read_40902 waiters_read 3 40902 NULL
+vlsi_alloc_ring_57003 vlsi_alloc_ring 3-4 57003 NULL
+sel_read_bool_24236 sel_read_bool 3 24236 NULL
+tcp_push_one_48816 tcp_push_one 2 48816 NULL
+drm_ioctl_65206 drm_ioctl 3 65206 NULL
+nfulnl_alloc_skb_65207 nfulnl_alloc_skb 2 65207 NULL
+dccp_recvmsg_16056 dccp_recvmsg 4 16056 NULL
+atomic_counters_read_48827 atomic_counters_read 3 48827 NULL
+vc_do_resize_48842 vc_do_resize 3-4 48842 NULL
+acpi_tb_parse_root_table_53455 acpi_tb_parse_root_table 1 53455 NULL
+dvb_dmxdev_read_sec_7892 dvb_dmxdev_read_sec 4 7892 NULL
+snd_nm256_capture_copy_28622 snd_nm256_capture_copy 5 28622 NULL
+kfifo_alloc_65242 kfifo_alloc 1 65242 NULL
+viafb_dvp1_proc_write_48864 viafb_dvp1_proc_write 3 48864 NULL
+iso_alloc_urb_57061 iso_alloc_urb 4 57061 NULL
+isr_tx_exch_complete_read_16103 isr_tx_exch_complete_read 3 16103 NULL
+pcmcia_replace_cis_57066 pcmcia_replace_cis 3 57066 NULL
+ide_driver_proc_write_32493 ide_driver_proc_write 3 32493 NULL
+dma_tx_requested_read_16110 dma_tx_requested_read 3 16110 NULL nohasharray
+isr_hw_pm_mode_changes_read_16110 isr_hw_pm_mode_changes_read 3 16110 &dma_tx_requested_read_16110
+dvb_ca_en50221_io_ioctl_16113 dvb_ca_en50221_io_ioctl 3 16113 NULL
+sys_setgroups16_48882 sys_setgroups16 1 48882 NULL
+btmrvl_pscmd_read_24308 btmrvl_pscmd_read 3 24308 NULL
+system_enable_write_61396 system_enable_write 3 61396 NULL
+raw_send_hdrinc_7937 raw_send_hdrinc 3 7937 NULL
+mac_drv_rx_init_48898 mac_drv_rx_init 2 48898 NULL nohasharray
+joydev_handle_JSIOCSAXMAP_48898 joydev_handle_JSIOCSAXMAP 3 48898 &mac_drv_rx_init_48898
+sisusbcon_scroll_area_25899 sisusbcon_scroll_area 3-4 25899 NULL
+xdi_copy_to_user_48900 xdi_copy_to_user 4 48900 NULL
+compat_core_sys_select_65285 compat_core_sys_select 1 65285 NULL
+fsm_init_16134 fsm_init 2 16134 NULL
+hysdn_rx_netpkt_16136 hysdn_rx_netpkt 3 16136 NULL
+__seq_open_private_40715 __seq_open_private 3 40715 NULL
+redirected_tty_write_65297 redirected_tty_write 3 65297 NULL
+ilo_read_32531 ilo_read 3 32531 NULL
+ieee80211_if_read_estab_plinks_32533 ieee80211_if_read_estab_plinks 3 32533 NULL
+ioremap_23172 ioremap 2-1 23172 NULL
+sysfs_write_file_57116 sysfs_write_file 3 57116 NULL
+csr1212_new_descriptor_leaf_57117 csr1212_new_descriptor_leaf 4 57117 NULL
+jffs2_trusted_setxattr_65310 jffs2_trusted_setxattr 4 65310 NULL
+kzalloc_node_24352 kzalloc_node 1 24352 NULL
+trace_options_write_48275 trace_options_write 3 48275 NULL
+format_devstat_counter_32550 format_devstat_counter 3 32550 NULL
+xfs_iext_remove_direct_40744 xfs_iext_remove_direct 3 40744 NULL
+cfi_read_pri_24366 cfi_read_pri 3 24366 NULL
+ima_show_htable_value_57136 ima_show_htable_value 2 57136 NULL
+aes_encrypt_fail_read_32562 aes_encrypt_fail_read 3 32562 NULL
+sys_mbind_7990 sys_mbind 5 7990 NULL
+proc_write_disp_16184 proc_write_disp 3 16184 NULL
+pg_write_40766 pg_write 3 40766 NULL
+event_heart_beat_read_48961 event_heart_beat_read 3 48961 NULL
+uea_idma_write_64139 uea_idma_write 3 64139 NULL
+ecryptfs_readlink_40775 ecryptfs_readlink 3 40775 NULL
+dma_rx_requested_read_65354 dma_rx_requested_read 3 65354 NULL
+getxattr_24398 getxattr 4 24398 NULL
+stk_prepare_sio_buffers_57168 stk_prepare_sio_buffers 2 57168 NULL
+vcs_read_8017 vcs_read 3 8017 NULL
+read_file_beacon_32595 read_file_beacon 3 32595 NULL
+create_table_16213 create_table 2 16213 NULL
+rx_hw_stuck_read_57179 rx_hw_stuck_read 3 57179 NULL
+_alloc_set_attr_list_48991 _alloc_set_attr_list 4 48991 NULL
+sys_set_mempolicy_32608 sys_set_mempolicy 3 32608 NULL
+atomic_read_file_16227 atomic_read_file 3 16227 NULL
+sel_write_enforce_48998 sel_write_enforce 3 48998 NULL
+b43_debugfs_read_24425 b43_debugfs_read 3 24425 NULL
+netdev_alloc_skb_ip_align_40811 netdev_alloc_skb_ip_align 2 40811 NULL
+ieee80211_rx_mgmt_beacon_24430 ieee80211_rx_mgmt_beacon 3 24430 NULL
+trace_parser_get_init_31379 trace_parser_get_init 2 31379 NULL
+__alloc_bootmem_nopanic_65397 __alloc_bootmem_nopanic 1 65397 NULL
+trace_seq_to_user_65398 trace_seq_to_user 3 65398 NULL
+irda_recvmsg_dgram_32631 irda_recvmsg_dgram 4 32631 NULL
+rcname_read_25919 rcname_read 3 25919 NULL
+skb_copy_to_page_8071 skb_copy_to_page 6 8071 NULL
+alloc_targets_8074 alloc_targets 2 8074 NULL
+tifm_alloc_adapter_10903 tifm_alloc_adapter 1 10903 NULL
+drm_calloc_large_65421 drm_calloc_large 1-2 65421 NULL
+generic_readlink_32654 generic_readlink 3 32654 NULL
+skb_copy_and_csum_datagram_iovec_24466 skb_copy_and_csum_datagram_iovec 2 24466 NULL
+ttm_bo_ioremap_40854 ttm_bo_ioremap 4-3-2 40854 NULL
+xpc_kzalloc_cacheline_aligned_65433 xpc_kzalloc_cacheline_aligned 1 65433 NULL
+drm_fb_helper_init_crtc_count_32666 drm_fb_helper_init_crtc_count 2-3 32666 NULL
+fbcon_do_set_font_4079 fbcon_do_set_font 2-3 4079 NULL
+move_addr_to_kernel_32673 move_addr_to_kernel 2 32673 NULL
+stk_allocate_buffers_16291 stk_allocate_buffers 2 16291 NULL
+__cxio_init_resource_fifo_16295 __cxio_init_resource_fifo 3 16295 NULL
+hid_input_report_32458 hid_input_report 4 32458 NULL
+rsc_mgr_init_16299 rsc_mgr_init 3 16299 NULL
+venus_lookup_8121 venus_lookup 4 8121 NULL
+ccid3_hc_tx_getsockopt_16314 ccid3_hc_tx_getsockopt 3 16314 NULL
+dmam_declare_coherent_memory_43679 dmam_declare_coherent_memory 4-2 43679 NULL
+io_mapping_create_wc_1354 io_mapping_create_wc 1-2 1354 NULL
+read_buf_20469 read_buf 2 20469 NULL
+request_key_with_auxdata_24515 request_key_with_auxdata 4 24515 NULL
+scsi_register_49094 scsi_register 2 49094 NULL
+isdn_add_channels_40905 isdn_add_channels 3 40905 NULL
+compat_do_readv_writev_49102 compat_do_readv_writev 4 49102 NULL
+vol_cdev_write_40915 vol_cdev_write 3 40915 NULL
+named_prepare_buf_24532 named_prepare_buf 2 24532 NULL
+hdpvr_read_9273 hdpvr_read 3 9273 NULL
+alloc_dr_65495 alloc_dr 2 65495 NULL
+intel_i830_alloc_by_type_40921 intel_i830_alloc_by_type 1 40921 NULL
+ftdi_elan_write_57309 ftdi_elan_write 3 57309 NULL
+total_ps_buffered_read_16365 total_ps_buffered_read 3 16365 NULL
+stats_read_ul_32751 stats_read_ul 3 32751 NULL
+pt_read_49136 pt_read 3 49136 NULL
+snd_vx_create_40948 snd_vx_create 4 40948 NULL
+dbg_leb_write_20478 dbg_leb_write 5-4 20478 NULL
+iscsi_tcp_conn_setup_16376 iscsi_tcp_conn_setup 2 16376 NULL
+tracing_ctrl_write_42324 tracing_ctrl_write 3 42324 NULL nohasharray
+hysdn_conf_read_42324 hysdn_conf_read 3 42324 &tracing_ctrl_write_42324
+check_mirror_57342 check_mirror 2-1 57342 NULL nohasharray
+usblp_read_57342 usblp_read 3 57342 &check_mirror_57342
+atyfb_setup_generic_49151 atyfb_setup_generic 3 49151 NULL
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/size_overflow_plugin.c linux-2.6.32.60-pax/tools/gcc/size_overflow_plugin.c
--- linux-2.6.32.60/tools/gcc/size_overflow_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/size_overflow_plugin.c	2013-02-17 17:20:34.396154305 +0100
@@ -0,0 +1,1941 @@
+/*
+ * Copyright 2011, 2012 by Emese Revfy <re.emese@gmail.com>
+ * Licensed under the GPL v2, or (at your option) v3
+ *
+ * Homepage:
+ * http://www.grsecurity.net/~ephox/overflow_plugin/
+ *
+ * This plugin recomputes expressions of function arguments marked by a size_overflow attribute
+ * with double integer precision (DImode/TImode for 32/64 bit integer types).
+ * The recomputed argument is checked against TYPE_MAX and an event is logged on overflow and the triggering process is killed.
+ *
+ * Usage:
+ * $ gcc -I`gcc -print-file-name=plugin`/include/c-family -I`gcc -print-file-name=plugin`/include -fPIC -shared -O2 -ggdb -Wall -W -Wno-missing-field-initializers -o size_overflow_plugin.so size_overflow_plugin.c
+ * $ gcc -fplugin=size_overflow_plugin.so test.c  -O2
+ */
+
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "intl.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "toplev.h"
+#include "function.h"
+#include "tree-flow.h"
+#include "plugin.h"
+#include "gimple.h"
+#include "c-common.h"
+#include "diagnostic.h"
+#include "cfgloop.h"
+
+#if BUILDING_GCC_VERSION >= 4007
+#include "c-tree.h"
+#else
+#define C_DECL_IMPLICIT(EXP) DECL_LANG_FLAG_2 (EXP)
+#endif
+
+#if BUILDING_GCC_VERSION >= 4008
+#define TODO_dump_func 0
+#endif
+
+struct size_overflow_hash {
+	const struct size_overflow_hash * const next;
+	const char * const name;
+	const unsigned int param;
+};
+
+#include "size_overflow_hash.h"
+
+enum marked {
+	MARKED_NO, MARKED_YES, MARKED_NOT_INTENTIONAL
+};
+
+static unsigned int call_count = 0;
+
+#define __unused __attribute__((__unused__))
+#define NAME(node) IDENTIFIER_POINTER(DECL_NAME(node))
+#define NAME_LEN(node) IDENTIFIER_LENGTH(DECL_NAME(node))
+#define BEFORE_STMT true
+#define AFTER_STMT false
+#define CREATE_NEW_VAR NULL_TREE
+#define CODES_LIMIT 32
+#define MAX_PARAM 32
+#define MY_STMT GF_PLF_1
+#define NO_CAST_CHECK GF_PLF_2
+
+#if BUILDING_GCC_VERSION == 4005
+#define DECL_CHAIN(NODE) (TREE_CHAIN(DECL_MINIMAL_CHECK(NODE)))
+#endif
+
+int plugin_is_GPL_compatible;
+void debug_gimple_stmt(gimple gs);
+
+static tree expand(struct pointer_set_t *visited, tree lhs);
+static bool pre_expand(struct pointer_set_t *visited, const_tree lhs);
+static tree report_size_overflow_decl;
+static const_tree const_char_ptr_type_node;
+static unsigned int handle_function(void);
+static void check_size_overflow(gimple stmt, tree size_overflow_type, tree cast_rhs, tree rhs, bool before);
+static tree get_size_overflow_type(gimple stmt, const_tree node);
+static tree dup_assign(struct pointer_set_t *visited, gimple oldstmt, const_tree node, tree rhs1, tree rhs2, tree __unused rhs3);
+
+static struct plugin_info size_overflow_plugin_info = {
+	.version	= "20130109beta",
+	.help		= "no-size-overflow\tturn off size overflow checking\n",
+};
+
+static tree handle_size_overflow_attribute(tree *node, tree __unused name, tree args, int __unused flags, bool *no_add_attrs)
+{
+	unsigned int arg_count;
+	enum tree_code code = TREE_CODE(*node);
+
+	switch (code) {
+	case FUNCTION_DECL:
+		arg_count = type_num_arguments(TREE_TYPE(*node));
+		break;
+	case FUNCTION_TYPE:
+	case METHOD_TYPE:
+		arg_count = type_num_arguments(*node);
+		break;
+	default:
+		*no_add_attrs = true;
+		error("%s: %qE attribute only applies to functions", __func__, name);
+		return NULL_TREE;
+	}
+
+	for (; args; args = TREE_CHAIN(args)) {
+		tree position = TREE_VALUE(args);
+		if (TREE_CODE(position) != INTEGER_CST || TREE_INT_CST_HIGH(position) || TREE_INT_CST_LOW(position) < 1 || TREE_INT_CST_LOW(position) > arg_count ) {
+			error("%s: parameter %u is outside range.", __func__, (unsigned int)TREE_INT_CST_LOW(position));
+			*no_add_attrs = true;
+		}
+	}
+	return NULL_TREE;
+}
+
+static const char* get_asm_name(tree node)
+{
+	return IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(node));
+}
+
+static tree handle_intentional_overflow_attribute(tree *node, tree __unused name, tree args, int __unused flags, bool *no_add_attrs)
+{
+	unsigned int arg_count, arg_num;
+	enum tree_code code = TREE_CODE(*node);
+
+	switch (code) {
+	case FUNCTION_DECL:
+		arg_count = type_num_arguments(TREE_TYPE(*node));
+		break;
+	case FUNCTION_TYPE:
+	case METHOD_TYPE:
+		arg_count = type_num_arguments(*node);
+		break;
+	case FIELD_DECL:
+		arg_num = TREE_INT_CST_LOW(TREE_VALUE(args));
+		if (arg_num != 0) {
+			*no_add_attrs = true;
+			error("%s: %qE attribute parameter can only be 0 in structure fields", __func__, name);
+		}
+		return NULL_TREE;
+	default:
+		*no_add_attrs = true;
+		error("%qE attribute only applies to functions", name);
+		return NULL_TREE;
+	}
+
+	for (; args; args = TREE_CHAIN(args)) {
+		tree position = TREE_VALUE(args);
+		if (TREE_CODE(position) != INTEGER_CST || TREE_INT_CST_HIGH(position) || TREE_INT_CST_LOW(position) > arg_count ) {
+			error("%s: parameter %u is outside range.", __func__, (unsigned int)TREE_INT_CST_LOW(position));
+			*no_add_attrs = true;
+		}
+	}
+	return NULL_TREE;
+}
+
+static struct attribute_spec size_overflow_attr = {
+	.name				= "size_overflow",
+	.min_length			= 1,
+	.max_length			= -1,
+	.decl_required			= true,
+	.type_required			= false,
+	.function_type_required		= false,
+	.handler			= handle_size_overflow_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity		= false
+#endif
+};
+
+static struct attribute_spec intentional_overflow_attr = {
+	.name				= "intentional_overflow",
+	.min_length			= 1,
+	.max_length			= -1,
+	.decl_required			= true,
+	.type_required			= false,
+	.function_type_required		= false,
+	.handler			= handle_intentional_overflow_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity		= false
+#endif
+};
+
+static void register_attributes(void __unused *event_data, void __unused *data)
+{
+	register_attribute(&size_overflow_attr);
+	register_attribute(&intentional_overflow_attr);
+}
+
+// http://www.team5150.com/~andrew/noncryptohashzoo2~/CrapWow.html
+static unsigned int CrapWow(const char *key, unsigned int len, unsigned int seed)
+{
+#define cwfold( a, b, lo, hi ) { p = (unsigned int)(a) * (unsigned long long)(b); lo ^= (unsigned int)p; hi ^= (unsigned int)(p >> 32); }
+#define cwmixa( in ) { cwfold( in, m, k, h ); }
+#define cwmixb( in ) { cwfold( in, n, h, k ); }
+
+	unsigned int m = 0x57559429;
+	unsigned int n = 0x5052acdb;
+	const unsigned int *key4 = (const unsigned int *)key;
+	unsigned int h = len;
+	unsigned int k = len + seed + n;
+	unsigned long long p;
+
+	while (len >= 8) {
+		cwmixb(key4[0]) cwmixa(key4[1]) key4 += 2;
+		len -= 8;
+	}
+	if (len >= 4) {
+		cwmixb(key4[0]) key4 += 1;
+		len -= 4;
+	}
+	if (len)
+		cwmixa(key4[0] & ((1 << (len * 8)) - 1 ));
+	cwmixb(h ^ (k + n));
+	return k ^ h;
+
+#undef cwfold
+#undef cwmixa
+#undef cwmixb
+}
+
+static inline unsigned int get_hash_num(const char *fndecl, const char *tree_codes, unsigned int len, unsigned int seed)
+{
+	unsigned int fn = CrapWow(fndecl, strlen(fndecl), seed) & 0xffff;
+	unsigned int codes = CrapWow(tree_codes, len, seed) & 0xffff;
+	return fn ^ codes;
+}
+
+static inline tree get_original_function_decl(tree fndecl)
+{
+	if (DECL_ABSTRACT_ORIGIN(fndecl))
+		return DECL_ABSTRACT_ORIGIN(fndecl);
+	return fndecl;
+}
+
+static inline gimple get_def_stmt(const_tree node)
+{
+	gcc_assert(node != NULL_TREE);
+	gcc_assert(TREE_CODE(node) == SSA_NAME);
+	return SSA_NAME_DEF_STMT(node);
+}
+
+static unsigned char get_tree_code(const_tree type)
+{
+	switch (TREE_CODE(type)) {
+	case ARRAY_TYPE:
+		return 0;
+	case BOOLEAN_TYPE:
+		return 1;
+	case ENUMERAL_TYPE:
+		return 2;
+	case FUNCTION_TYPE:
+		return 3;
+	case INTEGER_TYPE:
+		return 4;
+	case POINTER_TYPE:
+		return 5;
+	case RECORD_TYPE:
+		return 6;
+	case UNION_TYPE:
+		return 7;
+	case VOID_TYPE:
+		return 8;
+	case REAL_TYPE:
+		return 9;
+	case VECTOR_TYPE:
+		return 10;
+	case REFERENCE_TYPE:
+		return 11;
+	case OFFSET_TYPE:
+		return 12;
+	case COMPLEX_TYPE:
+		return 13;
+	default:
+		debug_tree((tree)type);
+		gcc_unreachable();
+	}
+}
+
+static size_t add_type_codes(const_tree type, unsigned char *tree_codes, size_t len)
+{
+	gcc_assert(type != NULL_TREE);
+
+	while (type && len < CODES_LIMIT) {
+		tree_codes[len] = get_tree_code(type);
+		len++;
+		type = TREE_TYPE(type);
+	}
+	return len;
+}
+
+static unsigned int get_function_decl(const_tree fndecl, unsigned char *tree_codes)
+{
+	const_tree arg, result, arg_field, type = TREE_TYPE(fndecl);
+	enum tree_code code = TREE_CODE(type);
+	size_t len = 0;
+
+	gcc_assert(code == FUNCTION_TYPE || code == METHOD_TYPE);
+
+	arg = TYPE_ARG_TYPES(type);
+	// skip builtins __builtin_constant_p
+	if (!arg && DECL_BUILT_IN(fndecl))
+		return 0;
+
+	if (TREE_CODE_CLASS(code) == tcc_type)
+		result = type;
+	else
+		result = DECL_RESULT(fndecl);
+
+	gcc_assert(result != NULL_TREE);
+	len = add_type_codes(TREE_TYPE(result), tree_codes, len);
+
+	if (arg == NULL_TREE) {
+		gcc_assert(CODE_CONTAINS_STRUCT(TREE_CODE(fndecl), TS_DECL_NON_COMMON));
+		arg_field = DECL_ARGUMENT_FLD(fndecl);
+		if (arg_field == NULL_TREE)
+			return 0;
+		arg = TREE_TYPE(arg_field);
+		len = add_type_codes(arg, tree_codes, len);
+		gcc_assert(len != 0);
+		return len;
+	}
+
+	gcc_assert(arg != NULL_TREE && TREE_CODE(arg) == TREE_LIST);
+	while (arg && len < CODES_LIMIT) {
+		len = add_type_codes(TREE_VALUE(arg), tree_codes, len);
+		arg = TREE_CHAIN(arg);
+	}
+
+	gcc_assert(len != 0);
+	return len;
+}
+
+static const struct size_overflow_hash *get_function_hash(tree fndecl)
+{
+	unsigned int hash;
+	const struct size_overflow_hash *entry;
+	unsigned char tree_codes[CODES_LIMIT];
+	size_t len;
+	const char *func_name = get_asm_name(fndecl);
+
+	len = get_function_decl(fndecl, tree_codes);
+	if (len == 0)
+		return NULL;
+
+	hash = get_hash_num(func_name, (const char*) tree_codes, len, 0);
+
+	entry = size_overflow_hash[hash];
+	while (entry) {
+		if (!strcmp(entry->name, func_name))
+			return entry;
+		entry = entry->next;
+	}
+
+	return NULL;
+}
+
+static void check_arg_type(const_tree arg)
+{
+	const_tree type = TREE_TYPE(arg);
+	enum tree_code code = TREE_CODE(type);
+
+	if (code == BOOLEAN_TYPE)
+		return;
+
+	gcc_assert(code == INTEGER_TYPE || code == ENUMERAL_TYPE ||
+		  (code == POINTER_TYPE && TREE_CODE(TREE_TYPE(type)) == VOID_TYPE) ||
+		  (code == POINTER_TYPE && TREE_CODE(TREE_TYPE(type)) == INTEGER_TYPE));
+}
+
+static unsigned int find_arg_number(const_tree arg, tree func)
+{
+	tree var;
+	unsigned int argnum = 1;
+
+	if (TREE_CODE(arg) == SSA_NAME)
+		arg = SSA_NAME_VAR(arg);
+
+	for (var = DECL_ARGUMENTS(func); var; var = TREE_CHAIN(var)) {
+		if (strcmp(NAME(arg), NAME(var))) {
+			argnum++;
+			continue;
+		}
+		check_arg_type(var);
+		return argnum;
+	}
+	gcc_unreachable();
+}
+
+static tree create_new_var(tree type)
+{
+	tree new_var = create_tmp_var(type, "cicus");
+
+#if BUILDING_GCC_VERSION <= 4007
+	add_referenced_var(new_var);
+	mark_sym_for_renaming(new_var);
+#endif
+	return new_var;
+}
+
+static gimple create_binary_assign(enum tree_code code, gimple stmt, tree rhs1, tree rhs2)
+{
+	gimple assign;
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+	tree type = TREE_TYPE(rhs1);
+	tree lhs = create_new_var(type);
+
+	gcc_assert(types_compatible_p(type, TREE_TYPE(rhs2)));
+	assign = gimple_build_assign_with_ops(code, lhs, rhs1, rhs2);
+	gimple_set_lhs(assign, make_ssa_name(lhs, assign));
+
+	gsi_insert_before(&gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+	gimple_set_plf(assign, MY_STMT, true);
+	return assign;
+}
+
+static bool is_bool(const_tree node)
+{
+	const_tree type;
+
+	if (node == NULL_TREE)
+		return false;
+
+	type = TREE_TYPE(node);
+	if (!INTEGRAL_TYPE_P(type))
+		return false;
+	if (TREE_CODE(type) == BOOLEAN_TYPE)
+		return true;
+	if (TYPE_PRECISION(type) == 1)
+		return true;
+	return false;
+}
+
+static tree cast_a_tree(tree type, tree var)
+{
+	gcc_assert(type != NULL_TREE);
+	gcc_assert(var != NULL_TREE);
+	gcc_assert(fold_convertible_p(type, var));
+
+	return fold_convert(type, var);
+}
+
+static gimple build_cast_stmt(tree dst_type, tree rhs, tree lhs, gimple_stmt_iterator *gsi, bool before)
+{
+	gimple assign;
+
+	gcc_assert(dst_type != NULL_TREE && rhs != NULL_TREE);
+	if (gsi_end_p(*gsi) && before == AFTER_STMT)
+		gcc_unreachable();
+
+	if (lhs == CREATE_NEW_VAR)
+		lhs = create_new_var(dst_type);
+
+	assign = gimple_build_assign(lhs, cast_a_tree(dst_type, rhs));
+
+	if (!gsi_end_p(*gsi)) {
+		location_t loc = gimple_location(gsi_stmt(*gsi));
+		gimple_set_location(assign, loc);
+	}
+
+	gimple_set_lhs(assign, make_ssa_name(lhs, assign));
+
+	if (before)
+		gsi_insert_before(gsi, assign, GSI_NEW_STMT);
+	else
+		gsi_insert_after(gsi, assign, GSI_NEW_STMT);
+	update_stmt(assign);
+	gimple_set_plf(assign, MY_STMT, true);
+
+	return assign;
+}
+
+static tree cast_to_new_size_overflow_type(gimple stmt, tree rhs, tree size_overflow_type, bool before)
+{
+	gimple assign;
+	gimple_stmt_iterator gsi;
+
+	if (rhs == NULL_TREE)
+		return NULL_TREE;
+
+	if (types_compatible_p(TREE_TYPE(rhs), size_overflow_type) && gimple_plf(stmt, MY_STMT))
+		return rhs;
+
+	gsi = gsi_for_stmt(stmt);
+	assign = build_cast_stmt(size_overflow_type, rhs, CREATE_NEW_VAR, &gsi, before);
+	gimple_set_plf(assign, MY_STMT, true);
+	return gimple_get_lhs(assign);
+}
+
+static tree cast_to_TI_type(gimple stmt, tree node)
+{
+	gimple_stmt_iterator gsi;
+	gimple cast_stmt;
+	tree type = TREE_TYPE(node);
+
+	if (types_compatible_p(type, intTI_type_node))
+		return node;
+
+	gsi = gsi_for_stmt(stmt);
+	cast_stmt = build_cast_stmt(intTI_type_node, node, CREATE_NEW_VAR, &gsi, BEFORE_STMT);
+	gimple_set_plf(cast_stmt, MY_STMT, true);
+	return gimple_get_lhs(cast_stmt);
+}
+
+static tree create_assign(struct pointer_set_t *visited, gimple oldstmt, tree rhs1, bool before)
+{
+	tree lhs;
+	gimple_stmt_iterator gsi;
+
+	if (rhs1 == NULL_TREE) {
+		debug_gimple_stmt(oldstmt);
+		error("%s: rhs1 is NULL_TREE", __func__);
+		gcc_unreachable();
+	}
+
+	switch (gimple_code(oldstmt)) {
+	case GIMPLE_ASM:
+		lhs = rhs1;
+		break;
+	case GIMPLE_CALL:
+		lhs = gimple_call_lhs(oldstmt);
+		break;
+	case GIMPLE_ASSIGN:
+		lhs = gimple_get_lhs(oldstmt);
+		break;
+	default:
+		debug_gimple_stmt(oldstmt);
+		gcc_unreachable();
+	}
+
+	gsi = gsi_for_stmt(oldstmt);
+	pointer_set_insert(visited, oldstmt);
+	if (lookup_stmt_eh_lp(oldstmt) != 0) {
+		basic_block next_bb, cur_bb;
+		const_edge e;
+
+		gcc_assert(before == false);
+		gcc_assert(stmt_can_throw_internal(oldstmt));
+		gcc_assert(gimple_code(oldstmt) == GIMPLE_CALL);
+		gcc_assert(!gsi_end_p(gsi));
+
+		cur_bb = gimple_bb(oldstmt);
+		next_bb = cur_bb->next_bb;
+		e = find_edge(cur_bb, next_bb);
+		gcc_assert(e != NULL);
+		gcc_assert(e->flags & EDGE_FALLTHRU);
+
+		gsi = gsi_after_labels(next_bb);
+		gcc_assert(!gsi_end_p(gsi));
+
+		before = true;
+		oldstmt = gsi_stmt(gsi);
+	}
+
+	return cast_to_new_size_overflow_type(oldstmt, rhs1, get_size_overflow_type(oldstmt, lhs), before);
+}
+
+static tree dup_assign(struct pointer_set_t *visited, gimple oldstmt, const_tree node, tree rhs1, tree rhs2, tree __unused rhs3)
+{
+	gimple stmt;
+	gimple_stmt_iterator gsi;
+	tree size_overflow_type, new_var, lhs = gimple_get_lhs(oldstmt);
+
+	if (gimple_plf(oldstmt, MY_STMT))
+		return lhs;
+
+	if (gimple_num_ops(oldstmt) != 4 && rhs1 == NULL_TREE) {
+		rhs1 = gimple_assign_rhs1(oldstmt);
+		rhs1 = create_assign(visited, oldstmt, rhs1, BEFORE_STMT);
+	}
+	if (gimple_num_ops(oldstmt) == 3 && rhs2 == NULL_TREE) {
+		rhs2 = gimple_assign_rhs2(oldstmt);
+		rhs2 = create_assign(visited, oldstmt, rhs2, BEFORE_STMT);
+	}
+
+	stmt = gimple_copy(oldstmt);
+	gimple_set_location(stmt, gimple_location(oldstmt));
+	gimple_set_plf(stmt, MY_STMT, true);
+
+	if (gimple_assign_rhs_code(oldstmt) == WIDEN_MULT_EXPR)
+		gimple_assign_set_rhs_code(stmt, MULT_EXPR);
+
+	size_overflow_type = get_size_overflow_type(oldstmt, node);
+
+	if (is_bool(lhs))
+		new_var = SSA_NAME_VAR(lhs);
+	else
+		new_var = create_new_var(size_overflow_type);
+	new_var = make_ssa_name(new_var, stmt);
+	gimple_set_lhs(stmt, new_var);
+
+	if (rhs1 != NULL_TREE)
+		gimple_assign_set_rhs1(stmt, rhs1);
+
+	if (rhs2 != NULL_TREE)
+		gimple_assign_set_rhs2(stmt, rhs2);
+#if BUILDING_GCC_VERSION >= 4007
+	if (rhs3 != NULL_TREE)
+		gimple_assign_set_rhs3(stmt, rhs3);
+#endif
+	gimple_set_vuse(stmt, gimple_vuse(oldstmt));
+	gimple_set_vdef(stmt, gimple_vdef(oldstmt));
+
+	gsi = gsi_for_stmt(oldstmt);
+	gsi_insert_after(&gsi, stmt, GSI_SAME_STMT);
+	update_stmt(stmt);
+	pointer_set_insert(visited, oldstmt);
+	return gimple_get_lhs(stmt);
+}
+
+static gimple overflow_create_phi_node(gimple oldstmt, tree result)
+{
+	basic_block bb;
+	gimple phi;
+	gimple_stmt_iterator gsi = gsi_for_stmt(oldstmt);
+	gimple_seq seq;
+
+	bb = gsi_bb(gsi);
+
+	phi = create_phi_node(result, bb);
+	seq = phi_nodes(bb);
+	gsi = gsi_last(seq);
+	gsi_remove(&gsi, false);
+
+	gsi = gsi_for_stmt(oldstmt);
+	gsi_insert_after(&gsi, phi, GSI_NEW_STMT);
+	gimple_set_bb(phi, bb);
+	gimple_set_plf(phi, MY_STMT, true);
+	return phi;
+}
+
+static basic_block create_a_first_bb(void)
+{
+	basic_block first_bb;
+
+	first_bb = split_block_after_labels(ENTRY_BLOCK_PTR)->dest;
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, first_bb, ENTRY_BLOCK_PTR);
+	return first_bb;
+}
+
+static tree cast_old_phi_arg(gimple oldstmt, tree size_overflow_type, tree arg, tree new_var, unsigned int i)
+{
+	basic_block bb;
+	const_gimple newstmt;
+	gimple_stmt_iterator gsi;
+	bool before = BEFORE_STMT;
+
+	if (TREE_CODE(arg) == SSA_NAME && gimple_code(get_def_stmt(arg)) != GIMPLE_NOP) {
+		gsi = gsi_for_stmt(get_def_stmt(arg));
+		newstmt = build_cast_stmt(size_overflow_type, arg, new_var, &gsi, AFTER_STMT);
+		return gimple_get_lhs(newstmt);
+	}
+
+	bb = gimple_phi_arg_edge(oldstmt, i)->src;
+	gsi = gsi_after_labels(bb);
+	if (bb->index == 0) {
+		bb = create_a_first_bb();
+		gsi = gsi_start_bb(bb);
+	}
+	newstmt = build_cast_stmt(size_overflow_type, arg, new_var, &gsi, before);
+	return gimple_get_lhs(newstmt);
+}
+
+static const_gimple handle_new_phi_arg(const_tree arg, tree new_var, tree new_rhs)
+{
+	gimple newstmt;
+	gimple_stmt_iterator gsi;
+	void (*gsi_insert)(gimple_stmt_iterator *, gimple, enum gsi_iterator_update);
+	gimple def_newstmt = get_def_stmt(new_rhs);
+
+	gsi_insert = gsi_insert_after;
+	gsi = gsi_for_stmt(def_newstmt);
+
+	switch (gimple_code(get_def_stmt(arg))) {
+	case GIMPLE_PHI:
+		newstmt = gimple_build_assign(new_var, new_rhs);
+		gsi = gsi_after_labels(gimple_bb(def_newstmt));
+		gsi_insert = gsi_insert_before;
+		break;
+	case GIMPLE_ASM:
+	case GIMPLE_CALL:
+		newstmt = gimple_build_assign(new_var, new_rhs);
+		break;
+	case GIMPLE_ASSIGN:
+		newstmt = gimple_build_assign(new_var, gimple_get_lhs(def_newstmt));
+		break;
+	default:
+		/* unknown gimple_code (handle_build_new_phi_arg) */
+		gcc_unreachable();
+	}
+
+	gimple_set_lhs(newstmt, make_ssa_name(new_var, newstmt));
+	gsi_insert(&gsi, newstmt, GSI_NEW_STMT);
+	gimple_set_plf(newstmt, MY_STMT, true);
+	update_stmt(newstmt);
+	return newstmt;
+}
+
+static tree build_new_phi_arg(struct pointer_set_t *visited, tree size_overflow_type, tree arg, tree new_var)
+{
+	const_gimple newstmt;
+	gimple def_stmt;
+	tree new_rhs;
+
+	new_rhs = expand(visited, arg);
+	if (new_rhs == NULL_TREE)
+		return NULL_TREE;
+
+	def_stmt = get_def_stmt(new_rhs);
+	if (gimple_code(def_stmt) == GIMPLE_NOP)
+		return NULL_TREE;
+	new_rhs = cast_to_new_size_overflow_type(def_stmt, new_rhs, size_overflow_type, AFTER_STMT);
+
+	newstmt = handle_new_phi_arg(arg, new_var, new_rhs);
+	return gimple_get_lhs(newstmt);
+}
+
+static tree build_new_phi(struct pointer_set_t *visited, tree orig_result)
+{
+	gimple phi, oldstmt = get_def_stmt(orig_result);
+	tree new_result, size_overflow_type;
+	unsigned int i;
+	unsigned int n = gimple_phi_num_args(oldstmt);
+
+	size_overflow_type = get_size_overflow_type(oldstmt, orig_result);
+
+	new_result = create_new_var(size_overflow_type);
+
+	pointer_set_insert(visited, oldstmt);
+	phi = overflow_create_phi_node(oldstmt, new_result);
+	for (i = 0; i < n; i++) {
+		tree arg, lhs;
+
+		arg = gimple_phi_arg_def(oldstmt, i);
+		if (is_gimple_constant(arg))
+			arg = cast_a_tree(size_overflow_type, arg);
+		lhs = build_new_phi_arg(visited, size_overflow_type, arg, new_result);
+		if (lhs == NULL_TREE)
+			lhs = cast_old_phi_arg(oldstmt, size_overflow_type, arg, new_result, i);
+		add_phi_arg(phi, lhs, gimple_phi_arg_edge(oldstmt, i), gimple_location(oldstmt));
+	}
+
+	update_stmt(phi);
+	return gimple_phi_result(phi);
+}
+
+static tree change_assign_rhs(gimple stmt, const_tree orig_rhs, tree new_rhs)
+{
+	const_gimple assign;
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+	tree origtype = TREE_TYPE(orig_rhs);
+
+	gcc_assert(gimple_code(stmt) == GIMPLE_ASSIGN);
+
+	assign = build_cast_stmt(origtype, new_rhs, CREATE_NEW_VAR, &gsi, BEFORE_STMT);
+	return gimple_get_lhs(assign);
+}
+
+static void change_rhs1(gimple stmt, tree new_rhs1)
+{
+	tree assign_rhs;
+	const_tree rhs = gimple_assign_rhs1(stmt);
+
+	assign_rhs = change_assign_rhs(stmt, rhs, new_rhs1);
+	gimple_assign_set_rhs1(stmt, assign_rhs);
+	update_stmt(stmt);
+}
+
+static bool check_mode_type(const_gimple stmt)
+{
+	const_tree lhs = gimple_get_lhs(stmt);
+	const_tree lhs_type = TREE_TYPE(lhs);
+	const_tree rhs_type = TREE_TYPE(gimple_assign_rhs1(stmt));
+	enum machine_mode lhs_mode = TYPE_MODE(lhs_type);
+	enum machine_mode rhs_mode = TYPE_MODE(rhs_type);
+
+	if (rhs_mode == lhs_mode && TYPE_UNSIGNED(rhs_type) == TYPE_UNSIGNED(lhs_type))
+		return false;
+
+	if (rhs_mode == SImode && lhs_mode == DImode && (TYPE_UNSIGNED(rhs_type) || !TYPE_UNSIGNED(lhs_type)))
+		return false;
+
+	// skip lhs check on signed SI -> HI cast or signed SI -> QI cast
+	if (rhs_mode == SImode && !TYPE_UNSIGNED(rhs_type) && (lhs_mode == HImode || lhs_mode == QImode))
+		return false;
+
+	return true;
+}
+
+static bool check_undefined_integer_operation(const_gimple stmt)
+{
+	const_gimple def_stmt;
+	const_tree lhs = gimple_get_lhs(stmt);
+	const_tree rhs1 = gimple_assign_rhs1(stmt);
+	const_tree rhs1_type = TREE_TYPE(rhs1);
+	const_tree lhs_type = TREE_TYPE(lhs);
+
+	if (TYPE_MODE(rhs1_type) != TYPE_MODE(lhs_type) || TYPE_UNSIGNED(rhs1_type) == TYPE_UNSIGNED(lhs_type))
+		return false;
+
+	def_stmt = get_def_stmt(rhs1);
+	if (gimple_code(def_stmt) != GIMPLE_ASSIGN)
+		return false;
+
+	if (gimple_assign_rhs_code(def_stmt) != MINUS_EXPR)
+		return false;
+	return true;
+}
+
+static bool is_a_cast_and_const_overflow(const_tree no_const_rhs)
+{
+	const_tree rhs1, lhs, rhs1_type, lhs_type;
+	enum machine_mode lhs_mode, rhs_mode;
+	gimple def_stmt = get_def_stmt(no_const_rhs);
+
+	if (!gimple_assign_cast_p(def_stmt))
+		return false;
+
+	rhs1 = gimple_assign_rhs1(def_stmt);
+	lhs = gimple_get_lhs(def_stmt);
+	rhs1_type = TREE_TYPE(rhs1);
+	lhs_type = TREE_TYPE(lhs);
+	rhs_mode = TYPE_MODE(rhs1_type);
+	lhs_mode = TYPE_MODE(lhs_type);
+	if (TYPE_UNSIGNED(lhs_type) == TYPE_UNSIGNED(rhs1_type) || lhs_mode != rhs_mode)
+		return false;
+
+	return true;
+}
+
+static tree create_cast_assign(struct pointer_set_t *visited, gimple stmt)
+{
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree lhs = gimple_get_lhs(stmt);
+	const_tree rhs1_type = TREE_TYPE(rhs1);
+	const_tree lhs_type = TREE_TYPE(lhs);
+
+	if (TYPE_UNSIGNED(rhs1_type) == TYPE_UNSIGNED(lhs_type))
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+
+	return create_assign(visited, stmt, rhs1, AFTER_STMT);
+}
+
+static tree handle_unary_rhs(struct pointer_set_t *visited, gimple stmt)
+{
+	tree size_overflow_type, lhs = gimple_get_lhs(stmt);
+	tree new_rhs1 = NULL_TREE;
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	const_tree rhs1_type = TREE_TYPE(rhs1);
+	const_tree lhs_type = TREE_TYPE(lhs);
+
+	if (gimple_plf(stmt, MY_STMT))
+		return lhs;
+
+	if (TREE_CODE(rhs1_type) == POINTER_TYPE)
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+
+	new_rhs1 = expand(visited, rhs1);
+
+	if (new_rhs1 == NULL_TREE)
+		return create_cast_assign(visited, stmt);
+
+	if (gimple_plf(stmt, NO_CAST_CHECK))
+		return dup_assign(visited, stmt, lhs, new_rhs1, NULL_TREE, NULL_TREE);
+
+	if (gimple_assign_rhs_code(stmt) == BIT_NOT_EXPR) {
+		size_overflow_type = get_size_overflow_type(stmt, rhs1);
+		new_rhs1 = cast_to_new_size_overflow_type(stmt, new_rhs1, size_overflow_type, BEFORE_STMT);
+		check_size_overflow(stmt, size_overflow_type, new_rhs1, rhs1, BEFORE_STMT);
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+	}
+
+	if (!gimple_assign_cast_p(stmt) || check_undefined_integer_operation(stmt))
+		return dup_assign(visited, stmt, lhs, new_rhs1, NULL_TREE, NULL_TREE);
+
+	if (TYPE_UNSIGNED(rhs1_type) != TYPE_UNSIGNED(lhs_type))
+		return dup_assign(visited, stmt, lhs, new_rhs1, NULL_TREE, NULL_TREE);
+
+	size_overflow_type = get_size_overflow_type(stmt, rhs1);
+	new_rhs1 = cast_to_new_size_overflow_type(stmt, new_rhs1, size_overflow_type, BEFORE_STMT);
+
+	check_size_overflow(stmt, size_overflow_type, new_rhs1, rhs1, BEFORE_STMT);
+
+	change_rhs1(stmt, new_rhs1);
+
+	if (!check_mode_type(stmt))
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+
+	size_overflow_type = get_size_overflow_type(stmt, lhs);
+	new_rhs1 = cast_to_new_size_overflow_type(stmt, new_rhs1, size_overflow_type, BEFORE_STMT);
+
+	check_size_overflow(stmt, size_overflow_type, new_rhs1, lhs, BEFORE_STMT);
+
+	return create_assign(visited, stmt, lhs, AFTER_STMT);
+}
+
+static tree handle_unary_ops(struct pointer_set_t *visited, gimple stmt)
+{
+	tree rhs1, lhs = gimple_get_lhs(stmt);
+	gimple def_stmt = get_def_stmt(lhs);
+
+	gcc_assert(gimple_code(def_stmt) != GIMPLE_NOP);
+	rhs1 = gimple_assign_rhs1(def_stmt);
+
+	if (is_gimple_constant(rhs1))
+		return create_assign(visited, def_stmt, lhs, AFTER_STMT);
+
+	gcc_assert(TREE_CODE(rhs1) != COND_EXPR);
+	switch (TREE_CODE(rhs1)) {
+	case SSA_NAME:
+		return handle_unary_rhs(visited, def_stmt);
+	case ARRAY_REF:
+	case BIT_FIELD_REF:
+	case ADDR_EXPR:
+	case COMPONENT_REF:
+	case INDIRECT_REF:
+#if BUILDING_GCC_VERSION >= 4006
+	case MEM_REF:
+#endif
+	case TARGET_MEM_REF:
+		return create_assign(visited, def_stmt, lhs, AFTER_STMT);
+	case PARM_DECL:
+	case VAR_DECL:
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+
+	default:
+		debug_gimple_stmt(def_stmt);
+		debug_tree(rhs1);
+		gcc_unreachable();
+	}
+}
+
+static void insert_cond(basic_block cond_bb, tree arg, enum tree_code cond_code, tree type_value)
+{
+	gimple cond_stmt;
+	gimple_stmt_iterator gsi = gsi_last_bb(cond_bb);
+
+	cond_stmt = gimple_build_cond(cond_code, arg, type_value, NULL_TREE, NULL_TREE);
+	gsi_insert_after(&gsi, cond_stmt, GSI_CONTINUE_LINKING);
+	update_stmt(cond_stmt);
+}
+
+static tree create_string_param(tree string)
+{
+	tree i_type, a_type;
+	const int length = TREE_STRING_LENGTH(string);
+
+	gcc_assert(length > 0);
+
+	i_type = build_index_type(build_int_cst(NULL_TREE, length - 1));
+	a_type = build_array_type(char_type_node, i_type);
+
+	TREE_TYPE(string) = a_type;
+	TREE_CONSTANT(string) = 1;
+	TREE_READONLY(string) = 1;
+
+	return build1(ADDR_EXPR, ptr_type_node, string);
+}
+
+static void insert_cond_result(basic_block bb_true, const_gimple stmt, const_tree arg, bool min)
+{
+	gimple func_stmt;
+	const_gimple def_stmt;
+	const_tree loc_line;
+	tree loc_file, ssa_name, current_func;
+	expanded_location xloc;
+	char *ssa_name_buf;
+	int len;
+	gimple_stmt_iterator gsi = gsi_start_bb(bb_true);
+
+	def_stmt = get_def_stmt(arg);
+	xloc = expand_location(gimple_location(def_stmt));
+
+	if (!gimple_has_location(def_stmt)) {
+		xloc = expand_location(gimple_location(stmt));
+		if (!gimple_has_location(stmt))
+			xloc = expand_location(DECL_SOURCE_LOCATION(current_function_decl));
+	}
+
+	loc_line = build_int_cstu(unsigned_type_node, xloc.line);
+
+	loc_file = build_string(strlen(xloc.file) + 1, xloc.file);
+	loc_file = create_string_param(loc_file);
+
+	current_func = build_string(NAME_LEN(current_function_decl) + 1, NAME(current_function_decl));
+	current_func = create_string_param(current_func);
+
+	gcc_assert(DECL_NAME(SSA_NAME_VAR(arg)) != NULL);
+	call_count++;
+	len = asprintf(&ssa_name_buf, "%s_%u %s, count: %u\n", NAME(SSA_NAME_VAR(arg)), SSA_NAME_VERSION(arg), min ? "min" : "max", call_count);
+	gcc_assert(len > 0);
+	ssa_name = build_string(len + 1, ssa_name_buf);
+	free(ssa_name_buf);
+	ssa_name = create_string_param(ssa_name);
+
+	// void report_size_overflow(const char *file, unsigned int line, const char *func, const char *ssa_name)
+	func_stmt = gimple_build_call(report_size_overflow_decl, 4, loc_file, loc_line, current_func, ssa_name);
+
+	gsi_insert_after(&gsi, func_stmt, GSI_CONTINUE_LINKING);
+}
+
+static void __unused print_the_code_insertions(const_gimple stmt)
+{
+	location_t loc = gimple_location(stmt);
+
+	inform(loc, "Integer size_overflow check applied here.");
+}
+
+static void insert_check_size_overflow(gimple stmt, enum tree_code cond_code, tree arg, tree type_value, bool before, bool min)
+{
+	basic_block cond_bb, join_bb, bb_true;
+	edge e;
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+
+	cond_bb = gimple_bb(stmt);
+	if (before)
+		gsi_prev(&gsi);
+	if (gsi_end_p(gsi))
+		e = split_block_after_labels(cond_bb);
+	else
+		e = split_block(cond_bb, gsi_stmt(gsi));
+	cond_bb = e->src;
+	join_bb = e->dest;
+	e->flags = EDGE_FALSE_VALUE;
+	e->probability = REG_BR_PROB_BASE;
+
+	bb_true = create_empty_bb(cond_bb);
+	make_edge(cond_bb, bb_true, EDGE_TRUE_VALUE);
+	make_edge(cond_bb, join_bb, EDGE_FALSE_VALUE);
+	make_edge(bb_true, join_bb, EDGE_FALLTHRU);
+
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, bb_true, cond_bb);
+	set_immediate_dominator(CDI_DOMINATORS, join_bb, cond_bb);
+
+	if (current_loops != NULL) {
+		gcc_assert(cond_bb->loop_father == join_bb->loop_father);
+		add_bb_to_loop(bb_true, cond_bb->loop_father);
+	}
+
+	insert_cond(cond_bb, arg, cond_code, type_value);
+	insert_cond_result(bb_true, stmt, arg, min);
+
+//	print_the_code_insertions(stmt);
+}
+
+static void check_size_overflow(gimple stmt, tree size_overflow_type, tree cast_rhs, tree rhs, bool before)
+{
+	const_tree rhs_type = TREE_TYPE(rhs);
+	tree cast_rhs_type, type_max_type, type_min_type, type_max, type_min;
+
+	gcc_assert(rhs_type != NULL_TREE);
+	if (TREE_CODE(rhs_type) == POINTER_TYPE)
+		return;
+
+	gcc_assert(TREE_CODE(rhs_type) == INTEGER_TYPE || TREE_CODE(rhs_type) == BOOLEAN_TYPE || TREE_CODE(rhs_type) == ENUMERAL_TYPE);
+
+	type_max = cast_a_tree(size_overflow_type, TYPE_MAX_VALUE(rhs_type));
+	// typemax (-1) < typemin (0)
+	if (TREE_OVERFLOW(type_max))
+		return;
+
+	type_min = cast_a_tree(size_overflow_type, TYPE_MIN_VALUE(rhs_type));
+
+	cast_rhs_type = TREE_TYPE(cast_rhs);
+	type_max_type = TREE_TYPE(type_max);
+	type_min_type = TREE_TYPE(type_min);
+	gcc_assert(types_compatible_p(cast_rhs_type, type_max_type));
+	gcc_assert(types_compatible_p(type_max_type, type_min_type));
+
+	insert_check_size_overflow(stmt, GT_EXPR, cast_rhs, type_max, before, false);
+	insert_check_size_overflow(stmt, LT_EXPR, cast_rhs, type_min, before, true);
+}
+
+static tree get_size_overflow_type_for_intentional_overflow(gimple def_stmt, tree change_rhs)
+{
+	gimple change_rhs_def_stmt;
+	tree lhs = gimple_get_lhs(def_stmt);
+	tree lhs_type = TREE_TYPE(lhs);
+	tree rhs1_type = TREE_TYPE(gimple_assign_rhs1(def_stmt));
+	tree rhs2_type = TREE_TYPE(gimple_assign_rhs2(def_stmt));
+
+	if (change_rhs == NULL_TREE)
+		return get_size_overflow_type(def_stmt, lhs);
+
+	change_rhs_def_stmt = get_def_stmt(change_rhs);
+
+	if (TREE_CODE_CLASS(gimple_assign_rhs_code(def_stmt)) == tcc_comparison)
+		return get_size_overflow_type(change_rhs_def_stmt, change_rhs);
+
+	if (gimple_assign_rhs_code(def_stmt) == LSHIFT_EXPR)
+		return get_size_overflow_type(change_rhs_def_stmt, change_rhs);
+
+	if (gimple_assign_rhs_code(def_stmt) == RSHIFT_EXPR)
+		return get_size_overflow_type(change_rhs_def_stmt, change_rhs);
+
+	if (!types_compatible_p(lhs_type, rhs1_type) || !types_compatible_p(rhs1_type, rhs2_type)) {
+		debug_gimple_stmt(def_stmt);
+		gcc_unreachable();
+	}
+
+	return get_size_overflow_type(def_stmt, lhs);
+}
+
+static bool is_a_constant_overflow(const_gimple stmt, const_tree rhs)
+{
+	if (gimple_assign_rhs_code(stmt) == MIN_EXPR)
+		return false;
+	if (!is_gimple_constant(rhs))
+		return false;
+	return true;
+}
+
+static bool is_subtraction_special(const_gimple stmt)
+{
+	gimple rhs1_def_stmt, rhs2_def_stmt;
+	const_tree rhs1_def_stmt_rhs1, rhs2_def_stmt_rhs1, rhs1_def_stmt_lhs, rhs2_def_stmt_lhs;
+	enum machine_mode rhs1_def_stmt_rhs1_mode, rhs2_def_stmt_rhs1_mode, rhs1_def_stmt_lhs_mode, rhs2_def_stmt_lhs_mode;
+	const_tree rhs1 = gimple_assign_rhs1(stmt);
+	const_tree rhs2 = gimple_assign_rhs2(stmt);
+
+	if (is_gimple_constant(rhs1) || is_gimple_constant(rhs2))
+		return false;
+
+	gcc_assert(TREE_CODE(rhs1) == SSA_NAME && TREE_CODE(rhs2) == SSA_NAME);
+
+	if (gimple_assign_rhs_code(stmt) != MINUS_EXPR)
+		return false;
+
+	rhs1_def_stmt = get_def_stmt(rhs1);
+	rhs2_def_stmt = get_def_stmt(rhs2);
+	if (!gimple_assign_cast_p(rhs1_def_stmt) || !gimple_assign_cast_p(rhs2_def_stmt))
+		return false;
+
+	rhs1_def_stmt_rhs1 = gimple_assign_rhs1(rhs1_def_stmt);
+	rhs2_def_stmt_rhs1 = gimple_assign_rhs1(rhs2_def_stmt);
+	rhs1_def_stmt_lhs = gimple_get_lhs(rhs1_def_stmt);
+	rhs2_def_stmt_lhs = gimple_get_lhs(rhs2_def_stmt);
+	rhs1_def_stmt_rhs1_mode = TYPE_MODE(TREE_TYPE(rhs1_def_stmt_rhs1));
+	rhs2_def_stmt_rhs1_mode = TYPE_MODE(TREE_TYPE(rhs2_def_stmt_rhs1));
+	rhs1_def_stmt_lhs_mode = TYPE_MODE(TREE_TYPE(rhs1_def_stmt_lhs));
+	rhs2_def_stmt_lhs_mode = TYPE_MODE(TREE_TYPE(rhs2_def_stmt_lhs));
+	if (GET_MODE_BITSIZE(rhs1_def_stmt_rhs1_mode) <= GET_MODE_BITSIZE(rhs1_def_stmt_lhs_mode))
+		return false;
+	if (GET_MODE_BITSIZE(rhs2_def_stmt_rhs1_mode) <= GET_MODE_BITSIZE(rhs2_def_stmt_lhs_mode))
+		return false;
+
+	gimple_set_plf(rhs1_def_stmt, NO_CAST_CHECK, true);
+	gimple_set_plf(rhs2_def_stmt, NO_CAST_CHECK, true);
+	return true;
+}
+
+static tree get_def_stmt_rhs(const_tree var)
+{
+	tree rhs1, def_stmt_rhs1;
+	gimple rhs1_def_stmt, def_stmt_rhs1_def_stmt, def_stmt;
+
+	def_stmt = get_def_stmt(var);
+	gcc_assert(gimple_code(def_stmt) != GIMPLE_NOP && gimple_plf(def_stmt, MY_STMT) && gimple_assign_cast_p(def_stmt));
+
+	rhs1 = gimple_assign_rhs1(def_stmt);
+	rhs1_def_stmt = get_def_stmt(rhs1);
+	if (!gimple_assign_cast_p(rhs1_def_stmt))
+		return rhs1;
+
+	def_stmt_rhs1 = gimple_assign_rhs1(rhs1_def_stmt);
+	def_stmt_rhs1_def_stmt = get_def_stmt(def_stmt_rhs1);
+
+	switch (gimple_code(def_stmt_rhs1_def_stmt)) {
+	case GIMPLE_CALL:
+	case GIMPLE_NOP:
+	case GIMPLE_ASM:
+		return def_stmt_rhs1;
+	case GIMPLE_ASSIGN:
+		return rhs1;
+	default:
+		debug_gimple_stmt(def_stmt_rhs1_def_stmt);
+		gcc_unreachable();
+	}
+}
+
+static tree handle_integer_truncation(struct pointer_set_t *visited, const_tree lhs)
+{
+	tree new_rhs1, new_rhs2;
+	tree new_rhs1_def_stmt_rhs1, new_rhs2_def_stmt_rhs1, new_lhs;
+	gimple assign, stmt = get_def_stmt(lhs);
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree rhs2 = gimple_assign_rhs2(stmt);
+
+	if (!is_subtraction_special(stmt))
+		return NULL_TREE;
+
+	new_rhs1 = expand(visited, rhs1);
+	new_rhs2 = expand(visited, rhs2);
+
+	new_rhs1_def_stmt_rhs1 = get_def_stmt_rhs(new_rhs1);
+	new_rhs2_def_stmt_rhs1 = get_def_stmt_rhs(new_rhs2);
+
+	if (!types_compatible_p(TREE_TYPE(new_rhs1_def_stmt_rhs1), TREE_TYPE(new_rhs2_def_stmt_rhs1))) {
+		new_rhs1_def_stmt_rhs1 = cast_to_TI_type(stmt, new_rhs1_def_stmt_rhs1);
+		new_rhs2_def_stmt_rhs1 = cast_to_TI_type(stmt, new_rhs2_def_stmt_rhs1);
+	}
+
+	assign = create_binary_assign(MINUS_EXPR, stmt, new_rhs1_def_stmt_rhs1, new_rhs2_def_stmt_rhs1);
+	new_lhs = gimple_get_lhs(assign);
+	check_size_overflow(assign, TREE_TYPE(new_lhs), new_lhs, rhs1, AFTER_STMT);
+
+	return dup_assign(visited, stmt, lhs, new_rhs1, new_rhs2, NULL_TREE);
+}
+
+static bool is_a_neg_overflow(const_gimple stmt, const_tree rhs)
+{
+	const_gimple def_stmt;
+
+	if (TREE_CODE(rhs) != SSA_NAME)
+		return false;
+
+	if (gimple_assign_rhs_code(stmt) != PLUS_EXPR)
+		return false;
+
+	def_stmt = get_def_stmt(rhs);
+	if (gimple_code(def_stmt) != GIMPLE_ASSIGN || gimple_assign_rhs_code(def_stmt) != BIT_NOT_EXPR)
+		return false;
+
+	return true;
+}
+
+static tree handle_intentional_overflow(struct pointer_set_t *visited, bool check_overflow, gimple stmt, tree change_rhs, tree new_rhs1, tree new_rhs2)
+{
+	tree new_rhs, size_overflow_type, orig_rhs;
+	void (*gimple_assign_set_rhs)(gimple, tree);
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree rhs2 = gimple_assign_rhs2(stmt);
+	tree lhs = gimple_get_lhs(stmt);
+
+	if (change_rhs == NULL_TREE)
+		return create_assign(visited, stmt, lhs, AFTER_STMT);
+
+	if (new_rhs2 == NULL_TREE) {
+		size_overflow_type = get_size_overflow_type_for_intentional_overflow(stmt, new_rhs1);
+		new_rhs2 = cast_a_tree(size_overflow_type, rhs2);
+		orig_rhs = rhs1;
+		gimple_assign_set_rhs = &gimple_assign_set_rhs1;
+	} else {
+		size_overflow_type = get_size_overflow_type_for_intentional_overflow(stmt, new_rhs2);
+		new_rhs1 = cast_a_tree(size_overflow_type, rhs1);
+		orig_rhs = rhs2;
+		gimple_assign_set_rhs = &gimple_assign_set_rhs2;
+	}
+
+	change_rhs = cast_to_new_size_overflow_type(stmt, change_rhs, size_overflow_type, BEFORE_STMT);
+
+	if (check_overflow)
+		check_size_overflow(stmt, size_overflow_type, change_rhs, orig_rhs, BEFORE_STMT);
+
+	new_rhs = change_assign_rhs(stmt, orig_rhs, change_rhs);
+	gimple_assign_set_rhs(stmt, new_rhs);
+	update_stmt(stmt);
+
+	return create_assign(visited, stmt, lhs, AFTER_STMT);
+}
+
+static tree handle_binary_ops(struct pointer_set_t *visited, tree lhs)
+{
+	tree rhs1, rhs2, new_lhs;
+	gimple def_stmt = get_def_stmt(lhs);
+	tree new_rhs1 = NULL_TREE;
+	tree new_rhs2 = NULL_TREE;
+
+	rhs1 = gimple_assign_rhs1(def_stmt);
+	rhs2 = gimple_assign_rhs2(def_stmt);
+
+	/* no DImode/TImode division in the 32/64 bit kernel */
+	switch (gimple_assign_rhs_code(def_stmt)) {
+	case RDIV_EXPR:
+	case TRUNC_DIV_EXPR:
+	case CEIL_DIV_EXPR:
+	case FLOOR_DIV_EXPR:
+	case ROUND_DIV_EXPR:
+	case TRUNC_MOD_EXPR:
+	case CEIL_MOD_EXPR:
+	case FLOOR_MOD_EXPR:
+	case ROUND_MOD_EXPR:
+	case EXACT_DIV_EXPR:
+	case POINTER_PLUS_EXPR:
+	case BIT_AND_EXPR:
+		return create_assign(visited, def_stmt, lhs, AFTER_STMT);
+	default:
+		break;
+	}
+
+	new_lhs = handle_integer_truncation(visited, lhs);
+	if (new_lhs != NULL_TREE)
+		return new_lhs;
+
+	if (TREE_CODE(rhs1) == SSA_NAME)
+		new_rhs1 = expand(visited, rhs1);
+	if (TREE_CODE(rhs2) == SSA_NAME)
+		new_rhs2 = expand(visited, rhs2);
+
+	if (is_a_neg_overflow(def_stmt, rhs2))
+		return handle_intentional_overflow(visited, true, def_stmt, new_rhs1, new_rhs1, NULL_TREE);
+	if (is_a_neg_overflow(def_stmt, rhs1))
+		return handle_intentional_overflow(visited, true, def_stmt, new_rhs2, NULL_TREE, new_rhs2);
+
+	if (is_a_constant_overflow(def_stmt, rhs2))
+		return handle_intentional_overflow(visited, !is_a_cast_and_const_overflow(rhs1), def_stmt, new_rhs1, new_rhs1, NULL_TREE);
+	if (is_a_constant_overflow(def_stmt, rhs1))
+		return handle_intentional_overflow(visited, !is_a_cast_and_const_overflow(rhs2), def_stmt, new_rhs2, NULL_TREE, new_rhs2);
+
+	return dup_assign(visited, def_stmt, lhs, new_rhs1, new_rhs2, NULL_TREE);
+}
+
+#if BUILDING_GCC_VERSION >= 4007
+static tree get_new_rhs(struct pointer_set_t *visited, tree size_overflow_type, tree rhs)
+{
+	if (is_gimple_constant(rhs))
+		return cast_a_tree(size_overflow_type, rhs);
+	if (TREE_CODE(rhs) != SSA_NAME)
+		return NULL_TREE;
+	return expand(visited, rhs);
+}
+
+static tree handle_ternary_ops(struct pointer_set_t *visited, tree lhs)
+{
+	tree rhs1, rhs2, rhs3, new_rhs1, new_rhs2, new_rhs3, size_overflow_type;
+	gimple def_stmt = get_def_stmt(lhs);
+
+	size_overflow_type = get_size_overflow_type(def_stmt, lhs);
+
+	rhs1 = gimple_assign_rhs1(def_stmt);
+	rhs2 = gimple_assign_rhs2(def_stmt);
+	rhs3 = gimple_assign_rhs3(def_stmt);
+	new_rhs1 = get_new_rhs(visited, size_overflow_type, rhs1);
+	new_rhs2 = get_new_rhs(visited, size_overflow_type, rhs2);
+	new_rhs3 = get_new_rhs(visited, size_overflow_type, rhs3);
+
+	return dup_assign(visited, def_stmt, lhs, new_rhs1, new_rhs2, new_rhs3);
+}
+#endif
+
+static tree get_size_overflow_type(gimple stmt, const_tree node)
+{
+	const_tree type;
+	tree new_type;
+
+	gcc_assert(node != NULL_TREE);
+
+	type = TREE_TYPE(node);
+
+	if (gimple_plf(stmt, MY_STMT))
+		return TREE_TYPE(node);
+
+	switch (TYPE_MODE(type)) {
+	case QImode:
+		new_type = intHI_type_node;
+		break;
+	case HImode:
+		new_type = intSI_type_node;
+		break;
+	case SImode:
+		new_type = intDI_type_node;
+		break;
+	case DImode:
+		if (LONG_TYPE_SIZE == GET_MODE_BITSIZE(SImode))
+			new_type = intDI_type_node;
+		else
+			new_type = intTI_type_node;
+		break;
+	default:
+		debug_tree((tree)node);
+		error("%s: unsupported gcc configuration.", __func__);
+		gcc_unreachable();
+	}
+
+	if (TYPE_QUALS(type) != 0)
+		return build_qualified_type(new_type, TYPE_QUALS(type));
+	return new_type;
+}
+
+static tree expand_visited(gimple def_stmt)
+{
+	const_gimple next_stmt;
+	gimple_stmt_iterator gsi = gsi_for_stmt(def_stmt);
+
+	gsi_next(&gsi);
+	next_stmt = gsi_stmt(gsi);
+
+	gcc_assert(gimple_plf((gimple)next_stmt, MY_STMT));
+
+	switch (gimple_code(next_stmt)) {
+	case GIMPLE_ASSIGN:
+		return gimple_get_lhs(next_stmt);
+	case GIMPLE_PHI:
+		return gimple_phi_result(next_stmt);
+	case GIMPLE_CALL:
+		return gimple_call_lhs(next_stmt);
+	default:
+		return NULL_TREE;
+	}
+}
+
+static tree expand(struct pointer_set_t *visited, tree lhs)
+{
+	gimple def_stmt;
+	enum tree_code code = TREE_CODE(TREE_TYPE(lhs));
+
+	if (is_gimple_constant(lhs))
+		return NULL_TREE;
+
+	if (TREE_CODE(lhs) == ADDR_EXPR)
+		return NULL_TREE;
+
+	if (code == REAL_TYPE)
+		return NULL_TREE;
+
+	gcc_assert(code == INTEGER_TYPE || code == POINTER_TYPE || code == BOOLEAN_TYPE || code == ENUMERAL_TYPE);
+
+	def_stmt = get_def_stmt(lhs);
+
+	if (!def_stmt || gimple_code(def_stmt) == GIMPLE_NOP)
+		return NULL_TREE;
+
+	if (gimple_plf(def_stmt, MY_STMT))
+		return lhs;
+
+	if (pointer_set_contains(visited, def_stmt))
+		return expand_visited(def_stmt);
+
+	switch (gimple_code(def_stmt)) {
+	case GIMPLE_PHI:
+		return build_new_phi(visited, lhs);
+	case GIMPLE_CALL:
+	case GIMPLE_ASM:
+		return create_assign(visited, def_stmt, lhs, AFTER_STMT);
+	case GIMPLE_ASSIGN:
+		switch (gimple_num_ops(def_stmt)) {
+		case 2:
+			return handle_unary_ops(visited, def_stmt);
+		case 3:
+			return handle_binary_ops(visited, lhs);
+#if BUILDING_GCC_VERSION >= 4007
+		case 4:
+			return handle_ternary_ops(visited, lhs);
+#endif
+		}
+	default:
+		debug_gimple_stmt(def_stmt);
+		error("%s: unknown gimple code", __func__);
+		gcc_unreachable();
+	}
+}
+
+static void change_function_arg(gimple stmt, const_tree origarg, unsigned int argnum, tree newarg)
+{
+	const_gimple assign;
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+	tree origtype = TREE_TYPE(origarg);
+
+	gcc_assert(gimple_code(stmt) == GIMPLE_CALL);
+
+	assign = build_cast_stmt(origtype, newarg, CREATE_NEW_VAR, &gsi, BEFORE_STMT);
+
+	gimple_call_set_arg(stmt, argnum, gimple_get_lhs(assign));
+	update_stmt(stmt);
+}
+
+static bool get_function_arg(unsigned int* argnum, const_tree fndecl)
+{
+	const char *origid;
+	tree arg;
+	const_tree origarg;
+
+	if (!DECL_ABSTRACT_ORIGIN(fndecl))
+		return true;
+
+	origarg = DECL_ARGUMENTS(DECL_ABSTRACT_ORIGIN(fndecl));
+	while (origarg && *argnum) {
+		(*argnum)--;
+		origarg = TREE_CHAIN(origarg);
+	}
+
+	gcc_assert(*argnum == 0);
+
+	gcc_assert(origarg != NULL_TREE);
+	origid = NAME(origarg);
+	*argnum = 0;
+	for (arg = DECL_ARGUMENTS(fndecl); arg; arg = TREE_CHAIN(arg)) {
+		if (!strcmp(origid, NAME(arg)))
+			return true;
+		(*argnum)++;
+	}
+	return false;
+}
+
+static bool skip_types(const_tree var)
+{
+	const_tree type;
+
+	switch (TREE_CODE(var)) {
+		case ADDR_EXPR:
+#if BUILDING_GCC_VERSION >= 4006
+		case MEM_REF:
+#endif
+		case ARRAY_REF:
+		case BIT_FIELD_REF:
+		case INDIRECT_REF:
+		case TARGET_MEM_REF:
+		case VAR_DECL:
+			return true;
+		default:
+			break;
+	}
+
+	type = TREE_TYPE(TREE_TYPE(var));
+	if (!type)
+		return false;
+	switch (TREE_CODE(type)) {
+		case RECORD_TYPE:
+			return true;
+		default:
+			break;
+	}
+
+	return false;
+}
+
+static bool walk_phi(struct pointer_set_t *visited, const_tree result)
+{
+	gimple phi = get_def_stmt(result);
+	unsigned int i, n = gimple_phi_num_args(phi);
+
+	if (!phi)
+		return false;
+
+	pointer_set_insert(visited, phi);
+	for (i = 0; i < n; i++) {
+		const_tree arg = gimple_phi_arg_def(phi, i);
+		if (pre_expand(visited, arg))
+			return true;
+	}
+	return false;
+}
+
+static bool walk_unary_ops(struct pointer_set_t *visited, const_tree lhs)
+{
+	gimple def_stmt = get_def_stmt(lhs);
+	const_tree rhs;
+
+	if (!def_stmt)
+		return false;
+
+	rhs = gimple_assign_rhs1(def_stmt);
+	if (pre_expand(visited, rhs))
+		return true;
+	return false;
+}
+
+static bool walk_binary_ops(struct pointer_set_t *visited, const_tree lhs)
+{
+	bool rhs1_found, rhs2_found;
+	gimple def_stmt = get_def_stmt(lhs);
+	const_tree rhs1, rhs2;
+
+	if (!def_stmt)
+		return false;
+
+	rhs1 = gimple_assign_rhs1(def_stmt);
+	rhs2 = gimple_assign_rhs2(def_stmt);
+	rhs1_found = pre_expand(visited, rhs1);
+	rhs2_found = pre_expand(visited, rhs2);
+
+	return rhs1_found || rhs2_found;
+}
+
+static const_tree search_field_decl(const_tree comp_ref)
+{
+	const_tree field = NULL_TREE;
+	unsigned int i, len = TREE_OPERAND_LENGTH(comp_ref);
+
+	for (i = 0; i < len; i++) {
+		field = TREE_OPERAND(comp_ref, i);
+		if (TREE_CODE(field) == FIELD_DECL)
+			break;
+	}
+	gcc_assert(TREE_CODE(field) == FIELD_DECL);
+	return field;
+}
+
+static enum marked mark_status(const_tree fndecl, unsigned int argnum)
+{
+	const_tree attr, p;
+
+	attr = lookup_attribute("intentional_overflow", DECL_ATTRIBUTES(fndecl));
+	if (!attr || !TREE_VALUE(attr))
+		return MARKED_NO;
+
+	p = TREE_VALUE(attr);
+	if (!TREE_INT_CST_LOW(TREE_VALUE(p)))
+		return MARKED_NOT_INTENTIONAL;
+
+	do {
+		if (argnum == TREE_INT_CST_LOW(TREE_VALUE(p)))
+			return MARKED_YES;
+		p = TREE_CHAIN(p);
+	} while (p);
+
+	return MARKED_NO;
+}
+
+static void print_missing_msg(tree func, unsigned int argnum)
+{
+	unsigned int new_hash;
+	size_t len;
+	unsigned char tree_codes[CODES_LIMIT];
+	location_t loc = DECL_SOURCE_LOCATION(func);
+	const char *curfunc = get_asm_name(func);
+
+	len = get_function_decl(func, tree_codes);
+	new_hash = get_hash_num(curfunc, (const char *) tree_codes, len, 0);
+	inform(loc, "Function %s is missing from the size_overflow hash table +%s+%u+%u+", curfunc, curfunc, argnum, new_hash);
+}
+
+static unsigned int search_missing_attribute(const_tree arg)
+{
+	const_tree type = TREE_TYPE(arg);
+	tree func = get_original_function_decl(current_function_decl);
+	unsigned int argnum;
+	const struct size_overflow_hash *hash;
+
+	gcc_assert(TREE_CODE(arg) != COMPONENT_REF);
+
+	if (TREE_CODE(type) == POINTER_TYPE)
+		return 0;
+
+	argnum = find_arg_number(arg, func);
+	if (argnum == 0)
+		return 0;
+
+	if (lookup_attribute("size_overflow", DECL_ATTRIBUTES(func)))
+		return argnum;
+
+	hash = get_function_hash(func);
+	if (!hash || !(hash->param & (1U << argnum))) {
+		print_missing_msg(func, argnum);
+		return 0;
+	}
+	return argnum;
+}
+
+static bool is_already_marked(const_tree lhs)
+{
+	unsigned int argnum;
+	const_tree fndecl;
+
+	argnum = search_missing_attribute(lhs);
+	fndecl = get_original_function_decl(current_function_decl);
+	if (argnum && mark_status(fndecl, argnum) == MARKED_YES)
+		return true;
+	return false;
+}
+
+static bool pre_expand(struct pointer_set_t *visited, const_tree lhs)
+{
+	const_gimple def_stmt;
+
+	if (is_gimple_constant(lhs))
+		return false;
+
+	if (skip_types(lhs))
+		return false;
+
+	// skip char type (FIXME: only kernel)
+	if (TYPE_MODE(TREE_TYPE(lhs)) == QImode)
+		return false;
+
+	if (TREE_CODE(lhs) == PARM_DECL)
+		return is_already_marked(lhs);
+
+	if (TREE_CODE(lhs) == COMPONENT_REF) {
+		const_tree field, attr;
+
+		field = search_field_decl(lhs);
+		attr = lookup_attribute("intentional_overflow", DECL_ATTRIBUTES(field));
+		if (!attr || !TREE_VALUE(attr))
+			return false;
+		return true;
+	}
+
+	def_stmt = get_def_stmt(lhs);
+
+	if (!def_stmt)
+		return false;
+
+	if (pointer_set_contains(visited, def_stmt))
+		return false;
+
+	switch (gimple_code(def_stmt)) {
+	case GIMPLE_NOP:
+		if (TREE_CODE(SSA_NAME_VAR(lhs)) == PARM_DECL)
+			return is_already_marked(lhs);
+		return false;
+	case GIMPLE_PHI:
+		return walk_phi(visited, lhs);
+	case GIMPLE_CALL:
+	case GIMPLE_ASM:
+		return false;
+	case GIMPLE_ASSIGN:
+		switch (gimple_num_ops(def_stmt)) {
+		case 2:
+			return walk_unary_ops(visited, lhs);
+		case 3:
+			return walk_binary_ops(visited, lhs);
+		}
+	default:
+		debug_gimple_stmt((gimple)def_stmt);
+		error("%s: unknown gimple code", __func__);
+		gcc_unreachable();
+	}
+}
+
+static bool search_attributes(tree fndecl, const_tree arg, unsigned int argnum)
+{
+	struct pointer_set_t *visited;
+	bool is_found;
+	enum marked is_marked;
+	location_t loc;
+
+	visited = pointer_set_create();
+	is_found = pre_expand(visited, arg);
+	pointer_set_destroy(visited);
+
+	is_marked = mark_status(fndecl, argnum + 1);
+	if ((is_found && is_marked == MARKED_YES) || is_marked == MARKED_NOT_INTENTIONAL)
+		return true;
+
+	if (is_found) {
+		loc = DECL_SOURCE_LOCATION(fndecl);
+		inform(loc, "The intentional_overflow attribute is missing from +%s+%u+", get_asm_name(fndecl), argnum + 1);
+		return true;
+	}
+	return false;
+}
+
+static void handle_function_arg(gimple stmt, tree fndecl, unsigned int argnum)
+{
+	struct pointer_set_t *visited;
+	tree arg, newarg;
+	bool match;
+
+	match = get_function_arg(&argnum, fndecl);
+	if (!match)
+		return;
+	gcc_assert(gimple_call_num_args(stmt) > argnum);
+	arg = gimple_call_arg(stmt, argnum);
+	if (arg == NULL_TREE)
+		return;
+
+	if (is_gimple_constant(arg))
+		return;
+
+	if (search_attributes(fndecl, arg, argnum))
+		return;
+
+	if (TREE_CODE(arg) != SSA_NAME)
+		return;
+
+	check_arg_type(arg);
+
+	visited = pointer_set_create();
+	newarg = expand(visited, arg);
+	pointer_set_destroy(visited);
+
+	if (newarg == NULL_TREE)
+		return;
+
+	change_function_arg(stmt, arg, argnum, newarg);
+
+	check_size_overflow(stmt, TREE_TYPE(newarg), newarg, arg, BEFORE_STMT);
+}
+
+static void handle_function_by_attribute(gimple stmt, const_tree attr, tree fndecl)
+{
+	tree p = TREE_VALUE(attr);
+	do {
+		handle_function_arg(stmt, fndecl, TREE_INT_CST_LOW(TREE_VALUE(p))-1);
+		p = TREE_CHAIN(p);
+	} while (p);
+}
+
+static void handle_function_by_hash(gimple stmt, tree fndecl)
+{
+	tree orig_fndecl;
+	unsigned int num;
+	const struct size_overflow_hash *hash;
+
+	orig_fndecl = get_original_function_decl(fndecl);
+	if (C_DECL_IMPLICIT(orig_fndecl))
+		return;
+	hash = get_function_hash(orig_fndecl);
+	if (!hash)
+		return;
+
+	for (num = 1; num <= MAX_PARAM; num++)
+		if (hash->param & (1U << num))
+			handle_function_arg(stmt, fndecl, num - 1);
+}
+
+static void set_plf_false(void)
+{
+	basic_block bb;
+
+	FOR_ALL_BB(bb) {
+		gimple_stmt_iterator si;
+
+		for (si = gsi_start_bb(bb); !gsi_end_p(si); gsi_next(&si))
+			gimple_set_plf(gsi_stmt(si), MY_STMT, false);
+		for (si = gsi_start_phis(bb); !gsi_end_p(si); gsi_next(&si))
+			gimple_set_plf(gsi_stmt(si), MY_STMT, false);
+	}
+}
+
+static unsigned int handle_function(void)
+{
+	basic_block next, bb = ENTRY_BLOCK_PTR->next_bb;
+
+	set_plf_false();
+
+	do {
+		gimple_stmt_iterator gsi;
+		next = bb->next_bb;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			tree fndecl, attr;
+			gimple stmt = gsi_stmt(gsi);
+
+			if (!(is_gimple_call(stmt)))
+				continue;
+			fndecl = gimple_call_fndecl(stmt);
+			if (fndecl == NULL_TREE)
+				continue;
+			if (gimple_call_num_args(stmt) == 0)
+				continue;
+			attr = lookup_attribute("size_overflow", DECL_ATTRIBUTES(fndecl));
+			if (!attr || !TREE_VALUE(attr))
+				handle_function_by_hash(stmt, fndecl);
+			else
+				handle_function_by_attribute(stmt, attr, fndecl);
+			gsi = gsi_for_stmt(stmt);
+			next = gimple_bb(stmt)->next_bb;
+		}
+		bb = next;
+	} while (bb);
+	return 0;
+}
+
+static struct gimple_opt_pass size_overflow_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "size_overflow",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= NULL,
+		.execute		= handle_function,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= PROP_cfg,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa_no_phi | TODO_cleanup_cfg | TODO_ggc_collect | TODO_verify_flow
+	}
+};
+
+static void start_unit_callback(void __unused *gcc_data, void __unused *user_data)
+{
+	tree fntype;
+
+	const_char_ptr_type_node = build_pointer_type(build_type_variant(char_type_node, 1, 0));
+
+	// void report_size_overflow(const char *loc_file, unsigned int loc_line, const char *current_func, const char *ssa_var)
+	fntype = build_function_type_list(void_type_node,
+					  const_char_ptr_type_node,
+					  unsigned_type_node,
+					  const_char_ptr_type_node,
+					  const_char_ptr_type_node,
+					  NULL_TREE);
+	report_size_overflow_decl = build_fn_decl("report_size_overflow", fntype);
+
+	DECL_ASSEMBLER_NAME(report_size_overflow_decl);
+	TREE_PUBLIC(report_size_overflow_decl) = 1;
+	DECL_EXTERNAL(report_size_overflow_decl) = 1;
+	DECL_ARTIFICIAL(report_size_overflow_decl) = 1;
+	TREE_THIS_VOLATILE(report_size_overflow_decl) = 1;
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable = true;
+
+	struct register_pass_info size_overflow_pass_info = {
+		.pass				= &size_overflow_pass.pass,
+		.reference_pass_name		= "ssa",
+		.ref_pass_instance_number	= 1,
+		.pos_op				= PASS_POS_INSERT_AFTER
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "no-size-overflow")) {
+			enable = false;
+			continue;
+		}
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &size_overflow_plugin_info);
+	if (enable) {
+		register_callback("start_unit", PLUGIN_START_UNIT, &start_unit_callback, NULL);
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &size_overflow_pass_info);
+	}
+	register_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/tools/gcc/stackleak_plugin.c linux-2.6.32.60-pax/tools/gcc/stackleak_plugin.c
--- linux-2.6.32.60/tools/gcc/stackleak_plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.60-pax/tools/gcc/stackleak_plugin.c	2013-02-17 17:20:34.400154305 +0100
@@ -0,0 +1,327 @@
+/*
+ * Copyright 2011-2013 by the PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Note: the choice of the license means that the compilation process is
+ *       NOT 'eligible' as defined by gcc's library exception to the GPL v3,
+ *       but for the kernel it doesn't matter since it doesn't link against
+ *       any of the gcc libraries
+ *
+ * gcc plugin to help implement various PaX features
+ *
+ * - track lowest stack pointer
+ *
+ * TODO:
+ * - initialize all local variables
+ *
+ * BUGS:
+ * - none known
+ */
+#include "gcc-plugin.h"
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "flags.h"
+#include "intl.h"
+#include "toplev.h"
+#include "plugin.h"
+//#include "expr.h" where are you...
+#include "diagnostic.h"
+#include "plugin-version.h"
+#include "tm.h"
+#include "function.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "rtl.h"
+#include "emit-rtl.h"
+
+#if BUILDING_GCC_VERSION >= 4008
+#define TODO_dump_func 0
+#endif
+
+extern void print_gimple_stmt(FILE *, gimple, int, int);
+
+int plugin_is_GPL_compatible;
+
+static int track_frame_size = -1;
+static const char track_function[] = "pax_track_stack";
+static const char check_function[] = "pax_check_alloca";
+static bool init_locals;
+
+static struct plugin_info stackleak_plugin_info = {
+	.version	= "201302112000",
+	.help		= "track-lowest-sp=nn\ttrack sp in functions whose frame size is at least nn bytes\n"
+//			  "initialize-locals\t\tforcibly initialize all stack frames\n"
+};
+
+static bool gate_stackleak_track_stack(void);
+static unsigned int execute_stackleak_tree_instrument(void);
+static unsigned int execute_stackleak_final(void);
+
+static struct gimple_opt_pass stackleak_tree_instrument_pass = {
+	.pass = {
+		.type			= GIMPLE_PASS,
+		.name			= "stackleak_tree_instrument",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= gate_stackleak_track_stack,
+		.execute		= execute_stackleak_tree_instrument,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= PROP_gimple_leh | PROP_cfg,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0, //TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts,
+		.todo_flags_finish	= TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_update_ssa
+	}
+};
+
+static struct rtl_opt_pass stackleak_final_rtl_opt_pass = {
+	.pass = {
+		.type			= RTL_PASS,
+		.name			= "stackleak_final",
+#if BUILDING_GCC_VERSION >= 4008
+		.optinfo_flags		= OPTGROUP_NONE,
+#endif
+		.gate			= gate_stackleak_track_stack,
+		.execute		= execute_stackleak_final,
+		.sub			= NULL,
+		.next			= NULL,
+		.static_pass_number	= 0,
+		.tv_id			= TV_NONE,
+		.properties_required	= 0,
+		.properties_provided	= 0,
+		.properties_destroyed	= 0,
+		.todo_flags_start	= 0,
+		.todo_flags_finish	= TODO_dump_func
+	}
+};
+
+static bool gate_stackleak_track_stack(void)
+{
+	return track_frame_size >= 0;
+}
+
+static void stackleak_check_alloca(gimple_stmt_iterator *gsi)
+{
+	gimple check_alloca;
+	tree fntype, fndecl, alloca_size;
+
+	fntype = build_function_type_list(void_type_node, long_unsigned_type_node, NULL_TREE);
+	fndecl = build_fn_decl(check_function, fntype);
+	DECL_ASSEMBLER_NAME(fndecl); // for LTO
+
+	// insert call to void pax_check_alloca(unsigned long size)
+	alloca_size = gimple_call_arg(gsi_stmt(*gsi), 0);
+	check_alloca = gimple_build_call(fndecl, 1, alloca_size);
+	gsi_insert_before(gsi, check_alloca, GSI_SAME_STMT);
+}
+
+static void stackleak_add_instrumentation(gimple_stmt_iterator *gsi)
+{
+	gimple track_stack;
+	tree fntype, fndecl;
+
+	fntype = build_function_type_list(void_type_node, NULL_TREE);
+	fndecl = build_fn_decl(track_function, fntype);
+	DECL_ASSEMBLER_NAME(fndecl); // for LTO
+
+	// insert call to void pax_track_stack(void)
+	track_stack = gimple_build_call(fndecl, 0);
+	gsi_insert_after(gsi, track_stack, GSI_CONTINUE_LINKING);
+}
+
+#if BUILDING_GCC_VERSION == 4005
+static bool gimple_call_builtin_p(gimple stmt, enum built_in_function code)
+{
+	tree fndecl;
+
+	if (!is_gimple_call(stmt))
+		return false;
+	fndecl = gimple_call_fndecl(stmt);
+	if (!fndecl)
+		return false;
+	if (DECL_BUILT_IN_CLASS(fndecl) != BUILT_IN_NORMAL)
+		return false;
+//	print_node(stderr, "pax", fndecl, 4);
+	return DECL_FUNCTION_CODE(fndecl) == code;
+}
+#endif
+
+static bool is_alloca(gimple stmt)
+{
+	if (gimple_call_builtin_p(stmt, BUILT_IN_ALLOCA))
+		return true;
+
+#if BUILDING_GCC_VERSION >= 4007
+	if (gimple_call_builtin_p(stmt, BUILT_IN_ALLOCA_WITH_ALIGN))
+		return true;
+#endif
+
+	return false;
+}
+
+static unsigned int execute_stackleak_tree_instrument(void)
+{
+	basic_block bb, entry_bb;
+	bool prologue_instrumented = false, is_leaf = true;
+
+	entry_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION(cfun)->next_bb;
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB(bb) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+
+			stmt = gsi_stmt(gsi);
+
+			if (is_gimple_call(stmt))
+				is_leaf = false;
+
+			// gimple match: align 8 built-in BUILT_IN_NORMAL:BUILT_IN_ALLOCA attributes <tree_list 0xb7576450>
+			if (!is_alloca(stmt))
+				continue;
+
+			// 2. insert stack overflow check before each __builtin_alloca call
+			stackleak_check_alloca(&gsi);
+
+			// 3. insert track call after each __builtin_alloca call
+			stackleak_add_instrumentation(&gsi);
+			if (bb == entry_bb)
+				prologue_instrumented = true;
+		}
+	}
+
+	// special cases for some bad linux code: taking the address of static inline functions will materialize them
+	// but we mustn't instrument some of them as the resulting stack alignment required by the function call ABI
+	// will break other assumptions regarding the expected (but not otherwise enforced) register clobbering  ABI.
+	// case in point: native_save_fl on amd64 when optimized for size clobbers rdx if it were instrumented here.
+	if (is_leaf && !TREE_PUBLIC(current_function_decl) && DECL_DECLARED_INLINE_P(current_function_decl))
+		return 0;
+	if (is_leaf && !strncmp(IDENTIFIER_POINTER(DECL_NAME(current_function_decl)), "_paravirt_", 10))
+		return 0;
+
+	// 4. insert track call at the beginning
+	if (!prologue_instrumented) {
+		gimple_stmt_iterator gsi;
+
+		bb = split_block_after_labels(ENTRY_BLOCK_PTR)->dest;
+		if (dom_info_available_p(CDI_DOMINATORS))
+			set_immediate_dominator(CDI_DOMINATORS, bb, ENTRY_BLOCK_PTR);
+		gsi = gsi_start_bb(bb);
+		stackleak_add_instrumentation(&gsi);
+	}
+
+	return 0;
+}
+
+static unsigned int execute_stackleak_final(void)
+{
+	rtx insn, next;
+
+	if (cfun->calls_alloca)
+		return 0;
+
+	// keep calls only if function frame is big enough
+	if (get_frame_size() >= track_frame_size)
+		return 0;
+
+	// 1. find pax_track_stack calls
+	for (insn = get_insns(); insn; insn = next) {
+		// rtl match: (call_insn 8 7 9 3 (call (mem (symbol_ref ("pax_track_stack") [flags 0x41] <function_decl 0xb7470e80 pax_track_stack>) [0 S1 A8]) (4)) -1 (nil) (nil))
+		rtx body;
+
+		next = NEXT_INSN(insn);
+		if (!CALL_P(insn))
+			continue;
+		body = PATTERN(insn);
+		if (GET_CODE(body) != CALL)
+			continue;
+		body = XEXP(body, 0);
+		if (GET_CODE(body) != MEM)
+			continue;
+		body = XEXP(body, 0);
+		if (GET_CODE(body) != SYMBOL_REF)
+			continue;
+		if (strcmp(XSTR(body, 0), track_function))
+			continue;
+//		warning(0, "track_frame_size: %d %ld %d", cfun->calls_alloca, get_frame_size(), track_frame_size);
+		// 2. delete call
+		delete_insn_and_edges(insn);
+#if BUILDING_GCC_VERSION >= 4007
+		if (GET_CODE(next) == NOTE && NOTE_KIND(next) == NOTE_INSN_CALL_ARG_LOCATION) {
+			insn = next;
+			next = NEXT_INSN(insn);
+			delete_insn_and_edges(insn);
+		}
+#endif
+	}
+
+//	print_simple_rtl(stderr, get_insns());
+//	print_rtl(stderr, get_insns());
+//	warning(0, "track_frame_size: %d %ld %d", cfun->calls_alloca, get_frame_size(), track_frame_size);
+
+	return 0;
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+	struct register_pass_info stackleak_tree_instrument_pass_info = {
+		.pass				= &stackleak_tree_instrument_pass.pass,
+//		.reference_pass_name		= "tree_profile",
+		.reference_pass_name		= "optimized",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_BEFORE
+	};
+	struct register_pass_info stackleak_final_pass_info = {
+		.pass				= &stackleak_final_rtl_opt_pass.pass,
+		.reference_pass_name		= "final",
+		.ref_pass_instance_number	= 1,
+		.pos_op 			= PASS_POS_INSERT_BEFORE
+	};
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &stackleak_plugin_info);
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "track-lowest-sp")) {
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+			track_frame_size = atoi(argv[i].value);
+			if (argv[i].value[0] < '0' || argv[i].value[0] > '9' || track_frame_size < 0)
+				error(G_("invalid option argument '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, argv[i].value);
+			continue;
+		}
+		if (!strcmp(argv[i].key, "initialize-locals")) {
+			if (argv[i].value) {
+				error(G_("invalid option argument '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, argv[i].value);
+				continue;
+			}
+			init_locals = true;
+			continue;
+		}
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &stackleak_tree_instrument_pass_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &stackleak_final_pass_info);
+
+	return 0;
+}
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/usr/gen_init_cpio.c linux-2.6.32.60-pax/usr/gen_init_cpio.c
--- linux-2.6.32.60/usr/gen_init_cpio.c	2012-03-04 18:49:44.000000000 +0100
+++ linux-2.6.32.60-pax/usr/gen_init_cpio.c	2012-03-13 13:15:36.124097937 +0100
@@ -299,7 +299,7 @@ static int cpio_mkfile(const char *name,
 	int retval;
 	int rc = -1;
 	int namesize;
-	int i;
+	unsigned int i;
 
 	mode |= S_IFREG;
 
@@ -383,9 +383,10 @@ static char *cpio_replace_env(char *new_
                        *env_var = *expanded = '\0';
                        strncat(env_var, start + 2, end - start - 2);
                        strncat(expanded, new_location, start - new_location);
-                       strncat(expanded, getenv(env_var), PATH_MAX);
-                       strncat(expanded, end + 1, PATH_MAX);
+                       strncat(expanded, getenv(env_var), PATH_MAX - strlen(expanded));
+                       strncat(expanded, end + 1, PATH_MAX - strlen(expanded));
                        strncpy(new_location, expanded, PATH_MAX);
+                       new_location[PATH_MAX] = 0;
                } else
                        break;
        }
diff -NurpX linux-2.6.32.60-pax/Documentation/dontdiff linux-2.6.32.60/virt/kvm/kvm_main.c linux-2.6.32.60-pax/virt/kvm/kvm_main.c
--- linux-2.6.32.60/virt/kvm/kvm_main.c	2012-10-09 11:00:35.516882485 +0200
+++ linux-2.6.32.60-pax/virt/kvm/kvm_main.c	2013-02-17 18:09:59.979995966 +0100
@@ -81,7 +81,12 @@ static cpumask_var_t cpus_hardware_enabl
 struct kmem_cache *kvm_vcpu_cache;
 EXPORT_SYMBOL_GPL(kvm_vcpu_cache);
 
-static __read_mostly struct preempt_ops kvm_preempt_ops;
+static void kvm_sched_in(struct preempt_notifier *pn, int cpu);
+static void kvm_sched_out(struct preempt_notifier *pn, struct task_struct *next);
+static struct preempt_ops kvm_preempt_ops = {
+	.sched_in = kvm_sched_in,
+	.sched_out = kvm_sched_out,
+};
 
 struct dentry *kvm_debugfs_dir;
 
@@ -1823,7 +1828,7 @@ static int kvm_vcpu_release(struct inode
 	return 0;
 }
 
-static struct file_operations kvm_vcpu_fops = {
+static file_operations_no_const kvm_vcpu_fops __read_only = {
 	.release        = kvm_vcpu_release,
 	.unlocked_ioctl = kvm_vcpu_ioctl,
 	.compat_ioctl   = kvm_vcpu_ioctl,
@@ -2423,7 +2428,7 @@ static int kvm_vm_mmap(struct file *file
 	return 0;
 }
 
-static struct file_operations kvm_vm_fops = {
+static file_operations_no_const kvm_vm_fops __read_only = {
 	.release        = kvm_vm_release,
 	.unlocked_ioctl = kvm_vm_ioctl,
 	.compat_ioctl   = kvm_vm_ioctl,
@@ -2510,7 +2515,7 @@ out:
 	return r;
 }
 
-static struct file_operations kvm_chardev_ops = {
+static file_operations_no_const kvm_chardev_ops __read_only = {
 	.unlocked_ioctl = kvm_dev_ioctl,
 	.compat_ioctl   = kvm_dev_ioctl,
 };
@@ -2573,7 +2578,7 @@ asmlinkage void kvm_handle_fault_on_rebo
 	if (kvm_rebooting)
 		/* spin while reset goes on */
 		while (true)
-			;
+			cpu_relax();
 	/* Fault while not rebooting.  We want the trace. */
 	BUG();
 }
@@ -2793,7 +2798,7 @@ static void kvm_sched_out(struct preempt
 	kvm_arch_vcpu_put(vcpu);
 }
 
-int kvm_init(void *opaque, unsigned int vcpu_size,
+int kvm_init(const void *opaque, unsigned int vcpu_size,
 		  struct module *module)
 {
 	int r;
@@ -2846,15 +2851,17 @@ int kvm_init(void *opaque, unsigned int
 	/* A kmem cache lets us meet the alignment requirements of fx_save. */
 	kvm_vcpu_cache = kmem_cache_create("kvm_vcpu", vcpu_size,
 					   __alignof__(struct kvm_vcpu),
-					   0, NULL);
+					   SLAB_USERCOPY, NULL);
 	if (!kvm_vcpu_cache) {
 		r = -ENOMEM;
 		goto out_free_5;
 	}
 
+	pax_open_kernel();
 	kvm_chardev_ops.owner = module;
 	kvm_vm_fops.owner = module;
 	kvm_vcpu_fops.owner = module;
+	pax_close_kernel();
 
 	r = misc_register(&kvm_dev);
 	if (r) {
@@ -2862,9 +2869,6 @@ int kvm_init(void *opaque, unsigned int
 		goto out_free;
 	}
 
-	kvm_preempt_ops.sched_in = kvm_sched_in;
-	kvm_preempt_ops.sched_out = kvm_sched_out;
-
 	kvm_init_debug();
 
 	return 0;
